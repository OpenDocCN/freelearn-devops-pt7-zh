- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Installing and Running Ansible
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和运行 Ansible
- en: Welcome to this, our first chapter in the second edition of *Learn Ansible*.
    In this chapter, we will look at a few topics to introduce you to **Ansible**;
    these topics will familiarize you with the basics of what Ansible is and give
    you a few different use cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们的第一章，《*Learn Ansible*》第二版的第一章。在本章中，我们将介绍一些主题，帮助你了解**Ansible**，这些内容将让你熟悉
    Ansible 的基本概念，并展示一些不同的使用场景。
- en: 'By the end of the chapter, you will have gotten hands-on with Ansible and covered
    the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将亲自操作 Ansible，并涵盖以下内容：
- en: Who is behind Ansible?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁是 Ansible 背后的团队？
- en: The differences between Ansible and other tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 与其他工具的区别
- en: The problem Ansible solves
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 解决的问题
- en: How to install Ansible on macOS and Linux
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 macOS 和 Linux 上安装 Ansible
- en: Running Ansible on Windows 11 using the Windows Subsystem for Linux
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 11 上使用 Windows 子系统运行 Ansible
- en: Launching a test virtual machine
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动测试虚拟机
- en: An introduction to playbooks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playbook 介绍
- en: Before we start talking about Ansible, let’s quickly discuss my background,
    how I came to be writing a book about Ansible, and what you will need to install
    and run Ansible on your system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论 Ansible 之前，让我们简要介绍一下我的背景，讲讲我如何开始写 Ansible 相关书籍，以及你需要在系统上安装和运行 Ansible
    的前提条件。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Later in this chapter, we will install Ansible, so you will need a machine capable
    of running it. I will go into more detail about these requirements in the second
    half of the chapter. We will also use **Multipass** to launch a virtual machine
    locally. A section walks through installing Multipass and downloading an Ubuntu
    image to use the virtual machine’s base, which is a download of a few hundred
    MBs. You can find all of the code used in this chapter at [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter01).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后续内容中，我们将安装 Ansible，因此你需要一台能够运行它的机器。关于这些要求，我将在本章下半部分详细说明。我们还将使用**Multipass**在本地启动虚拟机。接下来的一节将指导你安装
    Multipass，并下载一个 Ubuntu 镜像作为虚拟机的基础，这个镜像的下载量大约是几百 MB。你可以在 [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter01)
    找到本章中使用的所有代码。
- en: 'My story: part one'
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的故事：第一部分
- en: I have been working with servers, primarily ones that serve web pages, since
    the late 90s, and the landscape is unrecognizable. Here is a quick overview of
    my first few years running servers to give you an idea of how I used to operate
    my early servers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 自上世纪 90 年代末以来，我一直在与服务器打交道，主要是为网页提供服务的服务器，那个时代的技术和现在完全不同。这里简要回顾了我运营服务器的最初几年，以便你了解我当时是如何操作我的早期服务器的。
- en: Like most people at the time, I started with a shared hosting account where
    I had very little control over anything on the server side when the website I
    was running outgrew shared hosting due to the forum, which made up part of the
    site’s popularity. I moved to a dedicated server, where I thought I could flex
    my future system administrator muscles, but I was wrong.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数人一样，我从一个共享主机账户开始，当时网站因论坛而逐渐超出了共享主机的承载能力，这也是该站点受欢迎的部分原因。我搬到了专用服务器，以为可以展示未来的系统管理员能力，但我错了。
- en: The server I got was a Cobalt RaQ 3; this was a 1U server appliance that was
    ahead of its time. However, I did not have root-level access to the machine, and
    I had to use the web-based control panel for everything I needed to do. Eventually,
    I got a level of access where I could access the server using Telnet; I now know
    this isn’t good, but it was the early days, and SSH was considered cutting-edge.
    I started to teach myself how to be a system administrator by making changes in
    the web control panel and looking at the changes to the configuration files on
    the server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我获得的服务器是一台 Cobalt RaQ 3；这是一款 1U 服务器设备，超越了当时的技术水平。然而，我没有对机器的 root 级别访问权限，所有需要做的操作都必须通过基于
    Web 的控制面板来完成。最终，我获得了访问权限，可以通过 Telnet 访问服务器；现在我知道这并不好，但那是早期阶段，SSH 被认为是前沿技术。我开始通过在
    Web 控制面板中进行更改并查看服务器上配置文件的变化，自学如何成为一名系统管理员。
- en: After a while, I changed servers and, this time, opted to forego any web-based
    control panel and use what I had learned with the Cobalt RaQ to configure my first
    proper **Linux**, **Apache**, **MySQL**, **PHP** (or **LAMP** for short) server
    by using the pages of notes I had made. I had created runbooks of one-liners to
    install and configure the software I needed and numerous scribbles to help me
    investigate problems and keep the lights on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，我更换了服务器，这次我决定放弃任何基于网页的控制面板，转而使用我在Cobalt RaQ上学到的知识，通过我整理的笔记来配置我的第一台真正的**Linux**、**Apache**、**MySQL**、**PHP**（简称**LAMP**）服务器。我创建了运行手册，包含了安装和配置所需软件的单行命令，还有大量草稿帮助我排查问题并保持服务器运行。
- en: After I got my second server for another project, I realized that was probably
    a good time to type out my notes so that I could copy and paste them when I needed
    to deploy a server; the timing of this couldn’t have been better as it was a few
    months after making these notes that my first server failed—my host apologized
    and replaced it with a higher-specification but completely fresh machine with
    an updated operating system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我为另一个项目得到了第二台服务器时，我意识到那时候正是整理笔记的好时机，这样我就可以在需要部署服务器时直接复制粘贴这些内容；这时机恰到好处，因为就在整理这些笔记几个月后，我的第一台服务器出现故障——我的主机提供商道歉并更换了一台更新操作系统的高配置全新机器。
- en: So, I grabbed my Microsoft Word file containing my notes and copied and pasted
    each instruction, making tweaks based on what I needed to install on the upgraded
    operating system. Several hours later, I had my server up and running and my data
    restored.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我拿起了包含笔记的Microsoft Word文件，复制并粘贴每条指令，根据需要安装在升级操作系统上的内容进行了调整。几个小时后，我的服务器启动并运行，数据也成功恢复。
- en: One of the critical lessons I learned, other than that there is no such thing
    as too many backups, was not to use Microsoft Word to store these types of notes;
    the Linux command line doesn’t care if your notes are all nicely formatted with
    headings and courier font for the bits you need to paste in. It does care about
    proper syntax, and Word had very kindly autocorrected and formatted all of my
    notes for print, meaning that not only did I have the pressure of having to deploy
    a new server and restore the backups I had thankfully been taking each day but
    also to try and debug my notes as I was doing so.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我学到的一个重要教训是，除了“没有什么比备份过多更为重要”这一点之外，就是不要用Microsoft Word来存储这类笔记；Linux命令行并不在乎你的笔记是否有漂亮的格式、标题和用于打印的Courier字体。它在乎的是正确的语法，而Word很“贴心”地为我所有的笔记做了自动更正和格式化，意味着我不仅要在部署新服务器和恢复每天备份的同时，还得调试我已经做好的笔记。
- en: Because of this, I made a copy of the history file on the server and transcribed
    my notes in plaintext. These notes provided the base for the next few years as
    I started to script parts of them, mainly the bits that didn’t require any user
    input.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我将服务器上的历史文件复制了一份，并将我的笔记转录为纯文本。这些笔记为接下来的几年提供了基础，我开始将其中的一些部分脚本化，主要是那些不需要用户输入的部分。
- en: These scraps of commands, one-liners, and scripts were all adapted through Red
    Hat Linux 6; note the lack of the word Enterprise appended to the operating system’s
    name there, all the way through to CentOS 3 and 4.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令片段、单行指令和脚本最初是通过Red Hat Linux 6进行调整的；注意操作系统名称后面没有附加“Enterprise”这个词，一直到CentOS
    3和4版本。
- en: Things got complicated when I changed roles; I stopped consuming services from
    a web hosting company and started working for one. Suddenly, I was building servers
    for customers who may have different requirements than my projects—each server
    was different.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我换了职位之后，事情变得复杂了；我不再从一个网络托管公司消费服务，而是开始为其中一家工作。突然之间，我开始为客户构建服务器，而这些客户的需求可能与我自己的项目不同——每台服务器都是不同的。
- en: From here, I started working with Kickstart scripts, PXE boot servers, gold
    masters on imaging servers, virtual machines, and bash scripts that started prompting
    information on the system being built. I had also moved from only needing to worry
    about maintaining my servers to having to log in to hundreds of different physical
    and virtual servers, from ones that belonged to the company I was working for
    to customer machines.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我开始使用Kickstart脚本、PXE启动服务器、影像服务器上的金盘映像、虚拟机，以及开始要求提供有关系统构建信息的bash脚本。我也从只需要担心维护自己的服务器，变成了必须登录到成百上千台不同的物理和虚拟服务器，从属于我工作的公司，到客户的机器。
- en: Over the next few years, my single text file quickly morphed into a complex
    collection of notes, scripts, precompiled binaries, and spreadsheets of information
    that only made sense to me; if I am being honest, I ended up making myself quite
    a significant single point of failure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几年里，我的单一文本文件迅速变成了一个复杂的笔记、脚本、预编译二进制文件和信息电子表格的集合，这些内容只有我能理解；如果说实话，我最终自己成了一个显著的单点故障。
- en: While I had moved to automate quite a few parts of my day-to-day work using
    bash scripts and stringing commands together, I found that my days were still
    very much filled with running all these tasks manually and working a service desk
    dealing with customer-reported problems and queries.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我已开始通过bash脚本和将命令串联在一起来自动化我日常工作的许多部分，但我发现我的日子仍然充满了手动执行所有这些任务，并且需要在服务台处理客户报告的问题和查询。
- en: My story is typical of many people, while the operating systems used will probably
    be considered ancient. The entry point of using a GUI and moving to the command
    line while keeping a scratch pad of common commands is quite a common scenario
    I have heard when working with other system administrators and even modern-day
    DevOps practitioners.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我的故事是许多人典型的经历，虽然使用的操作系统可能被认为是古老的。使用图形界面（GUI）并转向命令行，同时保留常用命令的便签，这是我在与其他系统管理员甚至现代DevOps从业者合作时，常常听到的一个典型场景。
- en: So now that you know a little about my background, let’s talk about Ansible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了我的背景，接下来我们来谈谈Ansible。
- en: Ansible’s story
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible的故事
- en: Let’s take a quick look at who developed Ansible and what it actually is.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下是谁开发了Ansible，以及它究竟是什么。
- en: What is Ansible?
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible是什么？
- en: Before we discuss how Ansible started, we should quickly discuss the origin
    of the name. The term “Ansible” was penned by science fiction novelist Ursula
    K. Le Guin; it was first used in her novel *Rocannon’s World*, which was first
    published in 1966\. In the story’s context, an Ansible is a fictional device that
    sends and receives messages faster than light.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论Ansible的起源之前，我们应该简要讨论一下它名字的由来。“Ansible”这一术语是科幻小说作家乌苏拉·K·勒古恩所创造；它首次出现在她1966年出版的小说*《洛卡农的世界》*中。在故事中，Ansible是一种虚构的设备，能够比光速更快地发送和接收消息。
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In 1974, Ursula K. Le Guin’s novel *The Dispossessed: An Ambiguous Utopia*
    was published. This book features the development of the Ansible technology by
    exploring the (fictional) details of the mathematical theory that would make such
    a device possible.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '1974年，乌苏拉·K·勒古恩的小说*《被剥夺的: 一个模糊的乌托邦》*出版。这本书通过探索使得这种设备成为可能的（虚构的）数学理论，展示了Ansible技术的发展。'
- en: The term has since been used by several other notable authors within the genre
    to describe communication devices that are capable of relaying messages over interstellar
    distances, which, as you will discover throughout the course of the book, is quite
    an apt description of the software itself.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个术语此后被许多其他著名作家在同一类型的作品中使用，描述能够跨星际距离传递信息的通信设备，正如你将在本书的过程中发现的那样，这也是对Ansible软件本身的恰当描述。
- en: Ansible, the software
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible，软件
- en: Ansible was initially developed by Michael DeHaan, who was also the author of
    **Cobbler**, which was developed while DeHaan worked for Red Hat.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible最初由Michael DeHaan开发，他也是**Cobbler**的作者，Cobbler是在DeHaan为Red Hat工作期间开发的。
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Cobbler is a Linux installation server that allows you to deploy servers within
    your network quickly; it can help with DNS, DHCP, package updates and distribution,
    virtual machine deployment, power management of physical hosts, and also the handoff
    of a newly deployed server, be it physical or virtual, to a configuration management
    system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Cobbler是一个Linux安装服务器，可以帮助你在网络中快速部署服务器；它可以处理DNS、DHCP、包更新和分发、虚拟机部署、物理主机的电源管理，以及将新部署的服务器，无论是物理的还是虚拟的，交给配置管理系统。
- en: DeHaan left Red Hat and worked for companies such as **Puppet**, which was a
    good fit since many users of Cobbler used it to hand off to a Puppet server to
    manage the servers once they had been provisioned, myself included.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: DeHaan离开了Red Hat，转而为像**Puppet**这样的公司工作，这非常合适，因为许多Cobbler的用户会在服务器配置完毕后，使用Puppet服务器来管理这些服务器，我也是其中之一。
- en: 'A few years after leaving Puppet, DeHaan made the first public commit to the
    Ansible project on February 23, 2012\. The original `README` file gave quite a
    simple description that laid the foundation for what Ansible would eventually
    become:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 离开Puppet几年后，DeHaan于2012年2月23日首次向Ansible项目提交了公共代码。最初的`README`文件给出了一个相当简单的描述，为Ansible最终会成为什么打下了基础：
- en: Ansible is an extra-simple Python API for doing ‘remote things’ over SSH. As
    Func, which I co-wrote, aspired to avoid using SSH and have its own daemon infrastructure,
    Ansible aspires to be quite different and more minimal, but still able to grow
    more modularly over time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一个极简的 Python API，用于通过 SSH 执行“远程操作”。就像我共同编写的 Func 想要避免使用 SSH 并拥有自己的守护进程基础设施一样，Ansible
    则志在与之完全不同，更加简洁，但仍能够随着时间推移更加模块化地发展。
- en: Since that first commit, and at the time of writing, there have been over 53,000
    commits by 5,000 contributors, and the project has over 58,000 stars on GitHub.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 自从首次提交以来，截止本文写作时，已有超过 53,000 次提交，来自 5,000 位贡献者，且该项目在 GitHub 上的星标超过 58,000。
- en: In 2013, the project had grown. Ansible, Inc. was founded to offer commercial
    support to users who had relied on the project to manage their infrastructure
    and server configuration, whether physical, virtual, or hosted on public clouds.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到 2013 年，项目已经发展壮大。Ansible, Inc. 成立，旨在为依赖该项目管理基础设施和服务器配置（无论是物理的、虚拟的，还是托管在公共云上的用户）提供商业支持。
- en: Out of the formation of Ansible, Inc., which received $6 million in series A
    funding, came the commercial Ansible Tower, which acted as a web-based frontend
    where end users could consume role-based access to Ansible services.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible, Inc. 成立后，该公司获得了 600 万美元的 A 轮融资，推出了商业版 Ansible Tower，作为一个基于 Web 的前端，最终用户可以通过它访问基于角色的
    Ansible 服务。
- en: Then, in October 2015, Red Hat announced they would acquire Ansible for $150
    million.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 2015 年 10 月，Red Hat 宣布以 1.5 亿美元收购 Ansible。
- en: In the announcement, Joe Fitzgerald, who was vice president, Management, at
    Red Hat at the time of the acquisition, stated, *“Ansible is a clear leader in
    IT automation and DevOps, and helps Red Hat take a significant step forward in
    our goal of creating* *frictionless IT.”*
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在公告中，当时 Red Hat 的管理副总裁 Joe Fitzgerald 说道，*“Ansible 是 IT 自动化和 DevOps 的明显领导者，帮助
    Red Hat 在实现创建* *无摩擦 IT 目标上迈出了重要一步。”*
- en: During this book, you will find that the statements in the original `README`
    file and Red Hat’s statement when acquiring Ansible still ring true.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你会发现原始 `README` 文件中的声明以及 Red Hat 在收购 Ansible 时的声明依然有效。
- en: Before we look at rolling our sleeves up and installing Ansible, which we will
    do later in this chapter, we should look at some of its core concepts.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始动手安装 Ansible（稍后我们会在本章进行安装）之前，我们应该先了解它的一些核心概念。
- en: Ansible versus other tools
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 与其他工具
- en: 'If you look at the design principles in the first commit compared to the current
    version, you will notice that while there have been some additions and tweaks,
    the core principles remain pretty much intact:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对比第一次提交时的设计原则和当前版本的设计，你会发现，尽管有一些增加和调整，核心原则基本上保持不变：
- en: '**Agentless**: Everything should be managed by the SSH daemon using the WinRM
    protocol in the case of Windows machines or API calls—there should be no reliance
    on custom agents or additional ports that need to be opened or interacted with
    on the target host. The machine running Ansible should need line of sight of the
    target resource network-wise.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无代理**：所有操作都应该通过 SSH 守护进程来管理，Windows 机器则使用 WinRM 协议或 API 调用——不应该依赖于自定义代理或需要在目标主机上打开或交互的其他端口。运行
    Ansible 的机器应该能够从网络上直接访问目标资源。'
- en: '**Minimal**: You should be able to manage new remote machines without installing
    any new software on the target host; each Linux target host will typically have
    at least SSH and Python installed as part of a minimal installation, which is
    all needed to run Ansible.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化**：你应该能够在不安装任何新软件的情况下管理新的远程机器；每个 Linux 目标主机通常至少会安装 SSH 和 Python，这些是运行
    Ansible 所需的最小安装环境。'
- en: '**Descriptive**: You should be able to describe your infrastructure, stack,
    or task in a language readable by machines and humans.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述性**：你应该能够用机器和人类都能读懂的语言描述你的基础设施、栈或任务。'
- en: '**Simple**: The setup processes and the learning curve should be simple and
    intuitive.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单**：设置过程和学习曲线应该简单直观。'
- en: '**Easy to use**: It should be the most accessible IT automation system ever.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于使用**：它应该是最易接入的 IT 自动化系统。'
- en: A few of these principles make Ansible quite different from other tools. Let’s
    examine the fundamental difference between Ansible and other tools, such as Puppet
    and **Chef**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些原则使得 Ansible 与其他工具有很大的不同。让我们来看看 Ansible 和其他工具（如 Puppet 和 **Chef**）之间的根本区别。
- en: Declarative versus imperative
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明式与命令式
- en: When I started using Ansible, I had already implemented Puppet to help manage
    the stacks on the machines I was managing. As the configuration became increasingly
    complex, the Puppet code became highly complicated. This was when I started looking
    at alternatives, and some fixed some of the issues I was facing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始使用Ansible时，我已经实现了Puppet来帮助管理我所管理的机器上的堆栈。随着配置变得越来越复杂，Puppet代码变得非常复杂。这时，我开始寻找替代方案，一些方案解决了我面临的一些问题。
- en: Puppet uses a custom declarative language to describe the configuration. Puppet
    then packages this configuration as a manifest that the agent running on each
    server then applies.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet使用一种自定义声明式语言来描述配置。然后，Puppet将此配置打包为一个清单，代理程序会在每台服务器上应用此清单。
- en: Using declarative language means that Puppet, Chef, and other configuration
    tools, such as **CFEngine**, all operate using the principle of eventual consistency,
    meaning that eventually, after a few runs of the agent, your desired configuration
    would be in place.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用声明式语言意味着Puppet、Chef和其他配置工具，如**CFEngine**，都采用最终一致性的原则，这意味着最终，在代理程序运行几次之后，你期望的配置会到位。
- en: On the other hand, Ansible is an imperative language that, rather than just
    defining the end state of your desired outcome and letting the tool decide how
    it should get there, you also define the order in which tasks are executed to
    reach the state you have defined.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Ansible是一种命令式语言，它不仅定义了你期望的最终状态并让工具决定如何到达该状态，还定义了执行任务的顺序，以达到你定义的状态。
- en: 'The example I use is as follows. We have a configuration where the following
    states need to be applied to a server:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的示例如下。我们有一个配置，其中需要将以下状态应用到服务器：
- en: Create a group called `Team`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Team`的组。
- en: Create a user `Alice` and add her to the group `Team`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用户`Alice`并将其添加到`Team`组。
- en: Create a user `Bob`, and add him to the group `Team`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用户`Bob`，并将其添加到`Team`组。
- en: Give the user `Alice` escalated privileges.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给用户`Alice`提升权限。
- en: 'This may seem simple; however, when you execute these tasks using declarative
    language, you may, for example, find that the following happens:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能很简单；然而，当你使用声明式语言执行这些任务时，你可能会发现发生了以下情况：
- en: '![Figure 1.1 – An overview of what happens with the declarative run](img/B21620_01_1.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 声明式运行时发生情况的概览](img/B21620_01_1.jpg)'
- en: Figure 1.1 – An overview of what happens with the declarative run
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 声明式运行时发生情况的概览
- en: So, what has happened here? Our tool has executed the tasks during `Alice` could
    not be created when the first task ran because the group `Team` did not exist.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么呢？我们的工具在`Alice`无法创建时执行了任务，因为第一个任务运行时`Team`组不存在。
- en: However, as the group `Team` was created before the user `Bob` was created,
    `Bob`’s user was created without any errors, and the final task, adding escalated
    privileges to the user `Alice`, failed because no user called `Alice` existed
    on the system for the escalated privileges to be applied to.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于`Team`组在创建用户`Bob`之前已经存在，`Bob`的用户成功创建，没有任何错误，最后一个任务，即为用户`Alice`添加提升权限失败，因为系统上不存在名为`Alice`的用户，无法将提升的权限应用到该用户。
- en: During `Team` existed, the user `Alice` was created, and because `Alice` was
    present, that user was given escalated privileges.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Team`存在的情况下，用户`Alice`被创建，并且由于`Alice`存在，该用户获得了提升的权限。
- en: No changes were needed during **run 3** as everything was as expected; that
    is, consistent.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在**运行 3**期间没有需要更改的内容，因为一切如预期；也就是说，状态是一致的。
- en: Each subsequent run would continue until there was either a change to the configuration
    or on the host itself, for example, if `Bob` had annoyed `Alice` and she used
    her escalated privileges to remove the user `Bob` from the host. When the agent
    subsequently runs, `Bob` will be recreated as that is still our desired configuration,
    no matter what access `Alice` thinks `Bob` should have.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每次随后的运行都会继续，直到配置或主机本身发生变化。例如，如果`Bob`惹恼了`Alice`，并且她使用了提升的权限将用户`Bob`从主机上删除。那么，当代理程序随后运行时，`Bob`将会被重新创建，因为这是我们期望的配置，不管`Alice`认为`Bob`应该拥有怎样的权限。
- en: 'If we were to run the same tasks using an imperative language, then the following
    should happen:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用命令式语言运行相同的任务，那么应该发生以下情况：
- en: '![Figure 1.2 – An overview of what happens with the imperative run](img/B21620_01_2.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 命令式运行时发生情况的概览](img/B21620_01_2.jpg)'
- en: Figure 1.2 – An overview of what happens with the imperative run
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 命令式运行时发生情况的概览
- en: The tasks are executed in the order we defined them, meaning that the `Team`
    group is created, the `Alice` and `Bob` users are added, and the escalated privileges
    to the `Alice` user are applied.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 任务会按照我们定义的顺序执行，这意味着首先会创建`Team`组，然后添加`Alice`和`Bob`用户，最后将提升的权限应用于`Alice`用户。
- en: As you can see, both ways get to our final configuration and enforce our desired
    state. With the tools that use declarative language, it is possible to declare
    dependencies, meaning we can engineer the issue we encountered when running the
    tasks.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，两种方法都能达到最终配置，并强制执行我们期望的状态。使用声明性语言的工具可以声明依赖关系，这意味着我们可以解决在运行任务时遇到的问题。
- en: However, this example only has four steps; what happens when you have a few
    hundred steps that are launching servers in public cloud platforms and then installing
    software that needs several prerequisites?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个例子只有四个步骤；如果你有几百个步骤，其中涉及在公共云平台上启动服务器，然后安装需要多个前提条件的软件会发生什么呢？
- en: This is the position I found myself in before I started to use Ansible. Puppet
    was great at enforcing my desired end configuration; however, to get there, I
    had to worry about building so much logic into my manifests to arrive at my desired
    state. In Puppet, this logic was using a function that allowed me as the end user
    to define my dependencies.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在开始使用Ansible之前所面临的情况。Puppet在强制执行我期望的最终配置方面非常出色；然而，要实现这一点，我不得不在我的清单中加入大量的逻辑，以达到预期的状态。在Puppet中，这些逻辑是通过一个函数实现的，允许我作为最终用户定义我的依赖关系。
- en: In the example we used, I would have had to define that users could only be
    created once the block of code that created the group had been run and the resource
    was present.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用的例子中，我必须定义用户只能在创建组的代码块运行并且资源存在后才可以创建。
- en: The more complex my code got, the more I fought the way the declarative tools
    wanted to run and the longer each execution would take because the tool had to
    consider my logic, which was a little hit and miss.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我的代码变得越复杂，我与声明性工具希望运行的方式斗争得越多，每次执行所需的时间也就越长，因为该工具必须考虑我的逻辑，而我的逻辑有时并不完全正确。
- en: This became more annoying, as each successful run was getting close to taking
    about 40 minutes to complete. If I had dependency issues, I had to start from
    scratch with each failure and change to ensure that I was fixing the problem and
    not because things were starting to become consistent, so that typically meant
    having to redeploy a resource rather than running subsequent runs of my code.
    This made development very time-consuming, especially when it came to debugging
    the code, which sometimes involved trial and error.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这变得越来越让人烦恼，因为每次成功运行的时间接近40分钟。如果我遇到依赖问题，我不得不从头开始，每次失败和更改时都要确保自己解决了问题，而不是因为事情开始变得一致，这通常意味着必须重新部署资源，而不是运行后续的代码。这使得开发变得非常耗时，尤其是在调试代码时，有时还需要进行反复试验。
- en: This is not a great position to find yourself in when you are on the clock and
    must meet customer deadlines.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在计时并且必须满足客户的最后期限时，陷入这种境地并不理想。
- en: Configuration versus orchestration
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置与编排
- en: Another critical difference between Ansible and the other tools it is commonly
    compared to is that most of these tools have their origins as systems designed
    to deploy and police a configuration state.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible与其他常被拿来比较的工具之间的另一个关键区别是，大多数这些工具起初是为了部署和管理配置状态而设计的系统。
- en: They typically require an agent to be installed on each host; that agent discovers
    some information about the host it is installed on, then calls back to a central
    server saying, “*Hi, I am server XYZ. Could I please have my configuration?*”
    The server then decides what the configuration for the server looks like and sends
    it across to the agent, which then applies it. Typically, this exchange takes
    place every 15 to 30 minutes—this is great if you need to enforce a configuration
    on a server.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通常需要在每个主机上安装一个代理；该代理会发现它所安装的主机上的一些信息，然后回调到中央服务器说：“*你好，我是服务器XYZ。请给我我的配置好吗？*”然后，服务器决定服务器的配置是什么，并将其发送给代理，代理再应用它。通常，这种交换每15到30分钟进行一次——如果你需要在服务器上强制执行某个配置，这非常有用。
- en: However, the way that Ansible has been designed to run allows it to act as an
    orchestration tool; for example, you can run it to launch a server in your VMware
    environment, and once the server has been launched, it can then connect to your
    newly launched machine and install a LAMP stack. Then, it never has to connect
    to that host again, meaning that all we are left with is the server, the LAMP
    stack, and nothing else, other than maybe a few comments in files to say that
    Ansible added some lines of configuration, which should be the only sign that
    Ansible was used to configure the host.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Ansible 的设计方式使其能够作为一个编排工具运行；例如，你可以使用它在 VMware 环境中启动一个服务器，服务器启动后，它可以连接到新启动的机器并安装
    LAMP 堆栈。然后，它不再需要连接该主机，这意味着我们剩下的只是服务器、LAMP 堆栈，除此之外，可能只有几个文件中的注释，说明 Ansible 添加了一些配置行，这应该是唯一的迹象，表明
    Ansible 被用来配置该主机。
- en: Looking at some code
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看一些代码
- en: 'Before we finish this part of the chapter and move on to installing Ansible,
    let’s quickly look at examples of some actual code. The following bash script
    installs several RPMs using the yum package manager:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章这一部分并进入安装 Ansible 之前，让我们快速看一下实际代码的例子。以下 bash 脚本使用 yum 包管理器安装多个 RPM：
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is a Puppet class that does the same task as the previous bash
    script:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 Puppet 类，它完成与之前的 bash 脚本相同的任务：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next up, we have the same task using **SaltStack**:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 **SaltStack** 完成相同的任务：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we have the same task again, this time using Ansible:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次完成相同的任务，这次使用的是 Ansible：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even without going into any detail, you should be able to get the general gist
    of what each of the three examples is doing. While not strictly infrastructure,
    all three are valid examples of infrastructure as code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不深入细节，你也应该能够大致理解这三个例子各自的作用。虽然不完全是基础设施管理，但这三者都是基础设施即代码的有效示例。
- en: This is where you manage the code that manages your infrastructure in precisely
    the same way as a developer would manage the source code for their application.
    You use source control, store it in a centrally available repository where you
    can collaborate with your peers, branch and use pull requests to check in your
    changes, and, where possible, write and execute unit tests to ensure that changes
    to your infrastructure are successful and error-free before deploying to production.
    This should be as automated as possible. Any manual intervention in the tasks
    mentioned could be a point of failure, and you should work to automate the task.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你以与开发人员管理其应用程序源代码完全相同的方式来管理管理你基础设施的代码。你使用源代码管理，存储在一个中央可用的仓库中，在那里你可以与同事合作，分支并使用拉取请求来检查你的更改，并且在可能的情况下，编写并执行单元测试，以确保对基础设施的更改在部署到生产之前是成功且没有错误的。这应该尽可能自动化。任何在上述任务中的人工干预都可能是故障点，你应该努力将任务自动化。
- en: This approach to infrastructure management has a few advantages, one being that
    you, as system administrators, are using the same processes and tooling as your
    developer colleagues, meaning that any procedures that apply to them also apply
    to you. This makes for a more consistent working experience and exposes you to
    tools you may have yet to be exposed to or use.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基础设施管理方法有一些优势，其中之一是，作为系统管理员，你正在使用与开发同事相同的流程和工具，这意味着适用于他们的任何流程也适用于你。这使得工作体验更加一致，并且让你接触到你可能还没有接触过或使用过的工具。
- en: Secondly, and more importantly, it allows you to share your work. Before this
    approach, this type of work seemed to others a dark art performed only by system
    administrators. Doing this work in the open allows you to have your peers review
    and comment on your configuration and do the same yourself to theirs. Also, you
    can share your work so that others can incorporate elements into their projects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，更重要的是，它使你能够共享你的工作。在这种方法之前，这类工作对于其他人来说似乎是一门只有系统管理员才能掌握的黑暗艺术。将这项工作公开，允许你的同事审查并评论你的配置，同时你也可以对他们的配置进行相同的操作。此外，你还可以分享你的工作，供他人将其元素整合到他们的项目中。
- en: 'My story: part two'
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的故事：第二部分
- en: Before we finish this part of the chapter, I would like to finish the story
    of my journey. As mentioned earlier in the chapter, I moved from my collection
    of scripts and runbooks to Puppet, which was great until my requirements moved
    away from managing just server configuration and maintaining the servers’ state.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章这一部分之前，我想讲完我的旅程故事。正如本章前面提到的，我从一堆脚本和运行手册转向了 Puppet，这非常好，直到我的需求开始超出仅仅管理服务器配置和维护服务器状态的范围。
- en: I needed to start managing infrastructure in public clouds. This requirement
    quickly started to frustrate me when using Puppet. At the time, Puppet’s coverage
    of the APIs I needed to use for my infrastructure needed to be improved. I am
    assured it is a lot better now, but also, I found myself having to build too much
    logic into my manifests about the order in which each task was executed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要开始管理公共云中的基础设施。当时，使用 Puppet 时，这个需求让我感到越来越沮丧。因为 Puppet 对我需要使用的基础设施 API 的支持不够完善。我确信现在好多了，但同时我发现自己不得不在清单文件中编写过多的逻辑，来控制每个任务执行的顺序。
- en: It was around this time, which was December 2014, that I decided to look at
    Ansible. I know the date because I wrote a blog post entitled *First Steps With
    Ansible*; I don’t think I have looked back since. I have since introduced several
    of my work colleagues and customers to Ansible and have written books on the subject,
    including the first edition of the title you are reading now.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大约是在 2014 年 12 月，我决定开始了解 Ansible。我记得这个时间点，因为我写了一篇名为 *与 Ansible 的第一步* 的博客文章；自那以后，我想我再也没有回头看过。我后来将
    Ansible 介绍给了几位同事和客户，并写了相关书籍，包括你现在正在阅读的本书的第一版。
- en: So far in this chapter, we have looked at my personal history with both Ansible
    and some of the other tools that Ansible is compared to, and we have discussed
    the differences between these tools and where Ansible originated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经回顾了我个人与 Ansible 以及一些与 Ansible 相比的其他工具的历史，讨论了这些工具之间的区别，以及 Ansible
    的起源。
- en: Now we are going to start your journey with Ansible by looking at installing
    it and running our first Ansible playbook against a local virtual machine.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过查看如何安装 Ansible 并运行我们的第一个 Ansible playbook 来开始你的 Ansible 之旅，目标是运行在本地虚拟机上。
- en: Installing and running Ansible
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和运行 Ansible
- en: Let’s dive straight in and install Ansible. Throughout this book, I will assume
    you are running a macOS host machine or a Linux machine with an Ubuntu LTS release.
    While we will cover running Ansible on Windows 11 using the Linux subsystem for
    Windows, this book will not support using Windows as a host machine.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始安装 Ansible。在本书中，我假设你正在使用 macOS 主机或运行 Ubuntu LTS 版本的 Linux 主机。虽然我们会讲解如何在
    Windows 11 上使用 Windows 子系统运行 Ansible，但本书不支持将 Windows 作为主机来使用。
- en: Installing on macOS
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 macOS 上安装
- en: You can install Ansible on your macOS host machine in a few different ways.
    I will cover both here. As we are discussing two different ways of installing
    Ansible, I recommend reading through this section and the *Pros and cons* subsection
    before choosing which installation method to use on your local machine.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种不同的方式在 macOS 主机上安装 Ansible。我将在这里讲解两种方法。由于我们讨论的是两种不同的安装方式，我建议在选择适合你本地机器的安装方法之前，先阅读本节以及*优缺点*小节。
- en: Installing with Homebrew
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Homebrew 安装
- en: The first installation method is to use a package manager called **Homebrew**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种安装方法是使用一个叫做 **Homebrew** 的包管理器。
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Homebrew is a package manager of macOS. It can be used to install command-line
    tools and desktop packages. It describes itself as *“The missing package manager
    for macOS”*, and it usually is one of the first tools I install after a clean
    installation or when getting a new computer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Homebrew 是 macOS 的一个包管理器，可以用来安装命令行工具和桌面应用程序。它自称是 *“macOS 缺失的包管理器”*，通常是在我做干净安装或新电脑时安装的第一个工具。
- en: 'To install Ansible using Homebrew, you first need to install Homebrew. To do
    this, run the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 Homebrew 安装 Ansible，你首先需要安装 Homebrew。为此，运行以下命令：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At each step of the installation process, the installer will tell you exactly
    what it is going to do and also prompt you for any additional information it needs
    from you to complete the installation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程的每一步，安装程序都会告诉你它将做什么，并提示你提供完成安装所需的任何额外信息。
- en: 'Once installed, or if you already have Homebrew installed, run the following
    commands to update your list of packages; if there are any updates, then you can
    also upgrade them:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，或者如果你已经安装了 Homebrew，运行以下命令来更新你的软件包列表；如果有更新，你也可以进行升级：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, depending on how new your installation is or when you last used it,
    you might want to run the following command to check that your Homebrew installation
    is optimal:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，根据你安装的版本新旧，或者你上次使用它的时间，你可能需要运行以下命令来检查你的 Homebrew 安装是否最优化：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have Homebrew installed, updated, and ready to `brew`, we can run
    the following to check what Ansible packages Homebrew has by running:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装并更新了Homebrew，并准备好使用`brew`，我们可以运行以下命令来检查Homebrew中有哪些Ansible包：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see from the results in the following screenshot, there are several
    packages returned in the search:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从以下截图中的结果看到的，搜索结果中返回了几个包：
- en: '![Figure 1.3 – Searching for Ansible using the brew command](img/B21620_01_3.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 使用brew命令搜索Ansible](img/B21620_01_3.jpg)'
- en: Figure 1.3 – Searching for Ansible using the brew command
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 使用brew命令搜索Ansible
- en: 'We want the Ansible package; you can find out more about the package by running
    the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是Ansible包；你可以通过运行以下命令来获取有关该包的更多信息：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can see the results of the command in the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下截图中看到命令的结果：
- en: '![Figure 1.4 – Viewing information on the Ansible package we will install](img/B21620_01_4.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 查看我们将要安装的Ansible包的信息](img/B21620_01_4.jpg)'
- en: Figure 1.4 – Viewing information on the Ansible package we will install
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 查看我们将要安装的Ansible包的信息
- en: As you can see, the command returns information on the version of the package
    that will be installed along with a complete list of its dependencies; in the
    preceding screen, all of the dependencies have green ticks next to them because
    I already have them installed—yours may look different.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，命令返回了将要安装的包的版本信息，并列出了所有依赖项的完整列表；在之前的屏幕中，所有依赖项旁边都有绿色勾选，因为我已经安装了它们——你的显示可能会有所不同。
- en: It also gives the URL to the Homebrew formula, which will be used to install
    the package. In our case, you can view formula details at [https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb](https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它还给出了Homebrew公式的URL，用于安装该包。在我们的案例中，你可以在[https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb](https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb)查看公式详情。
- en: 'To install Ansible using Homebrew, we must run the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Homebrew安装Ansible，我们必须运行以下命令：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will download and install all dependencies and then the Ansible package
    itself.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载并安装所有依赖项，然后是Ansible包本身。
- en: Depending on how many dependencies are installed on your machine, this may take
    a few minutes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的机器上安装的依赖项数量，这可能需要几分钟时间。
- en: 'Once installed, you should see something like the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你应该能看到类似以下截图的内容：
- en: '![Figure 1.5 – Installing Ansible using Homebrew](img/B21620_01_5.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 使用Homebrew安装Ansible](img/B21620_01_5.jpg)'
- en: Figure 1.5 – Installing Ansible using Homebrew
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 使用Homebrew安装Ansible
- en: As you can see from the preceding screenshot, Homebrew is quite verbose in its
    output, giving you both feedback on what it is doing and details on how to use
    the packages it installs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从前面的截图中看到的，Homebrew的输出非常详细，既提供了它正在执行的操作反馈，又给出了如何使用其安装的包的详细信息。
- en: The second of two installation methods we will look at for macOS is a more traditional
    one.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第二种安装方法是一种更传统的方法。
- en: Installing using pip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用pip安装
- en: The second method, pip, is a more traditional approach to installing and configuring
    a Python package.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法，pip，是一种更传统的安装和配置Python包的方法。
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`pip` is a package manager for Python software. It is a recursive acronym for
    **pip install packages**. It is a good frontend for installing packages from the
    **Python Package** **Index** (**PyPI**).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip`是Python软件的包管理器。它是**pip install packages**的递归缩写。它是从**Python Package** **Index**（**PyPI**）安装包的一个很好的前端工具。'
- en: Most modern macOS installations come with pip installed by default; depending
    on what you have installed on your machine, you may have to check which pip binary
    you have installed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代macOS安装默认会安装pip；根据你机器上安装的内容，你可能需要检查安装了哪个pip二进制文件。
- en: 'To do this, run the following commands:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请运行以下命令：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One or both should return a version number and give you the path to the pip
    binary.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个或两个应该返回版本号，并提供pip二进制文件的路径。
- en: 'Depending on the version of pip you have installed, you may need to amend the
    following pip command, which is what we need to run to install Ansible:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你安装的pip版本，你可能需要修改以下pip命令，这是我们需要运行的命令来安装Ansible：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This command will download and install all the prerequisites to run Ansible
    on your system. While it is as verbose as Homebrew, its output contains information
    on what it has done rather than hints on what to do next:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将下载并安装运行 Ansible 所需的所有先决条件。虽然它和 Homebrew 一样详细，但它的输出包含的是它已完成的操作信息，而不是下一步的提示：
- en: '![Figure 1.6 – Installing Ansible using Pip](img/B21620_01_6.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 使用 Pip 安装 Ansible](img/B21620_01_6.jpg)'
- en: Figure 1.6 – Installing Ansible using Pip
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 使用 Pip 安装 Ansible
- en: As you can see from the small amount of output, many of the requirements were
    already satisfied.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从少量的输出中可以看到，许多依赖项已经满足。
- en: Pros and cons
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优缺点
- en: So, now that we have covered some of the different ways of installing Ansible
    on macOS, which is best? Well, there is no real answer to this as it comes down
    to personal preference. Both methods will install the latest versions of Ansible.
    However, Homebrew tends to be a week or two behind the current release.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现在我们已经覆盖了在 macOS 上安装 Ansible 的一些不同方法，哪种方法最好呢？实际上没有真正的答案，因为这取决于个人偏好。这两种方法都会安装
    Ansible 的最新版本。然而，Homebrew 往往比当前版本滞后一个或两个星期。
- en: 'If you have a lot of packages already installed using Homebrew, then you will
    be used to running the following commands:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用 Homebrew 安装了很多软件包，那么你应该已经习惯了运行以下命令：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Just run these occasionally to update your installed packages to the latest
    versions. If you already do this, it makes sense to use Homebrew to manage your
    Ansible installation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 只需偶尔运行这些命令来更新已安装的软件包到最新版本。如果你已经在做这件事，那么使用 Homebrew 来管理你的 Ansible 安装是有意义的。
- en: 'If you are not a Homebrew user and want to ensure that you immediately have
    the latest version installed, use the pip command to install Ansible. Upgrading
    to the latest version of Ansible is as simple as running the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是 Homebrew 用户，并且希望确保立即安装最新版本的 Ansible，可以使用 pip 命令来安装 Ansible。升级到最新版本的 Ansible，只需运行以下命令：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Should you need to, you can install older versions of Ansible using Homebrew
    and pip.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以使用 Homebrew 和 pip 安装 Ansible 的旧版本。
- en: 'To do this using Homebrew, you need to remove the current version by running
    the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Homebrew 执行此操作，你需要通过运行以下命令删除当前版本：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, you can install an earlier version of the package by running the following
    command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过运行以下命令安装旧版本的软件包：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'While this will install an earlier version, you do not have much choice in
    which version you get. If you really need an exact version, you can use the pip
    command to install it. For example, to install Ansible 2.3.1.0, you would need
    to run:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这会安装旧版本，但你对安装哪个版本没有太多选择。如果你确实需要一个精确的版本，可以使用 pip 命令来安装它。例如，要安装 Ansible 2.3.1.0，你需要运行：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is essential to note that you should never need to do this, and I do not
    recommend it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，你通常不需要这样做，而且我也不推荐这么做。
- en: However, I have found that on rare occasions, I have had to downgrade to help
    debug quirks in my playbooks introduced by upgrading to a later version of Ansible
    for playbooks that I last touched a few years ago.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我发现，在少数情况下，我不得不降级以帮助调试通过升级到较高版本的 Ansible 导致的我几年前最后一次修改的 playbook 中出现的怪异问题。
- en: As mentioned, I spend the bulk of my time in front of a macOS machine both during
    my day job and at home, so which of the two methods do I use?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我大部分时间都在 macOS 机器前度过，无论是在工作中还是在家里，那么我使用的是哪种方法呢？
- en: Primarily, I use Homebrew as I have several other tools installed using Homebrew.
    However, if I need to roll back to a previous version, I use pip and then return
    to Homebrew once the issue is resolved.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 主要是因为我使用 Homebrew，因为我还安装了其他几个工具。然而，如果我需要回滚到以前的版本，我会使用 pip，然后在问题解决后再返回使用 Homebrew。
- en: Installing on Linux
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Linux 上安装
- en: There are a few different ways of installing Ansible on Ubuntu. However, I am
    only going to cover one of them here. While there are packages available for Ubuntu
    that you can install with `apt`, they tend to become out of date quickly and are
    typically behind the current release.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上安装 Ansible 有几种不同的方法。但我这里只会介绍其中一种。虽然有适用于 Ubuntu 的包可以通过 `apt` 安装，但它们通常会很快过时，并且通常会滞后于当前发布版本。
- en: 'If you wish to install using the `apt` package manager, then you can run the
    following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用 `apt` 包管理器进行安装，可以运行以下命令：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`.``deb` files.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`.``deb` 文件。'
- en: 'Because of this, we will be using pip. The first thing to do is install pip,
    and this can be done by running the following commands:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用 pip。首先要做的是安装 pip，可以通过运行以下命令来完成：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first of the two `apt-get` commands downloads all the update files, ensuring
    that the package list is up to date on your Ubuntu installation, and the second
    command installs the `python3-pip` package and its dependencies.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `apt-get` 命令会下载所有更新文件，确保你的 Ubuntu 安装中的软件包列表是最新的，第二个命令安装 `python3-pip` 包及其依赖。
- en: 'Once pip is installed, the instruction for installing Ansible is similar to
    installing on macOS. Run the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 pip，安装 Ansible 的方法和在 macOS 上类似。运行以下命令：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will download and then install Ansible and its requirements, as shown
    in the following screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载并安装 Ansible 及其所需的组件，如下图所示：
- en: '![Figure 1.7 – Installing Ansible using pip on Ubuntu](img/B21620_01_7.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – 在 Ubuntu 上使用 pip 安装 Ansible](img/B21620_01_7.jpg)'
- en: Figure 1.7 – Installing Ansible using pip on Ubuntu
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 在 Ubuntu 上使用 pip 安装 Ansible
- en: 'Once installed, you can upgrade it by using the following command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以使用以下命令进行升级：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, downgrading Ansible uses the same command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，降级 Ansible 使用相同的命令：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding commands should work on most Linux distributions, such as Rocky
    Linux, Red Hat Enterprise Linux, Debian, and Linux Mint, to name a few.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令应适用于大多数 Linux 发行版，如 Rocky Linux、Red Hat Enterprise Linux、Debian 和 Linux
    Mint 等。
- en: 'A lot of these distributions have their own package managers you can also use
    to install Ansible; for example, on Red Hat-based distributions such as Red Hat
    Enterprise Linux or Rocky Linux, you could also run:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 很多这些发行版都有自己的包管理器，你也可以使用它们来安装 Ansible；例如，在基于 Red Hat 的发行版（如 Red Hat Enterprise
    Linux 或 Rocky Linux）上，你也可以运行：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Please consult the document for more details on installing whatever your Linux
    distribution of choice is.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考文档获取有关安装你选择的 Linux 发行版的更多细节。
- en: Installing on Windows 11
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Windows 11 上安装
- en: The last platform we will cover is Windows 11; well, sort of. While it is technically
    possible to run Ansible on a Windows 11 natively, it is not something I would
    recommend attempting as it is one of those tasks where the phrase “*just because
    you can doesn’t mean you should*” applies, as getting all of the dependencies
    installed and configured just right can be very troublesome, and maintaining them
    is more so.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的最后一个平台是 Windows 11，嗯，也不完全是。虽然技术上可以在 Windows 11 上本地运行 Ansible，但我不建议尝试，因为这是一个典型的“*只是因为你能，不代表你应该*”的例子，安装和配置所有依赖项的过程非常麻烦，而且维护起来更加复杂。
- en: Luckily, Microsoft—and as a long-term Linux System administrator typing this,
    this still feels strange—has excellent native support for running Linux systems
    seamlessly within Windows 11.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，微软——作为一名长期的 Linux 系统管理员，写下这些话时依然感觉很奇怪——对在 Windows 11 中无缝运行 Linux 系统提供了出色的原生支持。
- en: 'Open the Microsoft Store and search for Ubuntu; you should see something like
    the following screen:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Microsoft Store，搜索 Ubuntu；你应该看到类似下图的界面：
- en: '![Figure 1.8 – Finding Ubuntu in the Microsoft Store](img/B21620_01_8.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 在 Microsoft Store 中找到 Ubuntu](img/B21620_01_8.jpg)'
- en: Figure 1.8 – Finding Ubuntu in the Microsoft Store
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 在 Microsoft Store 中找到 Ubuntu
- en: Click the **Get** button to download Ubuntu. Once downloaded, we have Ubuntu
    on our Windows 11 host, but we still need something to run it on. To run it, we
    need to enable Windows Subsystem for Linux.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **获取** 按钮下载 Ubuntu。下载完成后，我们就可以在 Windows 11 主机上运行 Ubuntu，但我们仍需要一个可以运行它的环境。要运行它，我们需要启用
    Windows 子系统 Linux。
- en: 'To enable this, open a PowerShell window by typing **PowerShell** into your
    Windows Search bar and opening the **Windows PowerShell** application; once you
    are at a terminal prompt, run the following command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用此功能，请打开 PowerShell 窗口，在 Windows 搜索栏中输入 **PowerShell** 并打开 **Windows PowerShell**
    应用程序；当你进入终端提示符后，运行以下命令：
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Follow the onscreen prompts, and once everything is installed, restart your
    Windows 11 host.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 按照屏幕上的提示操作，安装完成后，重启你的 Windows 11 主机。
- en: 'Once rebooted, you should have something like the following prompt pop-up once
    you log back in:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 重启后，重新登录时，你应该会看到类似以下的提示：
- en: '![Figure 1.9 – Completing the Ubuntu installation on Windows 11](img/B21620_01_9.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – 完成在 Windows 11 上安装 Ubuntu](img/B21620_01_9.jpg)'
- en: Figure 1.9 – Completing the Ubuntu installation on Windows 11
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 完成在 Windows 11 上安装 Ubuntu
- en: Once the installation is completed, I like to switch out of the default Windows
    Subsystem for the Linux terminal and use the Microsoft Terminal, which you can
    grab for free in the Microsoft Store.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装完成，我喜欢退出默认的 Windows 子系统 Linux 终端，改用 Microsoft Terminal，你可以在 Microsoft Store
    中免费下载该终端。
- en: 'Once you have your preferred terminal emulator open and you are sitting at
    a prompt in your Windows Subsystem for Linux Ubuntu installation, you can run
    the same commands we ran to install Ansible on Linux, which are as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你打开了首选的终端模拟器，并且在 Windows 子系统中的 Ubuntu 安装的提示符下，可以运行我们在 Linux 上安装 Ansible 时运行的相同命令，命令如下：
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once you have run these commands, you should see an output that looks like
    the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这些命令后，你应该会看到如下截图的输出：
- en: '![Figure 1.10 – Installing Ansible in Ubuntu on Windows 11](img/B21620_01_10.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10 – 在 Windows 11 上的 Ubuntu 中安装 Ansible](img/B21620_01_10.jpg)'
- en: Figure 1.10 – Installing Ansible in Ubuntu on Windows 11
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 在 Windows 11 上的 Ubuntu 中安装 Ansible
- en: As you can see, everything works as if you were running an Ubuntu machine, allowing
    you to run and maintain your Ansible installation in precisely the same way.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一切工作方式就像你在运行一台 Ubuntu 机器，允许你以完全相同的方式运行和维护 Ansible 安装。
- en: Note
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **Windows Subsystem for Linux** (**WSL**) is not running on a virtual machine.
    It is a full native Linux experience baked right into Windows 11\. It targets
    developers who must run Linux tools as part of their toolchain. While the overall
    support for Linux commands is excellent, I recommend reading through the FAQs
    written and maintained by Microsoft to get an idea of the limits and quirks of
    the subsystem. The FAQ can be found at [https://learn.microsoft.com/en-us/windows/wsl/faq](https://learn.microsoft.com/en-us/windows/wsl/faq).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 子系统（WSL）** 并非在虚拟机中运行。它是一个完全本地化的 Linux 环境，直接集成在 Windows 11 中。它面向需要在工具链中运行
    Linux 工具的开发者。尽管整体上对 Linux 命令的支持非常好，我建议阅读微软编写并维护的常见问题解答，以了解子系统的限制和特性。常见问题解答可以在
    [https://learn.microsoft.com/en-us/windows/wsl/faq](https://learn.microsoft.com/en-us/windows/wsl/faq)
    找到。'
- en: As mentioned, while this is a viable way of running an Ansible control node
    on a Windows-based machine, some of the other tools we will cover in future chapters
    may not work with Windows. So, while you may follow along using the Ubuntu instructions,
    some parts may not work.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，虽然这是在 Windows 系统上运行 Ansible 控制节点的可行方式，但我们在未来章节中介绍的其他一些工具可能无法与 Windows 配合使用。因此，尽管你可以按照
    Ubuntu 的说明进行操作，但某些部分可能无法正常工作。
- en: Launching a virtual machine
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动虚拟机
- en: To launch a virtual machine to run our first set of Ansible commands against,
    we will use a tool called **Multipass**. This tool allows you to run Ubuntu virtual
    machines on your local host. It works with macOS, Linux, and Windows.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动一个虚拟机来运行我们的第一组 Ansible 命令，我们将使用一个名为 **Multipass** 的工具。这个工具允许你在本地主机上运行 Ubuntu
    虚拟机。它支持 macOS、Linux 和 Windows。
- en: 'To install Multipass on macOS, we can use Homebrew and run the following command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 macOS 上安装 Multipass，我们可以使用 Homebrew 并运行以下命令：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To install on Ubuntu, you can run the following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Ubuntu 上安装，你可以运行以下命令：
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, for Windows 11 users, you will have to first download and install the
    VirtualBox Windows executable from [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)
    and then download and install Multipass from https://multipass.run/install. I
    recommend reading through the installation notes for Windows, which can be found
    at the following URL https://multipass.run/docs/installing-on-windows before installing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 Windows 11 用户，你需要先从 [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)
    下载并安装 VirtualBox Windows 可执行文件，然后从 https://multipass.run/install 下载并安装 Multipass。我建议在安装之前，先阅读
    Windows 上的安装说明，说明文档可以在以下网址找到：https://multipass.run/docs/installing-on-windows。
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While you can run the same commands in Ubuntu running under Windows Subsystem
    for Linux, you will need to replace all references of the `multipass` command
    with `multipass.exe` so that the Windows version of Multipass is called.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在 Windows 子系统中的 Ubuntu 上运行相同的命令，但你需要将所有 `multipass` 命令的引用替换为 `multipass.exe`，以便调用
    Windows 版本的 Multipass。
- en: Next, check out the GitHub repo accompanying this title and open your terminal
    in the `Chapter01` folder—if you are running Windows 11, you must open an Ubuntu
    terminal, not a Windows one.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查看与本书相关的 GitHub 仓库，并在 `Chapter01` 文件夹中打开终端。如果你使用的是 Windows 11，必须打开 Ubuntu
    终端，而不是 Windows 终端。
- en: Important
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: 'Before we start, a quick word of warning: the folder `Chapter01` contains an
    OpenSSH key-pair, which will be used to access the local machine. It is important
    that you do not use this key-pair anywhere other than this example on your local
    machine as the key-pair is publicly accessible, which is not considered secure.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，快速提醒一句：`Chapter01`文件夹中包含一个OpenSSH密钥对，将用于访问本地机器。重要的是不要在本地机器上将这个密钥对用于除本例之外的其他任何地方，因为该密钥对是公开的，这样做不安全。
- en: You will see several files in the `Chapter01` folder. The one we are going to
    use when launching the virtual machine is called `vmadmin` and attach the public
    portion of an OpenSSH key to the user, meaning that when executing Ansible, we
    can use the private part of the OpenSSH key to authenticate as the `vmadmin` user.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter01`文件夹中，你会看到几个文件。我们在启动虚拟机时要使用的文件名为`vmadmin`，并将OpenSSH密钥的公共部分附加到该用户上，这意味着在执行Ansible时，我们可以使用OpenSSH密钥的私有部分进行身份验证，以`vmadmin`用户身份登录。
- en: 'The command we are going to run to launch the virtual machine, which will be
    called **ansiblevm**, is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要运行的命令来启动虚拟机，该虚拟机名为**ansiblevm**，命令如下：
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once the virtual machine has been launched, which may take a short while when
    you first run the command as it will download a virtual machine image, you need
    to run the following command to get some information on the newly created `ansiblevm`
    virtual machine:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦虚拟机启动（初次运行该命令时可能需要一段时间，因为它会下载虚拟机镜像），你需要运行以下命令来获取新创建的`ansiblevm`虚拟机的一些信息：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following screen shows me starting and viewing the information on the virtual
    machine:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕显示了我启动并查看虚拟机信息的过程：
- en: '![Figure 1.11 – Launching our virtual machine](img/B21620_01_11.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11 – 启动我们的虚拟机](img/B21620_01_11.jpg)'
- en: Figure 1.11 – Launching our virtual machine
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 启动我们的虚拟机
- en: Now that we have our virtual machine running and we have checked out the basic
    information, you will need to note the IP address, which in my case is `192.168.64.7`.
    The IP address will be different when you launch the virtual machine on your host.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在虚拟机已经启动并且基本信息已经检查过，你需要记下IP地址，在我这里是`192.168.64.7`。当你在主机上启动虚拟机时，IP地址会有所不同。
- en: 'Before we run our first Ansible playbook, you must make a copy of the `hosts-simple.example`
    and `hosts.example` files and remove the `.example` in the filename by running
    the following commands:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行第一个Ansible playbook之前，你必须复制`hosts-simple.example`和`hosts.example`文件，并通过运行以下命令去掉文件名中的`.example`：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once you have made a copy of the file, open the newly created files and replace
    just the text that says `paste_your_ip_here` with the IP address of the `ansiblevm`
    virtual machine; in my case, the `hosts-simple` file went from:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你复制了文件，打开新创建的文件，并将其中写着`paste_your_ip_here`的文本替换为`ansiblevm`虚拟机的IP地址；在我这里，`hosts-simple`文件的内容从以下内容变为：
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'to reading:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读内容：
- en: '[PRE31]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once you have changed both the `hosts-simple` and `hosts` files, you are ready
    to run your first Ansible Playbook.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你修改了`hosts-simple`和`hosts`文件，你就可以开始运行第一个Ansible Playbook了。
- en: An introduction to playbooks
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: playbook简介
- en: Typically, in IT, a **playbook** is a set of instructions run by someone when
    something happens; a little vague, I know, but stay with me. These range from
    building and configuring new server instances to deploying code updates and dealing
    with problems when they occur.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在IT领域，**playbook**通常是一组在某些事件发生时由某人执行的指令；这个定义有点模糊，我知道，但请继续听下去。这些指令包括从构建和配置新的服务器实例到部署代码更新，以及处理出现的问题等。
- en: In the traditional sense, a playbook is typically a collection of scripts or
    instructions for a user to follow, and while they are meant to introduce consistency
    and conformity across systems, even with the best intentions, this is seldom the
    case.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统意义上，playbook通常是用户要遵循的脚本或指令集合，虽然它们的目的是在系统之间引入一致性和规范性，但即使出于最好的意图，这种情况也很少发生。
- en: This is where Ansible comes in. Using an Ansible playbook, you are telling it
    to apply these changes and commands against these sets of hosts rather than having
    to log in and start working your way through the playbook manually.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Ansible的作用所在。通过使用Ansible playbook，你告诉它对这些主机组应用这些更改和命令，而不必登录并手动执行playbook。
- en: Before we run a playbook, let’s discuss how we provide Ansible with a list of
    hosts to target. To do this, we will be using the `ansible.builtin.setup` module.
    This connects to a host and then fetches as much information on the host as possible.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 playbook 之前，让我们讨论如何为 Ansible 提供目标主机的列表。为此，我们将使用 `ansible.builtin.setup`
    模块。这个模块会连接到主机，然后尽可能多地获取关于该主机的信息。
- en: Host inventories
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机清单
- en: To provide a list of hosts, we need to provide an inventory list. This is in
    the form of a host’s file.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供主机列表，我们需要提供一个清单列表。这是以主机文件的形式提供的。
- en: 'In its simplest form, our host’s file could contain a single line just like
    our `hosts-simple` file:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式下，我们的主机文件可以像我们的 `hosts-simple` 文件一样，包含一行内容：
- en: '[PRE32]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This tells Ansible that the host we want to contact is `192.168.64.7.nip.io`
    (please remember your IP address will be different) using the username `vmadmin`.
    If we didn’t provide the username, it would fall back to the user you are logged
    into your Ansible control host as, which in my case is the user `russ`, which
    does not exist on the `ansiblevm` we launched. The final part tells Ansible to
    use the private OpenSSH key file called `example_key`, which we installed the
    public portion of to the `vmadmin` user when we launched the virtual machine.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Ansible 我们要联系的主机是 `192.168.64.7.nip.io`（请记住，你的 IP 地址会不同），并使用用户名 `vmadmin`。如果我们没有提供用户名，它会回退到你在
    Ansible 控制主机上登录的用户，在我的例子中是 `russ` 用户，但 `ansiblevm` 上并不存在该用户。命令的最后部分告诉 Ansible
    使用名为 `example_key` 的私有 OpenSSH 密钥文件，我们在启动虚拟机时将其公钥部分安装到了 `vmadmin` 用户下。
- en: Note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are using [https://nip.io](https://nip.io), a free service that provides
    free wildcard DNS entries for any hostname containing an IP address. This means
    that our domain `192.168.64.7.nip.io` will resolve to `192.168.64.7` when a DNS
    lookup is made against the domain.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是 [https://nip.io](https://nip.io)，这是一个免费服务，提供任何包含 IP 地址的主机名的通配符 DNS 记录。这意味着我们的域名
    `192.168.64.7.nip.io` 在进行 DNS 查询时将解析为 `192.168.64.7`。
- en: 'To run the `ansible.builtin.setup` module, we need to run the following command
    from within the `Chapter01` folder where your updated `hosts-simple` and `example_key`
    files are stored, making sure to update the IP address to your own:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 `ansible.builtin.setup` 模块，我们需要从存储更新后的 `hosts-simple` 和 `example_key` 文件的
    `Chapter01` 文件夹中运行以下命令，并确保更新 IP 地址为你自己的：
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If everything works as expected, you should see a lot of output, which specifies
    some quite detailed and low-level information about your host. You should see
    something like the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该看到大量输出，其中包含关于你的主机的相当详细且低级别的信息。你应该看到类似以下内容：
- en: '![Figure 1.12 – The start of the output of me running the ansible.builtin.setup
    module](img/B21620_01_12.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12 – 我运行 ansible.builtin.setup 模块时输出的开始部分](img/B21620_01_12.jpg)'
- en: Figure 1.12 – The start of the output of me running the ansible.builtin.setup
    module
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 我运行 ansible.builtin.setup 模块时输出的开始部分
- en: As you can see from the preceding screenshot, Ansible has quickly found out
    a lot of information on our Vagrant box. The screenshot shows the IP addresses
    configured on the machine, along with the IPv6 addresses. It has recorded the
    time and date, and if you scroll through your output, you will see a lot of information
    returned detailing the host.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从前面的截图中看到的，Ansible 很快就发现了我们 Vagrant box 上的很多信息。截图显示了机器上配置的 IP 地址和 IPv6 地址。它记录了时间和日期，如果你滚动浏览输出，你会看到返回了很多详细的主机信息。
- en: 'Let’s go back to the command we ran:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们执行的命令：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, we are loading the `hosts-simple` file using the `-i` flag.
    We could have also used `--inventory=hosts-simple`, which loads our inventory
    file. The next part of the command is the host to the target. In our case, this
    is `192.168.50.4.nip.io`. The final part of the command, `-m`, tells Ansible to
    use the setup module. We could have also used `--``module-name= ansible.builtin.setup`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用 `-i` 标志加载 `hosts-simple` 文件。我们也可以使用 `--inventory=hosts-simple`，它会加载我们的清单文件。命令的下一部分是目标主机。在我们的例子中，这就是
    `192.168.50.4.nip.io`。命令的最后部分，`-m`，告诉 Ansible 使用 setup 模块。我们也可以使用 `--module-name=
    ansible.builtin.setup`。
- en: 'This means that the full command if we didn’t use shorthand would be:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们不使用简写命令，完整的命令应该是：
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As already mentioned, the `hosts-simple` file is as basic as we can get it.
    The following is a more common host inventory file:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`hosts-simple` 文件是我们能做到的最简单形式。以下是一个更常见的主机清单文件：
- en: '[PRE36]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is the content of the file called just `hosts`; as you can see, there is
    a lot more going on, so let’s quickly work through it from top to bottom.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是名为 `hosts` 的文件内容；如你所见，里面有更多的内容，所以我们从头到尾快速讲解一遍。
- en: 'The first line defines our single host. Unlike the simple example, we will
    be calling our target host `ansiblevm` and grouping it together in a group called
    `ansible_hosts`, so we are giving Ansible details of where it can SSH to. This
    means we can now use the name `ansiblevm` when referring to `192.168.64.7.nip.io`.
    This means our command would now look something like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了我们的单一主机。与简单示例不同，我们将目标主机命名为 `ansiblevm`，并将其归入名为 `ansible_hosts` 的组中，因此我们正在向
    Ansible 提供它可以 SSH 连接的位置。这意味着现在我们可以使用名称 `ansiblevm` 来引用 `192.168.64.7.nip.io`。这意味着我们的命令现在看起来像这样：
- en: '[PRE37]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next up in the file, we are creating a group of hosts called `ansible_hosts`
    and, in that group, we are adding our single host `ansiblevm`. This means that
    we can also run:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的下一部分，我们创建了一个名为 `ansible_hosts` 的主机组，并将我们的单一主机 `ansiblevm` 添加到该组中。这意味着我们也可以运行：
- en: '[PRE38]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If we had more than just a single host in the group, the preceding command would
    have looped through all of them. The final section of the `hosts` file sets up
    some common configuration options for all of the hosts in the boxes group. In
    this case, we are telling Ansible that all of the hosts in the group are using
    SSH, the user is `vmadmin`, the private key at `./example_key` should be used,
    and it should not check the host key when connecting.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们组中不止一个主机，前面的命令将会遍历所有主机。`hosts` 文件的最后部分为 `boxes` 组中的所有主机设置了一些常见的配置选项。在这种情况下，我们告诉
    Ansible 所有组中的主机都使用 SSH，用户是 `vmadmin`，应使用 `./example_key` 作为私钥，并且在连接时不检查主机密钥。
- en: We will be revisiting the inventory host files in later chapters. From now on,
    we will use the `hosts` file to target the `ansible_hosts` group.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中重新访问清单主机文件。从现在开始，我们将使用 `hosts` 文件来定位 `ansible_hosts` 组。
- en: Playbooks
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Playbooks
- en: In the previous section, running the `ansible` command allowed us to call a
    single module.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，运行 `ansible` 命令让我们调用了一个单独的模块。
- en: 'In this section, we are going to look at calling several modules. The following
    playbook is called `ansible.builtin.setup` module we called in the previous section
    and then uses the `ansible.builtin.debug` module to print a message to the screen:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍调用多个模块。以下是我们在前一节中调用的 `ansible.builtin.setup` 模块，然后使用 `ansible.builtin.debug`
    模块将消息打印到屏幕：
- en: '[PRE39]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Before we break the configuration down, let’s look at the results of running
    the playbook. To do this, use the following command:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们拆解配置之前，让我们先看看运行 playbook 的结果。为此，请使用以下命令：
- en: '[PRE40]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will connect to our host, gather information on the system, and then return
    just the information we want in a message:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这将连接到我们的主机，收集系统信息，然后只返回我们需要的信息，以消息形式显示：
- en: '![Figure 1.13 – The output of running ansible-playbook01.yml](img/B21620_01_13.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.13 – 运行 ansible-playbook01.yml 的输出](img/B21620_01_13.jpg)'
- en: Figure 1.13 – The output of running ansible-playbook01.yml
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 – 运行 ansible-playbook01.yml 的输出
- en: The first thing you will notice about the playbook is that it is written in
    **YAML**, a recursive acronym for **YAML Ain’t Markup Language**. YAML was designed
    to be a human-readable data serialization standard that all programming languages
    can use. It is commonly used to help define configurations.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，playbook 是用 **YAML** 编写的，YAML 是 **YAML Ain’t Markup Language** 的递归缩写。YAML
    旨在作为一种人类可读的数据序列化标准，所有编程语言都可以使用。它通常用于帮助定义配置。
- en: 'The indentation is very important in YAML as it is used to nest and define
    areas of the file. Let’s look at our playbook in more detail:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进在 YAML 中非常重要，因为它用于嵌套和定义文件的区域。让我们更详细地看看我们的 playbook：
- en: '[PRE41]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: While these lines might not seem like much, they are used as document separators,
    as Ansible compiles all the YAML files into a single file. It is essential for
    Ansible to know where one document ends and another begins.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些行看起来没什么特别的，但它们作为文档分隔符使用，因为 Ansible 会将所有 YAML 文件合并为一个文件。Ansible 必须知道一个文档的结束位置和另一个文档的开始位置。
- en: 'Next up, we have the configuration for the playbook. As you can see, this is
    where the indentation starts to come into play:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看一下 playbook 的配置。如你所见，这就是缩进开始发挥作用的地方：
- en: '[PRE42]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `-` tells Ansible that this is the start of a section. From there, key-value
    pairs are used. These are as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`-` 告诉 Ansible 这是一个部分的开始。从这里开始，使用键值对。具体如下：'
- en: '`name`: This gives a name to the playbook run.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这为 playbook 运行提供一个名称。'
- en: '`hosts`: This tells Ansible the host or host group to target in the playbook.
    This must be defined in a host inventory like the ones we covered in the previous
    section.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hosts`：这告诉 Ansible 在 playbook 中需要针对的主机或主机组。必须在像我们在前一部分中介绍的主机清单中定义这些主机。'
- en: '`gather_facts`: This tells Ansible to run the `ansible.builtin.setup` module
    when it first connects to the host. This information is then available to the
    playbook during the run.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gather_facts`：这告诉 Ansible 在首次连接到主机时运行 `ansible.builtin.setup` 模块。然后，这些信息将在运行过程中提供给
    playbook。'
- en: '`become`: This is present because we are connecting to our host as a basic
    user, in this case, the **vmadmin** user. Ansible may not have enough access privileges
    to execute some of the commands we are telling it to, so this instructs Ansible
    to execute all of its commands as the root user.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`become`：这是因为我们以普通用户身份连接到主机，在这种情况下是 **vmadmin** 用户。Ansible 可能没有足够的访问权限来执行一些我们告诉它的命令，因此这个指令告诉
    Ansible 以 root 用户身份执行所有命令。'
- en: '`become_method`: This tells Ansible how to become the root user; in our case,
    we have a passwordless sudo configured by the `cloud-init` script we ran when
    launching the virtual machine, so we are using `ansible.builtin.sudo`.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`become_method`：这告诉 Ansible 如何成为 root 用户；在我们的案例中，我们通过在启动虚拟机时运行的 `cloud-init`
    脚本配置了无密码的 sudo，因此我们使用 `ansible.builtin.sudo`。'
- en: '`tasks`: These are the tasks we can tell Ansible to run when connected to the
    target host.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks`：这些是我们可以告诉 Ansible 在连接到目标主机时执行的任务。'
- en: 'You will notice that from here, we move the indentation across again. This
    defines another section of the configuration. This time it is for the tasks:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，从这里开始，我们再次移动了缩进。这定义了配置的另一个部分。这一次是针对任务的：
- en: '[PRE43]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As we have already seen, the only task we run is the `ansible.builtin.debug`
    module. This module allows us to display output in the Ansible playbook run stream
    you saw when we ran the playbook.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们唯一运行的任务是 `ansible.builtin.debug` 模块。该模块允许我们在运行 playbook 时，在 Ansible
    playbook 执行流中显示输出。
- en: You may have already noticed that the information between the curly brackets
    is made up of the keys from the `ansible.builtin.setup` module. Here, we are telling
    Ansible to substitute the value of each key wherever we use the key. We will be
    using this a lot in our playbooks. We will also be defining our own key values
    to use as part of our playbook runs.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，大括号之间的信息由 `ansible.builtin.setup` 模块中的键组成。在这里，我们告诉 Ansible 在使用这些键时替换为每个键的值。我们将在我们的
    playbook 中经常使用这一点。我们还将定义我们自己的键值，作为 playbook 运行的一部分。
- en: 'Let’s extend our playbook by adding another task. The following can be found
    as **playbook02.yml**:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加另一个任务来扩展我们的 playbook。以下内容可以在 **playbook02.yml** 中找到：
- en: '[PRE44]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can see, we have added a second task that calls the `ansible.builtin.apt`
    module. This module is designed to help us interact with the package manager used
    by Ubuntu and other Debian-based operating systems called `apt`. We are setting
    three key values here:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们添加了第二个任务，调用了 `ansible.builtin.apt` 模块。这个模块旨在帮助我们与 Ubuntu 和其他基于 Debian
    的操作系统使用的包管理器 `apt` 进行交互。我们在这里设置了三个关键值：
- en: '`name`: This is a wildcard. It tells Ansible to use all of the installed packages
    rather than just a single named package. For example, we could have used something
    such as `apache2` here to target Apache.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是一个通配符。它告诉 Ansible 使用所有已安装的包，而不仅仅是一个指定的包。例如，我们可以在这里使用类似 `apache2` 的内容来定位
    Apache。'
- en: '`state`: Here, we are telling Ansible to ensure the package we have defined
    in the name key is the `latest` version. As we have named all of the installed
    packages, this will update everything we have installed.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`：在这里，我们告诉 Ansible 确保我们在 name 键中定义的包是 `latest` 版本。由于我们已经命名了所有已安装的包，这将更新我们安装的所有内容。'
- en: '`update_cache`: As the virtual machine image we downloaded was optimized for
    being small, it does not contain any information on the available package; by
    setting `update_cache` to `true`, this will download a list of all package and
    version information.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_cache`：由于我们下载的虚拟机镜像是为了优化体积而设计的，因此不包含有关可用包的信息；通过将 `update_cache` 设置为
    `true`，这将下载所有包及其版本信息的列表。'
- en: 'Run the playbook using the following command:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行 playbook：
- en: '[PRE45]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will give us the following results:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们带来以下结果：
- en: '![Figure 1.14 – The output of running ansible-playbook02.yml](img/B21620_01_14.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.14 – 运行 ansible-playbook02.yml 的输出](img/B21620_01_14.jpg)'
- en: Figure 1.14 – The output of running ansible-playbook02.yml
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 – 运行 ansible-playbook02.yml 的输出
- en: The `ansible.builtin.apt` task has been marked as changed on the host box. This
    means that packages were updated.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible.builtin.apt` 任务已在主机上标记为已更改。这意味着软件包已被更新。'
- en: 'Rerunning the same command shows the following results:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行相同的命令显示以下结果：
- en: '![Figure 1.15 – The output of rerunning ansible-playbook02.yml](img/B21620_01_15.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.15 – 重新运行 ansible-playbook02.yml 的输出](img/B21620_01_15.jpg)'
- en: Figure 1.15 – The output of rerunning ansible-playbook02.yml
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – 重新运行 ansible-playbook02.yml 的输出
- en: As you can see, the `ansible.builtin.apt` task is now showing as `ok` on our
    host. This is because there are currently no longer any packages requiring updates.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`ansible.builtin.apt` 任务现在在我们的主机上显示为 `ok`。这是因为当前没有软件包需要更新。
- en: Before we finish this quick look at playbooks, let’s do something more interesting.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这次对 playbook 的简短回顾之前，让我们做一些更有趣的事情。
- en: The playbook, `playbook03.yml`, adds NTP installing, configuring, and starting
    capabilities to our virtual machine. It also uses a template to add a custom NTP
    config file to our virtual machine.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 该 playbook `playbook03.yml` 为我们的虚拟机添加了 NTP 安装、配置和启动功能。它还使用模板将自定义的 NTP 配置文件添加到虚拟机中。
- en: 'The `vars` section allows us to configure our own key-value pairs. In this
    case, we are providing a list of NTP servers, which we will be using later in
    the playbook:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`vars` 部分允许我们配置自己的键值对。在这种情况下，我们提供了一组 NTP 服务器，稍后将在 playbook 中使用：'
- en: '[PRE46]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We are actually providing four different values for the same key. These will
    be used in the template task. We could have also written this as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上为相同的键提供了四个不同的值。这些将在模板任务中使用。我们也可以这样写：
- en: '[PRE47]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'However, this is a little more difficult to read. The next new section is `handlers`.
    A **handler** is a task that is assigned a name and called at the end of a playbook
    run depending on what tasks have changed:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这部分内容稍微有些难以阅读。下一个新增部分是 `handlers`。**处理器**是一个被赋予名称并在 playbook 执行结束时根据任务变更情况被调用的任务：
- en: '[PRE48]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In our case, the restart `ntp` handler uses the `ansible.builtin.service` module
    to restart `ntp`. Next up, we have two new tasks, starting with installing the
    NTP service and the `sntp` and `ntp-doc` packages using `ansible.builtin.apt`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，重启 `ntp` 处理器使用 `ansible.builtin.service` 模块来重启 `ntp`。接下来，我们有两个新任务，首先是使用
    `ansible.builtin.apt` 安装 NTP 服务以及 `sntp` 和 `ntp-doc` 软件包：
- en: '[PRE49]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As we need to install three packages, we need a way to provide three different
    package names to the `ansible.builtin.apt` module so that we don’t have to have
    three different tasks for each of the package installations. To achieve this,
    we use the `pkg` option rather than the `name` option, where you can only define
    a single package to install. Rather than using `latest`, we are using `present`;
    this will mean that our packages don’t get updated if they are already installed.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要安装三个软件包，我们需要一种方法将三个不同的软件包名称传递给 `ansible.builtin.apt` 模块，以便我们无需为每个软件包安装创建三个不同的任务。为此，我们使用
    `pkg` 选项，而不是只能定义一个软件包安装的 `name` 选项。我们没有使用 `latest`，而是使用了 `present`；这意味着如果软件包已经安装，它们不会被更新。
- en: 'The final addition to the playbook is the following task:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 对 playbook 的最后一个添加是以下任务：
- en: '[PRE50]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This task uses the `ansible.builtin.template` module. To read a template file
    from our Ansible controller, process it and upload the processed template to the
    host machine. Once uploaded, we are telling Ansible to notify the `restart ntp`
    handler if there have been any changes to the configuration file we are uploading.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 该任务使用 `ansible.builtin.template` 模块。从我们的 Ansible 控制器读取模板文件，处理它并将处理后的模板上传到主机。一旦上传，我们告诉
    Ansible 如果我们上传的配置文件有任何更改，则通知 `restart ntp` 处理器。
- en: 'In this case, the template file is the `ntp.conf.j2` file in the same folder
    as the playbooks, as defined in the `src` option. This file looks like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，模板文件是与 playbook 位于同一文件夹中的 `ntp.conf.j2` 文件，如 `src` 选项中定义的那样。该文件内容如下：
- en: '[PRE51]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The bulk of the file is the standard NTP configuration file, with the addition
    of a few Ansible parts. The first addition is the very first line:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的大部分内容是标准的 NTP 配置文件，附加了少量 Ansible 部分。第一个新增部分是第一行：
- en: '[PRE52]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If this line wasn’t there every time we ran Ansible, the file would be uploaded,
    which would count as a change and the restart ntp handler would be called, meaning
    that even if there were no changes, NTP would be restarted.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一行不存在，每次我们运行 Ansible 时，文件将被上传，这会被视为更改，并且 `restart ntp` 处理器会被调用，这意味着即使没有更改，NTP
    也会被重启。
- en: 'The next part loops through the `ntp_servers` values we defined in the `vars`
    section of the playbook:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分循环遍历我们在 playbook 的 `vars` 部分定义的 `ntp_servers` 值：
- en: '[PRE53]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: For each of the values, add a line that contains the word `server`, the value
    or `{{ item }},` and then `iburst`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个值，添加一行，包含单词 `server`，值或 `{{ item }}`，然后是 `iburst`。
- en: 'Now that we know what we have added to the playbook and have an idea of the
    additional tasks that will be performed, let’s run it using the following command:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了在 playbook 中添加的内容，并大致了解将要执行的额外任务，让我们使用以下命令运行它：
- en: '[PRE54]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following screen just shows the additional tasks and not the full output
    as we know it will be just marked as `ok`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕仅显示额外的任务，而不是完整的输出，因为我们知道它将只是标记为 `ok`：
- en: '![Figure 1.16 – The output of running ansible-playbook03.yml](img/B21620_01_16.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.16 – 运行 ansible-playbook03.yml 的输出](img/B21620_01_16.jpg)'
- en: Figure 1.16 – The output of running ansible-playbook03.yml
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – 运行 ansible-playbook03.yml 的输出
- en: 'This time, we have three changed tasks. Running the playbook again shows the
    following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们有三项更改任务。再次运行 playbook 后显示如下：
- en: '![Figure 1.17 – The output of rerunning ansible-playbook03.yml](img/B21620_01_17.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.17 – 重新运行 ansible-playbook03.yml 的输出](img/B21620_01_17.jpg)'
- en: Figure 1.17 – The output of rerunning ansible-playbook03.yml
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17 – 重新运行 ansible-playbook03.yml 的输出
- en: As expected, there are no changes because we haven’t changed the playbook or
    anything on the virtual machine, and Ansible is reporting everything as `ok`.
    Also, because no changes were detected to the NTP config file, the Handler to
    restart NTP did not need to be called, and therefore it doesn’t appear in the
    output.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，没有更改，因为我们没有更改 playbook 或虚拟机上的任何内容，Ansible 报告一切为 `ok`。此外，由于没有检测到 NTP
    配置文件的更改，因此没有调用重新启动 NTP 的 Handler，因此它不会出现在输出中。
- en: 'Before we finish, let’s launch a second virtual machine by running the following
    command:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束之前，让我们通过运行以下命令启动第二台虚拟机：
- en: '[PRE55]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once the second virtual machine has started, run the following command to get
    some information on the new virtual machine:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦第二台虚拟机启动，运行以下命令以获取有关新虚拟机的一些信息：
- en: '[PRE56]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now that we know the IP address, we can add two new lines to our `hosts` file.
    First of all, to define the new host, add the following code (updating it so it
    uses the correct IP address) underneath where our original host is defined:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 IP 地址，可以向 `hosts` 文件添加两行。首先，为了定义新主机，请在原始主机定义下方添加以下代码（更新为使用正确的 IP 地址）：
- en: '[PRE57]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, add `ansiblevm2` to the `ansible_hosts` group:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `ansiblevm2` 添加到 `ansible_hosts` 组中：
- en: '[PRE58]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, rerun the playbook using the following:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令重新运行 playbook：
- en: '[PRE59]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As you can see, the same commands run, but now we are targeting both virtual
    machines, the original virtual machine has no changes, and all the changes are
    applied to the newly deployed host:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，执行的是相同的命令，但现在我们针对的是两台虚拟机，原始虚拟机没有变化，所有更改都应用到新部署的主机：
- en: '![Figure 1.18 – The output of rerunning ansible-playbook03.yml against two
    virtual machines](img/B21620_01_18.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.18 – 针对两台虚拟机重新运行 ansible-playbook03.yml 的输出](img/B21620_01_18.jpg)'
- en: Figure 1.18 – The output of rerunning ansible-playbook03.yml against two virtual
    machines
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18 – 针对两台虚拟机重新运行 ansible-playbook03.yml 的输出
- en: If you rerun the command, you will see that everything is now shown as `ok`
    as there are no further changes.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新运行命令，你会看到一切现在都显示为 `ok`，因为没有进一步的更改。
- en: 'Before we move on to the summary, let’s tidy up our two virtual machines and
    remove them as we won’t need them again. To do this, run the following command:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续总结之前，让我们整理一下两台虚拟机，并将它们删除，因为我们不会再需要它们。为此，请运行以下命令：
- en: '[PRE60]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As I am sure you would have already guessed, this deletes the virtual machines
    and then purges the configuration and files.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，这将删除虚拟机，然后清除配置和文件。
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have taken our first steps with Ansible by installing it
    locally and then, using Vagrant, launching a virtual machine to interact with.
    We learned about basic host inventory files and used the Ansible command to execute
    a single task against our virtual machine.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过在本地安装 Ansible 并使用 Vagrant 启动虚拟机与其交互，迈出了使用 Ansible 的第一步。我们了解了基本的主机清单文件，并使用
    Ansible 命令对我们的虚拟机执行了一个任务。
- en: We then looked at playbooks, starting with a basic playbook that returned some
    information on our target before progressing to a playbook that updates all the
    installed operating system packages before installing and configuring the NTP
    service.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们查看了 playbook，从一个基本的 playbook 开始，该 playbook 返回了目标的相关信息，然后进入一个更新所有已安装操作系统包的
    playbook，接着安装并配置 NTP 服务。
- en: By the end of the chapter, we had launched a second virtual machine and quickly
    brought it up to the same configuration level as our first virtual machine.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，我们启动了第二台虚拟机，并迅速将其配置到与第一台虚拟机相同的水平。
- en: In the next chapter, we will look at Ansible Galaxy and discuss how Ansible
    packages up and maintains its community modules.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Ansible Galaxy，并讨论 Ansible 如何打包和维护其社区模块。
- en: Further reading
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In this chapter, we mentioned Puppet and SaltStack:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提到了 Puppet 和 SaltStack：
- en: '**Puppet** is a configuration management tool that runs a server/agent configuration.
    It comes in two flavors—an open source version and an enterprise version that
    Puppet, the company, supports. It is a declarative system and is closely tied
    to Ruby. For more information on Puppet, see [https://www.puppet.com/](https://www.puppet.com/).'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Puppet** 是一个配置管理工具，采用服务器/代理配置运行。它有两个版本——开源版本和由 Puppet 公司支持的企业版本。它是一个声明式系统，与
    Ruby 紧密相关。欲了解更多关于 Puppet 的信息，请参见 [https://www.puppet.com/](https://www.puppet.com/)。'
- en: '**SaltStack** is another configuration management tool. It is highly scalable
    and, while it shares a design approach with Ansible, it works in a similar way
    to Puppet in that it has a server/agent approach. You can find more information
    on SaltStack at [https://www.vmware.com/support/acquisitions/saltstack.html](https://www.vmware.com/support/acquisitions/saltstack.html).'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SaltStack** 是另一种配置管理工具。它具有高度可扩展性，虽然它与 Ansible 采用相似的设计方法，但它类似于 Puppet，采用服务器/代理模式。您可以在
    [https://www.vmware.com/support/acquisitions/saltstack.html](https://www.vmware.com/support/acquisitions/saltstack.html)
    获取更多关于 SaltStack 的信息。'
- en: I also mentioned my personal blog, which you can find at [https://www.russ.foo/](https://www.russ.foo/).
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我还提到了我的个人博客，您可以在 [https://www.russ.foo/](https://www.russ.foo/) 找到。
- en: 'We used the following Ansible modules, and you can find out more information
    on each module at the following links:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了以下 Ansible 模块，您可以通过以下链接了解每个模块的更多信息：
- en: '`ansible.builtin.setup`: [https://docs.ansible.com/ansible/latest/collections/ansible/builtin/setup_module.html](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/setup_module.html)'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible.builtin.setup`: [https://docs.ansible.com/ansible/latest/collections/ansible/builtin/setup_module.html](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/setup_module.html)'
- en: '`ansible.builtin.debug`: [https://docs.ansible.com/ansible/latest/collections/ansible/builtin/debug_module.html](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/debug_module.html)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible.builtin.debug`: [https://docs.ansible.com/ansible/latest/collections/ansible/builtin/debug_module.html](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/debug_module.html)'
- en: '`ansible.builtin.apt`: [https://docs.ansible.com/ansible/latest/collections/ansible/builtin/apt_module.html](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/apt_module.html)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible.builtin.apt`: [https://docs.ansible.com/ansible/latest/collections/ansible/builtin/apt_module.html](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/apt_module.html)'
- en: '`ansible.builtin.template`: [https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html)'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible.builtin.template`: [https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html)'
- en: '`ansible.builtin.service`: [https://docs.ansible.com/ansible/latest/collections/ansible/builtin/service_module.html](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/service_module.html)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible.builtin.service`: [https://docs.ansible.com/ansible/latest/collections/ansible/builtin/service_module.html](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/service_module.html)'
