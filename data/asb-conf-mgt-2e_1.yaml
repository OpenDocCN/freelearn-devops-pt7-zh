- en: Chapter 1. Getting Started with Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章：开始使用 Ansible
- en: '**Ansible** is profoundly different from other configuration management tools
    available today. It has been designed to make configuration easy in almost every
    way, from its simple English configuration syntax to its ease of setup. You''ll
    find that Ansible allows you to stop writing custom configuration and deployment
    scripts and lets you simply get on with your job.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible** 与目前市面上其他配置管理工具有着根本的不同。它的设计目的就是在几乎所有方面都让配置变得简单，从它简单的英文配置语法到易于设置的特点。你会发现，Ansible
    让你不再需要编写自定义的配置和部署脚本，而是可以直接专注于你的工作。'
- en: Ansible only needs to be installed on the machines that you use to manage your
    infrastructure. It does not need a client to be installed on the managed machine,
    nor does it need any server infrastructure to be set up before you can use it.
    You should even be able to use it merely minutes after it is installed, as we
    will show you in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 只需要在你用来管理基础设施的机器上安装。它不需要在被管理的机器上安装客户端，也不需要在使用之前设置任何服务器基础设施。你甚至可以在安装后几分钟内就开始使用它，正如我们在本章中将要展示的那样。
- en: 'The following are the topics covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Installing Ansible
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Ansible
- en: Configuring Ansible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Ansible
- en: Using Ansible from the command line
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行使用 Ansible
- en: Using Ansible to manage Windows machines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 管理 Windows 机器
- en: How to get help
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取帮助
- en: Hardware and software required
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所需的硬件和软件
- en: You will be using Ansible from the command line on one machine, which we will
    call the **controller machine**, and use it to configure another machine, which
    we will call the **managed machine**. Ansible currently only supports a Linux
    or OS X controller machine; however, the managed machine can be Linux, OS X, other
    Unix-like machines or Windows. Ansible does not place many requirements on the
    controller machine and even less on the managed machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从一台机器的命令行使用 Ansible，这台机器我们称之为 **控制机器**，然后使用它配置另一台机器，我们称之为 **被管理机器**。Ansible
    目前只支持 Linux 或 OS X 控制机器；然而，被管理机器可以是 Linux、OS X、其他类 Unix 机器或 Windows。Ansible 对控制机器的要求不高，对被管理机器的要求更少。
- en: 'The requirements for the controller machine are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 控制机器的要求如下：
- en: Python 2.6 or higher
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 2.6 或更高版本
- en: paramiko
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: paramiko
- en: PyYAML
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyYAML
- en: Jinja2
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja2
- en: httplib2
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: httplib2
- en: Unix-based OS
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Unix 的操作系统
- en: The managed machine needs Python 2.4 or higher and simplejson; however, if your
    Python is 2.5 or higher, you only need Python. Managed Windows machines will need
    Windows remoting turned on, and a version of Windows PowerShell greater than 3.0\.
    While Windows machines do have more requirements, all the tools are freely available
    and the Ansible project even includes the script to help you easily set up the
    dependencies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 被管理的机器需要 Python 2.4 或更高版本以及 simplejson；然而，如果你的 Python 版本是 2.5 或更高，你只需要 Python。被管理的
    Windows 机器需要开启 Windows 远程管理，并且 PowerShell 版本要大于 3.0。虽然 Windows 机器的要求更多，但所有这些工具都是免费的，Ansible
    项目甚至包括了帮助你轻松设置依赖项的脚本。
- en: Installation methods
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装方法
- en: If you want to use Ansible to manage a set of existing machines or infrastructure,
    you will likely want to use whatever package manager is included on those systems.
    This means that you will get updates for Ansible as your distribution updates
    it, which may lag several versions behind other methods. However, it means that
    you will be running a version that has been tested to work on the system you are
    using.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 Ansible 管理一组现有的机器或基础设施，你可能希望使用这些系统上附带的包管理器。这意味着你将随着分发版的更新而获得 Ansible
    的更新，可能会落后于其他方法的几个版本。然而，这也意味着你将运行一个已经过测试并能在你使用的系统上正常工作的版本。
- en: If you run an existing infrastructure, but need a newer version of Ansible,
    you can install Ansible via pip. **Pip** is a tool used to manage packages of
    Python software and libraries. Ansible releases are pushed to pip as soon as they
    are released, so if you are up to date with pip, you should always be running
    the latest version.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行一个现有的基础设施，但需要一个更新版本的 Ansible，你可以通过 pip 安装 Ansible。**Pip** 是一个用于管理 Python
    软件包和库的工具。Ansible 的发布版本会在发布后立即推送到 pip，因此如果你使用的是最新的 pip，你应该总是运行最新版本。
- en: If you imagine yourself developing lots of modules and possibly contributing
    back to Ansible, you should be running a version installed from source code. As
    you will be running the latest and least-tested version of Ansible, you may experience
    a hiccup or two.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算开发大量模块并可能为 Ansible 贡献代码，你应该使用从源代码安装的版本。由于你将运行最新且未经充分测试的版本，可能会遇到一些小问题。
- en: Installing from your distribution
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从发行版安装
- en: 'Most modern distributions include a package manager that automatically manages
    package dependencies and updates for you. This makes installing Ansible via your
    package manager by far the easiest way to get started with Ansible; usually it
    takes only a single command. It will also be updated as you update your machine,
    though it may be a version or two behind. The following are the commands to install
    Ansible on the most common distributions. If you are using something different,
    refer to the user guide of your package or your distribution''s package lists:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代发行版都包括一个包管理器，可以自动管理包的依赖关系和更新。这使得通过包管理器安装 Ansible 成为启动 Ansible 的最简单方式；通常只需要一个命令即可完成安装。它还会随着你的机器更新而自动更新，尽管可能会落后一两个版本。以下是在最常见的发行版上安装
    Ansible 的命令。如果你使用的是其他发行版，请参考你的包管理工具的用户指南或发行版的包列表：
- en: 'Fedora, RHEL, CentOS, and compatible:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fedora、RHEL、CentOS及兼容系统：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ubuntu, Debian, and compatible:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu、Debian及兼容系统：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that RHEL and CentOS require the EPEL repository to be installed. Details
    on EPEL, including how to install it can be found at [https://fedoraproject.org/wiki/EPEL](https://fedoraproject.org/wiki/EPEL).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，RHEL 和 CentOS 需要先安装 EPEL 仓库。有关 EPEL 的详细信息，包括如何安装，可以参考[https://fedoraproject.org/wiki/EPEL](https://fedoraproject.org/wiki/EPEL)。
- en: If you are on Ubuntu and wish to use the latest release instead of the one provided
    by your operating system, you can use the Ubuntu PPA provided by Ansible. Details
    on setting this up can be found at [https://launchpad.net/~ansible/+archive/ubuntu/ansible](https://launchpad.net/~ansible/+archive/ubuntu/ansible).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Ubuntu，并希望使用最新版本而不是操作系统提供的版本，你可以使用 Ansible 提供的 Ubuntu PPA。有关如何设置的详细信息，可以参考[https://launchpad.net/~ansible/+archive/ubuntu/ansible](https://launchpad.net/~ansible/+archive/ubuntu/ansible)。
- en: Installing from pip
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 pip 安装
- en: 'Pip, like a distribution''s package manager, will handle finding, installing,
    and updating the packages you ask for and its dependencies. This makes installing
    Ansible via pip as easy as installing from your package manager. It should be
    noted, however, that it will not be updated with your operating system. Additionally,
    updating your operating system may break your Ansible installation; however, this
    is unlikely. If you are a Python user, you might want to install Ansible in an
    isolated environment (virtual environment): This is not supported as Ansible tries
    to install its modules to the system. You should install Ansible system-wide using
    pip.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Pip，像发行版的包管理器一样，会处理你请求的包及其依赖项的查找、安装和更新。这使得通过 pip 安装 Ansible 和通过包管理器安装一样简单。然而，需要注意的是，它不会随着操作系统的更新而更新。此外，更新操作系统可能会破坏你的
    Ansible 安装；不过，这种情况不太可能发生。如果你是 Python 用户，可能希望在隔离环境（虚拟环境）中安装 Ansible：但这不被支持，因为 Ansible
    尝试将其模块安装到系统中。你应该使用 pip 在全系统范围内安装 Ansible。
- en: 'The following is the command to install Ansible via pip:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过 pip 安装 Ansible 的命令：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing from the source code
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从源代码安装
- en: 'Installing from the source code is a great way to get the latest version, but
    it may not be tested as correctly as the released versions. You also will need
    to take care of updating to newer versions yourself and making sure that Ansible
    will continue to work with your operating system updates. To clone the `git` repository
    and install it, run the following commands. You may need root access to your system
    to do this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码安装是获取最新版本的好方法，但它可能没有经过像正式发布版本那样的测试。此外，你还需要自行管理更新到新版本，并确保 Ansible 在操作系统更新后依然能够正常工作。要克隆
    `git` 仓库并安装，请运行以下命令。你可能需要系统的 root 权限才能执行此操作：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [http://www.packtpub.com](http://www.packtpub.com) 的帐户中下载你购买的所有 Packt 书籍的示例代码文件。如果你是从其他地方购买的本书，可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册，文件将通过电子邮件直接发送给你。
- en: Setting up Ansible
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Ansible
- en: Ansible needs to be able to get an inventory of the machines that you want to
    configure in order to manage them. This can be done in many ways due to inventory
    plug-ins. Several different inventory plug-ins are included with the base install.
    We will go over these later in the book. For now, we will cover the simple host's
    file inventory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 需要能够获取你想要配置的机器的清单，才能管理它们。由于有清单插件，这可以通过多种方式实现。基础安装包含了几个不同的清单插件。我们将在本书后面介绍这些插件。现在，我们将介绍简单的主机文件清单。
- en: The default Ansible inventory file is named hosts and is placed at `/etc/ansible`.
    It is formatted like an `INI` file. Group names are enclosed in square braces,
    and everything underneath it, down to the next group heading, gets assigned to
    that group. Machines can be in many groups at one time. Groups are used to allow
    you to configure many machines at once. You can use a group instead of a hostname
    as a host pattern in later examples, and Ansible will run the module on the entire
    group at once.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 Ansible 清单文件名为 hosts，存放在 `/etc/ansible` 目录下。它的格式类似于 `INI` 文件。组名用方括号括起来，所有位于组名下的内容，直到下一个组名，都会分配给该组。机器可以同时属于多个组。组的作用是让你可以一次配置多个机器。在接下来的示例中，你可以使用组名代替主机名作为主机模式，Ansible
    将对整个组同时运行模块。
- en: In the following example, we have three machines in a group named `webservers`,
    namely `site01`, `site02`, and `site01-dr`. We also have a `production` group
    that consists of `site01`, `site02`, `db01`, and `bastion`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们有三台机器在名为 `webservers` 的组中，分别是 `site01`、`site02` 和 `site01-dr`。我们还有一个名为
    `production` 的组，包含了 `site01`、`site02`、`db01` 和 `bastion`。
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you have placed your hosts in the Ansible inventory, you can start running
    commands against them. Ansible includes a simple module called `ping` that lets
    you test connectivity between yourself and the host. Let's use Ansible from the
    command line against one of our machines to confirm that we can configure them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将主机添加到 Ansible 清单中，你就可以开始对其运行命令。Ansible 包含一个简单的模块叫做 `ping`，可以让你测试自己与主机之间的连接。让我们从命令行使用
    Ansible 对我们的其中一台机器进行测试，确认我们可以配置它们。
- en: Ansible was designed to be simple, and one of the ways the developers have done
    this is by using SSH to connect to the managed machines. It then sends the code
    over the SSH connection and executes it. This means that you don't need to have
    Ansible installed on the managed machine. It also means that Ansible uses the
    same channels that you are already using to administer the machine. This makes
    is easier to setup, because in most cases there will be no setup required and
    no ports to open in a firewall.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 设计上追求简洁，而开发者通过使用 SSH 来连接被管理的机器实现了这一点。然后，它通过 SSH 连接发送代码并执行。这意味着你不需要在被管理的机器上安装
    Ansible。这也意味着 Ansible 使用的是你已经用来管理机器的通道。这使得设置更简单，因为在大多数情况下，通常不需要额外的配置，也不需要在防火墙中打开端口。
- en: 'First, we check connectivity to our server to be configured using the Ansible
    `ping` module. This module simply connects to the following server:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 Ansible `ping` 模块检查与服务器的连接。这个模块只是连接到以下服务器：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This should ask for the SSH password and then produce a result that looks like
    the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会要求输入 SSH 密码，然后输出如下结果：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you have an SSH key set up for the remote system, you will be able to leave
    off the `-k` argument to skip the prompt and use the keys. You can also configure
    Ansible to use a particular username all the time by either configuring it in
    the inventory on a per host basis or in the global Ansible configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为远程系统设置了 SSH 密钥，你将能够省略 `-k` 参数，跳过提示并使用密钥。你还可以通过在清单中为每个主机单独配置，或者在全局 Ansible
    配置中配置，来让 Ansible 始终使用特定的用户名。
- en: To set the username globally, edit `/etc/ansible/ansible.cfg` and change the
    line that sets `remote_user` in the `[defaults]` section. You can also change
    `remote_port` to change the default port that Ansible will SSH to. This will change
    the default settings for all the machines, but they can be overridden in the inventory
    file on a per server or per group basis.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要全局设置用户名，请编辑`/etc/ansible/ansible.cfg`并更改在`[defaults]`部分设置`remote_user`的行。您还可以更改`remote_port`以更改
    Ansible 将 SSH 连接到的默认端口。这将更改所有机器的默认设置，但可以在清单文件中按服务器或组进行覆盖。
- en: To set the username in the inventory file, simply append `ansible_ssh_user`
    to the line in the inventory. For example, the following code section shows an
    inventory where the `site01` host uses the username `root` and the `site02` host
    uses the username `daniel`. There are also other variables you can use. The `ansible_ssh_host`
    variable allows you to set a different hostname, and the `ansible_ssh_port` variable
    allows you to set a different port, which is demonstrated on the `site01-dr` host.
    Finally the `db01` host uses the username `fred` and also sets a private key using
    `ansible_ssh_private_key_file`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要在清单文件中设置用户名，只需在清单的相应行后附加`ansible_ssh_user`。例如，以下代码部分显示了一个清单，其中`site01`主机使用用户名`root`，`site02`主机使用用户名`daniel`。还有其他变量可以使用。`ansible_ssh_host`变量允许您设置不同的主机名，`ansible_ssh_port`变量允许您设置不同的端口，这在`site01-dr`主机上有所示。最后，`db01`主机使用用户名`fred`，并使用`ansible_ssh_private_key_file`设置私钥。
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you aren't comfortable with giving Ansible direct access to the root account
    on the managed machines, or your machine does not allow SSH access to the root
    account (such as Ubuntu's default configuration), you can configure Ansible to
    obtain root access using `sudo`. Using Ansible with `sudo` means that you can
    enforce auditing the same way you would otherwise. Configuring Ansible to use
    `sudo` is as simple as it is to configure the port, except that it requires `sudo`
    to be configured on the managed machine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不希望将 Ansible 直接访问受管机器上的 root 帐户，或者您的机器不允许 SSH 访问 root 帐户（例如 Ubuntu 的默认配置），您可以配置
    Ansible 使用`sudo`来获取 root 访问权限。使用`sudo`的 Ansible 意味着您可以强制进行与否则相同的审核。配置 Ansible
    使用`sudo`与配置端口一样简单，只是它要求在受管机器上配置`sudo`。
- en: 'The first step is to add a line to the `/etc/sudoers` file; on the managed
    node, this may already be set up if you choose to use your own account. You can
    use a password with `sudo`, or you can use a passwordless `sudo`. If you decide
    to use a password, you will need to use the `-k` argument to Ansible, or set the
    `ask_sudo_pass` value to `true` in `/etc/ansible/ansible.cfg`. To make Ansible
    use sudo, add `--sudo` to the command line like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是向`/etc/sudoers`文件添加一行；在受管节点上，如果选择使用自己的帐户，可能已经设置了这一点。您可以使用`sudo`与密码，也可以使用无密码的`sudo`。如果决定使用密码，您将需要对
    Ansible 使用`-k`参数，或者在`/etc/ansible/ansible.cfg`中将`ask_sudo_pass`值设置为`true`。要使 Ansible
    使用 sudo，请像这样在命令行中添加`--sudo`：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If this works, it should return something similar to:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正常工作，它应返回类似于：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Setting it up on Windows
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Windows 上设置它
- en: Ansible recently added the ability to manage Windows machines. Now, you can
    use Ansible to easily manage Windows machines the same way you manage your Linux
    machines.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 最近添加了管理 Windows 机器的功能。现在，您可以使用 Ansible 轻松管理 Windows 机器，就像管理 Linux 机器一样。
- en: This uses the Windows PowerShell Remoting tools in the same way that SSH is
    used on a Linux machine to execute modules remotely. Several new modules have
    been added that explicitly support Windows, but some existing modules have also
    been given the ability to work with Windows-managed machines.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在 Linux 机器上使用 SSH 执行模块的方式相同使用 Windows PowerShell Remoting 工具远程执行。已添加了几个明确支持
    Windows 的新模块，但也使一些现有模块能够与 Windows 受管机器一起使用。
- en: 'To get started with managing your Windows machine, you do have to perform a
    little bit of complex setup. You need to follow these steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始管理您的 Windows 机器，您需要执行一些复杂的设置。您需要遵循以下步骤：
- en: Create some Windows machines in your inventory
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在清单中创建一些 Windows 机器
- en: Install Python-winrm to allow Ansible to connect to the Windows machines
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Python-winrm 以允许 Ansible 连接到 Windows 机器
- en: Upgrade to PowerShell 3.0+ to support Windows modules
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级到 PowerShell 3.0+ 以支持 Windows 模块
- en: Enable Windows remoting so that Ansible can connect
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 Windows 远程管理以便 Ansible 连接
- en: 'Windows machines are created the same way as all the other machines that you
    have in your inventory. They are differentiated by the value of the `ansible_connection`
    variable. When `ansible_connection` is set to `winrm`, it will try to connect
    via winrm to Windows PowerShell on the remote machine. Ansible also uses the `ansible_ssh_user`,
    `ansible_ssh_pass`, and `ansible_ssh_port` values like it would on your other
    machine. Despite having the name ssh in them, they are used to provide the port
    and credentials that will be used to connect to the Windows PowerShell Remoting
    service. Here is what an example Windows machine might look like:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 机器的创建方式与清单中其他所有机器相同。它们通过 `ansible_connection` 变量的值来区分。当 `ansible_connection`
    设置为 `winrm` 时，它将尝试通过 winrm 连接到远程机器上的 Windows PowerShell。Ansible 还像在其他机器上一样使用 `ansible_ssh_user`、`ansible_ssh_pass`
    和 `ansible_ssh_port` 的值。尽管这些名字里包含 ssh，但它们是用来提供连接 Windows PowerShell 远程服务所需的端口和凭证。以下是一个
    Windows 机器示例：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For security reasons, you probably will not want to store the password in the
    inventory file. You can make Ansible prompt for the password the same way we showed
    previously for Unix systems by simply leaving off the `ansible_ssh_user` and `ansible_ssh_pass`
    variables and instead using the `-k` and `-u` arguments to Ansible if you wish.
    You might also choose to store them in an Ansible vault, which will be covered
    later in the book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全考虑，你可能不希望将密码存储在清单文件中。你可以像我们之前对 Unix 系统所展示的那样让 Ansible 提示输入密码，只需要去掉 `ansible_ssh_user`
    和 `ansible_ssh_pass` 变量，而改为使用 `-k` 和 `-u` 参数传递给 Ansible。如果你愿意，也可以选择将密码存储在 Ansible
    密库中，后续书中将详细介绍这个方法。
- en: After you have created the inventory, you need to install the winrm Python library
    on the controller machine. This library will give Ansible the ability to connect
    to the Windows Remote Management service and configure a remote Windows system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完清单文件后，你需要在控制器机器上安装 winrm Python 库。这个库将赋予 Ansible 连接 Windows 远程管理服务并配置远程 Windows
    系统的能力。
- en: 'At the moment, this library is fairly experimental, and its connection to Ansible
    isn''t quite perfect, so you have to install the particular version that matches
    the version of Ansible you are using. With the release of Ansible 1.8, this should
    sort things out a little bit. Most distributions do not have a packaged library
    yet, so you will probably want to install it via pip. As root, you need to run:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个库还处于实验阶段，它与 Ansible 的连接并不完美，因此你需要安装与当前使用的 Ansible 版本匹配的特定版本。随着 Ansible
    1.8 版本的发布，这个问题应该会有所解决。大多数发行版尚未打包该库，因此你可能需要通过 pip 安装。作为 root 用户，你需要运行以下命令：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, for newer versions, you should simply be able to run:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于较新的版本，你只需要运行以下命令：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will install the particular version of winrm that works with Ansible 1.7\.
    For other newer versions of Ansible, you may need a different version, and eventually
    the winrm Python library should be packaged up by different distributions. Your
    machine will now be able to connect to and manage Windows machines with Ansible.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装与 Ansible 1.7 兼容的特定版本 winrm。对于其他较新的 Ansible 版本，你可能需要不同的版本，最终 winrm Python
    库应该会被不同的发行版打包。现在，你的机器应该能够使用 Ansible 连接和管理 Windows 机器。
- en: 'Next you have to perform a few setup steps on the machine you are going to
    manage. The first of these is to make sure that you have PowerShell 3.0 or later
    installed. You can check what version you have installed with the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在将要管理的机器上进行一些设置。第一步是确保你已安装 PowerShell 3.0 或更高版本。你可以使用以下命令检查已安装的版本：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the value you get back is not 3 or higher than 3, then you will need to upgrade
    your version of PowerShell. You can choose to do this manually by downloading
    and installing the latest Windows Management Framework for your system, or you
    can use a script provided by the Ansible project. To save space, we will be explaining
    the scripted installation here; the manual installation is left as an exercise
    for the reader.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到的返回值不是3或者大于3，那么你需要升级你的 PowerShell 版本。你可以选择手动下载并安装适合你系统的最新 Windows 管理框架，或者使用
    Ansible 项目提供的脚本。为了节省空间，我们将在这里解释脚本化安装；手动安装留给读者自行操作。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first command downloads the upgrade script from the Ansible project repository
    on GitHub and saves it to disk. The second command will detect your operating
    system to download the correct version of the Windows Management Framework and
    install it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令从Ansible项目的GitHub存储库下载升级脚本并保存到磁盘。第二个命令将检测您的操作系统，以下载适合的Windows管理框架版本并安装它。
- en: 'Next you need to configure the Windows Remote Management Service. The Ansible
    project provides a script that will configure Windows Remote Management automatically
    in the way that Ansible expects it to be configured. While you can set it up manually,
    it is highly recommended that you use this script instead to prevent misconfiguration.
    To download and run this script, open a PowerShell terminal and run the following
    commands:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要配置Windows远程管理服务。Ansible项目提供了一个脚本，该脚本会自动按Ansible期望的方式配置Windows远程管理。虽然您可以手动设置，但强烈建议您使用此脚本，以避免配置错误。要下载并运行此脚本，请打开PowerShell终端并运行以下命令：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first command downloads the configuration script from the Ansible project
    on GitHub, and the second command runs it. You should receive the output `Ok`
    from the second script if everything worked correctly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令从Ansible项目的GitHub上下载配置脚本，第二个命令运行该脚本。如果一切正常，第二个脚本应该返回`Ok`的输出。
- en: You should now be able to connect to your machine and configure it with Ansible.
    As we did earlier, let's run a ping command to confirm that Ansible is able to
    execute its modules remotely. While Unix machines can use the `ping` module, Windows
    machines use the `win_ping` module. The usage is almost exactly the same; however,
    as we've added the password to the inventory file, you don't need the `-k` option.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该能够连接到您的机器并使用Ansible进行配置。像之前一样，我们运行一个ping命令来确认Ansible是否能够远程执行其模块。虽然Unix机器可以使用`ping`模块，但Windows机器使用`win_ping`模块。用法几乎完全相同；不过，由于我们已经将密码添加到库存文件中，因此无需使用`-k`选项。
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If everything works correctly, you should see the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该看到以下输出：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output indicates that Ansible was able to connect to the Windows Remote
    Management Service, login successfully, and execute a module on the remote host.
    If this works correctly, then you should be able to use all the other Windows
    modules to manage your machine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表示Ansible成功连接到Windows远程管理服务，成功登录并在远程主机上执行了一个模块。如果一切正常，那么您应该能够使用所有其他Windows模块来管理您的机器。
- en: First steps with Ansible
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible的第一步
- en: Ansible modules take arguments in key-value pairs that look similar to `key=value`,
    perform a job on the remote server, and return information about the job as `JSON`.
    The key-value pairs allow the module to know what to do when requested. They can
    be hardcoded values, or in playbooks they can use variables, which will be covered
    in [Chapter 2](part0020.xhtml "Chapter 2. Simple Playbooks"), *Simple Playbooks*.
    The data returned from the module lets Ansible know if anything changed in the
    managed host or if any information kept by Ansible should be changed afterwards.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible模块以类似`key=value`的键值对形式接收参数，执行远程服务器上的任务，并以`JSON`格式返回任务信息。键值对允许模块在请求时知道应该做什么。它们可以是硬编码的值，或者在播放书中，它们可以使用变量，关于这一点将在[第2章](part0020.xhtml
    "第2章 简单播放书")，*简单播放书*中介绍。模块返回的数据让Ansible知道是否在受管理的主机中发生了任何更改，或者是否之后应该更改Ansible保存的任何信息。
- en: Modules are usually run within playbooks, as this lets you chain many together,
    but they can also be used on the command line. Previously, we used the `ping`
    command to check that Ansible had been correctly setup and was able to access
    the configured node. The `ping` module only checks that the core of Ansible is
    able to run on the remote machine, but effectively does nothing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 模块通常在播放书中运行，因为这样可以将多个模块串联起来，但也可以在命令行中使用。之前，我们使用了`ping`命令来检查Ansible是否已正确设置并能够访问配置的节点。`ping`模块仅检查Ansible核心是否能够在远程机器上运行，但实际上什么都不做。
- en: A slightly more useful module is named `setup`. This module connects to the
    configured node, gathers data about the system, and then returns those values.
    This isn't particularly handy for us while running from the command line. However,
    in a playbook, you can use the gathered values later in other modules.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微更有用的模块名为`setup`。该模块连接到配置的节点，收集有关系统的数据，然后返回这些值。虽然在命令行运行时这并不特别方便，但在播放书中，您可以稍后在其他模块中使用收集到的值。
- en: To run Ansible from the command line, you need to pass two things, though usually
    three. First is a host pattern to match the machine that you want to apply the
    module to. Second you need to provide the name of the module that you wish to
    run and optionally any arguments that you wish to give to the module. For the
    host pattern, you can use a group name, a machine name, a glob, and a tilde (~),
    followed by a regular expression matching hostnames. Alternatively, to symbolize
    all of these, you can either use the word `all` or simply `*`. Running Ansible
    modules on the command line this way is referred to as an ad hoc Ansible command.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行运行 Ansible，你需要传递两个参数，通常是三个。第一个是一个主机模式，用于匹配你想要应用模块的机器。第二个是你需要提供你希望运行的模块名称，和可选的任何参数。对于主机模式，你可以使用一个组名、一个机器名、一个
    glob 模式，或一个波浪符（~），后面跟一个正则表达式匹配主机名。或者，为了表示所有这些，你可以使用`all`这个词或简单地使用`*`。以这种方式在命令行运行
    Ansible 模块被称为临时 Ansible 命令。
- en: 'To run the `setup` module on one of your nodes, you need the following command
    line:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的节点上运行 `setup` 模块，你需要以下命令行：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `setup` module will then connect to the machine and give you a number of
    useful facts back. All the facts provided by the `setup` module itself are prepended
    with `ansible_` to differentiate them from variables.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`setup`模块将连接到机器并返回许多有用的信息。`setup`模块提供的所有事实信息都以`ansible_`为前缀，以便与变量区分开来。
- en: This module will work on both Windows and Unix machines. Currently, Unix machines
    will give much more information than a Windows machine. However, as new versions
    of Ansible are released, you can expect to see more Windows functionality get
    included along with Ansible.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块可以在 Windows 和 Unix 机器上工作。目前，Unix 机器会提供比 Windows 机器更多的信息。然而，随着 Ansible 新版本的发布，你可以期待看到更多
    Windows 功能被加入到 Ansible 中。
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The following is a table of the most common values you will use; not all of
    these will be available on all machines. Windows machines especially return a
    lot less data from the setup module.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将使用的最常见值的表格；并非所有这些值都在所有机器上可用。尤其是 Windows 机器从 `setup` 模块返回的数据要少得多。
- en: '| Field | Example | Description |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 示例 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ansible_architecture` | x86_64 | This is the architecture of the managed
    machine |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_architecture` | x86_64 | 这是受管机器的架构 |'
- en: '| `ansible_distribution` | CentOS | This is the Linux or Unix distribution
    on the managed machine |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_distribution` | CentOS | 这是受管机器上的 Linux 或 Unix 发行版 |'
- en: '| `ansible_distribution_version` | 6.3 | This is the version of the preceding
    distribution |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_distribution_version` | 6.3 | 这是前述发行版的版本 |'
- en: '| `ansible_domain` | example.com | This is the domain name part of the server''s
    hostname |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_domain` | example.com | 这是服务器主机名中的域名部分 |'
- en: '| `ansible_fqdn` | machinename.example.com | This is the fully qualified domain
    name of the managed machine |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_fqdn` | machinename.example.com | 这是受管机器的完全合格域名 |'
- en: '| `ansible_interfaces` | ["lo", "eth0"] | This is a list of all the interfaces
    the machine has, including the loopback interface |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_interfaces` | ["lo", "eth0"] | 这是该机器所有接口的列表，包括回环接口 |'
- en: '| `ansible_kernel` | 2.6.32-279.el6.x86_64 | This is the kernel version installed
    on the managed machine |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_kernel` | 2.6.32-279.el6.x86_64 | 这是受管机器上安装的内核版本 |'
- en: '| `ansible_memtotal_mb` | 996 | This is the total memory in megabytes available
    on the managed machine |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_memtotal_mb` | 996 | 这是受管机器上可用的总内存，以兆字节为单位 |'
- en: '| `ansible_processor_count` | 1 | These are the total number of CPUs available
    on the managed machine |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_processor_count` | 1 | 这是受管机器上可用的 CPU 总数 |'
- en: '| `ansible_virtualization_role` | guest | This determines whether the machine
    is a guest or a host machine |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_virtualization_role` | guest | 这决定了机器是客机还是主机 |'
- en: '| `ansible_virtualization_type` | kvm | This is the type of virtualization
    setup on the managed machine |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_virtualization_type` | kvm | 这是受管机器上虚拟化的类型 |'
- en: On a Unix machine, these variables are gathered using Python from the managed
    machine; if you have facter or ohai installed on the remote node, the `setup`
    module will execute them and return their data as well. As with other facts, ohai
    facts are prepended with `ohai_` and facter facts with `facter_`. While the setup
    module doesn't appear to be too useful on the command line, it is useful once
    you start writing playbooks. Note that facter and ohai are not available in Windows
    hosts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 机器上，这些变量通过 Python 从受管机器收集；如果远程节点上安装了 facter 或 ohai，`setup` 模块将执行它们并返回它们的数据。与其他事实一样，ohai
    的事实前缀是 `ohai_`，facter 的事实前缀是 `facter_`。尽管在命令行中 `setup` 模块看起来没什么用处，但一旦开始编写 playbook，它会变得非常有用。请注意，facter
    和 ohai 在 Windows 主机上不可用。
- en: If all the modules in Ansible do as little as the `setup` and the `ping` module,
    we will not be able to change anything on the remote machine. Almost all of the
    other modules that Ansible provides, such as the `file` module, allow us to actually
    configure the remote machine.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Ansible 中的所有模块像 `setup` 和 `ping` 模块那样仅做很少的事情，我们将无法更改远程机器上的任何内容。Ansible 提供的几乎所有其他模块，如
    `file` 模块，都允许我们实际配置远程机器。
- en: The `file` module can be called with a single path argument; this will cause
    it to return information about the file in question. If you give it more arguments,
    it will try and alter the file's attributes and tell you if it has changed anything.
    Ansible modules will tell you if they have changed anything, which becomes more
    important when you are writing playbooks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`file` 模块可以通过单个路径参数调用；这将使其返回有关该文件的信息。如果你提供更多参数，它将尝试更改文件的属性，并告诉你是否已进行更改。Ansible
    模块会告诉你是否进行了更改，这在你编写 playbooks 时变得更加重要。'
- en: 'You can call the `file` module, as shown in the following command, to see details
    about `/etc/fstab`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调用 `file` 模块，如下所示，查看 `/etc/fstab` 的详细信息：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding command should elicit a response like the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令应该产生类似以下内容的响应：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively, the response could be something like the following command to
    create a new test directory in `/tmp`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，响应可能是类似以下命令的内容，用于在 `/tmp` 创建一个新的测试目录：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding command should return something like the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令应该返回类似以下内容：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can see that the changed variable is set to `true` in the response, because
    the directory doesn't exist or has different attributes and changes were required
    to make it match the state given by the provided arguments. If it is run a second
    time with the same arguments, the value of changed will be set to `false`, which
    means that the module did not make any changes to the system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到响应中 `changed` 变量被设置为 `true`，因为目录不存在或具有不同的属性，需要进行更改以使其与提供的参数所指定的状态匹配。如果第二次使用相同的参数运行该命令，`changed`
    的值将设置为 `false`，意味着该模块没有对系统做出任何更改。
- en: 'There are several modules that accept similar arguments to the `file` module,
    and one such example is the `copy` module. The `copy` module takes a file on the
    controller machine, copies it to the managed machine, and sets the attributes
    as required. For example, to copy the `/etc/fstab` file to `/tmp` on the managed
    machine, you will use the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个模块接受与 `file` 模块类似的参数，其中一个例子是 `copy` 模块。`copy` 模块会将控制机上的文件复制到受管机器，并按要求设置其属性。例如，要将
    `/etc/fstab` 文件复制到受管机器的 `/tmp`，你可以使用以下命令：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding command, when run the first time, should return something like
    the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令在第一次运行时，应该返回类似以下内容：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There is also a module named `command` that will run any arbitrary command on
    the managed machine. This lets you configure it with any arbitrary command, such
    as a `preprovided` installer or a self-written script; it is also useful for rebooting
    machines. Note that this module does not run the command within the shell, so
    you cannot perform redirection, use pipes, expand shell variables, or background
    commands.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为 `command` 的模块，可以在受管机器上运行任何任意命令。这使得你可以使用任何任意命令进行配置，比如一个 `preprovided`
    安装程序或自编写的脚本；它对于重启机器也非常有用。请注意，这个模块不会在 shell 中运行命令，因此你无法执行重定向、使用管道、展开 shell 变量或在后台运行命令。
- en: Ansible modules strive to prevent changes being made when they are not required.
    This is referred to as idempotency and can make running commands against multiple
    servers much faster. Unfortunately, Ansible cannot know if your command has changed
    anything or not, so to help it be more idempotent, you have to give it some help.
    It can do this either via the `creates` or the `removes` argument. If you give
    a `creates` argument, the command will not run if the filename argument exists.
    The opposite is true of the `removes` argument; if the filename exists, the command
    will run.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 模块致力于在不需要更改时避免进行修改。这被称为幂等性，它可以使得在多个服务器上运行命令时变得更快。不幸的是，Ansible 无法知道你的命令是否做出了更改，因此为了帮助它更具幂等性，你需要提供一些帮助。它可以通过`creates`或`removes`参数来实现这一点。如果你给出`creates`参数，则如果文件名参数存在，命令将不会运行。`removes`参数则相反；如果文件名存在，命令将会执行。
- en: 'You can run the command as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按以下方式运行该命令：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If there is no file or directory named `/tmp/testing`, the command output will
    indicate that it was skipped, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有名为`/tmp/testing`的文件或目录，命令输出将指示该文件已被跳过，如下所示：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Otherwise, if the file did exist, it will look like the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果文件确实存在，它将像以下代码一样显示：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Often it is better to use another module in place of the `command` module.
    Other modules offer more options and can better capture the problem domain they
    work in. For example, it would be much less work for Ansible and also the person
    writing the configurations to use the `file` module in this instance, since the
    `file` module will recursively delete something if the state is set to `absent`.
    So the preceding command would be equivalent to the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，使用其他模块代替`command`模块会更好。其他模块提供更多选项，并且能够更好地捕获它们所工作的问题领域。例如，在这个例子中，使用`file`模块对于
    Ansible 和编写配置的人员来说都会减少工作量，因为`file`模块如果状态设置为`absent`，会递归地删除某些东西。所以，前面的命令相当于以下命令：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you need to use features usually available in a shell while running your
    command, you will need the `shell` module. This way you can use redirection, pipes,
    or job back grounding. You can pick which shell to use with the executable argument.
    You can use the `shell` module as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在运行命令时使用通常在 shell 中可用的功能，你需要使用`shell`模块。这样你就可以使用重定向、管道或后台作业。你可以使用`executable`参数来选择要使用的
    shell。你可以按以下方式使用`shell`模块：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Module help
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块帮助
- en: Unfortunately, we don't have enough space to cover every module that is available
    in Ansible; luckily though, Ansible includes a command name `ansible-doc` that
    can retrieve help information. All the modules included within Ansible have this
    data populated; however, with modules gathered from elsewhere you may find less
    help. The `ansible-doc` command also allows you to see a list of all modules available
    to you.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们没有足够的空间来涵盖 Ansible 中所有可用的模块；不过幸运的是，Ansible 包含了一个名为`ansible-doc`的命令，可以用来检索帮助信息。Ansible
    中包含的所有模块都有这个数据，但从其他地方收集的模块可能帮助信息较少。`ansible-doc`命令还允许你查看所有可用模块的列表。
- en: 'To get a list of all the modules that are available to you along with a short
    description of each type, use the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有可用模块的列表，并附带每种类型的简短描述，可以使用以下命令：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To see the help file for a particular module, you supply it as the single argument
    to `ansible-doc`. To see the help information for the `file` module, for example,
    use the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看某个特定模块的帮助文件，你需要将模块作为`ansible-doc`命令的唯一参数。例如，要查看`file`模块的帮助信息，可以使用以下命令：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered which installation type to choose for installing
    Ansible and how to build an inventory file to reflect your environment. After
    this we saw how to use Ansible modules in an ad hoc style for simple tasks. Finally
    we discussed how to learn which modules are available on your system and how to
    use the command line to get instructions for using a module.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了选择哪种安装类型来安装 Ansible，以及如何构建一个清单文件来反映你的环境。接着，我们展示了如何以临时方式使用 Ansible
    模块来执行简单任务。最后，我们讨论了如何了解系统中可用的模块，并如何使用命令行获取使用模块的指令。
- en: In the next chapter, you will learn how to use many modules together in a playbook.
    This allows you to perform more complex tasks than you could do with single modules
    alone.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学习如何在 Playbook 中一起使用多个模块。这使得你能够执行比单独使用模块时更加复杂的任务。
