- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Git Best Practices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 最佳实践
- en: The last chapter of *Mastering Git* presents a collection of generic and Git-specific
    version control recommendations and best practices. You have encountered many
    of these recommendations already in the earlier chapters; they are here as a summary
    and as a reminder. For details and the reasoning behind each best practice, refer
    to the specific chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 《*Git 入门*》的最后一章展示了一系列通用和特定于 Git 的版本控制建议和最佳实践。你在前面的章节中已经接触到其中很多建议；这里将它们作为总结和提醒。有关每个最佳实践的详细信息和背后的原因，请参考具体章节。
- en: This chapter will cover the issues of managing the working directory, creating
    commits and series of commits (pull requests), submitting changes for inclusion,
    and the peer review of changes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖管理工作目录、创建提交和提交系列（拉取请求）、提交更改以供包含以及同行评审变更的问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to separate projects into repositories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将项目拆分为仓库
- en: What types of data to store in a repository and which files Git should ignore
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在仓库中存储哪些类型的数据，以及 Git 应该忽略哪些文件
- en: What to check before creating a new commit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建新提交之前需要检查什么
- en: How to create a good commit and a good commit series (or, in other words, how
    to create a good pull request)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建良好的提交和良好的提交系列（换句话说，如何创建良好的拉取请求）
- en: How to choose an effective branching strategy, and how to name branches and
    tags
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何选择有效的分支策略，以及如何命名分支和标签
- en: How to review changes and how to respond to the review
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何审查变更以及如何回应审查
- en: Starting a project
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动一个项目
- en: 'When starting a project, you should choose and clearly define a project governance
    model (who manages work, who integrates changes, and who is responsible for what).
    You should decide about the license and the copyright of the code: whether it
    is work for hire and whether contributions require a copyright assignment, a contributor
    agreement, a contributor license agreement, or simply a digital certificate of
    origin.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动项目时，你应该选择并明确项目治理模型（谁管理工作，谁整合更改，谁负责什么）。你还需要决定代码的许可证和版权：它是否是外包工作，贡献是否需要版权转让、贡献者协议、贡献者许可证协议，或者仅仅是数字原产地证书。
- en: Dividing work into repositories
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将工作分配到仓库中
- en: In centralized version control systems, often everything is put under the same
    project tree. With distributed version control systems such as Git, it very much
    depends on the nature of the project. Often, it is better to split separate projects
    into separate repositories, but if those projects are tightly coupled together
    it might be better to use a **monorepo** – all projects in a single large repository.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在集中式版本控制系统中，通常所有内容都放在同一个项目树下。而在分布式版本控制系统（如 Git）中，这在很大程度上取决于项目的性质。通常，最好将不同的项目拆分到不同的仓库中，但如果这些项目紧密耦合在一起，那么使用**单一仓库（monorepo）**可能更好——将所有项目放在一个大的仓库中。
- en: If some part of the code is needed by multiple separate projects, consider extracting
    it into its own project and then incorporating it as a submodule or subtree, grouping
    concepts into a superproject. See [*Chapter 11*](B21194_11.xhtml#_idTextAnchor270),
    *Managing Subprojects*, for the details.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某部分代码被多个独立项目需要，考虑将其提取为一个独立的项目，并将其作为子模块或子树引入，按概念将其组织成一个超级项目。有关详细信息，请参见 [*第
    11 章*](B21194_11.xhtml#_idTextAnchor270)，*管理子项目*。
- en: Selecting the collaboration workflow
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择协作工作流
- en: You need to make decisions on the collaboration structure, whether your project
    will use a dispersed contributor model, a “blessed” repository model, or a central
    repository, and so on (as found in [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140),
    *Collaborative Development* *with Git*).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做出关于协作结构的决策，决定你的项目将采用分散贡献者模型、"受信任"仓库模型、还是中央仓库等（具体内容请见 [*第 6 章*](B21194_06.xhtml#_idTextAnchor140)，*使用
    Git 进行协作开发*）。
- en: This often requires setting up an access control mechanism and deciding on the
    permission structure; see [*Chapter 14*](B21194_14.xhtml#_idTextAnchor349)*, Git
    Administration*, for details on how one can set up this.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常需要设置访问控制机制并决定权限结构；有关如何设置这些内容的详细信息，请参见 [*第 14 章*](B21194_14.xhtml#_idTextAnchor349)*，Git
    管理*。
- en: You also need to decide on the branching patterns to use. See [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196),
    *Advanced Branching Techniques*, for examples of the most common patterns. You
    need to decide how to integrate changes, and how to isolate independent work.
    Those branching patterns are often grouped together into a single named branching
    workflow.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要决定使用的分支模式。参见[*第8章*](B21194_08_split_000.xhtml#_idTextAnchor196)，*高级分支技术*，其中包含了最常见模式的示例。你需要决定如何集成变更，以及如何隔离独立的工作。这些分支模式通常会组合成一个单独的命名分支工作流。
- en: This decision about branching doesn’t need to be cast in stone. As your project
    and your team experience grow, you might want to consider changing the branching
    model, for example, from the trunk-based workflow to a plain branch-per-feature
    model, a GitHub flow, or any of the other derivatives.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于分支的决策不需要一成不变。随着项目和团队经验的增长，你可能希望考虑改变分支模型，例如，从基于主干的工作流改为每个功能独立分支模型、GitHub流，或其他衍生模型。
- en: The decisions about licensing, the collaboration structure, and the branching
    model should all be stated explicitly in the developer documentation (at a minimum
    in the `README` and `LICENSE`/`COPYRIGHT` files, and perhaps also in `CodingGuidelines`
    and `CodeOfConduct`). You need to remember that if the way in which the project
    is developed changes, this documentation needs to be updated to reflect the changes.
    This can happen, for example, because the project has grown beyond its initial
    stage.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有关许可、协作结构和分支模型的决策应该在开发者文档中明确说明（至少在`README`和`LICENSE`/`COPYRIGHT`文件中，可能还包括在`CodingGuidelines`和`CodeOfConduct`中）。你需要记住，如果项目的开发方式发生变化，这些文档需要更新以反映这些变化。例如，因为项目已超出最初阶段，可能会发生这种情况。
- en: Choosing which files to keep under version control
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择要保留在版本控制中的文件
- en: In most cases, you should not include any of the **generated files** in the
    version control system (though there are some very rare exceptions). You should
    track only the sources (the original resources); Git works best if these sources
    are plain text files, but it also works well with binary files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不应该将任何**生成的文件**包含在版本控制系统中（尽管有一些非常罕见的例外）。你应该只跟踪源文件（即原始资源）；Git在处理这些源文件时表现最好，尽管它也能很好地处理二进制文件。
- en: To avoid accidentally including unwanted files in a repository, you should use
    the `.gitignore` file in the project tree; those specific to the developer (for
    example, backup files created by the editor one uses or the operating system-specific
    helper files) should go into their per-user `core.excludesFile` (which, in modern
    Git, is the `~/.config/git/ignore` file), or into a local configuration of the
    specific clone of the repository, that is, `.git/info/excludes`. See [*Chapter
    3*](B21194_03_split_000.xhtml#_idTextAnchor049), *Managing Your* *Worktrees*,
    for details.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免不小心将不需要的文件包含在代码库中，你应该在项目树中使用`.gitignore`文件；开发者特定的文件（例如，由编辑器或操作系统创建的备份文件）应放入他们各自的`core.excludesFile`（在现代Git中是`~/.config/git/ignore`文件），或者放入特定克隆版本库的本地配置中，即`.git/info/excludes`。有关详细信息，请参见[*第3章*](B21194_03_split_000.xhtml#_idTextAnchor049)，*管理你的工作树*。
- en: A good start for ignore patterns is the [https://gitignore.io](https://gitignore.io)
    site with its `.gitignore` templates for various operating systems, IDEs, and
    programming languages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略模式的一个良好起点是[https://gitignore.io](https://gitignore.io)网站，它提供了各种操作系统、IDE和编程语言的`.gitignore`模板。
- en: Another suggestion is to not add to Git the configuration files that might change
    from environment to environment (for example, those that are different for MS
    Windows and Linux).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个建议是，不要将可能因环境而变化的配置文件添加到Git中（例如，MS Windows和Linux之间不同的配置文件）。
- en: Working on a project
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在项目中工作
- en: Here are some guidelines on how to create changes and develop new revisions.
    These guidelines can be used either for your work on your own project, or to help
    contribute your code to a project maintained by somebody else.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有关如何创建变更和开发新版本的一些指导方针。这些方针可以用于你自己项目的工作，或者帮助你向由他人维护的项目贡献代码。
- en: Different projects can use different development workflows; therefore, some
    of the recommendations presented here might not make sense depending on the given
    workflow in use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的项目可能使用不同的开发工作流；因此，根据使用的工作流，本文提供的一些建议可能没有意义。
- en: Working on a topic branch
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在主题分支上工作
- en: 'Branching in Git has two functions ([*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196),
    *Advanced Branching Techniques*): as a mediator for the code contributed by developers
    keeping to the **specified level of code stability and maturity** (long-running
    public branches), providing the road to integration and deployment, and as a **sandbox
    for the development of a new idea** (short-lived private branches).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Git中的分支有两个功能（[*第8章*](B21194_08_split_000.xhtml#_idTextAnchor196)，*高级分支技巧*）：作为开发者提交的代码在**指定的代码稳定性和成熟度级别**下的中介（长期存在的公共分支），提供集成和部署的路径，以及作为**新想法开发的沙盒**（短期存在的私人分支）。
- en: The ability to sandbox changes is why it is considered a good practice to create
    a separate branch for each new task you work on. Such a branch is called a topic
    branch or a feature branch. Using separate branches makes it possible to switch
    between tasks easily, and to keep disparate pieces of work in progress from interfering
    with each other. On the other hand, if such branches are long-lived, it would
    go against **c****ontinuous integration** (**CI**) practices, reduce changeset
    visibility, and lead to more difficult integration because of larger divergence.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒化变更的能力是为什么创建一个单独的分支来处理每个新任务被认为是一个好习惯。这样的分支被称为主题分支或功能分支。使用独立的分支使得在任务之间轻松切换成为可能，并且可以防止不同的工作进度互相干扰。另一方面，如果这些分支存在很长时间，这会违反**持续集成**（**CI**）的实践，减少变更集的可见性，并因为更大的分歧导致更困难的集成。
- en: You should choose short and descriptive names for branches. There are different
    naming conventions for topic branches; the convention your project uses should
    be specified in the developer documentation. In general, branches are usually
    named with a summary of a topic they host, usually in all-lowercase and with the
    spaces between words replaced by hyphens or underscores (see the `git-check-ref-format`
    manpage to know what is forbidden in branch names). Branch names can include slashes
    (be hierarchical).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该为分支选择简短且具有描述性的名称。主题分支有不同的命名约定，你的项目使用的约定应在开发文档中说明。通常，分支名称会总结它们所托管的主题，通常是全小写字母，单词之间的空格用连字符或下划线替代（查看`git-check-ref-format`的手册页以了解分支名称中禁止使用的字符）。分支名称可以包含斜杠（成为层次化结构）。
- en: If you are using an issue tracker, then a branch that fixes a bug or implements
    an issue can have its name prefixed with the identifier (the number) of the ticket
    describing the issue, for example, `1234-doc_spellcheck`. On the other hand, the
    maintainer, while gathering submissions from other developers, could put these
    submissions in topic branches named after the initials of the developer and the
    name of the topic, for example, `ad/whitespace-cleanup` (this is an example of
    a **hierarchical** **branch name**).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用问题追踪器，那么修复bug或实现某个问题的分支可以在其名称前加上描述该问题的票据编号，例如`1234-doc_spellcheck`。另一方面，维护者在收集其他开发者的提交时，可以将这些提交放入以开发者的首字母和主题名称命名的主题分支中，例如`ad/whitespace-cleanup`（这是一个**层次化的**
    **分支名称**示例）。
- en: It is considered a good practice to delete your topic branch from your local
    repository, and also from the upstream repository after you are done with the
    branch in question, to reduce clutter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成相关分支的工作后，从本地仓库以及上游仓库删除你的主题分支被认为是一个好习惯，以减少杂乱。
- en: Deciding what to base your work on
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定基于什么来开展你的工作
- en: As a developer, you are usually working on some specific issue at a given time,
    be it a bug fix, an enhancement, a correction to some topic, or a new feature.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你通常会在某个特定问题上进行工作，无论是bug修复、功能增强、某个主题的修正，还是新特性的开发。
- en: Where to start your work on a given topic, and what branch to base your work
    on, both depend on the branching workflow chosen for the project (see [*Chapter
    8*](B21194_08_split_000.xhtml#_idTextAnchor196), *Advanced Branching Techniques*,for
    a selection of branching workflows). This decision also depends on the type of
    work you do.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定主题上开始工作的地方，以及基于哪个分支开始工作，都取决于项目所选的分支工作流（参见[*第8章*](B21194_08_split_000.xhtml#_idTextAnchor196)，*高级分支技巧*，了解不同的分支工作流）。这个决定也取决于你所做工作的类型。
- en: For a topic branch workflow (or a branch-per-feature workflow), you would want
    to base your work on the oldest and most stable long-running branch that your
    change is relevant to, and for which you plan to merge your changes into. This
    is because, as described in [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196),
    *Advanced Branching Techniques*, you should **never merge** a **less stable branch
    into** a **more stable branch**. The reason behind this best practice rule is
    to avoid destabilizing the branch as merging carries over all the changes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主题分支工作流（或每个功能一个分支工作流），你应该选择基于与你的更改相关的、最老且最稳定的长期运行分支，并计划将更改合并到该分支。这是因为，正如在[*第8章*](B21194_08_split_000.xhtml#_idTextAnchor196)《*高级分支技巧*》中所描述的，你**绝不应该将**一个**不太稳定的分支合并到**一个**更稳定的分支**。这一最佳实践的背后原因是为了避免使分支不稳定，因为合并会带入所有更改。
- en: Different types of changes require a different long-lived branch to be used
    as a base for a topic branch with those changes, or to put those changes onto.
    In general, to help developers working on a project, this information should be
    described in the developer documentation; not everybody needs to be knowledgeable
    about the branching workflow used by the project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的更改需要不同的长期存在的分支作为主题分支的基础，或者将这些更改放置到该分支上。一般来说，为了帮助开发者理解项目的工作流程，这些信息应当在开发文档中进行描述；并不是每个人都需要了解项目使用的分支工作流。
- en: 'The following describes what is usually used as a base branch, depending on
    the purpose of the changes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容描述了根据更改的目的，通常作为基础分支使用的内容：
- en: '**Bugfix**: In this case, the topic branch (the bugfix branch) should be based
    on the oldest and the most stable branch in which the bug is present. This means,
    in general, starting with the maintenance branch. If the bug is not present in
    the maintenance branch, then base the bugfix branch on the stable branch. For
    a bug that is not present in the stable branch, find the topic branch that introduced
    it and base your work on top of that topic branch.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bug修复**：在这种情况下，主题分支（bugfix分支）应基于存在该bug的最老且最稳定的分支。通常来说，从维护分支开始。如果在维护分支中没有该bug，则应基于稳定分支创建bugfix分支。对于在稳定分支中不存在的bug，找到引入该bug的主题分支，并基于该主题分支进行工作。'
- en: '**New feature**: In this case, the topic branch (the feature branch) should
    be based on the stable branch, if possible. If the new feature depends on some
    topic that is not ready for the stable branch, then base your work on that topic
    (from a topic branch).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新功能**：在这种情况下，主题分支（功能分支）应尽可能基于稳定分支。如果新功能依赖于某个尚未准备好进入稳定分支的主题，则应基于该主题（从主题分支）。'
- en: Corrections and enhancements to a topic that didn’t get merged into the stable
    branch should be based on the tip of the topic branch being corrected. If the
    topic in question is not considered published, it’s alright to make changes to
    the steps of the topic, squashing minor corrections in the series (see the section
    about rewriting history in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247)*,
    Keeping* *History Clean*).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于未合并到稳定分支中的主题的修正和增强，应基于正在修正的主题分支的最新版本。如果相关主题尚未发布，可以对该主题的步骤进行更改，将小的修正合并到系列中（详见[*第10章*](B21194_10_split_000.xhtml#_idTextAnchor247)《*保持*
    *历史清晰*》中的历史重写部分）。
- en: If the project you are contributing to is large enough to have dedicated maintainers
    for selected parts (subsystems) of the system, you first need to decide which
    repository and fork (sometimes named “a tree”) to base your work on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你所参与的项目足够大，拥有专门的维护者来管理系统的某些部分（子系统），你首先需要决定将基于哪个代码库和分支（有时称为“树”）进行工作。
- en: Splitting changes into logically separate steps
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将更改拆分为逻辑上独立的步骤
- en: Unless your work is really simple and can be done in a single step (a single
    commit)—as is the case with many bugfixes—you should make separate commits for
    logically separate changes, one commit per single step. Those commits should be
    ordered logically.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你的工作非常简单并且可以在一个步骤内完成（一个提交）——就像许多bug修复一样——你应该将逻辑上独立的更改拆分为单独的提交，每个提交代表一个步骤。这些提交应按逻辑顺序排列。
- en: Following good practice for commit messages (with an explanation of what you
    have done—see the next section) could help in deciding when to commit. If your
    description gets too long and you begin to see that you have two independent changes
    squashed together, that’s a sign that you probably need to split your commit into
    finer-grained pieces and use smaller steps.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循提交信息的最佳实践（说明你所做的更改——见下一节）有助于决定何时提交。如果你的描述过长，并且开始看到你有两个独立的更改被混合在一起，那么这意味着你可能需要将提交拆分成更小的部分，并使用更细粒度的步骤。
- en: Remember, however, that it is a matter of balance between the project conventions
    and the development workflow chosen. Changes should, at a minimum, stand on their
    own. At each step (at each commit) of the implementation of a feature, the code
    compiles and the program passes the test suite. You should `git bisect` (which
    is described in [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083), *Exploring* *Project
    History*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，这取决于项目约定和所选开发工作流之间的平衡。更改至少应该是自成一体的。在实现某个特性时的每一步（每次提交），代码应该能够编译，程序也能通过测试套件。你应该使用
    `git bisect`（这一点在 [*第 4 章*](B21194_04.xhtml#_idTextAnchor083)，*探索项目历史* 中有所描述）。
- en: Note that you don’t necessarily need to come up with the perfect sequence of
    steps from the start. If you notice that you have entangled the work directory’s
    state, you can make use of the staging area, using an interactive add to disentangle
    it (this is described in [*Chapter 2*](B21194_02.xhtml#_idTextAnchor028)*, Developing
    with Git,* and [*Chapter 3*](B21194_03_split_000.xhtml#_idTextAnchor049)*, Managing
    Your* *Worktrees*). You can also use an interactive rebase or a similar technique,
    as shown in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247)*, Keeping
    History Clean*, to curate commits into an easy-to-read (and easy-to-bisect) history
    before publishing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不必一开始就制定完美的步骤序列。如果你发现工作目录的状态被混合在一起，可以利用暂存区，通过交互式添加将其解开（这一点在 [*第 2 章*](B21194_02.xhtml#_idTextAnchor028)*，开发与
    Git,* 和 [*第 3 章*](B21194_03_split_000.xhtml#_idTextAnchor049)*，管理工作树* 中有所描述）。你也可以使用交互式变基或类似技术，如
    [*第 10 章*](B21194_10_split_000.xhtml#_idTextAnchor247)*，保持历史整洁* 中所示，整理提交，生成易读（且易于二分）的历史，然后再发布。
- en: Important note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should remember that a commit is a place to record your result (or a particular
    step towards the result), not a place to save the temporary state of your work.
    If you need to temporarily save the current state before going back to it, use
    **git stash**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记住，提交是记录你的结果（或朝着结果迈出的特定步骤）的位置，而不是保存工作临时状态的地方。如果你需要在返回之前暂时保存当前状态，可以使用 **git
    stash**。
- en: Writing a good commit message
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写一条好的提交信息
- en: A good commit message should include an explanation for the change with sufficient
    detail so that other developers on the team (including reviewers and the maintainer)
    can judge whether it is a good idea to include the change in the codebase. This
    good-or-not decision should not require them to read the actual changes to find
    out what the commit intends to do.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一条好的提交信息应该包含对更改的解释，足够详细，以便团队中的其他开发人员（包括审查者和维护者）能够判断是否应该将该更改包含到代码库中。这个是否“好”的决策不应该需要他们阅读实际的更改内容才能判断提交的意图。
- en: The first line of the commit message should be a short, terse description (from
    around 50 to 72 characters) with a summary of the changes. It should be separated
    by an empty line from the rest of the commit message, if there is one. This is
    partly because, in many places, such as in the `git log --oneline` command output,
    in a graphical history viewer such as `gitk`, and in the instruction sheet of
    `git rebase --interactive`, you will see only this one line of the commit message
    and have to decide the action with respect to that commit on the basis of this
    one line. If you have trouble with coming up with a good summary of changes, this
    might mean that these changes need to be split into smaller steps.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 提交信息的第一行应简洁明了（大约 50 到 72 个字符），概述所做的更改。如果有其他内容，应该用空行将其与剩余部分分开。这是因为在许多地方，例如 `git
    log --oneline` 命令输出、图形化历史查看器如 `gitk` 和 `git rebase --interactive` 的指令页中，你只会看到这一行提交信息，并且必须根据这一行来决定对该提交的操作。如果你在总结更改时遇到困难，这可能意味着这些更改需要拆分成更小的步骤。
- en: 'There are various conventions for this summary line of changes. One convention
    is to prefix the first summary line with **area:**, which is an identifier for
    the general area of the code being modified: the name of the subsystem, of an
    affected subdirectory, or a filename of a file being changed. If the development
    is managed via an issue tracker, this summary line can start with something like
    the **[#1234]** prefix, where **1234** is the identifier of an issue or task implemented
    in the commit. In general, when not sure about what information to include in
    the commit message, refer to the development documentation or fall back to the
    current convention used by other commits in the history.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更改的摘要行，有多种约定。一种约定是使用**area:**作为前缀，后面跟随代码修改的领域标识符：如子系统名称、受影响的子目录名，或被修改的文件名。如果开发通过问题跟踪器管理，则此摘要行可以以类似**[#1234]**的前缀开始，其中**1234**是提交中实现的问题或任务的标识符。通常情况下，如果不确定提交信息中应该包含哪些信息，请参考开发文档或回溯到历史提交中使用的当前约定。
- en: Tip
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using agile development methods, you can look for especially good
    commit messages during retrospectives and add them as examples to the developer
    documentation for the future.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是敏捷开发方法，你可以在回顾过程中寻找特别好的提交信息，并将其作为示例添加到未来的开发者文档中。
- en: 'For all but trivial changes, there should be a longer meaningful description,
    the body of the commit message. There is something that people coming from other
    version control systems might need to unlearn: namely, not writing a commit message
    at all or writing it all on one long line. Note that Git will not allow the creation
    of a commit with an empty commit message unless forced to with `--allow-empty`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非琐碎的更改，应该有一段更长的有意义的描述，也就是提交信息的正文。这里有些事情是来自其他版本控制系统的人可能需要忘记的：即不写提交信息或将其写在一长行中。注意，Git
    不允许创建一个空提交信息的提交，除非通过`--allow-empty`强制允许。
- en: 'The commit message should do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 提交信息应该做到以下几点：
- en: Include the rationale for the commit, explaining the problem that the commit
    tries to solve – the *why*, in other words. It should include a description of
    what is wrong with the current code or the current behavior of the project without
    the change. This should be self-contained, but it can refer to other sources including
    the issue tracker (the bug tracker) or other external documents such as articles,
    wikis, or **Common Vulnerabilities and** **Exposures** (**CVEs**).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括提交的理由，解释提交试图解决的问题——换句话说，*为什么*。它应该包含描述当前代码或项目在没有这个变更时的行为或状态的问题。这部分应当自包含，但可以引用其他来源，包括问题跟踪器（bug
    跟踪器）或其他外部文档，如文章、wiki 或**常见漏洞与** **暴露**（**CVE**）。
- en: Include a quick summary. In most cases, it should also explain the *how* and
    justify the way the commit solves the problem.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含简短的摘要。在大多数情况下，它也应该解释*如何*解决问题，并为提交解决方案的方式提供理由。
- en: Describe why you think the result with the change is better; this part of the
    description does not need to explain what the code does, as that is largely a
    task for the code comments.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述为什么你认为变更后的结果更好；这部分描述无需解释代码的作用，因为这通常是代码注释的任务。
- en: If there was more than one possible solution, include a description of the alternative
    solutions that were considered but ultimately discarded, perhaps with links to
    the discussion or review(s).
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在多个可能的解决方案，请包含考虑过但最终被弃用的替代解决方案的描述，并提供指向讨论或评审的链接。
- en: It’s a good idea to try to make sure that your explanation of the changes can
    be understood without access to any external resources (that is, without accessing
    the issue tracker, the internet, or a mailing list archive). Instead of just referring
    to the discussion, or in addition to giving a URL or an issue number, write a
    summary of the relevant points in the commit message.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的变更说明可以在不访问任何外部资源的情况下理解（也就是说，不访问问题跟踪器、互联网或邮件列表档案）。与其仅仅引用讨论，或在提供 URL 或问题编号的同时，写出相关要点的总结并包含在提交信息中。
- en: One of the possible recommendations when writing a commit message is to describe
    changes in the imperative mood, for example, **make foo do bar**, as if you are
    giving orders to the codebase to change its behavior, instead of writing **This
    commit makes...** or **[I]** **changed ...**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 写提交信息时的一项可能推荐做法是使用祈使语气描述变更，例如**让 foo 执行 bar**，就好像你在命令代码库改变其行为，而不是写**这个提交使得...**或**[我]**
    **更改了...**。
- en: Here, `commit.template` and commit message hooks can help in following these
    practices. see[*Chapter 13*](B21194_13_split_000.xhtml#_idTextAnchor320), *Customizing
    and Extending Git*, for details (and [*Chapter 14*](B21194_14.xhtml#_idTextAnchor349),
    *Git Administration*, for a description of the way to enforce this recommendation).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`commit.template` 和提交消息钩子可以帮助遵循这些做法。详细信息请见[*第 13 章*](B21194_13_split_000.xhtml#_idTextAnchor320)，*定制和扩展
    Git*（以及[*第 14 章*](B21194_14.xhtml#_idTextAnchor349)，*Git 管理*，描述了强制执行这一建议的方法）。
- en: Preparing changes for submission
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备变更以供提交
- en: If the topic branch was started a long time ago, consider rebasing the branch
    to be submitted on top of the current tip of the base branch. This should make
    it easier to integrate changes in the future. If your topic branch was based on
    the development version, or on the other in-flight topic branch (perhaps because
    it depended on some specific feature), and the branch it was based on got merged
    into a stable line of development, you should rebase your changes on top of the
    stable integration branch instead.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果话题分支是很久之前开始的，考虑将该分支基于当前基础分支的最新提交进行 rebase。这应该会使未来的变更集成变得更容易。如果你的话题分支是基于开发版本，或者是基于其他正在进行中的话题分支（可能是因为它依赖某些特定功能），并且它所基于的分支已经合并到稳定的开发线路中，那么你应该将你的变更
    rebase 到稳定的集成分支之上。
- en: 'Rebasing is also a chance for a final clean-up of the history; the chance to
    make submitted changes easier to review. Simply run an interactive rebase with
    `git rebase --interactive`, or a patch management tool if you prefer (see [*Chapter
    10*](B21194_10_split_000.xhtml#_idTextAnchor247), *Keeping History Clean*). One
    caveat: **do not rewrite the** **published history**.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Rebase 也是最后清理历史的机会；这是使提交的变更更容易审查的机会。只需运行 `git rebase --interactive` 进行交互式 rebase，或者如果你喜欢，可以使用补丁管理工具（详见[*第
    10 章*](B21194_10_split_000.xhtml#_idTextAnchor247)，*保持历史干净*）。有一个注意事项：**不要重写已发布的历史**。
- en: Consider testing that your changes merge cleanly, and fix it if they don’t (if
    possible). Make sure that they apply or merge cleanly into the appropriate integration
    branch.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑测试你的变更是否能够顺利合并，如果不能，尽量修复它（如果可能）。确保它们能够顺利地应用或合并到适当的集成分支中。
- en: Take a last look at your commits to be submitted. Make sure that your changes
    do not add the commented-out (or the ifdef-ed-out) code, nor any extra files not
    related to the purpose of the patch (for example, changes in an upcoming feature).
    Review your commit series before submission to ensure accuracy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后检查一下即将提交的提交记录。确保你的变更没有添加注释掉的代码（或是 `ifdef` 注释掉的代码），也没有包含任何与补丁目的无关的额外文件（例如，未来功能的变更）。在提交之前，审查你的提交系列，确保准确无误。
- en: Integrating changes
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成变更
- en: The exact details on how to submit changes for merging depends, of course, on
    the development workflow that the project is using. Various classes of possible
    workflows are described in [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140), *Collaborative
    Development* *with Git.*
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 提交变更以进行合并的具体细节，当然取决于项目使用的开发工作流。关于各种可能的工作流类，详情请见[*第 6 章*](B21194_06.xhtml#_idTextAnchor140)，*使用
    Git 进行协作开发*。
- en: Submitting and describing changes
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交并描述变更
- en: If the project has a dedicated maintainer or, at least someone responsible for
    merging the proposed changes into the official version, you also need to describe
    the submitted changes as a whole (in addition to describing each commit in the
    series). This can be done in the form of a cover letter for the patch series while
    sending changes as patches via email. It can also be done with comments in the
    pull request while using the collocated contributor repositories model, or it
    can be the description in an email with a pull request, which already includes
    the URL and the branch in your public repository with changes (generated with
    `git request-pull`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目有专门的维护者，或者至少有负责将提交的变更合并到官方版本的人，那么你还需要对提交的变更进行整体描述（除了描述每个提交之外）。这可以通过邮件发送补丁时的补丁系列封面信形式来完成。也可以通过使用协作贡献者仓库模型时，在
    pull 请求中的评论中进行描述，或者可以通过已包含 URL 和你公共仓库中更改分支的邮件描述来完成（该 URL 是通过 `git request-pull`
    生成的）。
- en: This cover letter or pull request should include a description of the purpose
    of the patch series or the pull request. Consider also providing an overview of
    why the work is taking place (with any relevant links and a summary of the discussion).
    Be explicit in stating that it is a work in progress in the description of changes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这封封面信件或拉取请求应该包括补丁系列或拉取请求的目的描述。考虑提供为什么进行此项工作的概述（包括任何相关链接和讨论摘要）。在更改描述中明确表示这是一项进行中的工作。
- en: In the dispersed contributor model, where changes are submitted for review as
    patches or patch series, usually to a mailing list, you should use Git-based tools
    such as `git format-patch` and, if possible, `git send-email`. Multiple related
    patches should be grouped together, for example, in their own email thread. The
    convention is to send them as replies to an additional cover letter message, which
    should describe the feature as a whole.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在分散的贡献者模型中，变更作为补丁或补丁系列提交以供审查，通常是提交到邮件列表，你应该使用基于Git的工具，如`git format-patch`，如果可能，使用`git
    send-email`。多个相关的补丁应该被归为一组，例如放在同一个邮件线程中。约定是将它们作为对附加封面信件的回复发送，封面信件应该描述整个特性。
- en: If the changes are sent to the mailing list, it is a common convention to prefix
    your subject line with `[PATCH]` or `[PATCH m/n]` (where `m` is the patch number
    in the series of the `n` patches). This lets people easily distinguish patch submissions
    from other emails. This part can be done with `git format-patch`. What you need
    to decide yourself is whether to use additional markers after `PATCH` to mark
    the nature of the series, for example, `PATCH/RFC`. (**RFC** here means **Request
    For Comments**, i.e., an idea for a feature with an example of its implementation.
    Such a patch series should only be examined if the idea is worthy; it is not ready
    to be applied/merged yet and is provided only for discussion among the developers.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改被发送到邮件列表，通常的约定是将主题行前缀加上`[PATCH]`或`[PATCH m/n]`（其中`m`是补丁系列中的补丁编号，`n`是总补丁数）。这样可以让人们轻松区分补丁提交和其他邮件。这个部分可以通过`git
    format-patch`来完成。你需要自己决定是否在`PATCH`后使用额外的标记来标记系列的性质，例如，`PATCH/RFC`。（**RFC**在这里指的是**征求意见**，即提出一个特性的想法，并附上其实现的示例。这种补丁系列只有在想法有价值时才应被审查；它还不准备应用/合并，只是为了开发者之间的讨论。）
- en: In the collocated contributor repositories model, where all the developers use
    the same Git hosting website or software (for example, GitHub, Bitbucket, GitLab,
    or a private instance of it), you would push changes to your own public repository,
    a fork of the official version. Then, you would create a merge request or pull
    request, usually via the web interface of the hosting service, again describing
    the changes as a whole there.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在共同位置的贡献者仓库模型中，所有开发者使用相同的Git托管网站或软件（例如GitHub、Bitbucket、GitLab或其私有实例），你会将更改推送到你自己的公开仓库，即官方版本的一个分支。然后，你会创建一个合并请求或拉取请求，通常通过托管服务的网页界面进行，在那里再次描述更改的整体内容。
- en: In the case of using the central repository (perhaps in a shared maintenance
    model), you would push changes to a separate and possibly new branch in the integration
    repository, and then send an announcement to the maintainer so that they can find
    the changes to merge. The details of this step depend on the exact setup; sending
    announcements might be done via email, some kind of internal messaging mechanism,
    or even via tickets (or the comments in the tickets).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用中央仓库的情况下（可能是在共享维护模型中），你会将更改推送到集成仓库中的一个单独且可能是新的分支，然后向维护者发送公告，以便他们能够找到这些更改进行合并。此步骤的详细信息取决于具体的设置；发送公告可能通过电子邮件、某种内部消息机制，甚至通过工单（或工单中的评论）进行。
- en: The development documentation might include rules specifying where to send announcements
    and/or changes. It is considered a courtesy to notify the people who are involved
    in the area of code you are changing about the new changes (you can use `git blame`
    and `git shortlog` to identify these
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 开发文档可能包括规则，指定在哪里发送公告和/或更改。通知涉及到你所修改的代码区域的人员是出于礼貌的行为（你可以使用`git blame`和`git shortlog`来识别这些人）。
- en: people; see [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083), *Exploring Project
    History*). These people are important; they can write comments about the change
    and help review it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 人员；请参见[*第4章*](B21194_04.xhtml#_idTextAnchor083)，*探索项目历史*）。这些人很重要；他们可以写评论并帮助审查变更。
- en: Crediting people and signing your work
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 署名和致谢
- en: 'Some open source projects, in order to improve the tracking provenance of the
    code, use the sign-off procedure borrowed from the Linux kernel called **Digital
    Certificate of Origin**. The sign-off is a simple line at the end of the commit
    message, like the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开源项目为了改进代码的来源追踪，使用了借鉴自Linux内核的签名程序，称为**数字来源证书**。签名是一行简单的内容，位于提交信息的末尾，如以下示例：
- en: '**Signed-off-by: Random** **Developer <rdeveloper@company.com>**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**Signed-off-by: Random** **Developer <rdeveloper@company.com>**'
- en: By adding this line, you certify that the contribution is either created as
    a whole or in part by you, or is based on previous work, or was provided directly
    to you, and that everybody in the chain has the right to submit it under the appropriate
    license. If your work is based on work by somebody else, or if you are just passing
    somebody’s work, then there can be multiple sign-off lines forming a chain of
    provenance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这一行，你证明该贡献要么完全由你创建，要么部分由你创建，或基于之前的工作，或直接提供给你，并且链中的每个人都有权在适当的许可证下提交它。如果你的工作是基于其他人的工作，或者你只是转交别人的工作，那么可能会有多条签名行，形成一条来源链。
- en: In order to credit people who helped with creating the commit, you can append
    to the commit message other trailers, such as **Reported-by:**, **Reviewed-by:**,
    **Acked-by:** (this one states that it was liked by the person responsible for
    the area covered by the change), or **Tested-by:**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表彰帮助创建提交的人，你可以在提交信息中附加其他尾注，例如**Reported-by:**、**Reviewed-by:**、**Acked-by:**（此项表示该更改得到了负责该区域的人的认可）或**Tested-by:**。
- en: The art of the change review
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改审查的艺术
- en: 'Completing a peer review of changes is time-consuming (although so is using
    version control), but the benefits are huge: better code quality, a reduction
    in the time needed for quality assurance testing, transfer of knowledge, and so
    on. The change can be reviewed by a peer developer, reviewed by a community (requiring
    consensus), or reviewed by the maintainer or one of their lieutenants.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 完成同行评审更改是非常耗时的（尽管使用版本控制也同样耗时），但其好处巨大：更好的代码质量、减少质量保证测试所需的时间、知识转移等等。更改可以由同行开发人员进行评审，也可以由社区评审（需要达成共识），或者由维护者或他们的副手进行评审。
- en: Before beginning the code review process, you should read through the description
    of the proposed changes to discover why the change was proposed and decide whether
    you are the correct person to perform the review (that is one of the reasons why
    good commit messages are so important). You need to understand the problem that
    the change tries to solve. You should familiarize yourself with the context of
    the issue, and with the code in the area of changes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始代码审查过程之前，你应该阅读拟议更改的描述，以了解为什么提出这个更改，并决定你是否是执行审查的合适人选（这也是为什么好的提交信息如此重要的原因之一）。你需要理解该更改尝试解决的问题。你应该熟悉问题的背景，并了解更改涉及的代码部分。
- en: 'The first step is to reproduce the state before the change and check whether
    the program works as described (for example, that the bug in a bugfix can be reproduced).
    Then, you need to check out the topic branch with the proposed changes and verify
    that the result works correctly. If it works, review the proposed changes, creating
    a comprehensive list of everything wrong (though if there are errors early in
    the process, it might be unnecessary to go deeper), as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是重现更改前的状态，检查程序是否按描述工作（例如，检查一个bug修复是否能够重现该bug）。然后，你需要检查包含拟议更改的主题分支，并验证结果是否正确。如果有效，审查这些更改，列出所有错误的地方（尽管如果在流程早期就发现错误，可能无需深入下去），如下所示：
- en: Are the commit messages descriptive enough? Is the code easily understood?
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交信息是否足够描述性？代码是否易于理解？
- en: Is the contribution architected correctly? is it architecturally sound?
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贡献的架构是否正确？它在架构上是否稳健？
- en: Does the code comply with the project’s coding standards and with the agreed-upon
    coding conventions?
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是否符合项目的编码标准和约定的编码规范？
- en: Are the changes limited to the scope described in the commit message?
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改是否仅限于提交信息中描述的范围？
- en: Does the code follow the industry’s best practices? Is it safe and efficient?
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是否遵循行业最佳实践？它是否安全且高效？
- en: Is there any redundant or duplicate code? Is the code as modular as possible?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有冗余或重复的代码？代码是否尽可能模块化？
- en: Does the code introduce any regressions in the test suite? If it is a new feature,
    does the change include the tests for the new feature, both positive and negative?
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是否在测试套件中引入了任何回归？如果是新功能，变更是否包括该新功能的测试，包括正向和负向测试？
- en: Is the new code performing the way it did before the change (within the project’s
    tolerances)?
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新代码的表现是否和变更前一样（在项目的容忍范围内）？
- en: Are all the words spelled correctly, and does the new version follow the formatting
    guidelines for the content?
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有单词拼写是否正确，新版本是否遵循内容的格式化指南？
- en: This is only one possible proposal for such a code review checklist. Depending
    on the specifics of the project, there might be more questions that need to be
    asked as a part of the review; make the team write their own checklist. You can
    find good examples online.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个可能的代码审查检查清单提案。根据项目的具体情况，可能还会有其他需要在审查中提出的问题；让团队编写自己的检查清单。你可以在网上找到很好的例子。
- en: 'Divide the problems that you have found during reviews into the following categories:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将在审查过程中发现的问题分为以下几类：
- en: '**Wrong problem**: This feature does not lie within the scope of the project.
    It is sometimes used for a bug that cannot be reproduced. Is the idea behind the
    contribution sound? If so, eject the changes with or without prejudice and do
    not continue the analysis for the review.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误问题**：该功能不在项目范围内。有时用于无法复现的 bug。贡献背后的想法是否合理？如果合理，则可以带有或不带有偏见地弹出变更，并且不再继续分析审查。'
- en: '**Does not work**: This does not compile, introduces a regression, doesn’t
    pass the test suite, doesn’t fix the bug, and so on. These problems absolutely
    must be fixed.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无法正常工作**：这无法编译，导致回归，未通过测试套件，未修复 bug 等。这些问题必须彻底修复。'
- en: '**Fails best practices**: This does not follow the industry guidelines or the
    project’s coding conventions. Is the contribution polished? These are pretty important
    to fix, but there might be some nuances as to why it is written the way it is.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不符合最佳实践**：这不符合行业指导原则或项目的编码规范。贡献是否经过打磨？这些问题是相当重要的，但可能存在一些写法上的细微差别。'
- en: '**Does not match** **reviewer preferences**. In this case, you should suggest
    modifications, or alternatively ask for clarification.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不符合** **审查者偏好**。在这种情况下，你应该建议修改，或者请求进一步澄清。'
- en: Minor problems, for example, typos or spelling errors, can be fixed immediately
    by the reviewer. If the exact problem repeats itself, however, consider asking
    the original author for a fix and resubmission; this is done to spread knowledge.
    You should not be making any substantive edits in the review process (barring
    extenuating circumstances).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 小问题，例如拼写错误或打字错误，可以由审查者立即修复。然而，如果相同的问题重复出现，考虑请求原作者进行修复并重新提交；这样做是为了传播知识。在审查过程中，你不应该做任何实质性的编辑（除非有特殊情况）。
- en: Ask, don’t tell. Explain your reasoning about why the code should be changed.
    Offer ways to improve the code. Distinguish between facts and opinions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 提问，而不是直接告诉。解释为什么代码需要修改。提供改进代码的建议。区分事实和意见。
- en: Responding to reviews and comments
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回应审查和评论
- en: Changes are not always accepted on the first try. You can and will get suggestions
    for improvement (and other comments) from the maintainer, the code reviewer, and
    other developers. You might even get these comments in the patch form or a fixup
    commit form.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 变更并不总是会在第一次尝试时被接受。你可以并且会收到来自维护者、代码审查员和其他开发人员的改进建议（以及其他评论）。你甚至可能会收到补丁形式或修复提交形式的评论。
- en: First, consider leading your response with an expression of appreciation for
    the commenter having taken the time to perform a review. If anything in the review
    is unclear, do ask for clarification; if there is a lack of understanding between
    you and the reviewer, offer clarification.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，可以考虑在回应中表达对评论者花时间进行审查的感激。如果审查中的任何内容不清楚，可以请求澄清；如果你和审查者之间存在理解上的差距，提供澄清。
- en: The next step is often to polish and refine the changes. Then, you should resubmit
    them (perhaps, marking them as **v2**). You should respond to the review for each
    commit and for the whole series.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步通常是打磨和完善变更。然后，你应该重新提交它们（也许标记为**v2**）。你应该针对每次提交和整个系列的审查作出回应。
- en: If you are responding to comments in a pull request, reply in the same way.
    In the case of patch submissions via email, you can put the comments for a new
    version (with a response to the review or a description of the difference from
    the previous attempt), either between three dashes `diffstat`, or at the top of
    an email separated from what is to be in the commit message by a “scissors” line,
    for example, `git` `format-patch --notes`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在回应 pull request 中的评论，按照相同的方式回复。如果是通过电子邮件提交补丁，你可以将新版本的评论（包括对审查的回应或与上次尝试的不同之处）放在三条破折号
    `diffstat` 中间，或者放在电子邮件顶部，用“剪刀”线将其与提交信息分开，例如，使用 `git` `format-patch --notes`。
- en: Depending on the project’s governance structure, you will likely have to wait
    for the changes to be considered good and ready for inclusion. This can be the
    decision of a benevolent dictator for life in open source projects, or the decision
    of the team leader, a committee, or a consensus. It is considered a good practice
    to summarize the discussion while submitting a final version of a feature.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目的治理结构，你可能需要等待更改被认为是合适的并准备好合并。这可能是开源项目中由终身仁慈的独裁者做出的决定，或者是团队领导、委员会或共识的决定。在提交功能的最终版本时，总结讨论结果被视为一种良好的做法。
- en: Note that changes that have been accepted might nevertheless go through a few
    more stages before finally graduating to the stable branch and being present in
    the project.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，已经接受的更改仍可能会经过几个阶段，才最终进入稳定分支并出现在项目中。
- en: Other recommendations
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他建议
- en: In this section, you will find the best practices and recommendations that do
    not fit cleanly into one of the areas described so far, namely starting a project,
    working on a project, and integrating changes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将找到那些不完全符合前面描述的项目启动、项目工作和集成更改领域的最佳实践和建议。
- en: Don’t panic, recovery is almost always possible
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要慌张，恢复几乎总是可能的。
- en: As long as you have committed your work and stored your changes in the repository,
    it will not be lost. It could only perhaps be misplaced. Git also tries to preserve
    your current uncommitted (unsaved) work, but it cannot distinguish for example
    between the accidental and the conscious removal of all the changes to the working
    directory with `git reset --hard`. Therefore, make sure to commit or stash your
    current work before trying to recover lost commits.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你已经提交了工作并将更改存储在版本库中，它们就不会丢失。它们可能会被误放置。Git 也会尽力保存你当前未提交（未保存）的工作，但它无法区分例如通过
    `git reset --hard` 意外或故意删除所有工作目录中的更改。因此，在尝试恢复丢失的提交之前，确保先提交或暂存当前的工作。
- en: Thanks to the reflog (both for the specific branch and for the `HEAD` ref),
    it is easy to undo most operations. Then, there is the list of stashed changes
    (see [*Chapter 3*](B21194_03_split_000.xhtml#_idTextAnchor049), *Managing Your*
    *Worktrees*), where your changes might be hiding. And there is `git fsck` as the
    last resort. See [*Chapter 14*](B21194_14.xhtml#_idTextAnchor349), *Git Administration*,
    for some further information about data recovery.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 reflog（无论是特定分支还是 `HEAD` 引用），大多数操作都很容易撤销。然后是暂存更改的列表（见 [*第3章*](B21194_03_split_000.xhtml#_idTextAnchor049)，*管理你的工作树*），你的更改可能隐藏在其中。还有
    `git fsck`，作为最后的手段。有关数据恢复的更多信息，请参见 [*第14章*](B21194_14.xhtml#_idTextAnchor349)，*Git
    管理*。
- en: If the problem is that you have made a mess of the working directory, stop and
    think. Do not drop your changes needlessly. With the help of interactive add,
    interactive reset (the `--patch` option), and interactive checkout (the same),
    you can usually disentangle the mess.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题是你弄乱了工作目录，停下来思考一下。不要无谓地丢弃你的更改。在交互式添加、交互式重置（`--patch` 选项）和交互式检出（相同的方式）帮助下，你通常可以解开这个困局。
- en: Running `git status` and carefully reading its output helps in many cases where
    you are stuck after doing some lesser-known `git` operation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `git status` 并仔细阅读其输出，有助于你在执行某些鲜为人知的 `git` 操作后卡住时找到解决方法。
- en: If you have a problem with a rebase or merge, and you cannot pass the responsibility
    to another developer, there is always the third-party `git-imerge` tool.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到了 rebase 或 merge 问题，且无法将责任推给其他开发者，总有第三方 `git-imerge` 工具可以帮助你。
- en: Don’t change the published history
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要更改已发布的历史
- en: 'Once you have made your changes public, you should ideally consider those revisions
    to be etched in stone, immutable, and unchanging. If you find problems with commits,
    create a fix (perhaps by undoing the effect of the changes with `git revert`).
    This is all described in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping History Clean*: that is, unless it is stated explicitly in the development
    documentation that these specific branches can be rewritten or redone; but it
    is nevertheless better to avoid creating such branches.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将修改公开，理想情况下应认为这些修订是不可更改、不可改变的。如果你发现提交存在问题，应创建修复（可能通过使用`git revert`撤销修改的效果）。这一切都在[*第10章*](B21194_10_split_000.xhtml#_idTextAnchor247)，*保持历史清洁*中描述：也就是说，除非在开发文档中明确说明这些特定的分支可以被重写或重做，否则最好避免创建此类分支。
- en: 'In some rare cases, you might really need to change the history: remove a file,
    clean up an unencrypted stored password, remove accidentally added large files,
    and so on. If you need to do it, notify all the developers of the fact.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些少见的情况下，你可能确实需要更改历史记录：例如删除文件、清理未加密的存储密码、删除意外添加的大文件等。如果你需要这么做，请通知所有开发人员这一事实。
- en: Numbering and tagging releases
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布版本的编号和标签
- en: Before you release a new version of your project, mark the version to be released
    with a signed tag. This ensures the integrity of the just-created revision.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布新版本之前，请使用签名标签标记将要发布的版本。这可以确保刚创建的修订版的完整性。
- en: There are various conventions for naming the release tags and using release
    numbering. One of the more common ones is tagging releases by using, for example,
    `1.0.2` or `v1.0.2` as a tag name.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 命名发布标签和使用发布编号有各种约定。常见的一种约定是通过使用例如`1.0.2`或`v1.0.2`作为标签名称来标记发布版本。
- en: Tip
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If the integrity of the project is important, consider using signed merges for
    integration (that is, merging signed tags). See [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140),
    *Collaborative Development with Git*, and for signed pushes, see [*Chapter 14*](B21194_14.xhtml#_idTextAnchor349),*Git
    Administration*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目的完整性很重要，考虑使用签名合并进行集成（即合并已签名的标签）。详见[*第6章*](B21194_06.xhtml#_idTextAnchor140)，*使用
    Git 进行协作开发*，签名推送的内容请见[*第14章*](B21194_14.xhtml#_idTextAnchor349)，*Git 管理*。
- en: There are different conventions for naming releases. For example, with time-based
    releases, there is the convention of naming releases after dates, such as `2015.04`
    (or `15.04`). Then, there is the common convention of `MAJOR.MINOR.PATCH` numbering,
    where `PATCH` increases when you are making backward-compatible bug fixes, `MINOR`
    is increased when adding functionality that is backward compatible, and the `MAJOR`
    version is increased when making incompatible API changes. Even when not using
    full semantic versioning, it is common to add a third number for maintenance releases,
    for example, `v1.0` and `v1.0.3`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 命名发布版本有不同的约定。例如，时间驱动的发布版本通常使用日期命名，如`2015.04`（或`15.04`）。然后，有一种常见的`MAJOR.MINOR.PATCH`编号约定，其中`PATCH`在进行向后兼容的错误修复时增加，`MINOR`在添加向后兼容的功能时增加，而`MAJOR`版本在进行不兼容的
    API 更改时增加。即使不使用完整的语义版本控制，通常也会为维护版本添加第三个数字，例如`v1.0`和`v1.0.3`。
- en: Automate where possible
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尽可能实现自动化
- en: You should not only have the coding standards written down in the development
    documentation; you also need to enforce them. Following these standards can be
    facilitated with client-side hooks ([*Chapter 13*](B21194_13_split_000.xhtml#_idTextAnchor320),
    *Customizing and Extending Git*) and enforced with server-side hooks ([*Chapter
    14*](B21194_14.xhtml#_idTextAnchor349),*Git Administration*).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅应该在开发文档中写下编码标准，还需要强制执行这些标准。通过客户端钩子（[*第13章*](B21194_13_split_000.xhtml#_idTextAnchor320)，*定制和扩展
    Git*）可以方便地遵循这些标准，而通过服务器端钩子（[*第14章*](B21194_14.xhtml#_idTextAnchor349)，*Git 管理*）可以强制执行。
- en: Hooks can also help by automatically managing tickets in the issue tracker and
    selecting an operation based on given triggers (patterns) in the commit message.
    Hooks can also be used to protect against rewriting the history.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子还可以通过自动管理问题跟踪器中的工单，并根据提交消息中的触发模式（模式）选择操作。钩子还可用于防止重写历史记录。
- en: Consider using third-party solutions, such as Gitolite or GitLab, to enforce
    rules for access control. If you need to do a code review, use appropriate tools
    such as Gerrit or the pull requests of GitHub, Bitbucket, or GitLab.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用第三方解决方案，如Gitolite或GitLab，来强制执行访问控制规则。如果你需要进行代码审查，使用适当的工具，如Gerrit或GitHub、Bitbucket或GitLab的拉取请求。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: These recommendations, based on the best practices of using Git as a version
    control system, can really help your development and your team. You have learned
    the steps along the road, starting from an idea, going all the way, and ending
    with the changes being integrated into the project. These checklists should help
    you develop better code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些建议基于使用 Git 作为版本控制系统的最佳实践，能够真正帮助你的开发工作和团队。你已经学会了沿着这条道路的步骤，从一个想法开始，一直到最后的更改被集成到项目中。这些清单应该帮助你开发更好的代码。
- en: Further reading
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多本章所涵盖的主题，请查看以下资源：
- en: 'Emma Jane Hogbin Westby: *Git for Teams* (2015), O’Reilly Media'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Emma Jane Hogbin Westby: *Git for Teams* (2015)，O''Reilly Media'
- en: '*Learn Git* *Branching* [https://learngitbranching.js.org/](https://learngitbranching.js.org/)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习 Git* *分支管理* [https://learngitbranching.js.org/](https://learngitbranching.js.org/)'
- en: '*Conventional Commits: A specification for adding human and machine-readable
    meaning to commit* *messages* [https://www.conventionalcommits.org/](https://www.conventionalcommits.org/)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Conventional Commits：为提交* *信息* 添加人类和机器可读意义的规范 [https://www.conventionalcommits.org/](https://www.conventionalcommits.org/)'
- en: '*Commitizen - a release management tool designed for* *teams* [https://commitizen-tools.github.io/commitizen/](https://commitizen-tools.github.io/commitizen/)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Commitizen - 旨在为* *团队* 设计的发布管理工具 [https://commitizen-tools.github.io/commitizen/](https://commitizen-tools.github.io/commitizen/)'
- en: 'Sage Sharp: *The Gentle Art Of Patch Review* (2014) [https://sage.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/](https://sage.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Sage Sharp: *补丁审查的温和艺术* (2014) [https://sage.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/](https://sage.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/)'
- en: '*Dangit,* *Git!?!* [https://dangitgit.com/en](https://dangitgit.com/en)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*该死的，* *Git!?!* [https://dangitgit.com/en](https://dangitgit.com/en)'
- en: 'Julia Evans: *Oh shit, git!* Zine [https://wizardzines.com/zines/oh-shit-git/](https://wizardzines.com/zines/oh-shit-git/)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Julia Evans: *天哪，git!* 小册子 [https://wizardzines.com/zines/oh-shit-git/](https://wizardzines.com/zines/oh-shit-git/)'
- en: '*Semantic Versioning* *2.0.0* [https://semver.org/](https://semver.org/)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*语义化版本控制* *2.0.0* [https://semver.org/](https://semver.org/)'
