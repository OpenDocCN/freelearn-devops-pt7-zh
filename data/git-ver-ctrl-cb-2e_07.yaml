- en: Enhancing Your Daily Work with Git Hooks, Aliases, and Scripts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Git 钩子、别名和脚本增强你的日常工作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Using a branch description in a commit message
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提交信息中使用分支描述
- en: Creating a dynamic commit message template
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态提交信息模板
- en: Using external information in a commit message
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提交信息中使用外部信息
- en: Preventing the push of specific commits
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止推送特定的提交
- en: Configuring and using Git aliases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和使用 Git 别名
- en: Configuring and using Git scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和使用 Git 脚本
- en: Setting up and using a commit template
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和使用提交模板
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In order to work efficiently in a corporate environment, there are certain prerequisites,
    or rules, regarding any code that is produced. It should be able to compile and
    pass specific sets of unit tests. There should also be certain documentation in
    the commit messages, such as references to a bug fix ID or an instance. Most of
    these rules can be automated using scripts. But why not put these rules into the
    process? In this chapter, you will see some examples of how to transfer data from
    one location to a commit message before you see the message. You will also learn
    how you can verify whether you are pushing your code to the right location. Finally,
    you will see how you can add scripts to Git.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在企业环境中高效工作，关于生产的任何代码都有一些前提条件或规则。代码应该能够编译并通过特定的单元测试集。此外，提交信息中还应该包含某些文档内容，例如修复
    ID 或实例的引用。这些规则中的大多数可以通过脚本进行自动化。但为什么不把这些规则纳入到流程中呢？在本章中，你将看到一些示例，展示如何在看到提交信息之前将数据从一个位置传输到提交信息中。你还将学习如何验证你是否将代码推送到正确的位置。最后，你将学习如何将脚本添加到
    Git 中。
- en: A hook in Git is a script that will be triggered on events, such as pushing,
    committing, or rebasing. If these scripts exit with a non-zero value, it is probably
    best to cancel the current Git operation. You can find these hook scripts in the
    `.git/hooks` folder in any Git clone. If they have the `.sample` file extension,
    they are not active.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Git 中的钩子是一个在特定事件（如推送、提交或变基）触发时执行的脚本。如果这些脚本以非零值退出，最好取消当前的 Git 操作。你可以在任何 Git 克隆的
    `.git/hooks` 文件夹中找到这些钩子脚本。如果它们的文件扩展名是 `.sample`，则表示这些钩子是非激活状态。
- en: Using a branch description in a commit message
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在提交信息中使用分支描述
- en: In [Chapter 3](05533902-404c-4c14-9755-7137337e8190.xhtml), *Branching, Merging,
    and Options*, we mentioned that you can set a description on your branch, and
    this information can be retrieved from a script using the `git config --get branch.<branchname>
    description` command. In this example, we will take this information and use it
    for the commit message.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](05533902-404c-4c14-9755-7137337e8190.xhtml)《*分支、合并与选项*》中，我们提到过你可以为你的分支设置描述，并且可以通过
    `git config --get branch.<branchname> description` 命令从脚本中获取此信息。在这个例子中，我们将提取这些信息并将其用于提交信息。
- en: We will be using the `prepare-commit-msg` hook. The `prepare-commit-msg` hook
    is executed every time you want to commit, and the hook can be set to anything
    you wish to check, before you actually see the commit message editor.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `prepare-commit-msg` 钩子。`prepare-commit-msg` 钩子会在每次你想要提交时执行，钩子可以设置为在你实际看到提交信息编辑器之前检查任何你想要检查的内容。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need a clone and a branch to get started on this exercise, hence we will
    clone `jgit` again to the `chapter7.5` folder, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个克隆和一个分支来开始这个练习，因此我们将再次将 `jgit` 克隆到 `chapter7.5` 文件夹中，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Check out a local `descriptioInCommit` branch that tracks the `origin/stable-3.2`
    branch:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 检出一个本地的 `descriptioInCommit` 分支，该分支跟踪 `origin/stable-3.2` 分支：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will start by setting the description of our local branch. Then, we will
    create the hook that can extract this information and put it in the commit message.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从设置本地分支的描述开始。然后，我们将创建一个钩子来提取此信息并将其放入提交信息中。
- en: 'We have our local `descriptioInCommit` branch, for which we need to set a description.
    We will use the `--edit-description` Git branch to add a description to our local
    branch. This opens the description editor, and you can type in a message by performing
    the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有本地的 `descriptioInCommit` 分支，我们需要为其设置描述。我们将使用 `--edit-description` Git 分支命令为本地分支添加描述。这样会打开描述编辑器，你可以通过以下步骤输入消息：
- en: 'When you execute the command, the description editor will open and you can
    type in a message:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你执行命令时，描述编辑器将打开，你可以输入消息：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, type in the following message:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入以下消息：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should write your branch description just as you write your commit messages. It
    make sense then to reuse the description in the commit. Now, we will verify whether
    we have a message with the following description:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该像编写提交信息一样编写你的分支描述。然后，将描述重复使用在提交信息中是有意义的。现在，我们将验证是否有以下描述的信息：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As expected, we have the desired output. Now, we can continue creating the hook
    that will take the description and use it.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如预期的那样，我们得到了所需的输出。现在，我们可以继续创建将获取描述并使用它的钩子。
- en: Next, we will check whether we have a description for the hook and, if we do,
    we will use that description as the commit message.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查是否有钩子的描述，如果有，我们将使用该描述作为提交信息。
- en: 'First, we will ensure that we can get the information into the commit message
    at our desired position. There are many ways to do this and we have settled on
    the following method: open the `.git/hook/prepare-commit-msg` hook file, type
    in the following script, and make it executable (`chmod +x`):'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将确保能够在期望的位置获取提交信息。实现这一点有多种方法，我们选择了以下方法：打开`.git/hook/prepare-commit-msg`钩子文件，输入以下脚本，并使其可执行（`chmod
    +x`）：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can try to create a commit and see whether the message is being displayed
    as predicted. Use `git commit --allow-empty` to generate an empty commit, but
    also to trigger the prepare-commit-msg hook:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试创建一个提交，看看提交信息是否按预期显示。使用`git commit --allow-empty`生成一个空提交，同时触发prepare-commit-msg钩子：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should get the message editor with our branch description as the commit
    message, as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会看到一个带有我们分支描述作为提交信息的编辑器，如下所示：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is as we expected. Save the commit message and close the editor. Try using
    the `git log -1` command to verify whether we have the following message in our
    commit:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这正如我们所预期的那样。保存提交信息并关闭编辑器。尝试使用`git log -1`命令来验证我们是否在提交中有以下信息：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should get something similar to a commit message that is the same as our
    branch description. However, what about an empty branch description? How will
    our hook handle that? We can try again with a new branch named `noDescriptionBranch`.
    Use `git checkout` to create it, and check it as shown in the following command:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会得到类似的提交信息，内容与我们的分支描述相同。不过，如果分支描述为空呢？我们的钩子会如何处理？我们可以尝试创建一个名为`noDescriptionBranch`的新分支。使用`git
    checkout`创建它，并按以下命令检查：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we will make yet another empty commit to see whether the commit message
    is as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将再创建一个空提交，以查看提交信息是否如下所示：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should get the commit message editor with the default commit message text,
    as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会看到带有默认提交信息文本的提交信息编辑器，如下所示：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is all as we expected. This script can be combined with the next exercise,
    which will take content from a defective system as well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都如我们预期的那样。这个脚本可以与下一个练习结合使用，后者将从一个有缺陷的系统中提取内容。
- en: Creating a dynamic commit message template
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动态提交信息模板
- en: Developers can be encouraged to do the right thing, or developers can be forced
    to do the right thing. However, in the end, developers need to spend time coding.
    So, if a good commit message is required, we can use the `prepare-commit-msg`
    hook to assist the developer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可以鼓励开发人员做正确的事，或者可以强迫开发人员做正确的事。然而，最终，开发人员需要花时间进行编码。因此，如果需要良好的提交信息，我们可以使用`prepare-commit-msg`钩子来协助开发人员。
- en: In this example, we will create a commit message for developers that contains
    information about the state of the work area. It will also insert some information
    from a web page. This could just as well be defect information from Bugzilla.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将为开发人员创建一个包含工作区状态信息的提交信息。它还会插入一些来自网页的信息。这些信息也可以是Bugzilla中的缺陷信息。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To start this exercise, we will not be cloning a repository, but creating one. To
    do this, we will be using `git init`, as shown in the following code. You can
    use `git init <directory>` to create a new repository somewhere, or you can go
    to a directory and execute `git init` and Git will create a repository for you.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这个练习，我们不会克隆一个仓库，而是创建一个新的仓库。为此，我们将使用`git init`，如以下代码所示。你可以使用`git init <directory>`在某个地方创建一个新仓库，或者你可以进入一个目录并执行`git
    init`，Git会为你创建一个仓库。
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We have our `chapter7` directory, where we just initialized our repository.
    In this directory, the hooks are already available. Just look in the `.git/hooks`
    directory. We will be using the `prepare-commit-msg` hook. Perform the following
    steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的`chapter7`目录，在这里我们刚刚初始化了我们的仓库。在此目录中，钩子已经可用。只需查看`.git/hooks`目录即可。我们将使用`prepare-commit-msg`钩子。执行以下步骤：
- en: 'Start by looking in the folder with the following hooks:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下钩子文件夹开始查找：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, there are plenty of hooks in each of the hook files. There
    is an example script, and a short explanation of what the hook does and when it
    is executed. To enable `prepare-commit-msg`, rename the file as shown in the following
    code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，每个钩子文件中都有很多钩子。这里有一个示例脚本，并简要说明了钩子做什么以及何时执行。要启用`prepare-commit-msg`，请按以下代码所示重命名文件：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Open the `prepare-commit-msg` file in your preferred editor.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的编辑器中打开`prepare-commit-msg`文件。
- en: You can read the information in the file, but for our examples, we will clear
    the file so that we can include the script.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以查看文件中的信息，但对于我们的示例，我们将清空文件，以便可以包括脚本。
- en: 'Now, include the following command in the file:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在文件中包含以下命令：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save the file.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: 'Finally, try to commit either something or nothing. Usually, you cannot make
    a commit that is empty, but with the `--allow-empty` option, you can create an
    empty commit as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，尝试提交某些内容或不提交内容。通常，您不能提交空的内容，但使用`--allow-empty`选项，您可以创建一个空的提交，如下所示：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, we get the message we put in the `prepare-commit-msg` script
    file. You can check whether or not we have a commit by using `git log -1` as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所见，我们得到了在`prepare-commit-msg`脚本文件中输入的消息。您可以使用`git log -1`命令检查我们是否有提交，方法如下：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is no commit, and we get an error message that we have not seen before.
    The message has to be there because there is no commit so far in this repository.
    Before we make further changes to the script, we should know that the `prepare-commit-msg`
    hook takes some arguments, depending on the situation. The first argument is always
    `.git/COMMIT_EDITMSG`, and the second argument can be merge, commit, squash, or
    template, depending on the situation. We can use these in the script.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 没有提交，我们收到了一个我们以前没有见过的错误消息。消息必须存在，因为到目前为止在这个仓库中还没有提交。在我们进一步更改脚本之前，我们应该知道`prepare-commit-msg`钩子会根据情况接收一些参数。第一个参数始终是`.git/COMMIT_EDITMSG`，第二个参数可以是merge、commit、squash或template，具体取决于情况。我们可以在脚本中使用这些参数。
- en: 'Change the script so that we can reject amending commits as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改脚本，以便我们可以拒绝修改提交，如下所示：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have changed the script, let''s create a commit and try to amend
    it as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经更改了脚本，让我们创建一个提交并尝试修改它，如下所示：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that we have a commit, let''s try to amend it using `git commit --amend`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了提交，让我们尝试使用`git commit --amend`来修改它：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we expected, we were not allowed to amend the commit. If we wish to extract
    some information, for instance, from a bug handling system, we will have to put
    this information into the file before opening the editor. So, again, we will change
    the script as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们所预期的那样，我们没有被允许修改提交。如果我们希望提取一些信息，例如从错误处理系统中提取，我们必须在打开编辑器之前将这些信息放入文件中。所以，我们将再次更改脚本，如下所示：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This script downloads a commit message from `http://www.whatthecommit.com/`
    and inserts it into the commit message. Every time you commit, you will get a
    new message from the web page. Let''s give it a try by using the following command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本从`http://www.whatthecommit.com/`下载一个提交消息并将其插入到提交信息中。每次提交时，您都会从网页上获取一条新的消息。让我们使用以下命令试一下：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the commit message editor opens, you should see a message from `whatthecommit.com`.
    Close the editor and, using `git log -1`, verify whether we have the commit, as
    follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提交信息编辑器打开时，您应该看到来自`whatthecommit.com`的消息。关闭编辑器后，使用`git log -1`命令验证我们是否已经有了提交，方法如下：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As expected, we have succeeded with the commit. Obviously, this is not the
    best message to have for the committer. A more typical usage is to list the bugs
    assigned to the developer, as follows, in the commit message:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们已经成功完成了提交。显然，这不是为提交者准备的最佳消息。更典型的做法是在提交信息中列出分配给开发者的错误，如下所示：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This way, the developer can easily select the correct bug ID, or the artefact
    ID, from TeamForge in this case, using the correct format for the other systems
    that will look into the commit messages.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，开发者可以轻松地从TeamForge中选择正确的错误ID，或者在这种情况下，使用其他系统查看提交信息时所需的正确格式的工件ID。
- en: There's more...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: You can extend the functionality of the `prepare-commit-msg` hook easily, but
    you should bear in mind that the waiting time for fetching some information should
    be worth the benefits. One thing that is usually easy to check is a dirty work
    area.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松扩展 `prepare-commit-msg` 钩子的功能，但你应该记住，获取一些信息的等待时间应该是值得的。一个通常很容易检查的事情是工作区是否有修改。
- en: 'Here, we need to use the `git status` command in the prepare commit message
    hook, and we need to predict whether we will have modified files after the commit:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要在准备提交信息的钩子中使用 `git status` 命令，并且我们需要预测提交后是否会有修改的文件：
- en: 'To check this, we need to have something staged for committing and some unstaged
    changes, as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查这一点，我们需要有一些已暂存的更改和一些未暂存的更改，如下所示：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, modify the `fishtank.txt` file:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，修改 `fishtank.txt` 文件：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use `git status --porcelain` to check the work area:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `git status --porcelain` 检查工作区：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the file to the staging area using `git add`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `git add` 将文件添加到暂存区：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now try `git status --porcelain`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试 `git status --porcelain`：
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What you should note is the space before `M` the first time we use the `--porcelain`
    option for Git status. The `porcelain` option provides a machine-friendly output
    that shows the state of the files for Git status. The first character is the status
    in the staging area, whereas the second character is the status in the work area.
    So, `MM fishtank.txt` would mean the file is modified in the work area and in
    the staging area. So, if you modify `fishtank.txt` again, the following is the
    result you can expect:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要注意的是，第一次使用 `--porcelain` 选项查看 Git 状态时，`M` 前面有一个空格。`porcelain` 选项提供了机器友好的输出，显示
    Git 状态下文件的状态。第一个字符表示暂存区的状态，而第二个字符表示工作区的状态。因此，`MM fishtank.txt` 表示该文件在工作区和暂存区都有修改。所以，如果你再次修改
    `fishtank.txt`，你可以预期如下结果：
- en: '[PRE31]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As expected, the output from Git status is `MM fishtank.txt`. We can use this
    in the hook to tell whether or not the work area will have uncommitted changes
    after we commit. Add the following command to the `prepare-commit-msg` file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如预期的那样，Git 状态的输出为 `MM fishtank.txt`。我们可以在钩子中使用这个输出，来判断提交后工作区是否会有未提交的更改。将以下命令添加到
    `prepare-commit-msg` 文件中：
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'First, we list all the files that have changed with `git status --porcelain`.
    Then, for each of these files, we check whether there is a second character. If
    this is true, we will have a dirty work area after the commit. In the end, we
    just insert the message into the commit message so that it is available for the
    developer to see. Let''s try and commit the change by using the following command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用 `git status --porcelain` 列出所有已更改的文件。然后，对于每个文件，我们检查是否有第二个字符。如果有第二个字符，那么提交后工作区就会有修改。最后，我们将信息插入到提交信息中，以便开发人员查看。让我们尝试并通过以下命令提交更改：
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Check that you have a message similar to the following. The first line might
    be different, as we still have the message from `http://www.whatthecommit.com/`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有类似以下内容的消息。第一行可能会有所不同，因为我们仍然有来自 `http://www.whatthecommit.com/` 的消息：
- en: '[PRE34]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Saving the file and closing the editor will create the commit. Verify this
    with `git log -1`, as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并关闭编辑器将创建提交。使用 `git log -1` 验证此操作，如下所示：
- en: '[PRE35]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have the information we expected. The text about the dirty work area is
    in the commit message . To clean up nicely before the next exercise, we should
    reset our work area to `HEAD`, as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们得到了预期的信息。有关脏工作区的文本已出现在提交信息中。为了在下一次练习前做一个干净的清理，我们应该将工作区重置为 `HEAD`，如下所示：
- en: '[PRE36]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, it is just a matter of finding out what suits you. Is there any information
    you would like to check before you commit and potentially push the code to a remote
    branch? This may include:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需找出什么最适合你。在提交并可能推送代码到远程分支之前，你是否希望检查任何信息？这可能包括：
- en: Style checks in code
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中的样式检查
- en: Using Pylint to check your Python scripts
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pylint 检查你的 Python 脚本
- en: Checking for files that you are not allowed to add to Git
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否有不允许添加到 Git 的文件
- en: This list is not exhaustive; there is probably something to add for every organization
    or development team in the world. However, this clearly is one way of taking tedious
    manual work away from the developer so that he or she can focus on coding.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表并不详尽；对于世界上每个组织或开发团队，可能还有其他需要添加的内容。然而，这显然是一种方法，可以减少开发者繁琐的手动工作，让他们能够专注于编码。
- en: Using external information in a commit message
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在提交信息中使用外部信息
- en: The commit hook is executed when you close the commit message editor. It can,
    among other things, be used to manipulate the commit message or do an automatic review
    of the commit message to check whether it has a specific format.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 提交钩子在你关闭提交信息编辑器时执行。它可以用于操作提交信息或自动审核提交信息，以检查其是否具有特定的格式。
- en: In this recipe, we will be manipulating and checking the content of a commit
    message.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将操作并检查提交信息的内容。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To start this exercise, we just need to create a branch and check it out. We
    need to disable the current `prepare-commit-msg` hook; we can do this by simply
    renaming it. Now, we can start working on the `commit-msg` hook by using the following
    command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这个练习，我们只需要创建一个分支并切换到它。我们需要禁用当前的`prepare-commit-msg`钩子；可以通过简单地重命名它来实现。现在，我们可以通过以下命令开始处理`commit-msg`钩子：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'What we want to do in the first example is to check whether or not the defect
    information is correct. There is no need to release a commit that refers to a
    defect that does not exist:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们要做的是检查缺陷信息是否正确。无需发布引用不存在的缺陷的提交：
- en: 'We will start by testing the `commit-msg` hook. First, make a copy of the current
    hook, then we will force the hook to exit with a non-zero value that will abort
    the creation of the commit:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从测试`commit-msg`钩子开始。首先，复制当前的钩子文件，然后我们将强制使钩子以非零值退出，从而中止提交的创建：
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, open the file in your preferred editor and add the following lines to
    the file:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你喜欢的编辑器中打开文件，并将以下行添加到文件中：
- en: '[PRE39]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we will try to make a commit and see what happens, as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将尝试进行一次提交，看看会发生什么，具体如下：
- en: '[PRE40]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The editor will open, you can write a small commit message, and then close
    the editor. You should see the `you are not allowed to commit` message, and if
    you check with `git log -1`, you will see that you don''t have a commit with the
    message you just wrote, as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑器将打开，你可以写一个简短的提交信息，然后关闭编辑器。你应该会看到`you are not allowed to commit`的消息，如果你使用`git
    log -1`检查，你会发现没有你刚才写的提交信息，具体如下：
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you can see, the commit message hook is executed after you close the message
    editor, whereas the `prepare-commit-msg` hook is executed before the message editor.
    To validate, if we have a proper reference to the hook in our commit message,
    we will be checking whether a specific error is available for the Jenkins-CI project.
    Replace the lines in the `commit-msg` hook so that it looks like the following
    command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，提交信息钩子在你关闭消息编辑器后执行，而`prepare-commit-msg`钩子在消息编辑器之前执行。为了验证，如果我们在提交信息中有对钩子的正确引用，我们将检查Jenkins-CI项目是否有特定的错误。将`commit-msg`钩子中的行替换成以下命令：
- en: '[PRE43]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We are using curl to retrieve the web page and, if it is empty, we know that
    the ID does not exist. Now, we should create a commit and see what happens if
    we put in the wrong ID, `jenkins 384895`, or an ID that exists as `jenkins 3157`.
    To check this, we will create a commit as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用curl来检索网页，如果网页为空，我们就知道该ID不存在。现在，我们应该创建一个提交，看看如果我们输入错误的ID（如`jenkins 384895`）或者一个存在的ID（如`jenkins
    3157`）会发生什么。为此，我们将按如下方式创建提交：
- en: '[PRE44]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the commit message, write something such as `Feature cascading...` as a
    commit message subject. Then, in the body of the commit message, insert `jenkins
    384895`. This is the important part, as the hook will use that number to look
    it up on the Jenkins issue tracker:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提交信息中，写入类似`Feature cascading...`的提交信息标题。然后，在提交信息的正文中插入`jenkins 384895`。这是关键部分，因为钩子将使用该号码在Jenkins问题追踪器中查找：
- en: '[PRE45]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should end up with the following output:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE46]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is what we expected. Now, verify whether the change has been committed
    or not with `git status`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们预期的结果。现在，使用`git status`验证更改是否已经提交：
- en: '[PRE47]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we will try to commit again; this time, we will be using the correct JIRA
    ID:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将再次尝试提交；这次，我们将使用正确的JIRA ID：
- en: '[PRE48]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Key in a commit message like the previous one; this time, make sure the Jenkins
    issue ID is one that exists. You can use `51444`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个像之前那样的提交信息；这次，确保Jenkins问题ID是存在的。你可以使用`51444`：
- en: '[PRE49]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Saving the commit message should result in an output as follows. We can clean
    it some more by removing the title HTML tags:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存提交信息后，应该得到如下输出。我们可以通过去除标题HTML标签进一步清理它：
- en: '[PRE50]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see, we can get information to output. We could also add this information
    to the commit message itself. Then, we can change and insert this as the `else`
    clause in the script:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们可以获取信息并输出。我们也可以将这些信息添加到提交信息中。然后，我们可以更改并将其作为`else`分支插入脚本：
- en: '[PRE51]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To test this, we will create a commit again, and, in the message, we need to
    specify the JIRA ID that exists:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们将再次创建一个提交，并且在信息中需要指定存在的JIRA ID：
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To verify whether we got the information in the message, we will use `git log
    -1` again:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证我们是否在信息中得到了所需的内容，我们将再次使用`git log -1`：
- en: '[PRE53]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As expected, we have the information at the end of the commit. In these examples,
    we are just discarding the commit message if the JIRA ID does not exist. This
    is a little harsh to the developer. So, you can combine this with the `prepare-commit-msg`
    hook. If `commit-msg` halts the commit process, then save the message temporarily
    so that the `prepare-commit-msg` hook can use that message when the developer
    tries again.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们在提交的末尾得到了信息。在这些示例中，如果JIRA ID不存在，我们将丢弃提交信息。这对开发者来说有点苛刻。所以，你可以将它与`prepare-commit-msg`钩子结合使用。如果`commit-msg`停止提交过程，那么临时保存该信息，以便在开发者再次尝试时，`prepare-commit-msg`钩子可以使用这个信息。
- en: Preventing the push of specific commits
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止特定提交的推送
- en: The pre-push hooks are triggered whenever you use the push command and the script
    execution happens before the push. So, we can prevent a push if we find a reason
    to reject it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 预推送钩子会在使用推送命令时触发，并且脚本执行发生在推送之前。因此，我们可以在发现拒绝推送的原因时阻止推送。
- en: One reason could be that you have a commit with the `nopush` text in the commit
    message.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个原因可能是你在提交信息中有`nopush`文本。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To use the Git pre-push, we need to have a remote repository. We will be cloning
    `jgit` again, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Git的预推送钩子，我们需要有一个远程仓库。我们将再次克隆`jgit`，如以下所示：
- en: '[PRE54]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We want to be able to push to a remote branch but, unfortunately, Git will
    try to authenticate through HTTPS for the `jgit` repository before the hooks are
    executed. Because of this, we will create a local clone from the `chapter7.1`
    directory, as follows. This will make our remote a local folder:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够推送到远程分支，但不幸的是，Git会在执行钩子之前通过HTTPS尝试对`jgit`仓库进行身份验证。因此，我们将从`chapter7.1`目录创建一个本地克隆，如下所示。这将使我们的远程变为本地文件夹：
- en: '[PRE55]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We are cloning the `chapter7.1` directory in a folder named `chapter7.2`, and
    will check the `master` branch when the clone has finished.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将`chapter7.1`目录克隆到名为`chapter7.2`的文件夹中，克隆完成后将检查`master`分支。
- en: What we now want to do is to create a commit with a commit message that has
    `nopush` as part of it. By adding this word to the commit message, the code in
    the hook will automatically stop the push. We will be doing this on top of a branch.
    So, to start with, you should check out a `prepushHook` branch that tracks the
    `origin/master` branch and then creates a commit.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想做的是创建一个提交，提交信息中包含`nopush`。通过在提交信息中添加这个词，钩子中的代码将自动停止推送。我们将在一个分支上进行此操作。所以，首先，你应该检出一个`prepushHook`分支，该分支跟踪`origin/master`分支，然后创建一个提交。
- en: 'We will try to push it to the remote when we have the pre-push commit in place,
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置好预推送提交时，我们将尝试将其推送到远程，具体如下：
- en: 'Start by creating a new branch named `prepushHook`, which tracks `origin/master`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建一个名为`prepushHook`的新分支开始，该分支跟踪`origin/master`：
- en: '[PRE56]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we use `reset` to go back to an earlier commit. It is not important how
    far back we go. So, we have just selected a random commit as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`reset`回到一个较早的提交。这并不重要我们回到多远。我们只是选择了一个随机的提交，如下所示：
- en: '[PRE57]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now we can create a commit. We will do a simple inline replace with `sed`,
    and then add `pom.xml` and commit it:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个提交。我们将使用`sed`进行简单的内联替换，然后添加`pom.xml`并提交：
- en: '[PRE58]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To verify whether we have the commit with the text, run `git log -1`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证我们是否有包含文本的提交，可以运行`git log -1`：
- en: '[PRE59]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We have what we want in the commit message. Now, we just need to prepare the
    hook. We will start by copying the sample hook to the real name so that it will
    be executed on push:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在提交信息中得到了所需的内容。现在，我们只需要准备钩子。我们将从复制示例钩子开始，重命名为实际名称，以便它会在推送时执行：
- en: '[PRE60]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Edit the hook so that its code is as shown in the following snippet:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑钩子，使其代码如以下代码片段所示：
- en: '[PRE61]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we are ready to push. We will be pushing our current branch `HEAD` to the
    `master` branch in the remote:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备推送了。我们将把当前分支`HEAD`推送到远程的`master`分支：
- en: '[PRE62]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As expected, the hook is being executed, and the push is being denied by the
    hook. Now, we can implement the check we want to carry out. If we have the word
    `nopush` in any commit message, we want to exit. We can use `git log --grep` to
    search for commits with the keyword `nopush` in the commit message, as shown in
    the following command:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如预期的那样，钩子正在执行，推送被钩子拒绝。现在，我们可以实现我们想要进行的检查。如果我们在任何提交信息中有`nopush`这个词，我们希望退出。我们可以使用`git
    log --grep`来搜索提交信息中包含`nopush`关键词的提交，如下所示的命令：
- en: '[PRE63]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We have our newly created commit with the keyword `nopush`. Now, we will perform
    a simple check for this in the hook and edit the pre-push hook so that it has
    the following text:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经创建了带有`nopush`关键词的新提交。现在，我们将在钩子中执行一个简单的检查，并编辑pre-push钩子，使其包含以下内容：
- en: '[PRE64]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now we can try to push again to see what the result will be. We will try to
    push our `HEAD` to the master branch on the remote `origin`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以再次尝试推送，看看结果会是什么。我们将尝试将我们的`HEAD`推送到远程`origin`的主分支：
- en: '[PRE65]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As expected, we are not allowed to push as we have the `nopush` message in the
    commit.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，由于我们在提交中有`nopush`信息，系统不允许我们推送。
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Having a hook to prevent you from pushing commits that you don't want to push
    is very handy. You can specify any keywords you want. Words such as `reword`,
    `temp`, `nopush`, `temporary`, or `hack` can all be things you want to stop, but
    sometimes you want to get them through anyway.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个钩子来防止你推送不想推送的提交非常方便。你可以指定任何你想要的关键词。诸如`reword`、`temp`、`nopush`、`temporary`或`hack`等词语都可以是你希望停止的内容，但有时你可能还是想把它们推送出去。
- en: What you can do is have a small checker that checks for specific words, then
    lists the commits, and asks if you want to push anyway.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做的是有一个小检查器，检查特定的词，然后列出提交，并询问你是否仍然想要推送。
- en: 'If you change the script to the following snippet, the hook will try to find
    commits with the keyword `nopush` and list them. If you wish to push them in any
    case, you can answer the question and Git will push anyway:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将脚本更改为以下片段，钩子将尝试找到包含`nopush`关键词的提交并列出它们。如果你希望无论如何推送它们，你可以回答问题，Git将继续推送：
- en: '[PRE66]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Try it with the `git push` command again, as shown in the following snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试使用`git push`命令，如下所示：
- en: '[PRE67]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Type `n` and press *Enter*. Then, expect the push to be aborted with the following
    message:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`n`并按*Enter*。然后，预期推送将被中止，并显示以下信息：
- en: '[PRE68]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As predicted, it will not push. However, if you press y, Git will push to the
    remote. Try this now using the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，它不会推送。但是，如果你按下y，Git将推送到远程。现在使用以下命令尝试一下：
- en: '[PRE69]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As predicted, the push will be tried, but, as you can see from the output, it
    is rejected by the remote. This is because we diverged, and the push was not working
    at the tip of the master branch.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，推送将被尝试，但正如你从输出中看到的，它被远程拒绝了。这是因为我们产生了分歧，推送在主分支的最新提交上不起作用。
- en: So, with this hook, you can make your life a little easier by having the hook
    prevent you from accidentally pushing something you are not interested in being
    pushed. This example also considers commits that have been released; so, if you
    select a different keyword, then other commits—not only the locally created ones—will
    be taken into consideration by the script.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过这个钩子，你可以让生活更轻松些，防止不小心推送你不希望推送的内容。这个示例也考虑了已经发布的提交；因此，如果你选择一个不同的关键词，那么其他提交——不仅仅是本地创建的——也会被脚本考虑进去。
- en: Configuring and using Git aliases
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和使用Git别名
- en: Git aliases, like Unix aliases, are short commands that can be configured on
    a global level or for each repository. It is a simple way of renaming some Git
    commands to use short abbreviations, for example, `git checkout` could be `git
    co`, and so on.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Git别名，像Unix别名一样，是可以在全局或每个仓库中配置的简短命令。它是一种简单的方式来重命名一些Git命令，以使用简短的缩写，例如，`git checkout`可以是`git
    co`，以此类推。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: It's very simple and straightforward to create an alias. You simply need to
    configure it with `git config`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 创建别名非常简单直接。你只需要使用`git config`进行配置。
- en: 'What we will do is check a branch and then create its aliases one by one and
    execute them to view their output by performing the following steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做的是检查一个分支，然后逐一创建它的别名并执行它们，通过执行以下步骤来查看它们的输出：
- en: So, we will start by checking a branch named `gitAlias`, which tracks the
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们将从检查一个名为`gitAlias`的分支开始，该分支跟踪
- en: '`origin/stable-3.2` branch:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`origin/stable-3.2`分支：'
- en: '[PRE70]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'After this, we can start creating some aliases. We will start with the following
    one, which will simply just amend your commit:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以开始创建一些别名。我们将从以下别名开始，它只会简单地修改你的提交：
- en: '[PRE71]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Executing this alias will open the commit message editor with the following
    message from the `HEAD` commit:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行这个别名将会打开提交信息编辑器，里面有来自`HEAD`提交的以下信息：
- en: '[PRE72]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As you can see, it can be very simple to speed up the process of your daily
    workflow with Git aliases. The following command will just work on the last 10
    commits using `--oneline` as an option for `git log`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，使用 Git 别名可以非常简单地加速你日常工作流程的处理。以下命令将只作用于最后10次提交，使用`git log`的`--oneline`选项：
- en: '[PRE73]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Using the alias will give you the following output:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用别名将会得到以下输出：
- en: '[PRE74]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can also perform a simple checkout. Thus, instead of using the Git checkout, you
    can use `git co <branch>.` Configure it as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以执行一个简单的checkout。这样，你可以使用`git co <branch>`来代替 Git 的 checkout。按照如下方式进行配置：
- en: '[PRE75]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You will see that the aliases take arguments, just as the regular Git command
    does. Let''s try the alias using the following command:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到，别名也像普通的 Git 命令一样接受参数。让我们使用以下命令来试试这个别名：
- en: '[PRE76]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The command works as expected. You may wonder why we diverged after checking
    out the `gitAlias` branch again. Then, we diverged when we amended the `HEAD`
    commit. The next alias is creating a commit with everything that has not been
    committed in the work area, except for the untracked files:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令按预期工作。你可能会好奇为什么在再次检出`gitAlias`分支后我们发生了分叉。然后，当我们修改`HEAD`提交时，我们发生了分叉。下一个别名是创建一个包含工作区中所有未提交内容的提交，除了未跟踪的文件：
- en: '[PRE77]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Before we can test the alias, we should create a file and modify it to show
    what it actually does. So, create a file as shown in the following command:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们测试这个别名之前，我们应该创建一个文件并修改它，以展示它的实际作用。你可以按下面的命令创建一个文件：
- en: '[PRE78]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To verify what you want, run `git status`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证你想要的内容，运行`git status`：
- en: '[PRE79]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, we can test the alias using the following command:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令来测试这个别名：
- en: '[PRE80]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To verify whether the `aquarium` file was part of the commit or not, use `git
    status`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证`aquarium`文件是否是提交的一部分，使用`git status`：
- en: '[PRE81]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You can also use `git log -1` to see the commit we just created:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以使用`git log -1`来查看我们刚刚创建的提交：
- en: '[PRE82]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output is just as we expected. The next alias is a little different, as
    it will count the number of commits in the repository, and this can be done with
    the `wc` (`wordcount`) tool. However, since this is not a built-in Git tool, we
    have to use the exclamation mark and also specify Git:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出正如我们所预期的那样。下一个别名稍有不同，因为它将计算仓库中的提交次数，可以使用`wc`（`wordcount`）工具来完成此操作。然而，由于这不是一个内置的
    Git 工具，我们必须使用感叹号并指定 Git：
- en: '[PRE83]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Let''s try it with the following command:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们试试下面的命令：
- en: '[PRE84]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'So, currently, we have `3008` commits in the repository. This also means you
    can execute external tools as if they were Git tools just by creating a Git alias;
    for instance, if you are using Windows, Mac, or Linux, you can create an alias
    as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，仓库中有`3008`个提交。这也意味着你可以像使用 Git 工具一样，通过创建 Git 别名来执行外部工具；例如，如果你正在使用 Windows、Mac
    或 Linux，你可以按如下方式创建一个别名：
- en: '[PRE85]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This alias will open up an Window Explorer at the path you are currently at.
    The next one shows what changed in the `HEAD` commit. It executes this with the
    `--name-status` option for `git log`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个别名将会打开你当前所在路径的文件资源管理器。下一个别名展示了`HEAD`提交中发生了什么变更。它使用`git log`的`--name-status`选项来执行：
- en: '[PRE86]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now try it using the following command:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，试试下面的命令：
- en: '[PRE87]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'As you can see, it simply lists the commit and the files, including what happened
    to the files in the commit. As the aliases take arguments, we can actually reuse
    this functionality to list the information for another branch. Let''s try it with
    the following command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，它只是简单地列出了提交和文件，包括文件在提交中的变动。由于别名接受参数，我们实际上可以重复利用这个功能来列出另一个分支的信息。让我们试试下面的命令：
- en: '[PRE88]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: As you can see, we get the expected output. So, for instance, if you have been
    using a specific set of options for `git diff`, then you can make it an alias
    to use it with ease.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们得到了预期的输出。所以，举个例子，如果你一直在为`git diff`使用一组特定的选项，那么你可以将其制作成一个别名，以便轻松使用。
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'It is as simple as inserting text in the `config` file. So, you can try and
    open the `.git/config` configuration file, or you can list the configuration with
    `git config -list`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像是在`config`文件中插入文本一样简单。所以，你可以尝试打开`.git/config`配置文件，或者你也可以通过`git config -list`来列出配置：
- en: '[PRE89]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The `alias` feature is very strong, and the idea behind it is that you should
    use it to shorten those long one-liners that you often use. You can also use this
    feature to cut down those one-liners to shorter aliases so that you can use the
    command frequently and with more precision. If you have a long and complex Git
    comment as an alias, you will run it the same way every time, where keying a long
    command is bound to fail once in a while.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias` 特性非常强大，它的理念是让你通过它来缩短那些你经常使用的长命令。你还可以利用这个特性将那些长命令缩短为别名，这样你就能更加频繁和精确地使用命令。如果你将一个长而复杂的
    Git 评论设置为别名，你每次运行它时都会按相同的方式操作，而输入长命令则时常容易出错。'
- en: Configuring and using Git scripts
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和使用 Git 脚本
- en: Yes, we have aliases, and aliases do what they do best – take short one-liners
    and convert them into short, useful Git commands. However, when it comes to longer
    scripts that are also a part of your process, and you would like to incorporate
    them into Git, you can simply name the script `git-scriptname`, and then use it
    as `git scriptname`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们有别名，别名的作用就是将简短的命令转换为简洁有用的 Git 命令。然而，当涉及到较长的脚本，它们也是你工作流程的一部分，并且你希望将它们整合进
    Git 时，你可以简单地将脚本命名为 `git-scriptname`，然后像使用 `git scriptname` 一样调用它。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'There are a few things to remember. The script has to be in your path so that
    Git can use the script. Besides this, only imagination sets the boundaries:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要记住。脚本必须在你的路径中，这样 Git 才能使用它。除此之外，只有想象力才是界限：
- en: 'Open your favorite editor and insert the following lines into the file:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你喜欢的编辑器，并将以下内容插入到文件中：
- en: '[PRE90]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Save the file with the name `git-likeaboss`. This is a very simple script that
    will list random commit subjects with either passed or failed as the result. It
    will not stop until you press *Ctrl* + *C*:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存为 `git-likeaboss`。这是一个非常简单的脚本，它将列出随机的提交主题，结果会显示“通过”或“失败”。它会一直运行，直到你按下 *Ctrl*
    + *C*：
- en: '[PRE91]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Note that you can also tab complete these commands, and Git will take them
    into consideration when you slightly misspell commands, as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，你也可以使用 tab 补全这些命令，Git 会在你稍微拼写错误时考虑它们，具体如下：
- en: '[PRE92]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Obviously, this script, in itself, is not so useful in a day-to-day environment,
    but we hope you get the point we are trying to make. All scripts revolve around
    the software delivery chain and you can name them Git as they are part of Git.
    This makes it much easier to remember which of the scripts you have are available
    for your job.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个脚本本身在日常工作中并没有太大用处，但我们希望你能理解我们要表达的意思。所有脚本都围绕软件交付链展开，你可以将它们命名为 Git，因为它们是
    Git 的一部分。这使得记住哪些脚本适用于你的工作变得更加容易。
- en: Both Git aliases and Git scripts will show up as Git commands when using tab
    completion. Type in `git <tab> <tab>` to see the list of possible Git commands.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是 Git 别名还是 Git 脚本，在使用 tab 补全时都会作为 Git 命令显示出来。输入 `git <tab> <tab>` 以查看可能的 Git
    命令列表。
- en: Setting up and using a commit template
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和使用提交模板
- en: In this chapter, we have been using dynamic templates, but Git also has the
    option of a static commit template. A static template is essentially just a text
    file configured as a template. Using the template is very easy and straightforward.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在使用动态模板，但 Git 也有静态提交模板的选项。静态模板本质上只是一个配置好的文本文件。使用模板非常简单直接。
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First of all, we need a template. This has to be a text file that you know
    the location of. Create a file with the following content:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个模板。这个模板必须是一个你知道位置的文本文件。创建一个包含以下内容的文件：
- en: '[PRE93]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This is our take on a simple commit message template. You might find that there
    are other templates out there that prefer to have the bug in the title or at the
    bottom of the commit message. The reason for having this at the top is that people
    often tend not to read the important parts of the text! The important part here
    is the formatting of the references to systems outside Git. If we get these references
    correct, we can automatically update the defect system as well. Save the file
    as `~/committemplate`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们提供的一个简单的提交信息模板。你可能会发现有其他模板倾向于将 bug 放在标题或提交信息的底部。将 bug 放在顶部的原因是，人们往往不会阅读文本中的重要部分！这里重要的是格式化外部系统引用的部分。如果我们正确地处理了这些引用，我们也能自动更新缺陷系统。将文件保存为
    `~/committemplate`。
- en: How to do it...
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We will configure our newly created template, and then we will make a commit
    that will utilize the template.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置我们新创建的模板，然后进行一次提交，使用这个模板。
- en: 'To configure the template, we need to use `git config commit.template <pathtofile>`
    to set it, and, as soon as it is set, we can try to create a commit and see how
    it works:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置模板，我们需要使用`git config commit.template <pathtofile>`来设置它，一旦设置完成，我们就可以尝试创建一次提交，看看它是如何工作的：
- en: 'Start by configuring the template as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下配置模板开始：
- en: '[PRE94]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now list the `config` file to see that it has been set:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在列出`config`文件以查看它是否已被设置：
- en: '[PRE95]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'As we predicted, the configuration was a success. The template, just like any
    other configuration, can be set at a global level using `git config --global`,
    or it can be set at a local repository level by leaving out the `--global` option.
    We configured our commit template for this repository only. Let''s try and make
    a commit:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们预料的那样，配置成功了。模板，就像任何其他配置一样，可以通过`git config --global`在全局级别设置，或者通过不使用`--global`选项在本地仓库级别设置。我们仅为这个仓库配置了提交模板。让我们尝试进行一次提交：
- en: '[PRE96]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, the commit message editor should open, and you should see our template
    in the commit message editor:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，提交信息编辑器应该已打开，你应该在提交信息编辑器中看到我们的模板：
- en: '[PRE97]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: It's really as simple as that.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单。
- en: In this chapter, we have seen how to prevent pushing when there are special
    words in commit messages. We have also seen how you can dynamically create a commit
    message with valid information for you or another developer when you are committing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了如何在提交信息中存在特定单词时防止推送。我们还看到了如何在提交时动态创建适用于你或其他开发人员的有效提交信息。
- en: We went on to see how you can build functionality into your own Git by adding
    short scripts or aliases that are all executed using Git. Hopefully, this information
    will help you to work smarter instead of harder.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着展示了如何通过添加简短的脚本或别名将功能集成到你自己的 Git 中，这些脚本或别名都会通过 Git 执行。希望这些信息能帮助你更加聪明地工作，而不是更加辛苦。
