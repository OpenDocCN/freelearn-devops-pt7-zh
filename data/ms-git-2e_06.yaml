- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Searching Through the Repository
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在仓库中进行搜索
- en: After selecting the parts of the project history that you want to search, the
    next task is to extract the information you want from selected commits. You can
    limit your search according to the revision metadata, such as the author of the
    commit, the date that the change was created, or the contents of the commit message.
    You can look at the changes themselves, or you may be interested in how a given
    file or subsystem evolved. With access to the project history, you can find who
    wrote a given section of the code or which commit introduced a regression (first
    buggy commit).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了你想要搜索的项目历史部分之后，下一步任务是从选定的提交中提取你需要的信息。你可以根据修订元数据来限制搜索范围，例如提交的作者、变更创建的日期，或提交信息的内容。你可以查看实际的更改，或者你可能对某个特定文件或子系统如何演变感兴趣。通过访问项目历史，你可以找到谁编写了某一段代码，或是哪次提交引入了回归（首次出现的错误提交）。
- en: Another important skill is to format Git output so that it is easy to find the
    information you want. This task is made possible by various predefined pretty
    `git log` output formats and the ability to define and compose one’s own output
    format.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的技能是格式化Git输出，以便容易找到你想要的信息。通过各种预定义的漂亮`git log`输出格式和定义及组合自定义输出格式的能力，可以实现这一任务。
- en: 'Here is the list of topics we will cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本章中讨论的主题列表：
- en: Limiting the history and history simplification
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制历史记录和历史简化
- en: Searching the history with the pickaxe tool and diff search
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用取铁锹工具和差异搜索来搜索历史记录
- en: Finding bugs with **git bisect**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**git bisect**查找错误
- en: Line-wise history of file contents with **git blame** and rename detection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**git blame**查看文件内容的逐行历史，并检测文件重命名
- en: Selecting and formatting output (the pretty formats)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择和格式化输出（美观的格式）
- en: Summarizing contribution with **git shortlog**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**git shortlog**概括贡献
- en: Specifying a canonical author name and email with **.mailmap**
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**.mailmap**指定标准的作者姓名和电子邮件
- en: Viewing specific revisions, files at revision, and diff output options
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看特定的修订、修订中的文件以及差异输出选项
- en: The purpose of this chapter is to show how to extract information from the project
    history.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是展示如何从项目历史中提取信息。
- en: Searching the history
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索历史记录
- en: A huge number and variety of useful options for the `git log` command are revising
    limiting options — that is, options that let you show only a subset of commits.
    This complements selecting commits to view by passing the appropriate revision
    range and allows us to search the history for specific versions, utilizing information
    other than the shape of the graph of revisions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`git log`命令有大量且多样的有用选项，其中修订限制选项是最常用的——即那些只允许你显示部分提交的选项。这与通过传递适当的修订范围选择要查看的提交相辅相成，并允许我们利用除了修订图形外的其他信息来搜索特定版本的历史记录。'
- en: Limiting the number of revisions
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制修订数量
- en: The most basic way of limiting `git log` output is to show only the specified
    number of the most recent commits. This is done using the `-<n>` option (where
    `n` is any integer); this can also be written as `-n <n>`, or in long form as
    `--max-count=<n>`. For example, `git log -2` would show the two last (most recent)
    commits in the current line of development, starting from the implicit `HEAD`
    revision.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 限制`git log`输出的最基本方法是仅显示指定数量的最新提交。可以使用`-<n>`选项（其中`n`是任意整数）来实现；也可以写作`-n <n>`，或者以长格式写作`--max-count=<n>`。例如，`git
    log -2`将显示当前开发线中最新的两个提交，从隐式的`HEAD`修订开始。
- en: You can skip the first few commits shown with `--skip=<n>`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`--skip=<n>`跳过显示的前几个提交。
- en: Matching revision metadata
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配修订元数据
- en: History limiting options can be divided into those that check the information
    stored in the commit object itself (the revision metadata) and those that filter
    commits based on the changeset (based on changes from the parent commit or commits).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 历史限制选项可以分为两类：一种是检查提交对象本身存储的信息（修订元数据），另一种是根据变更集过滤提交（基于父提交或多个提交之间的变更）。
- en: Time-limiting options
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间限制选项
- en: 'If you are interested in commits created within some specific date range, you
    can use a number of options such as `--since` and `--until,` or `--before` and
    `--after`. For example, the following command returns the list of commits made
    in the last two weeks:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对某个特定日期范围内创建的提交感兴趣，可以使用如`--since`和`--until`，或者`--before`和`--after`等选项。例如，以下命令返回过去两周内所做的提交列表：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These options work with various *date* formats. You can specify a specific date
    such as *2008-04-21*, or a relative date such as *2 years 3 months 3 days ago*;
    you can also use a dot in place of a space.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项可以与各种*日期*格式一起使用。你可以指定一个具体日期，如*2008-04-21*，也可以指定一个相对日期，如*2年前3个月3天*；你还可以使用点代替空格。
- en: When using a specific date, you must remember that if the date does not include
    a time zone, it will be interpreted in the local time zone. It is important because,
    in such a situation, Git will not yield identical results when run by colleagues
    who may be situated in other time zones around the world. For example, `--since="2014-04-29
    12:00:00"` would catch six hours’ worth more commits when issued in Birmingham,
    England, UK (where it means 2014-04-29Z11:00:00 universal time) than when issued
    in Birmingham, Alabama, USA (where it means 2014-04-29Z17:00:00). To get the same
    results, you need to include the time zone in the time limit — for example, `-``‍``-after="2013-04-29T17:07:22+0200"`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用特定日期时，必须记住，如果日期没有包含时区，它将被解释为本地时区。这很重要，因为在这种情况下，当Git由位于世界其他时区的同事运行时，结果可能不会相同。例如，`--since="2014-04-29
    12:00:00"`在英国伯明翰（这表示2014-04-29Z11:00:00的世界协调时间）运行时，会比在美国阿拉巴马州伯明翰（这表示2014-04-29Z17:00:00）运行时多出六小时的提交。为了获得相同的结果，你需要在时间限制中包括时区——例如，`-``‍``-after="2013-04-29T17:07:22+0200"`。
- en: 'Note that commits in Git are described not by a single date, but by two possibly
    different dates: the author date and the committer date. Time-limiting options
    described here examine the **committer date**, which means the date and time when
    the revision object was created. This might be different from the **author date**,
    which means the date and time when a changeset was created (when the change was
    made).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Git中的提交并不是由单一日期描述的，而是由两个可能不同的日期描述：作者日期和提交者日期。此处描述的时间限制选项检查**提交者日期**，即修订对象创建的日期和时间。这可能不同于**作者日期**，即变更集创建的日期和时间（即更改发生的时间）。
- en: 'The date of authorship can be different from the date of committership in a
    few cases:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，作者日期和提交者日期可以不同：
- en: One case is when the commit was created in one repository, converted to email,
    and then applied by another person in another repository.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种情况是，当提交是在一个仓库中创建的，转换为电子邮件后，再由另一个人应用到另一个仓库中。
- en: Another way to have those two dates differ is to have the commit recreated while
    rebasing; by default, this keeps the author date and gets a new committer date
    (see [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229), *Merging Changes Together*,
    the *Rebasing a branch* section, and [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping History Clean*, the *An interactive* *rebase* section).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种让这两个日期不同的方法是，在重新基础化时重新创建提交；默认情况下，这会保留作者日期并获得一个新的提交者日期（参见[*第9章*](B21194_09.xhtml#_idTextAnchor229)，*合并更改*，*基础化分支*部分，以及[*第10章*](B21194_10_split_000.xhtml#_idTextAnchor247)，*保持历史记录清晰*，*交互式*
    *基础化*部分）。
- en: Matching commit contents
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配提交内容
- en: If you want to filter your commit history to only show those done by a specific
    author or committer, you can use the `--author` or `--committer` options, respectively.
    For example, let’s say you’re looking for all the commits in the Git source code
    authored by Linus. You could use something like `git log --author=Linus`. The
    search is, by default, case-sensitive, and uses `--author=^Linus`. Using `^` here
    means that the authorship information should start with **Linus**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想过滤出由特定作者或提交者完成的提交，可以分别使用`--author`或`--committer`选项。例如，假设你在寻找Linus编写的所有Git源代码中的提交。你可以使用类似`git
    log --author=Linus`的命令。默认情况下，搜索是区分大小写的，使用`--author=^Linus`。这里使用`^`表示作者信息应该以**Linus**开头。
- en: The `--grep` option lets you search commit messages (which should contain descriptions
    of the changes). Let’s say that you want to find all the security bug fixes that
    mention `git` `log --grep=CVE`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`--grep`选项允许你搜索提交信息（这些信息应包含对更改的描述）。假设你想查找所有提到`git`的安全漏洞修复，可以使用`git log --grep=CVE`。'
- en: If you specify both `--author` and `--grep` options, or more than one `--author`
    or `--grep` option, Git will show commits that match either query. In other words,
    Git would logically OR all the commit matching options. If you want to find commits
    that match all the queries, with matching options logically AND-ed, you need to
    use the `--``all-match` option.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你同时指定了`--author`和`--grep`选项，或者多个`--author`或`--grep`选项，Git将显示匹配任一查询的提交。换句话说，Git会逻辑地“或”所有提交匹配选项。如果你希望找到匹配所有查询的提交，并且这些匹配选项之间是逻辑“与”关系，你需要使用`--all-match`选项。
- en: There is also a set of options to modify the meaning of matching patterns, similar
    to the ones used by the `grep` program. To make the search case-insensitive, use
    the `-i` / `--regexp-ignore-case` option. If you want to match simply a substring,
    you can use `-F` / `--fixed-strings` (you might want to do this to avoid having
    to escape regular expression metacharacters such as `.` and `?`). To write more
    powerful search terms, you can use `--extended-regexp` or `--perl-regexp` (you
    can use the latter only if Git was compiled and linked with the `--invert-grep`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一组选项，可以修改匹配模式的含义，类似于`grep`程序中使用的选项。为了使搜索不区分大小写，可以使用`-i` / `--regexp-ignore-case`选项。如果你想简单地匹配一个子字符串，可以使用`-F`
    / `--fixed-strings`（你可能希望这么做，以避免需要转义正则表达式中的元字符，如`.`和`?`）。如果你想写更强大的搜索词，可以使用`--extended-regexp`或`--perl-regexp`（如果Git是用`--invert-grep`编译并链接的，后者才可用）。
- en: 'When walking reflogs with `git log -g` (see the *Reflog shortnames* section),
    you can use the `--grep-reflog=<regexp>` option to show only positions with the
    matching reflog entry. For example, to show all operations on `HEAD` that were
    not a simple commit operation, you can use the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`git log -g`查看reflog时（参见*Reflog简写*部分），你可以使用`--grep-reflog=<regexp>`选项，仅显示包含匹配reflog条目的位置。例如，要显示所有对`HEAD`的操作，这些操作不是简单的提交操作，你可以使用以下命令：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Commit parents
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提交的父级
- en: Git, by default, will follow all the parents of each merge commit when walking
    down the ancestry chain. To make it follow only the first parent, you can use
    the aptly named `--first-parent` option. This would show you the main line of
    history (sometimes called the trunk), assuming that you follow the specific practices
    with respect to merging changes; you will learn more about this in [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196),
    *Advanced Branching Techniques*, and [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229),
    *Merging* *Changes Together*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Git会在遍历提交历史时，跟随每个合并提交的所有父提交。为了只跟随第一个父提交，你可以使用恰如其分的`--first-parent`选项。这样会显示历史的主线（有时称为主干），假设你遵循了特定的合并实践；你将在[*第8章*](B21194_08_split_000.xhtml#_idTextAnchor196)《高级分支技巧》和[*第9章*](B21194_09.xhtml#_idTextAnchor229)《合并变更》部分学到更多。
- en: 'Consider the following command (this example uses the very nice `--graph` option
    that makes an ASCII-art diagram of the history):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下命令（这个例子使用了非常实用的`--graph`选项，它能够生成历史的ASCII艺术图表）：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compare it with this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与以下命令进行比较：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can filter the list to show only the merge commits or only the non-merge
    commits with the `--merges` and `--no-merges` options, respectively. These options
    can be considered simply shortcuts for more generic options: `--min-parents=<number>`
    (`--merges` is `--min-parents=2`) and `--max-parents=<number>` (`--no-merges`
    is `--max-parents=1`).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`--merges`和`--no-merges`选项，分别过滤出仅显示合并提交或非合并提交。这些选项实际上是更通用选项的简化版：`--min-parents=<number>`（`--merges`等同于`--min-parents=2`）和`--max-parents=<number>`（`--no-merges`等同于`--max-parents=1`）。
- en: 'Let’s say that you want to find the starting point(s) of your project. You
    can do this with the help of `--max-parents=0`, which would give all the root
    commits:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想找到项目的起始点，你可以借助`--max-parents=0`来实现，这样会显示所有的根提交：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Searching changes in revisions
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索修订中的更改
- en: Sometimes, searching through commit messages and other revision metadata is
    not enough. Perhaps descriptions of the changes were not detailed enough. Or,
    what if you are looking for a revision when a function was introduced, or where
    variable started to be used?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，单靠搜索提交信息和其他修订元数据是不够的。也许对更改的描述不够详细，或者，你可能在寻找某个功能被引入的修订，或者某个变量开始使用的修订？
- en: Git allows you to look through the changes that each revision brought (the difference
    between a commit and its parent). The faster option is called a **pickaxe** search.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Git允许你查看每个修订所带来的更改（即提交与其父提交之间的差异）。更快的选项被称为**pickaxe**搜索。
- en: With the `-S<string>` option, Git will look for differences that introduce or
    remove an instance of a given string. Note that this is different from the string
    simply appearing in the diff output. You can do a match using a regular expression
    with the `--pickaxe-regex` option. Git checks each revision to see whether there
    are files whose *current* side and *parent* side have a different number of the
    specified string, and show the revisions that match.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-S<string>`选项时，Git会查找引入或删除给定字符串的差异。注意，这不同于字符串仅仅出现在diff输出中。你可以使用正则表达式与`--pickaxe-regex`选项进行匹配。Git会检查每个修订，看是否有文件的*当前*侧和*父*侧有不同数量的指定字符串，并显示匹配的修订。
- en: 'As a side effect, `git log` with the `-S` option would also show the changes
    that each revision made (as if the `--patch` option were used), but only those
    differences that match the query. To show differences for all the files and also
    differences where the change in number occurred, you need to use the `--``pickaxe-all`
    option:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为副作用，使用`git log`和`-S`选项还会显示每次修订所做的更改（就像使用了`--patch`选项一样），但仅显示与查询匹配的差异。若要显示所有文件的差异，以及发生数字变化的差异，你需要使用`--pickaxe-all`选项：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With `-G<regex>`, Git would literally look for differences whose added or removed
    line matches the given regular expression. Note that the unified diff format (that
    Git uses) considers the changed line to be a removal of the old version and adding
    of a new one; refer to [*Chapter 2*](B21194_02.xhtml#_idTextAnchor028), *Developing
    with Git* (the *Examining the changes to be committed* section) for an explanation
    of how Git describes changes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-G<regex>`时，Git会字面上寻找那些添加或删除的行与给定正则表达式匹配的差异。注意，Git使用的统一diff格式将更改的行视为删除旧版本并添加新版本；参见[*第2章*](B21194_02.xhtml#_idTextAnchor028)，*使用Git开发*（*检查待提交的更改*部分），了解Git如何描述更改。
- en: 'To illustrate the difference between `-S<regex> --pickaxe-regex` and `-G<regex>`,
    consider a commit with the following diff:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`-S<regex> --pickaxe-regex`与`-G<regex>`之间的差异，考虑一个包含以下diff的提交：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While `git log -G"error\("` will show this commit (because the query matches
    both changed lines), `git log -S"error\(" --pickaxe-regex` will not (because the
    number of occurrences of that string did not change).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当`git log -G"error\("`会显示这个提交（因为查询匹配了两个更改的行）时，`git log -S"error\(" --pickaxe-regex`则不会显示（因为该字符串的出现次数没有发生变化）。
- en: Tip
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you are interested in a single file, it is easier to use **git blame** (perhaps
    in a graphical blame browser, like with **git gui blame**) to check when the given
    change was introduced. However, **git blame** can’t be used to find a commit that
    deleted a line — you need a pickaxe search for that.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对单个文件感兴趣，使用**git blame**（也许在图形化的blame浏览器中，如**git gui blame**）查看某个更改何时被引入会更容易。然而，**git
    blame**无法用于找到删除行的提交——你需要使用pickaxe搜索。
- en: Selecting types of changes
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择更改类型
- en: 'Sometimes, you might want to see only those changes that added or renamed files.
    With Git, you can do this with `git log --diff-filter=AR`. You can select any
    combination of types of changes; see the `git-log(1)` manpage for details. For
    example, to find all renames while listing all changed files, you can use `--diff-filter=R*`,
    such as in the following example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能只想查看那些添加或重命名文件的更改。使用Git，你可以通过`git log --diff-filter=AR`来做到这一点。你可以选择任何类型变化的组合；详情请参见`git-log(1)`手册。例如，要在列出所有更改的文件时找到所有重命名文件，你可以使用`--diff-filter=R*`，如以下示例所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The mnemonics for types of changes are the same as those used by `git status
    --short` or `git` `log --name-status`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更改类型的助记符与`git status --short`或`git log --name-status`所使用的是一样的：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, we will examine how to search the history based on which files were changed,
    and later, also how to format the `git` `log` output.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究如何根据更改的文件搜索历史，随后还会讨论如何格式化`git log`的输出。
- en: History of a file
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件的历史
- en: As described in the *Whole-tree commits* section at the beginning of the previous
    chapter, Git revisions are about the state of the whole project as one single
    entity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一章开头的*整个树提交*部分所描述，Git修订是关于将整个项目作为一个单一实体的状态。
- en: In many cases, especially with larger projects, we are interested only in the
    history of a single file, or the history limited to the changes in the given directory
    (in the given subsystem).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，特别是在大型项目中，我们只关心单个文件的历史，或仅限于给定目录（给定子系统）内更改的历史。
- en: Path limiting
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径限制
- en: To examine the history of a single file, you can simply use `git log <pathname>`.
    Git will then only show all those revisions that affected the given pathname (a
    file or a directory), which means those revisions where there was a change to
    the given file or a change to a file inside the given subdirectory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看单个文件的历史，你只需使用`git log <pathname>`。Git将仅显示所有影响指定路径名（文件或目录）的修订，这意味着那些对指定文件或指定子目录中的文件做出更改的修订。
- en: Disambiguation between branch names and path names
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 分支名称与路径名称的歧义消除
- en: Git usually guesses what you mean by writing **git log foo**; did you mean to
    ask for the history of the **foo** branch (the line of development), or for the
    history of the **foo** file? However, sometimes, Git can get confused. To prevent
    confusion between pathnames and branch names, you can use **--** (two dashes)
    to separate filename arguments from other options. Everything after **--** would
    be taken to be a pathname, and everything before that would be taken to be the
    branch name or other option.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Git通常会猜测你写的**git log foo**是什么意思；你是想查看**foo**分支（开发线）的历史，还是想查看**foo**文件的历史？然而，有时Git可能会混淆。为防止路径名和分支名称之间的混淆，你可以使用**--**（两个破折号）来分隔文件名参数和其他选项。**--**之后的所有内容将被视为路径名，而**--**之前的所有内容将被视为分支名称或其他选项。
- en: For example, writing **git log -- foo** explicitly asks for the history of the
    **foo** path.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，编写**git log -- foo**明确请求查看**foo**路径的历史。
- en: One of the common situations where it is needed, besides when having the same
    name for a branch and a file, is when examining the *history of a deleted file*
    that is no longer present in a project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了当分支和文件同名时，另一个常见的使用场景是在检查*已删除文件的历史*时，该文件不再出现在项目中。
- en: You can specify more than one path; you can even look for changes that affect
    a given type of file with the help of wildcards (pattern match). For example,
    to find only changes to Perl scripts (files with the `*.pl` extension), you can
    use `git log -- '*.pl'`. Note that you need to protect the `*.pl` wildcard from
    being expanded by the shell before Git sees it — for example, via single quotes
    as shown here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定多个路径；甚至可以使用通配符（模式匹配）来查找影响某一特定类型文件的更改。例如，要查找仅对Perl脚本（`.pl`扩展名的文件）所做的更改，可以使用`git
    log -- '*.pl'`。请注意，你需要保护`*.pl`通配符，以免在Git看到它之前被Shell展开——例如，使用单引号，如此处所示。
- en: Pathspec magic
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Pathspec魔法
- en: 'Most commands that accept **<path>** or **<pathspec>** as a parameter, such
    as **git log**, also support **pathspec magic**. A pathspec that starts with a
    colon ‘**:**’ has a special meaning: it is expected that this colon is then followed
    by either one or more *magic signature* letters, or a comma-separated list of
    zero or more *magic words*. An optional colon ‘**:**’ can be used to separate
    the magics from the pattern to match them. Here are a few examples: **:(top):data/**
    or **:/data/** would make the pattern match the data/directory at the top directory
    of the repository, regardless of where we are inside the repository (the current
    directory). The **git log :(exclude):*.html** or **git log :^*.html** command
    will list all revisions where there was at least one change to the file that is
    not an HTML file. You can find more magics in the **gitglossary(7)** manpage,
    in the **pathspec** entry.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数接受**<path>**或**<pathspec>**作为参数的命令，如**git log**，也支持**pathspec 魔法**。以冒号‘**:**’开头的路径规格有特殊含义：此冒号后面通常跟着一个或多个*魔法签名*字母，或者是零个或多个*魔法词*的逗号分隔列表。可以选择性地使用冒号‘**:**’来分隔魔法部分和匹配模式。以下是一些例子：**:(top):data/**
    或 **:/data/** 将使模式匹配到仓库顶层目录中的data/目录，而不管我们当前位于仓库中的哪个位置（当前目录）。命令**git log :(exclude):*.html**
    或 **git log :^*.html** 将列出所有修订，其中至少有一个文件发生了变化，并且该文件不是HTML文件。你可以在**gitglossary(7)**手册页中的**pathspec**条目找到更多的魔法。
- en: However, because Git uses pathname parameters as *limiters* in showing the history
    of a project, querying for the history of a single file doesn’t automatically
    *follow renames*. You need to use `git log --follow <file>` to continue listing
    the history of a file beyond renames. Unfortunately, it doesn’t work in all cases.
    Sometimes, you need to use either the `git blame` command (see the *Blame – the
    line-wise history of a file* section), or examine the boundary commits with rename
    detection turned on (`git show -M -C --raw --abbrev <rev>`) and follow renames
    and file moving manually.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 Git 在显示项目历史时使用路径名参数作为*限制器*，查询单个文件的历史不会自动*跟踪重命名*。你需要使用 `git log --follow
    <file>` 来继续列出文件的历史，超越重命名。不幸的是，它并不是在所有情况下都有效。有时，你需要使用 `git blame` 命令（请参见*Blame
    – 文件的逐行历史*部分），或通过启用重命名检测的边界提交（`git show -M -C --raw --abbrev <rev>`）来手动跟踪重命名和文件移动。
- en: 'In modern Git, you can also trace *the evolution of the line range* within
    the file using `git log -L`, which is currently limited to the walk starting from
    a single revision (zero or one positive revision argument) and a single file.
    The range is given either denoting the start and end of the range with `-L <start>,<end>:<file>`
    (where either `<start>` or `<end>` can be a line number or a `/regexp/`), or a
    function to track with `-L :<funcname regexp>:<file>`. This technique cannot,
    however, be used together with the ordinary pathspec-based path limiting. For
    example, to see the history of the `index.html` file, limited to the changes in
    the `<head>` element, you can use the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 Git 中，你还可以使用 `git log -L` 跟踪文件中*行范围的演变*，目前该功能仅限于从单个修订（零或一个正向修订参数）和单个文件开始的遍历。范围可以通过`-L
    <start>,<end>:<file>`来指定，`<start>` 或 `<end>` 可以是行号或`/regexp/`（正则表达式），也可以用 `-L
    :<funcname regexp>:<file>`来跟踪一个函数。 然而，这种技术不能与基于路径的常规路径限制一起使用。例如，要查看`index.html`文件的历史，限制在`<head>`元素中的更改，可以使用以下命令：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: History simplification
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 历史简化
- en: By default, when requested for the history of a path, Git would *simplify the
    history*, showing only those commits that are required (that are enough) to explain
    how the files that match the specified paths came to be. Git would exclude those
    revisions that do not change the given file. Additionally, for non-excluded merge
    commits, Git would exclude those parents that do not change the file (thus excluding
    lines of development).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当请求某路径的历史时，Git 会*简化历史*，只显示那些必要的提交（足以解释匹配指定路径的文件是如何演变的）。Git 会排除那些没有更改给定文件的修订。此外，对于非排除的合并提交，Git
    会排除那些没有更改文件的父提交（从而排除开发线）。
- en: You can control this kind of history simplification with the `git log` options
    such as `--full-history` or `--simplify-merges`. Check the Git documentation for
    more details, such as the *History simplification* section in the `git-log(1)`
    manpage.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `git log` 选项来控制这种历史简化，如 `--full-history` 或 `--simplify-merges`。更多详情请参见
    Git 文档，尤其是 `git-log(1)` 手册中的*历史简化*部分。
- en: Blame — the line-wise history of a file
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blame — 文件的逐行历史
- en: The `git blame` annotates each line with appropriate line-authorship information.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`git blame` 会为每一行标注适当的行作者信息。'
- en: 'Git can start annotating from the given revision (useful when browsing the
    history of a file or examining how an older version of a file came to be), or
    even limit the search to a given revision range. You can also limit the range
    of lines annotated to make blame faster — for example, to check only the history
    of an `esc_html` function, you can use the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Git 可以从给定的修订开始标注（这在浏览文件历史或检查文件的旧版本是如何演变时非常有用），甚至可以将搜索限制在给定的修订范围内。你还可以限制标注的行范围，以提高
    `blame` 的速度——例如，若只想查看 `esc_html` 函数的历史，可以使用以下命令：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What makes the blame operation so useful is that it *follows the history* of
    a file across whole-file renames. It can optionally follow lines that were moved
    from one file to another (with the `-M` option), and even follow lines that were
    copied and pasted from another file (with the `-C` option); this includes internal
    code movement.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`blame` 操作之所以如此有用，是因为它*跟踪历史*，即使文件进行了整文件的重命名。它可以选择跟踪从一个文件移动到另一个文件的行（使用 `-M`
    选项），甚至跟踪从另一个文件复制粘贴过来的行（使用 `-C` 选项）；这也包括内部代码的移动。'
- en: When following code movement, it is useful to ignore changes in whitespace to
    find when a given fragment of code was truly introduced and avoid finding when
    it was just re-indented (for example, due to refactoring repeated code into a
    function — code movement). This can be done by passing the diff-formatting option,
    `–w` / `--``ignore-all-space`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟踪代码移动时，忽略空白符变化非常有用，这样可以找出某段代码真正被引入的时间，而不是仅仅发现它被重新缩进（例如，由于重构重复代码为函数——代码移动）。这可以通过传递
    diff 格式选项 `–w` / `--ignore-all-space` 来完成。
- en: Rename detection
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名检测
- en: A good version control system should be able to deal with renaming files and
    other ways of changing the directory structure of a project. There are two ways
    to deal with this problem. The first is **rename tracking**, which means that
    the information about the fact that a file was renamed is saved at the commit
    time; the version control systems mark renames. This usually requires using the
    **rename** and **move** commands to rename files. For example, you cannot use
    a file manager that is not version-control aware to move files. However, you can
    detect the rename when creating the revision." It can involve some kind of **file
    identity** surviving across renames.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的版本控制系统应该能够处理文件重命名和其他改变项目目录结构的方式。解决这个问题有两种方法。第一种是 **重命名追踪**，意味着在提交时保存关于文件被重命名的事实信息；版本控制系统会标记重命名。这通常需要使用
    **rename** 和 **move** 命令来重命名文件。例如，你不能使用不支持版本控制的文件管理器来移动文件。但是，在创建修订时，可以检测到重命名。这可能涉及某种形式的
    **文件身份**，它在重命名时得以保留。
- en: 'The second method, and the one used by Git, is **rename detection**. In this
    case, the **mv** command is only a shortcut for deleting a file with the old name
    and adding a file with the same contents and a new name. Rename detection means
    that the fact that the file was renamed is detected at the time it is needed:
    when doing a merge, when viewing the line-wise history of a file (if requested),
    or when showing a diff (if requested or configured). This has the advantage that
    the rename detection algorithm can be improved and is not frozen at the time of
    commit. It is a more generic solution, allowing it to handle not only the whole-file
    renames but also the code movement and copying within a single file and across
    different files, as can be seen in the description of **git blame**.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法，也是 Git 使用的方法，是 **重命名检测**。在这种情况下，**mv** 命令仅仅是删除旧文件名并添加一个包含相同内容的新文件名的快捷方式。重命名检测意味着在需要时检测文件被重命名的事实：在进行合并时、查看文件的逐行历史记录时（如果请求）、或在显示差异时（如果请求或配置了）。这种方式的优势在于，重命名检测算法可以得到改进，并且不会在提交时被冻结。它是一种更通用的解决方案，不仅可以处理整个文件的重命名，还可以处理单个文件内部以及不同文件之间的代码移动和复制，这可以从
    **git blame** 的描述中看到。
- en: 'The disadvantage of rename detection, which in Git is based on the heuristic
    of the similarity of the file contents and the pathname, is that it takes resources
    to run and that in rare cases, it can fail: not detecting renames, or detecting
    a rename where there isn’t one.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名检测的缺点是，它在 Git 中基于文件内容和路径名相似性的启发式方法，因此需要消耗一定的资源，并且在某些罕见情况下可能会失败：无法检测重命名，或错误地检测出没有发生重命名的情况。
- en: Note that, in modern Git, basic rename detection is turned on for diffs by default.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在现代 Git 中，基本的重命名检测默认启用，用于显示差异。
- en: 'Many graphical interfaces for Git include a graphical version of the blame
    operation. The `git gui blame` is an example of such a graphical interface for
    the blame operation (it is a part of `git gui`, a Tcl/Tk-based graphical interface).
    Such graphical interfaces can show the full description of changes and simultaneously
    show the history with and without considering renames. From such a GUI, it is
    usually possible to go to a specified commit, browsing the history of the lines
    of a file interactively. In addition, the GUI blame tool makes it very easy to
    follow files across renames:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Git 的图形界面包含了图形化版本的 blame 操作。`git gui blame` 就是其中一个图形化界面的例子（它是基于 Tcl/Tk 的
    `git gui` 图形界面的一部分）。这些图形界面可以展示完整的更改描述，并同时展示考虑与不考虑重命名的历史记录。通过这样的 GUI，通常可以跳转到指定的提交，交互式地浏览文件行的历史。此外，GUI
    blame 工具使得跨重命名跟踪文件变得非常简单：
- en: "![Figure 5.1 – \uFEFF'git gui blame' in action, showing the detection of copying\
    \ or moving fragments of code](img/B21194_05_01.jpg)"
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: "![图 5.1 – \uFEFF'git gui blame' 操作演示，展示了代码片段的复制或移动检测](img/B21194_05_01.jpg)"
- en: Figure 5.1 – 'git gui blame' in action, showing the detection of copying or
    moving fragments of code
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 'git gui blame' 操作示例，展示如何检测代码片段的复制或移动
- en: Finding bugs with git bisect
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 git bisect 查找 bug
- en: Git provides a couple of tools to help you debug issues in your projects. These
    tools can be extremely useful, especially in the case of a software regression
    — that is, a software bug that makes a feature stop functioning as intended after
    a certain revision. If you don’t know where the bug can be, and there have been
    dozens or hundreds of commits since the last state where you know the code worked,
    you’ll likely turn to `git bisect` for help.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Git 提供了一些工具来帮助你调试项目中的问题。这些工具非常有用，特别是在软件回归的情况下——即在某次修订后，软件出现了 bug，导致某个功能无法正常工作。如果你不知道
    bug 出现的位置，而自上次知道代码正常工作以来已经有数十次或数百次提交，你可能会求助于 `git bisect`。
- en: 'The **bisect** command searches semi-automatically, step by step, through project
    history, trying to find the revision that introduced the bug. In each step, it
    bisects the history into roughly equal parts and asks whether there is a bug in
    the dividing commit. It then uses the answer to eliminate one of the two sections
    and reduces the size of the revision range where there can be a commit that introduced
    the bug:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**bisect** 命令通过半自动化的方式，一步步地在项目历史中进行查找，尝试找出引入 bug 的修订。在每一步中，它将历史分成大致相等的两部分，询问分割提交是否存在
    bug。然后，它根据答案淘汰掉其中一部分，从而缩小包含 bug 的提交范围：'
- en: "![Figure 5.2 –  An example of git bisect in action, finding the buggy commit\
    \ after \uFEFF4 steps](img/B21194_05_02.jpg)"
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 –  git bisect 操作示例，在 4 步后找到有问题的提交](img/B21194_05_02.jpg)'
- en: Figure 5.2 – An example of git bisect in action, finding the buggy commit after
    4 steps
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – git bisect 操作示例，在 4 步后找到有问题的提交
- en: Starting the git bisect process
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 git bisect 过程
- en: Suppose version 1.14 of your project worked, but the release candidate for the
    new version, 1.15-rc0, crashes. You go back to the 1.15-rc0 version, and it turns
    out you can *reproduce the issue* (this is very important!), but you can’t figure
    out what is going wrong.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设项目的版本 1.14 正常工作，但新版本的候选发布版 1.15-rc0 崩溃。你回到 1.15-rc0 版本，结果发现你能够 *重现问题*（这非常重要！），但无法找出问题出在哪里。
- en: 'You can bisect the code history to find out. You need to start the bisection
    process with `git bisect start`, and then tell Git which version is broken with
    `git bisect bad`. Then, you must tell the bisect process the last known good state
    (or set of states) with `git` `bisect good`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 bisect 代码历史来查找原因。你需要通过 `git bisect start` 启动二分查找过程，然后使用 `git bisect bad`
    告诉 Git 哪个版本是坏的。接着，你必须告诉 bisect 过程最后一个已知的正常状态（或状态集合），使用 `git bisect good`：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finding the buggy commit
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找有问题的提交
- en: 'Git figured out that about 300 commits came between the commit you marked as
    the last good commit (`v1.14`) and the bad version (`v1.15-rc0`), and checked
    out the middle one (`7ea60c15`) for you. If you run `git branch` or `git status`
    at this point, you’ll see that git has temporarily moved you to `(``no branch)`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Git 发现大约有 300 次提交位于你标记为最后一次正常提交（`v1.14`）和有问题版本（`v1.15-rc0`）之间，并为你检出了中间的提交（`7ea60c15`）。如果此时运行
    `git branch` 或 `git status`，你会看到 Git 已暂时将你切换到了（``no branch）：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this point, you need to run your test to check whether the issue is present
    in the commit currently checked out by the bisect operation. If the program crashes,
    mark the current commit as bad with `git bisect bad`. If the issue is not present,
    mark it as correct with `git bisect good`. After about seven steps, Git would
    show the suspect commit:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你需要运行测试以检查问题是否存在于 bisect 操作当前检出的提交中。如果程序崩溃，使用 `git bisect bad` 标记当前提交为有问题。如果问题不存在，使用
    `git bisect good` 标记其为正常。大约经过七步后，Git 会显示出可疑的提交：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The last line in the preceding example output is in the so-called *raw* diff
    output, showing which files changed in a commit. You can then examine the suspected
    commit with `git show`. From there, you can find the author of the said commit,
    and ask them for clarification or ask them to fix it (by sending them a bug report).
    If the good practice of creating small, incremental changes was followed during
    the development of the project, the amount of code to examine after finding the
    bad commit should be small.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例输出的最后一行是所谓的 *原始* diff 输出，显示了在某次提交中发生变化的文件。你可以使用 `git show` 来检查可疑的提交。接下来，你可以查看该提交的作者，并向他们寻求澄清或要求修复（通过发送
    bug 报告）。如果在项目开发过程中遵循了创建小规模、增量变化的良好实践，那么在找到有问题的提交后，需检查的代码量应该会很小。
- en: If, at any point, you land on a commit that broke something unrelated and is
    not a good one to test, you can skip such a commit with `git bisect skip`. You
    can even skip a range of commits by giving the revision range to the `skip` subcommand.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个时刻，你遇到了一个与当前问题无关的提交，且它不适合用来测试，你可以使用`git bisect skip`跳过此提交。你甚至可以通过向`skip`子命令提供修订范围来跳过一系列提交。
- en: 'When you’re finished, you should run `git bisect reset` to return you to the
    branch you started from:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，应该运行`git bisect reset`，以便将你带回到开始时的分支。
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To finish bisection while staying on the bad commit you found, you can use `git
    bisect` `reset HEAD`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要在停留在你找到的坏提交上完成二分查找，你可以使用`git bisect` `reset HEAD`。
- en: Automating testing during the git bisect process
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在git bisect过程中自动化测试
- en: 'You can even fully automate finding bad revisions with `git bisect run`. For
    this, you need to have a script that will test for the presence of a bug and exit
    with a value of 0 if the project works all right, or a non-0 value if there is
    a bug. The special exit code, `125`, should be used when the currently checked-out
    code cannot be tested. In this case, you also start the `bisect` operation by
    providing the known bad and good commits. You can do this by simply listing them
    with the `bisect start` command if you want, listing the known bad commit first
    and the known good commit(s) second. You can even cut down the number of trials,
    if you know what part of the tree is involved in the problem you are tracking
    down, by specifying path parameters (the double-dash before the path is not strictly
    necessary, but is helpful). Then, you start automated bisection:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过`git bisect run`完全自动化查找坏修订版本。为此，你需要一个脚本来测试是否存在bug，如果项目正常工作则退出时返回0，或者如果存在bug则返回非0值。当当前检出的代码无法进行测试时，应使用特殊的退出代码`125`。在这种情况下，你还可以通过提供已知的坏和好的提交来启动`bisect`操作。你可以通过简单地使用`bisect
    start`命令列出这些提交，先列出已知的坏提交，再列出已知的好提交（如果有多个好提交）。如果你知道问题涉及树中的哪一部分，还可以通过指定路径参数来减少测试的次数（路径前的双破折号并非严格必要，但很有帮助）。然后，你就可以开始自动化的二分查找：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Doing so automatically runs `test-error.sh` on each checked-out commit until
    Git finds the first broken commit.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会自动在每个检出的提交上运行`test-error.sh`，直到Git找到第一个坏的提交。
- en: If the bug is that the project stopped compiling (a broken build), you can use
    `make` as a test script (with `git bisect` `run make`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题是项目停止编译（构建失败），你可以使用`make`作为测试脚本（与`git bisect` `run make`一起使用）。
- en: Selecting and formatting the git log output
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择并格式化git日志输出
- en: Now that you know how to select revisions to examine and limit which revisions
    are shown (selecting those that are interesting), it is time to see how to select
    which part of the information is associated with the queried revisions to show,
    and how to format this output. There is a huge number and variety of options for
    the `git log` command available for this.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何选择要检查的修订版本，并限制显示的修订版本（选择那些有意义的修订），接下来是学习如何选择与查询修订版本相关的部分信息并格式化输出。`git
    log`命令提供了大量的选项来实现这一点。
- en: Predefined and user-defined output formats
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预定义和用户定义的输出格式
- en: 'A very useful `git log` option is `--pretty`. This option changes the format
    of the log output. There are a few prebuilt formats available for you to use.
    The `oneline` format prints each commit on a single line, which is useful if you’re
    looking at a lot of commits; there exists the `--oneline` shorthand for `--pretty=oneline
    --abbrev-commit` used together. In addition, the `short`, `medium` (the default),
    `full`, and `fuller` formats show the output in roughly the same format, but with
    less or more information, respectively. The `raw` format shows commits in internal
    Git representation, and `email` or `mboxrd` in a `git format-patch`-like format,
    as an email. The `reference` format is intended to refer to another commit in
    a commit message, per the following example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的`git log`选项是`--pretty`。此选项会改变日志输出的格式。有几个预设格式可以供你使用。`oneline`格式将每个提交打印在一行上，这对于查看大量提交时非常有用；存在`--oneline`的快捷方式，它等同于`--pretty=oneline
    --abbrev-commit`，通常一起使用。此外，`short`、`medium`（默认格式）、`full`和`fuller`格式以大致相同的格式显示输出，只是信息的多少有所不同。`raw`格式以Git内部表示形式显示提交，`email`或`mboxrd`则以类似`git
    format-patch`的邮件格式显示。`reference`格式用于在提交信息中引用另一个提交，以下是一个示例：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It is possible to change the format of dates shown in those verbose, pretty
    formats with an appropriate `--date` option: make Git show relative dates such
    as, for example, `--date=relative`, dates in your local time zone with `--date=local`,
    and so on.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用适当的`--date`选项更改这些详细格式中显示日期的格式：让Git显示相对日期，例如`--date=relative`，或者使用`--date=local`显示本地时区的日期，等等。
- en: 'You can also specify your own log output format with `--pretty=format:<string>`
    (and its `tformat` variant, with terminator rather than separator semantics —
    output for each commit has the newline appended). This is especially useful when
    you’re generating output for machine parsing for use in scripts because when you
    specify the format explicitly, you know it won’t change with updates to Git. The
    format string works a little bit like in `printf`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`--pretty=format:<string>`指定您自己的日志输出格式（以及其`tformat`变体，该变体使用终止符而非分隔符语义——每次提交的输出会附加换行符）。当您为机器解析生成输出并在脚本中使用时，这尤其有用，因为当您明确指定格式时，您知道它在Git更新时不会更改。格式字符串的工作方式有点像`printf`：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is a very large number of placeholders. Selected ones of those are listed
    in the following table:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多占位符。以下表格列出了其中的一些：
- en: '| **Placeholder** | **Description** **of output** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **占位符** | **输出描述** |'
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%H` | Commit hash (full SHA-1 identifier of revision) |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `%H` | 提交哈希（修订的完整SHA-1标识符） |'
- en: '| `%h` | Abbreviated commit hash |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `%h` | 缩略提交哈希 |'
- en: '| `%``an` | Author name |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `%``an` | 作者姓名 |'
- en: '| `%``ae` | Author email |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `%``ae` | 作者电子邮件 |'
- en: '| `%``ar` | Author date, relative |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `%``ar` | 作者日期，相对时间 |'
- en: '| `%``cn` | Committer name |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `%``cn` | 提交者姓名 |'
- en: '| `%``ce` | Committer email |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `%``ce` | 提交者电子邮件 |'
- en: '| `%``cr` | Committer date, relative |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `%``cr` | 提交者日期，相对时间 |'
- en: '| `%s` | Subject (first line of a commit message, describing revision) |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `%s` | 主题（提交消息的第一行，描述修订） |'
- en: '| `%%` | A raw `%` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `%%` | 一个原始的`%` |'
- en: Table 5.1 – Placeholders and their description
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表格5.1 – 占位符及其描述
- en: Author versus committer
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 作者与提交者
- en: The **author** is the person who originally wrote the patch (authored the changes),
    whereas the **committer** is the person who last applied the patch (created a
    commit object with those changes, representing the revision in the DAG). So, if
    you send in a patch to a project and one of the core members applies the patch,
    both of you get credit — you as the author and the core member as the committer.
    Also, after rebase, for rebased revisions the original author of the commit is
    kept, while the person performing the rebase is made the committer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**作者**是最初编写补丁的人（撰写更改），而**提交者**是最后应用补丁的人（创建了包含这些更改的提交对象，表示DAG中的修订）。因此，如果您向一个项目提交补丁并且其中一位核心成员应用了该补丁，那么你们两个人都会获得荣誉——您是作者，核心成员是提交者。此外，在进行变基后，变基修订的原始提交作者保持不变，而执行变基的人成为提交者。'
- en: 'The `--oneline` format option is especially useful together with another `git
    log` option called `--graph`, though the latter can be used with any format. The
    latter option adds a nice little ASCII graph showing your branch and merge history.
    To see where tags and branches are, you can use an option named `--decorate` (which
    in modern Git is now the default):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`--oneline`格式选项与另一个名为`--graph`的`git log`选项结合使用时特别有用，尽管后者可以与任何格式一起使用。后者选项会添加一个漂亮的小ASCII图表，显示您的分支和合并历史。要查看标签和分支的位置，您可以使用一个名为`--decorate`的选项（在现代Git中，默认已启用该选项）：'
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You might want to use a graphical tool to visualize your commit history. One
    such tool is a Tcl/Tk program called `gitk` that is distributed with Git. You
    can find more information about various types of graphical tools in [*Chapter
    13*](B21194_13_split_000.xhtml#_idTextAnchor320), *Customizing and* *Extending
    Git*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想使用图形工具来可视化您的提交历史。一个这样的工具是名为`gitk`的Tcl/Tk程序，它随Git一起分发。您可以在[*第13章*](B21194_13_split_000.xhtml#_idTextAnchor320)中找到更多关于各种类型图形工具的信息，*自定义和扩展Git*。
- en: Including, formatting, and summing up changes
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包括、格式化和总结更改
- en: You can examine a single revision with the `git show` command, which, in addition
    to the commit metadata, shows changes in the unified diff format, described in
    [*Chapter 2*](B21194_02.xhtml#_idTextAnchor028), *Developing with Git*, in the
    *Unified Git diff format* subsection. Sometimes, however, you might want to display
    changes alongside the selected part of the history in the `git log` output. You
    can do this with the help of the `-p` option. This is very helpful for code review,
    or to quickly browse what happened during a series of commits that a collaborator
    has added.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`git show`命令检查单个修订版本，该命令除了显示提交元数据外，还以统一 diff 格式展示更改，该格式在[*第2章*](B21194_02.xhtml#_idTextAnchor028)中有描述，书名为*使用
    Git 开发*，在*统一 Git diff 格式*小节中有详细介绍。然而，有时你可能希望将更改与所选历史部分一起显示在`git log`输出中。你可以通过使用`-p`选项来实现。这对于代码审查非常有帮助，或者快速浏览合作者在一系列提交中所做的更改。
- en: Ordinarily, Git would not show the changes for a merge commit. To show changes
    from all parents, you need to use the `–c` option (or `–cc` for compressed output),
    while to show changes from each parent individually, use `–m`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Git 不会显示合并提交的更改。要显示来自所有父提交的更改，你需要使用`–c`选项（或者使用`–cc`进行压缩输出），而要显示每个父提交的更改，可以使用`–m`。
- en: 'Sometimes, it’s easier to review changes on the word level rather than on the
    line level. The `git log` accepts various options to change the format of the
    diff output. One of those options is `--word-diff` (with various variants, including
    `color`). This way of viewing differences is useful for examining changes in documents
    (for example, documentation):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在单词级别审查更改比在行级别审查更容易。`git log`接受多种选项来更改 diff 输出的格式。其中一个选项是`--word-diff`（包括各种变体，如`color`）。这种查看差异的方式对于检查文档中的更改（例如文档）非常有用：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Another useful set of options is about ignoring changes in whitespace, including
    `–w` / `--ignore-all-space` to ignore all whitespace changes, and `-b` / `--ignore-space-change`
    to ignore changes in the amount of whitespace.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的选项集是关于忽略空白字符更改的，包括`–w` / `--ignore-all-space`来忽略所有空白字符更改，以及`-b` / `--ignore-space-change`来忽略空白字符的数量变化。
- en: With color support, you can ask Git to show moved code with `--color-moved`,
    possibly ignoring whitespace changes (with `--color-moved-ws`).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持颜色的情况下，你可以要求 Git 使用`--color-moved`来显示移动的代码，并可能忽略空白字符的变化（使用`--color-moved-ws`）。
- en: Sometimes, you are interested only in the summary of changes and not the details.
    There is a series of `diff` summarizing options that you can use. If you want
    to know only which files changed, use `--names-only` (or `--raw --abbrev`). If
    you also want to know how much those files changed, you can use the `--stat` option
    (or perhaps its machine-parse-friendly version, `--numstat`) to see some abbreviated
    stats. If you are interested only in a short summary of changes, use `--shortstat`
    or `--summary`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你只对更改的汇总感兴趣，而不是详细信息。你可以使用一系列`diff`汇总选项。如果你只想知道哪些文件发生了更改，可以使用`--names-only`（或`--raw
    --abbrev`）。如果你还想知道这些文件发生了多少更改，可以使用`--stat`选项（或者它的机器解析友好的版本`--numstat`）来查看一些简要的统计数据。如果你只关心更改的简短总结，可以使用`--shortstat`或`--summary`。
- en: Summarizing contributions
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇总贡献
- en: 'Ever wondered how many commits you’ve contributed to a project? Or, perhaps,
    who the most active developer was during the last month (with respect to the number
    of commits)? Well, wonder no more, because this is what `git shortlog` is good
    for:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 是否曾想过自己为某个项目贡献了多少次提交？或者，或许你想知道在上个月（按提交次数计算），谁是最活跃的开发者？不必再猜测了，因为`git shortlog`就是用来做这个的：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `-s` option squashes all of the commit messages into the number of commits;
    without it, `git shortlog` would list a summary of all the commits, grouped by
    the developer. The `-n` option sorts the list of developers by the number of commits;
    otherwise, it is sorted alphabetically. You can add an `–e` option to also show
    an email address; note, however, that with this option, Git will separate contributions
    made by the same author under different emails. The `git shortlog` output can
    be configured to some extent with a pretty-like `--``format` option.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`-s`选项将所有的提交信息压缩成提交次数的统计；如果没有这个选项，`git shortlog`将列出所有提交的汇总，按开发者分组。`-n`选项按提交次数对开发者列表进行排序；否则，默认按字母顺序排序。你可以添加`–e`选项来显示电子邮件地址；不过请注意，使用此选项时，Git
    会根据不同的电子邮件地址将同一作者的贡献分开。`git shortlog`输出的格式可以通过类似`--format`选项的漂亮配置进行一定程度的调整。'
- en: 'The `git shortlog` command accepts a revision range and other revision-limiting
    options such as `--since=1.month.ago` — anything that `git log` accepts and makes
    sense for `shortlog`. For example, to see who contributed what to the last release
    candidate, you can use the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`git shortlog`命令接受修订版本范围和其他限制修订版本的选项，例如`--since=1.month.ago`——任何`git log`接受并对`shortlog`有意义的选项。例如，要查看谁为最后一个发布候选版做出了贡献，您可以使用以下命令：'
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: One needs to remember that the number of revisions authored is only one way
    of measuring contribution. For example, somebody who creates buggy commits only
    to fix them later would have a larger number of commits than a developer who doesn’t
    make mistakes (or cleans the history before publishing changes).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住，编写的修订版本数量仅是衡量贡献的一种方式。例如，那些只创建有缺陷提交以后再修复它们的人，其提交数量将比不犯错误的开发者多。
- en: There are other measures of programmer productivity — for example, the number
    of changed lines in authored commits, or the number of surviving lines. Those
    can be calculated with the help of Git, but there is no built-in command to calculate
    them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他衡量程序员生产力的方法——例如，作者提交的更改行数，或者幸存行数。这些可以通过Git的帮助进行计算，但没有内置的命令来计算它们。
- en: Mapping authors
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射作者
- en: 'One problem with running `git shortlog –s -n -e` or `git blame` in Git repositories
    of long-running projects is that an author may change their name or email, or
    both, during the course of the project, due to many reasons: changing work (and
    work email), misconfiguration, spelling mistakes, and others. For example, you
    might have `.mailmap` file in the top directory of your project. This file allows
    you to specify *canonical* names for contributors, which in its simplest form
    looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在长期运行的项目中使用`git shortlog –s -n -e`或`git blame`命令时的一个问题是，作者在项目过程中可能会更改他们的姓名或电子邮件，或者两者都会，原因有很多：工作变动（及其工作电子邮件）、配置错误、拼写错误等等。例如，您可能在项目的顶级目录中有一个`.mailmap`文件。此文件允许您为贡献者指定*规范*名称，其最简单的形式如下：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: (Actually, it allows you to specify a canonical name, canonical email, or both
    name and email, matching by email or by name and email.)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: （实际上，它允许您指定规范名称、规范电子邮件，或者名称和电子邮件，通过电子邮件或名称和电子邮件匹配。）
- en: 'By default, those corrections are applied to all commands: `git blame`, `git
    shortlog`, and `git log`. With custom `log` output, you can use placeholders that
    output the original name or corrected name, and the original email or corrected
    email.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些更正会应用于所有命令：`git blame`、`git shortlog`和`git log`。使用自定义`log`输出，您可以使用占位符输出原始名称或更正后的名称，以及原始电子邮件或更正后的电子邮件。
- en: Viewing a revision and a file at revision
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看修订版本和修订版本的文件
- en: Sometimes, you might want to examine a single revision (for example, a commit
    suspected to be buggy, found with `git bisect`) in more detail, together with
    changes and their descriptions. Or, perhaps, you want to examine the tag message
    of an annotated tag together with the commit it points to. Git provides a generic
    `git show` command for this; it can be used for any type of object.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望更详细地检查单个修订版本（例如，使用`git bisect`发现的疑似有缺陷的提交），以及其更改和描述。或者，您可能希望检查带有标记消息的注释标签，以及它指向的提交。Git提供了一个通用的`git
    show`命令；它可以用于任何类型的对象。
- en: 'For example, to examine the grandparent of the current version, you can use
    the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要检查当前版本的父版本，可以使用以下命令：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `git show` command can also be used to display directories (trees) and
    file contents (blobs). To view a file (or a directory), you need to specify where
    it is from (from which revision) and the path to the file, using `:` to connect
    them. For example, to view the contents of the `src/rand.c` file as it was in
    the version tagged `v0.1`, use the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`git show`命令还可用于显示目录（树）和文件内容（blob）。要查看文件（或目录），您需要指定它来自于哪个修订版本，并指定文件的路径，使用`:`连接它们。例如，要查看标记为`v0.1`的版本中`src/rand.c`文件的内容，请使用以下命令：'
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This might be more convenient than checking out the required version of the
    file into the working directory with `git checkout v0.1 -- src/rand.c`. Before
    the colon may be anything that names a commit (`v0.1` here), and after that, it
    may be any path to a file tracked by Git (`src/rand.c` here). The pathname here
    is the full path from the top of the project directory, but you can use `./` after
    the colon for relative paths — for example, `v0.1:./rand.c` if you are in the
    `src/` subdirectory.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能比用`git checkout v0.1 -- src/rand.c`将所需版本的文件检出到工作目录中更方便。在冒号前面可以是任何命名提交的内容（此处为`v0.1`），冒号后面可以是任何Git跟踪的文件路径（此处为`src/rand.c`）。这里的路径名是从项目目录顶部开始的完整路径，但你可以在冒号后使用`./`表示相对路径——例如，如果你在`src/`子目录中，可以使用`v0.1:./rand.c`。
- en: You can use the same trick to compare arbitrary files at arbitrary revisions;
    on the other hand, the `git show :src/rand.c` command (as if with an empty revision)
    will show the state of the file at the time `git add` was run — the state of the
    chosen file in the index (in the staging area).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的技巧比较任意修订版本中的任意文件；另一方面，`git show :src/rand.c`命令（如果没有指定修订版本）会显示`git add`运行时文件的状态——即索引中（暂存区）选定文件的状态。
- en: If you want to find out what files are present at a given revision (to select
    one to examine), you can use `git ls-tree <revision>`. To find out what files
    are present in the worktree and in the index, use `git ls-files` with the appropriate
    option to select what you want to see.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看在给定修订版本中存在哪些文件（以便选择一个进行查看），你可以使用`git ls-tree <revision>`。要查看工作树和索引中存在哪些文件，可以使用`git
    ls-files`并选择适当的选项来查看你想要的内容。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter showed us the various ways of exploring project history: selecting
    and filtering revisions to display, searching through various parts of commit-related
    data, and formatting the output.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们展示了探索项目历史的各种方式：选择和过滤要显示的修订版本，搜索与提交相关的各种数据，并格式化输出。
- en: You have learned how to find all the revisions that were made by a given developer,
    how to search through the commit message and the changes made by the commit, and
    how to narrow the search to a specific range of time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何找出给定开发者所做的所有修订版本，如何通过提交消息和提交所做的更改进行搜索，以及如何将搜索范围缩小到特定的时间段。
- en: 'We can even try to find bugs in the code by exploring the history: finding
    when a function was deleted from the code with a *pickaxe search*, examining a
    file for how its code came to be and who wrote it with `git blame`, and utilizing
    semi-automatic or automatic search through the project history to find which version
    introduced a regression with `git bisect`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过探索历史来尝试找出代码中的bug：通过*撬棍搜索*查找某个函数何时从代码中删除，使用`git blame`检查文件，了解它的代码是如何变成现在这样并且是谁写的，以及通过`git
    bisect`利用半自动或自动化搜索项目历史，找出哪个版本引入了回归。
- en: When examining a revision, we can select the format in which the information
    is shown, even to the point of user-defined formats. There are various ways of
    summarizing the information, from the statistics of the changed files, to the
    statistics of the number of commits per author.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查一个修订版本时，我们可以选择信息展示的格式，甚至可以自定义格式。总结信息的方式有很多种，从更改文件的统计数据，到每个作者提交次数的统计数据。
- en: In the next chapter, we will examine how Git can help developers work together
    as a team on a single project.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究Git如何帮助开发者作为团队在一个项目上协同工作。
- en: Questions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，测试你对本章内容的理解：
- en: How would you list all commits made since yesterday on any remote-tracking branch?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何列出自昨天以来在任何远程跟踪分支上做出的所有提交？
- en: How would you find out who the original author of a given function or class
    was, to ask for clarification or a code review?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何查找给定函数或类的原始作者，以便向他请教或进行代码审查？
- en: How would you use Git to help find the source of regression — that is, a bug
    that is present in the new revision of the project, but was not there in older
    versions?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用Git来帮助找出回归的来源——即在项目的新修订版本中存在的bug，而在旧版本中并不存在？
- en: You have noticed that your colleague made a few commits with a misconfigured
    email, using **bob@laptop.company.com** instead of **bob@company.com**. How would
    you fix the attribution, assuming that it is not possible to rewrite those commits?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你注意到你的同事使用了错误配置的电子邮件做了一些提交，使用了**bob@laptop.company.com**而不是**bob@company.com**。假设无法重写这些提交，你将如何修复归属问题？
- en: Answers
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to the questions given above:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是上述问题的答案：
- en: 'Combine time-limiting options with the **--****remotes** option:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将时间限制选项与**--****remotes**选项结合使用：
- en: '**git log --****since=yesterday --remotes**.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**git log --****since=yesterday --remotes**。'
- en: Use the **git blame** command or an interactive GUI to do this, such as **git
    gui blame** (or an integration with your editor or **integrated development environment**
    (**IDE**); you can also search through the history of the relevant fragment of
    a file with **git** **log -L**.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**git blame**命令或交互式GUI进行操作，如**git gui blame**（或与编辑器或**集成开发环境**（**IDE**）的集成）；你还可以通过**git**
    **log -L**搜索文件相关片段的历史。
- en: Use **git bisect** to find the commit that introduced the bug, perhaps even
    by automating the search with **git** **bisect run**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**git bisect**来找到引入bug的提交，甚至可以通过自动化搜索来使用**git** **bisect run**。
- en: Add the correct name and email to the **.****mailmap** file.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将正确的姓名和电子邮件添加到**.****mailmap**文件中。
- en: Further reading
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本章讨论的更多主题，请查看以下资源：
- en: 'Scott Chacon, Ben Straub, *Pro Git*, 2nd Edition (2014), Apress, *Chapter 7**.5
    Git Tools –* *Searching*: [https://git-scm.com/book/en/v2/Git-Tools-Searching](https://git-scm.com/book/en/v2/Git-Tools-Searching)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scott Chacon, Ben Straub, *Pro Git*, 第二版（2014年），Apress，*第7章 7.5 Git工具–* *搜索*：[https://git-scm.com/book/en/v2/Git-Tools-Searching](https://git-scm.com/book/en/v2/Git-Tools-Searching)
- en: 'Christian Couder, *Fighting regressions with git bisect* (slides from the Linux-Kongress
    2009 conference): [http://www.linux-kongress.org/2009/slides/fighting_regressions_with_git_bisect_christian_couder.pdf](http://www.linux-kongress.org/2009/slides/fighting_regressions_with_git_bisect_christian_couder.pdf)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Christian Couder, *通过git bisect解决回归问题*（2009年Linux-Kongress大会的幻灯片）：[http://www.linux-kongress.org/2009/slides/fighting_regressions_with_git_bisect_christian_couder.pdf](http://www.linux-kongress.org/2009/slides/fighting_regressions_with_git_bisect_christian_couder.pdf)
- en: 'Junio C Hamano, *Fun with first parent history* (2013): [https://git-blame.blogspot.com/2013/09/fun-with-first-parent-history.html](https://git-blame.blogspot.com/2013/09/fun-with-first-parent-history.html)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Junio C Hamano, *与第一父项历史的乐趣*（2013年）：[https://git-blame.blogspot.com/2013/09/fun-with-first-parent-history.html](https://git-blame.blogspot.com/2013/09/fun-with-first-parent-history.html)
- en: 'Junio C Hamano, *Measuring Project Activities (2)* (2013): [https://git-blame.blogspot.com/2013/03/measuring-project-activities-2.html](https://git-blame.blogspot.com/2013/03/measuring-project-activities-2.html)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Junio C Hamano, *衡量项目活动（2）*（2013年）：[https://git-blame.blogspot.com/2013/03/measuring-project-activities-2.html](https://git-blame.blogspot.com/2013/03/measuring-project-activities-2.html)
- en: 'Jan Goyvaerts, *Regular Expressions Tutorial - Learn How to Use and Get The
    Most out of Regular* *Expressions*: [https://www.regular-expressions.info/tutorial.html](https://www.regular-expressions.info/tutorial.html)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jan Goyvaerts, *正则表达式教程 - 学习如何使用并充分利用正则表达式*：[https://www.regular-expressions.info/tutorial.html](https://www.regular-expressions.info/tutorial.html)
