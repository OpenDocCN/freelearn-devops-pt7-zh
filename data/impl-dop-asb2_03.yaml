- en: Installing, Configuring, and Running Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装、配置和运行 Ansible
- en: Ansible is a relatively new addition to the DevOps and Configuration Management
    ecosystem. Its radical simplicity, structured automation format, and no brainer
    development paradigm has caught the eyes of both corporations and startups alike.
    Organizations such as Twitter have managed to successfully leverage Ansible for
    highly scaled deployments and Configuration Management implementations across,
    and have scaled it to manage and deploy to thousands of servers simultaneously.
    Twitter isn't the only player within the Ansible space that has managed to leverage
    Ansible at scale; other well-known organizations that have successfully leveraged
    Ansible include Logitech, NASA, NEC, Microsoft, and hundreds more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是 DevOps 和配置管理生态系统中一个相对较新的成员。它的极简主义、结构化的自动化格式和简单易用的开发范式吸引了众多企业和初创公司的关注。像
    Twitter 这样的组织已经成功地利用 Ansible 进行大规模部署和配置管理的实施，并将其扩展到同时管理和部署到数千台服务器。Twitter 并不是唯一一个在
    Ansible 领域成功大规模应用的公司；其他一些成功利用 Ansible 的知名组织还包括 Logitech、NASA、NEC、Microsoft 等数百家公司。
- en: As it stands today, Ansible is in use by some of the largest and well known
    technology companies and organizations around the world, and is responsible for
    managing thousands of deployments and maintaining the Configuration Management
    solutions for countless organizations. Learning the fundamentals of the Ansible
    solution will provide us with the tools we will need to properly install, configure
    and run Ansible at small and large scales.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，Ansible 已被全球一些最大、最知名的科技公司和组织使用，负责管理数千个部署并为无数组织维护配置管理解决方案。学习 Ansible 解决方案的基础知识将为我们提供适当安装、配置和运行
    Ansible 所需的工具，无论是小规模还是大规模应用。
- en: 'In this chapter, we will formally introduce you to Ansible. Together we will
    learn how to install it, dive into its run-time architectures, and learn how to
    configure it to run simple automation sequences. In addition to these topics,
    we will cover the basics of the Ansible control server under Ubuntu Linux and
    learn how Ansible can be leveraged for local executions as well as remote management.
    Finally in this chapter, we will cover the basic concept of a playbook and discover
    the underlying constructs behind what makes Ansible so powerful. The goals for
    this chapter will be to grasp the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将正式介绍 Ansible。我们将一起学习如何安装它，深入了解其运行时架构，并学习如何配置它以运行简单的自动化序列。除了这些主题，我们还将涵盖在
    Ubuntu Linux 下的 Ansible 控制服务器基础知识，并学习如何利用 Ansible 进行本地执行以及远程管理。最后，在本章中，我们将介绍 playbook
    的基本概念，并探索使 Ansible 如此强大的底层构造。本章的目标是掌握以下内容：
- en: Installing Ansible
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Ansible
- en: The Ansible Architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 架构
- en: The Ansible Command Line Interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 命令行界面
- en: Configuring Ansible
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Ansible
- en: The Ansible Inventory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 清单
- en: Now that we have the introductions out of the way let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了介绍，让我们开始吧！
- en: Installing Ansible
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Ansible
- en: 'Ansible itself is cross-platform. The basic installation of the Ansible system
    is actually fairly easy. Before we can install it, we need to get the Ansible
    runtime packages. Ansible is available for consumption via the following online
    solutions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 本身是跨平台的。Ansible 系统的基本安装其实相当简单。在我们安装它之前，我们需要获取 Ansible 运行时包。Ansible 可以通过以下在线解决方案进行获取：
- en: Yum (Red Hat Linux-based distributions)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yum（基于 Red Hat Linux 的发行版）
- en: Apt (Debian)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apt（Debian）
- en: Apt (Ubuntu)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apt（Ubuntu）
- en: Portage (Gentoo)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Portage（Gentoo）
- en: Pkg (FreeBSD)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pkg（FreeBSD）
- en: macOS (dmg)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS（dmg）
- en: OpenCSW (Solaris)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCSW（Solaris）
- en: Pacman (Arch Linux)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pacman（Arch Linux）
- en: Pip (Python)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pip（Python）
- en: Tarball (Source)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tarball（源码）
- en: Source (Source)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源码（Source）
- en: The following is a set of examples and command-line syntaxes for each of the
    listed options. These commands will help you get up-and-running with Ansible quickly
    (they are taken from the Ansible website).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一组示例和命令行语法，适用于上述列出的每个选项。这些命令将帮助你快速开始使用 Ansible（它们来自 Ansible 官方网站）。
- en: Red Hat Enterprise Linux via Configuration Management
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过配置管理安装 Red Hat Enterprise Linux
- en: 'Installing Ansible on most popular Red Hat Enterprise Linux flavor distributions
    is quite easy. This can be accomplished as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在最流行的 Red Hat Enterprise Linux 发行版上安装 Ansible 非常简单。可以按照以下步骤完成：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Apt for Debian/Apt for Ubuntu
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apt for Debian/Apt for Ubuntu
- en: 'Installing Ansible on Debian or Ubuntu flavor Linux distributions is a breeze.
    This can be accomplished using the Apt package management solution as shown in
    the following commands:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Debian 或 Ubuntu 系列 Linux 发行版上安装 Ansible 非常简单。可以使用 Apt 包管理解决方案，按照以下命令操作：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Porting Ansible to Gentoo
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Ansible 移植到 Gentoo
- en: 'For Gentoo Linux users, installing Ansible can be accomplished fairly easily.
    The following command-line syntax can be leveraged to accomplish the installation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Gentoo Linux 用户，安装 Ansible 可以相当容易地完成。可以使用以下命令行语法来完成安装：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: PKG for FreeBSD
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FreeBSD 的 PKG
- en: 'FreeBSD-specific users can use `pkg install` to install the Ansible control
    server solution and get Ansible up-and-running quickly:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 特定用户可以使用 `pkg install` 来安装 Ansible 控制服务器解决方案，并快速启动 Ansible：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Pip for macOS
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS 上的 Pip
- en: The preferred way to install Ansible for macOS is to use Python's pip installation
    solution. An example of how to do this is provided next.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Ansible 在 macOS 上的首选方法是使用 Python 的 pip 安装方案。以下将提供一个示例，展示如何操作。
- en: 'If needed, you can install `pip` via the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如有需要，你可以通过以下命令安装 `pip`：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once `pip` is installed, you can install Ansible with the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了`pip`，你可以使用以下命令安装 Ansible：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: OpenCSW for Solaris/SunOS
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Solaris/SunOS 的 OpenCSW
- en: 'Solaris users have the ability to install and configure Ansible using the OpenCSW
    package management solution. This solution can be leveraged as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Solaris 用户可以使用 OpenCSW 包管理解决方案安装和配置 Ansible。可以按以下方式操作：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Installing Ansible for Arch Linux is quite simple. The following command should
    help accomplish this task:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arch Linux 上安装 Ansible 非常简单。以下命令应该能帮助完成这一任务：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Via Python pip
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Python pip
- en: 'Prior to installing Ansible using pip we may need to actually install pip.
    To accomplish this on the command line, the following command can be used:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 pip 安装 Ansible 之前，我们可能需要先安装 pip。可以使用以下命令行来完成此操作：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then install Ansible with the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下命令安装 Ansible：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once Ansible has been installed
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一旦 Ansible 安装完成
- en: 'Once Ansible is installed on the desired Linux machine, we will want to verify
    that it is properly installed and functioning. To do this from the command line,
    enter the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Ansible 安装在目标 Linux 机器上，我们需要验证它是否已正确安装并正常运行。为此，请在命令行输入以下命令：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Upon successful execution of these commands, Ansible should output version information
    and related help information respectively.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些命令成功后，Ansible 应该分别输出版本信息和相关帮助信息。
- en: Setting up authentication between the control server and hosts
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置控制服务器与主机之间的认证
- en: When connecting Ansible with remote hosts, Ansible's best practices encourage
    the use of SSH key sharing. SSH keys allow one Linux host to talk to another without
    asking for a specific password. In this section we are going to briefly look at
    how to set SSH key sharing up on the control server and *n* number of target machines.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接 Ansible 与远程主机时，Ansible 的最佳实践建议使用 SSH 密钥共享。SSH 密钥允许一台 Linux 主机与另一台主机通信，而无需特定的密码。在这一部分，我们将简要查看如何在控制服务器和
    *n* 个目标机器上设置 SSH 密钥共享。
- en: If SSH key Sharing is not available Ansible also offers the option to ask for
    a password using the `--ask-become-pass` command-line argument.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SSH 密钥共享不可用，Ansible 还提供了通过 `--ask-become-pass` 命令行参数请求密码的选项。
- en: To get started, create a `/etc/ansible/hosts` (if it doesn't exist) and add
    one or more remote systems into its contents. Your specific public SSH key should
    be located in `authorized_keys` on those target systems.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个 `/etc/ansible/hosts`（如果不存在的话），并将一个或多个远程系统添加到其内容中。你的特定公钥 SSH 密钥应位于这些目标系统的
    `authorized_keys` 文件中。
- en: 'In this brief tutorial we will assume the SSH key authentication solution is
    being used. It helps us avoid having to enter or store raw passwords:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本简短教程中，我们假设使用 SSH 密钥认证方案。它帮助我们避免输入或存储原始密码：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now ping all the nodes (assumes you have an inventory file created):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 ping 所有节点（假设你已经创建了清单文件）：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For a complete documentation set around setting up SSH key sharing in Ubuntu
    the documentation can be found at [http://linuxproblem.org/art_9.html](http://linuxproblem.org/art_9.html).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在 Ubuntu 上设置 SSH 密钥共享的完整文档集，请访问 [http://linuxproblem.org/art_9.html](http://linuxproblem.org/art_9.html)。
- en: The Ansible Architecture
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 架构
- en: Ansible was created with an incredibly flexible and scalable automation engine.
    It allows users to leverage it in many diverse ways and can be adapted to be used
    in the way that best suits your specific needs. Since Ansible is agentless (meaning
    there is no permanently running daemon on the systems it manages or executes from),
    it can be used locally to control a single system (without any network connectivity)
    or leveraged to orchestrate and execute automation against many systems, via a
    control server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible创建时便具备了一个非常灵活且可扩展的自动化引擎。它允许用户以多种不同的方式进行使用，并且可以根据用户的特定需求进行调整。由于Ansible没有代理（这意味着在它管理或执行的系统上没有长期运行的守护进程），它可以本地使用来控制单个系统（无需网络连接），或者通过控制服务器来协调和执行多个系统的自动化。
- en: In addition to the aforementioned architectures, Ansible can also be leveraged
    via Vagrant or Docker to provision infrastructure automatically. This type of
    solution basically allows Ansible users to bootstrap their hardware or infrastructure
    provisioning by running one or more Ansible playbooks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述架构外，Ansible还可以通过Vagrant或Docker来自动化配置基础设施。这种解决方案基本上允许Ansible用户通过运行一个或多个Ansible剧本来启动他们的硬件或基础设施配置。
- en: 'If you happen to be a Vagrant user, there are instructions within the HashiCorp
    Ansible provisioning located at the following URL: [https://www.vagrantup.com/docs/provisioning/ansible.html](https://www.vagrantup.com/docs/provisioning/ansible.html).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你恰好是Vagrant用户，HashiCorp的Ansible配置说明可以在以下网址找到：[https://www.vagrantup.com/docs/provisioning/ansible.html](https://www.vagrantup.com/docs/provisioning/ansible.html)。
- en: As we mentioned briefly, Ansible is open source, module-based, pluggable, and
    agentless. These key differentiators from other Configuration Management solutions
    give Ansible a significant edge. Let's take a look at each of these differentiators
    in detail and see what it actually means for Ansible developers and users.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们简要提到的，Ansible是开源的、基于模块的、可插拔的并且没有代理。与其他配置管理解决方案的这些关键差异使得Ansible具有显著的优势。让我们详细看看这些差异，并了解它们对Ansible开发者和用户意味着什么。
- en: Open source
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开源
- en: It is no secret that successful open source solutions are usually extraordinarily
    feature-rich. This is because, instead of a simple eight-person (or even 100-person)
    engineering team, there are potentially thousands of developers. Each development
    and enhancement has been designed to fit a unique need. As a result, the end deliverable
    product provides consumers of Ansible with a very well-rounded solution that can
    be adapted or leveraged in numerous ways.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的开源解决方案通常具有丰富的功能，这已经不是什么秘密。这是因为，除了简单的八人（甚至100人的）工程团队外，可能还有成千上万的开发者参与其中。每个开发和增强功能的设计都旨在满足特定需求。因此，最终交付的产品为Ansible的用户提供了一个非常全面的解决方案，可以以多种方式进行适应或利用。
- en: Module-based
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模块
- en: 'Ansible has been developed for integration with numerous other open and closed
    source software solutions. This idea means that Ansible is currently compatible
    with multiple flavors of Linux, Windows, and cloud providers. Aside from its OS-level
    support, Ansible currently integrates with hundreds of other software solutions:
    EC2, JIRA, Jenkins, Bamboo, Microsoft Azure, DigitalOcean, Docker, Google, and
    many more.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible已经开发与众多其他开源和闭源软件解决方案的集成。这个理念意味着Ansible目前兼容多种Linux版本、Windows操作系统以及云服务提供商。除了操作系统层面的支持外，Ansible目前还与数百种其他软件解决方案集成：EC2、JIRA、Jenkins、Bamboo、Microsoft
    Azure、DigitalOcean、Docker、Google等。
- en: "For a complete list of Ansible modules, consult the official Ansible module\
    \ support list located at the following URL: [http://docs.ansible.com/ansible/modules_by_category.html](http://docs.ansible.com/ansible/modules_by_category.html)\uFEFF\
    ."
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 若要查看完整的Ansible模块列表，请参考以下官方Ansible模块支持列表：[http://docs.ansible.com/ansible/modules_by_category.html](http://docs.ansible.com/ansible/modules_by_category.html)。
- en: Agentless
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无代理
- en: One of the key differentiators that gives Ansible an edge against the competition
    is the fact that it is completely agentless. This means there are no daemons that
    need to be installed on remote machines, no firewall ports that need to be opened
    (besides traditional SSH), no monitoring that needs to be performed on remote
    machines, and no management that needs to be performed on the infrastructure fleet.
    In effect, this makes Ansible very self-sufficient.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible相较于竞争对手的一大优势是它完全没有代理。这意味着不需要在远程机器上安装守护进程，不需要打开防火墙端口（除了传统的SSH），不需要在远程机器上进行监控，也不需要对基础设施进行管理。实际上，这使得Ansible非常自给自足。
- en: Since Ansible can be implemented in a few different ways, the aim of this section
    is to highlight these options and help get us familiar with the architecture types
    that Ansible supports. Generally, the architecture of Ansible can be categorized
    into three distinct architecture types. These are described next.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Ansible 可以通过几种不同的方式实现，本节的目标是突出这些选项，并帮助我们熟悉 Ansible 支持的架构类型。一般来说，Ansible 的架构可以分为三种不同的架构类型。接下来将描述这三种类型。
- en: Pluggable
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可插拔
- en: While Ansible comes out-of-the-box with a wide spectrum of software integration
    support, it is oftentimes a requirement to integrate the solution with a company-based
    internal software solution or a software solution that has not already been integrated
    into Ansible's robust playbook suite. The answer to such a requirement would be
    to create a plugin-based solution for Ansible, thus providing the custom functionality
    necessary.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Ansible 自带广泛的软件集成支持，但它通常需要与公司内部的软件解决方案或尚未集成到 Ansible 强大 playbook 套件中的软件解决方案进行集成。解决这种需求的办法是为
    Ansible 创建基于插件的解决方案，从而提供必要的定制功能。
- en: Local automation execution using Ansible
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 执行本地自动化
- en: The easiest way to leverage Ansible is to instruct it to manage a local system.
    This means there is no need for SSH connections or port openings or SSH key sharing
    to be done. This implementation simply involves one user, a set of playbooks (or
    one), and a local system. Local automation execution is the scenario in which
    Ansible is leveraged to execute a playbook (a series of automation tasks) against
    a local machine. This specific architecture type means that Ansible does not need
    an available network connection or internet connection for it to perform its work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Ansible 的最简单方式是指示它管理本地系统。这意味着无需进行 SSH 连接、端口打开或共享 SSH 密钥。这种实现只需要一个用户、一组 playbook（或一个）和一个本地系统。地方自动化执行是指通过
    Ansible 执行一个 playbook（即一系列自动化任务）以针对本地机器执行任务。这种特定的架构类型意味着 Ansible 在执行工作时不需要可用的网络连接或互联网连接。
- en: 'This architecture type is diagrammed next:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构类型的示意图如下：
- en: '![](img/02a14c66-a572-400a-b83a-d16a907c27d1.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02a14c66-a572-400a-b83a-d16a907c27d1.png)'
- en: 'As we can see from the diagram, Ansible can be used for local provisioning.
    This architecture may seem a bit unscalable, but with a bit of creativity, there
    is a significant amount of power behind this specific architecture. Let''s take
    a look at some of the various ways in which this specific architecture can be
    applied:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中我们可以看出，Ansible 可以用于本地配置。这种架构可能看起来有些不可扩展，但通过一些创意，这种特定架构背后隐藏着强大的能力。我们来看看这种架构可以应用的几种方式：
- en: 'To locally provision a development environment and configure it to be a single
    click setup: ideally with this approach, Ansible playbooks will be written and
    stored in the local development source control system and then leveraged by new
    developers to setup and configure their development environments. This will save
    a significant amount of time on-boarding and getting an employee started.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地配置开发环境并将其配置为一键设置：理想情况下，采用这种方法时，Ansible 的 playbook 将编写并存储在本地开发源代码控制系统中，然后由新开发人员利用这些
    playbook 来设置和配置他们的开发环境。这将大大节省入职培训的时间，并帮助员工快速启动。
- en: 'To enforce local infrastructure-provisioning rules and revert changes made
    to the system that were done out of band: this solution would be ideal for enforcing
    infrastructure that gets tampered with or altered accidentally.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制执行本地基础设施配置规则并恢复系统中因外部操作而做出的更改：这种解决方案非常适合用于防止基础设施被篡改或意外更改的情况。
- en: To execute a set of timed automations that could be leveraged to perform automated
    routines.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一组定时自动化任务，可用于执行自动化例程。
- en: 'As we can see from the architecture, Ansible''s local execution gives us the
    ability to execute a playbook against a localized system without any fuss or complexity.
    Let''s take a quick look at how to run an Ansible playbook against a local system
    using the command line. To begin though, let''s learn how to run an ad hoc command
    against a local system. The example is provided as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构中我们可以看出，Ansible 的本地执行让我们能够在没有任何麻烦或复杂性的情况下，针对本地化的系统执行 playbook。让我们快速了解如何使用命令行在本地系统上运行
    Ansible playbook。但首先，我们来学习如何在本地系统上运行一个临时命令。以下是示例：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The command simply tells Ansible to target all systems in the ad hoc inventory
    implementation (which in our simple use case is only localhost), then execute
    the command `echo "hello DevOps world"` against this system. Simple, right? Now
    let''s take a look at how this same implementation might look if it were in Ansible
    playbook form. An example of this in playbook form is provided as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令只是告诉 Ansible 以目标是临时清单中所有系统（在我们的简单用例中，只有 localhost）为准，然后对该系统执行命令 `echo "hello
    DevOps world"`。简单吧？现在，让我们看一下如果它以 Ansible playbook 形式呈现时会是什么样子。以下是这个 playbook 形式的示例：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This example represents a very simple Ansible playbook. Ansible playbooks are
    written in **Yet Another Markup Language** (**YAML**). They are intended to be
    easy to read, easy to write, highly structured, and without complexity. The idea
    of a *playbook* in the Ansible world comes from the playbook one might receive
    when attending a broadway show. Playbooks describe in brief the upcoming scenes
    and actors. As such, Ansible playbooks also contain a list of upcoming events
    (defined as tasks, and the details of those events). In our simple example, we
    are telling Ansible to instruct the Linux shell (on the target system(s)) to display
    a simple introductory message: `hello DevOps world`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代表了一个非常简单的 Ansible playbook。Ansible playbook 是用 **Yet Another Markup Language**（**YAML**）编写的。它们旨在易读、易写、结构化高且没有复杂性。在
    Ansible 的世界中，*playbook* 的概念来源于人们在观看百老汇演出时可能收到的节目单。Playbook 简要描述了即将上演的场景和演员。因此，Ansible
    playbook 也包含了即将发生的事件列表（定义为任务及其详细信息）。在我们这个简单的示例中，我们指示 Ansible 向 Linux shell（在目标系统上）显示一个简单的介绍信息：`hello
    DevOps world`。
- en: 'At this point, you may be wondering, *how does one run such a playbook?* I''m
    glad you asked. Playbooks can be run from the command line by specifying the playbook
    name. An example of this is provided here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会想，*怎么运行这样的 playbook 呢？* 很高兴您问了。可以通过命令行指定 playbook 名称来运行 playbook。以下是一个示例：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next let's take a look at remote automation execution. This methodology is significantly
    different from local execution as it allows for much larger scalability support.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下远程自动化执行。这种方法与本地执行有显著不同，因为它支持更大的扩展性。
- en: Remote automation execution using Ansible
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 进行远程自动化执行
- en: The most popular use of Ansible is through remote execution. This architecture
    requires a network connection and SSH or Windows remoting. By using remote execution,
    we are essentially instructing Ansible to reach out over SSH to one or many machines,
    authenticate using a previously shared SSH or RM key, create a temporary TCP connection
    to one or more remote machines, and execute a set of playbook-based automations
    against them. If this sounds a bit confusing, let's take a look in depth at how
    this architecture and automation solution works.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 最常见的使用方式是通过远程执行。这种架构需要网络连接和 SSH 或 Windows 远程连接。通过使用远程执行，我们实际上是在指示 Ansible
    通过 SSH 连接到一个或多个机器，使用之前共享的 SSH 或 RM 密钥进行身份验证，建立到一个或多个远程机器的临时 TCP 连接，并针对它们执行一组基于
    playbook 的自动化任务。如果这听起来有些混乱，接下来我们将深入了解这种架构和自动化解决方案是如何工作的。
- en: To begin with, as a local administrator, we will need to pre-authorize the preferred
    Ansible user with the target machines. By doing this pre-authentication, we are
    essentially (most commonly through SSH key sharing) configuring at least two Linux-oriented
    machines (the control and the target) with the permissions needed for the control
    server to communicate with and control the target machine without further authorization.
    Details on how to perform a basic SSH key-sharing implementation are covered later
    in this chapter (or can be found at [http://docs.ansible.com/ansible/intro_getting_started.html](http://docs.ansible.com/ansible/intro_getting_started.html)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，作为本地管理员，我们需要先对目标机器授权给首选的 Ansible 用户。通过这个预授权，实际上我们（通常通过 SSH 密钥共享）正在为至少两台面向
    Linux 的机器（控制机和目标机）配置所需的权限，使得控制服务器能够与目标机器进行通信并控制它，而无需进一步授权。本章稍后会详细介绍如何执行基本的 SSH
    密钥共享实现（或可以参考 [http://docs.ansible.com/ansible/intro_getting_started.html](http://docs.ansible.com/ansible/intro_getting_started.html)）。
- en: Once key sharing has been implemented and has been verified as working, Ansible
    can effectively take control of the remote systems and execute automation against
    them. This is accomplished through a nifty self-installation solution provided
    by Ansible. Effectively, the Ansible automation system (upon execution) will copy
    itself over to the remote system, install itself on the remote system, run a specified
    set of playbooks on the target system, verify the results of the execution, and
    delete itself (and the playbook) from the target system. This leaves the system
    in the desired state without the need to maintain a running daemon on the target
    system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦密钥共享已实现并验证有效，Ansible 就能有效地控制远程系统并对其执行自动化操作。这个过程是通过 Ansible 提供的巧妙自安装方案实现的。实际上，Ansible
    自动化系统（执行时）会将自身复制到远程系统，安装到远程系统上，在目标系统上运行指定的 playbook，验证执行结果，并从目标系统中删除自己（以及 playbook）。这样，系统就处于所需状态，而无需在目标系统上维持一个常驻守护进程。
- en: 'The remote automation execution architecture can be seen via the following
    illustration:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 远程自动化执行架构可以通过以下插图看到：
- en: '![](img/e474c377-cd57-4561-a3b0-d0e493e60f31.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e474c377-cd57-4561-a3b0-d0e493e60f31.png)'
- en: As we can see from the previous diagram, the Linux control server (running Ansible)
    uses a set of secure protocols (**SSH** and **Windows RM** respectively) to control,
    automate, and configure the remote systems. These automation executions happen
    in parallel, meaning that Ansible has the ability to simultaneously control between
    1 and 10,000 machines without a significant degradation in performance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的图示中看到的，运行 Ansible 的 Linux 控制服务器使用一组安全协议（**SSH** 和 **Windows RM**）来控制、自动化和配置远程系统。这些自动化执行是并行进行的，意味着
    Ansible 能够同时控制从 1 台到 10,000 台机器，而性能几乎没有显著下降。
- en: Now that we have a good idea of how a remote execution architecture works, let's
    take a look at a couple of examples. Ansible (as we discovered in the previous
    section) leverages playbooks to manage human-readable automation. In this first
    example, we will need two machines, both Linux based, with Ansible installed on
    the control server (see the previous diagram for which machine is the control
    server), and a target server with SSH keys shared so that the control server can
    properly control or manage the target.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对远程执行架构有了一个较好的了解，接下来我们来看看几个例子。Ansible（正如我们在前一节中发现的）通过 playbook 来管理人类可读的自动化。在这个第一个例子中，我们需要两台机器，都是基于
    Linux 的，控制服务器上安装了 Ansible（参见前面的图示，了解哪台机器是控制服务器），并且目标服务器共享 SSH 密钥，这样控制服务器才能正确控制或管理目标服务器。
- en: 'Now to create a playbook, simply edit a file title `hellodevopsworld.yml` and
    paste the following lines of code into it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要创建一个 playbook，只需编辑一个名为 `hellodevopsworld.yml` 的文件，并将以下代码粘贴进去：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Save the file onto disk, in a location you prefer (we chose `/opt/hellodevopsworld.yml`).
    Next we will need to identify the IP address or `HOSTNAME/FQDN` of the target
    machine and run the playbook. For this example our target host is on `192.168.10.10`.
    Now let''s run the playbook against the target machine from the control server:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存到磁盘，选择一个你喜欢的位置（我们选择了 `/opt/hellodevopsworld.yml`）。接下来，我们需要确定目标机器的 IP 地址或
    `HOSTNAME/FQDN`，然后运行 playbook。对于本例，目标主机的地址是 `192.168.10.10`。现在，让我们从控制服务器运行 playbook
    以操作目标机器：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From this command, we should see Ansible execute the `hellowdevopsworld` playbook
    against the target machine (`192.168.10.10`) and the execution should output `hellodevopsworld`
    to the command-line interface. The following is the output we should see from
    the executions provided through Ansible:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个命令中，我们应该看到 Ansible 执行 `hellowdevopsworld` playbook，针对目标机器（`192.168.10.10`）进行操作，执行结果应该输出
    `hellodevopsworld` 到命令行界面。以下是我们应该从 Ansible 执行过程中看到的输出：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By default Ansible is configured to to execute *all* automations in parallel.
    This can be altered by specifying the `--limit` option on the command line, which
    allows the administrator to limit the number of parallel executions to a specific
    number. This can be handy when you need to be able to debug a playbook or restrict
    the number of simultaneous executions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible 配置为并行执行 *所有* 自动化任务。通过在命令行上指定 `--limit` 选项，可以修改这一行为，允许管理员限制并行执行的数量。这在你需要调试
    playbook 或限制同时执行的数量时非常有用。
- en: Container-oriented automation
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向容器的自动化
- en: 'Container-oriented automation is similar to local automation execution, although
    it leverages the Configuration Management and automation execution capabilities
    of Ansible on the container. This architecture is slightly different from the
    others in the sense that it does not rely on Ansible being installed on a given
    host or container prior to the execution of a playbook but rather installs Ansible
    on-the-fly (during the provisioning phase of the container) and then executes
    a playbook once Ansible is installed. As a result, the flow of automation would
    be better represented through a flow diagram:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 面向容器的自动化类似于本地自动化执行，尽管它利用了 Ansible 在容器中的配置管理和自动化执行能力。与其他架构略有不同的是，它并不依赖于在执行 playbook
    之前在指定主机或容器上安装 Ansible，而是通过即时安装 Ansible（在容器的配置阶段）并在安装后执行 playbook。因此，自动化流程的最佳表示方式是通过流程图来展示：
- en: '![](img/6aca378f-bdbe-4297-a7b6-8f00d4f1422a.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6aca378f-bdbe-4297-a7b6-8f00d4f1422a.png)'
- en: Container-oriented automation can be especially useful for provisioning environments
    (development, testing, production, and so on) as well as helping get developers
    up and running quickly. Let's take a look at a quick Vagrant setup using Ansible
    as the bootstrapping solution within the VM.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 面向容器的自动化特别适用于环境的配置（如开发、测试、生产等），同时也能帮助开发人员快速启动。让我们来看一下一个使用 Ansible 作为虚拟机内引导解决方案的快速
    Vagrant 设置。
- en: 'To begin, let''s log in to our local machine as the `root` user and create
    a directory setup to hold our local infrastructure. In this example, we are using
    a macOS machine with VirtualBox and Vagrant ([https://www.vagrantup.com/about.html](https://www.vagrantup.com/about.html))
    installed (and while these instructions are macOS-specific, they can be applied
    to Windows machines quite easily as well):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们以 `root` 用户身份登录到本地机器，并创建一个目录来存放我们的本地基础设施。在这个示例中，我们使用的是安装了 VirtualBox 和
    Vagrant 的 macOS 机器（[https://www.vagrantup.com/about.html](https://www.vagrantup.com/about.html)），虽然这些步骤是针对
    macOS 的，但同样可以很容易地应用到 Windows 机器上：
- en: 'Create a directory, which will house our project, and change into it:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录，用于存放我们的项目，并进入该目录：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Initialize Vagrant using the `vagrant init` command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`vagrant init`命令初始化 Vagrant：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Edit the newly created `Vagrantfile`, which should be now located at `~/Desktop/helloVagrantAnsible/Vagrantfile`,
    to reflect what is shown here (taken from the Ansible website):'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑新创建的`Vagrantfile`，它应该位于`~/Desktop/helloVagrantAnsible/Vagrantfile`，并根据此处展示的内容进行修改（内容取自
    Ansible 网站）：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see from the `Vagrantfile`, we are essentially configuring Vagrant
    to fire up and execute `playbook.yml` upon the initial fire-up. This implementation
    once understood is incredibly powerful as it provides us with a way of bootstrapping
    an infrastructure solution with Ansible as its provisioner. This implementation
    is ideal for developers or quality assurance engineers as it provides them with
    a way of storing their infrastructure as code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Vagrantfile` 中我们可以看到，实际上我们是在配置 Vagrant 以便在初次启动时执行 `playbook.yml`。一旦理解了这种实现，它非常强大，因为它为我们提供了一种使用
    Ansible 作为配置工具来引导基础设施解决方案的方式。这种实现非常适合开发人员或质量保证工程师，因为它为他们提供了将基础设施作为代码存储的方法。
- en: 'Now that we have our `Vagrantfile`, let''s create `playbook.yml` in the same
    directory as the `Vagrantfile`. Its contents should reflect the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Vagrantfile`，接下来让我们在与`Vagrantfile`相同的目录中创建`playbook.yml`。其内容应如下所示：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This playbook (as you may have guessed) simply installs Apache2 on the Ubuntu
    system we defined in our `vagrant init` command and tells Ansible to provision
    it with Apache enabled as a system service at boot.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 playbook（如你所猜测的）仅仅是在我们在`vagrant init`命令中定义的 Ubuntu 系统上安装 Apache2，并告诉 Ansible
    在启动时将 Apache 作为系统服务进行配置。
- en: 'The final step in this tutorial is to simply run our Vagrant setup by typing
    the following command into our command-line window:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的最后一步就是通过在命令行窗口中输入以下命令来运行我们的 Vagrant 设置：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If everything was successful, you should be able to see your local Apache instance
    running within the VirtualBox provisioned and running through Vagrant.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该能看到本地的 Apache 实例在通过 Vagrant 配置并运行的 VirtualBox 中运行。
- en: The Ansible Command-Line Interface
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 命令行界面
- en: Ansible provides a robust command-line interface, which provides users with
    the ability to run Ansible playbooks, simulate the execution of Ansible playbooks,
    run ad hoc commands, and much more. In the Ansible galaxy (more to come on that
    specific pun later in the book), there are two specific types of Ansible commands
    that can be run. The `ansible` command allows users to run ad hoc commands, whereas
    the `ansible-playbook` command allows the user to execute a set of Ansible playbook
    instructions against the targeted infrastructure.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 提供了一个强大的命令行界面，允许用户运行 Ansible playbook、模拟 Ansible playbook 的执行、运行临时命令等。在
    Ansible galaxy（稍后会对这个特定的双关语进行解释）中，有两种可以执行的 Ansible 命令类型。`ansible` 命令允许用户运行临时命令，而
    `ansible-playbook` 命令则允许用户针对目标基础设施执行一组 Ansible playbook 指令。
- en: This is ambiguous within the documentation, Ansible and Ansible-playbook appear
    to be symlinks but there are some reports of different functionality between the
    two. More research is needed before final drafting to ensure accuracy of information
    reported. For now, there will be a section for Ansible and Ansible-playbook (provided
    in the following sections) but these may change going forward.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 文档中对此表述模糊，Ansible 和 Ansible-playbook 似乎是符号链接，但有一些报告显示两者的功能不同。为了确保所报告信息的准确性，仍然需要更多的研究。在最终草拟前，Ansible
    和 Ansible-playbook 将各自有一节（稍后部分提供），但这些内容可能会有所更改。
- en: The Ansible command-line interface is the gateway into the heart of Ansible
    and provides a wide array of options and configurable switches that will help
    you gain the most out of Ansible. Let's take a quick tour of the Ansible command-line
    interface and see what the available switches and knobs do.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 命令行界面是进入 Ansible 核心的门户，提供了多种选项和可配置的开关，帮助用户充分利用 Ansible。让我们快速浏览一下 Ansible
    命令行界面，看看有哪些可用的开关和按钮。
- en: 'Usage: ansible <host-pattern> [options]'
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用法：ansible <主机模式> [选项]
- en: In this section we are going to take a look at the Ansible command-line patterns
    and see how they function. The implementation of the command line solution for
    Ansible is actually quite easy to understand. Let's take a look at a couple of
    easy examples.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将看看 Ansible 命令行模式，并了解它们的工作原理。Ansible 的命令行解决方案实现实际上很容易理解。让我们来看几个简单的例子。
- en: 'The `--help` option will display a complete list of available command-line
    options. This is probably one of the most important command-line options within
    the Ansible CLI:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`--help` 选项会显示可用命令行选项的完整列表。这可能是 Ansible CLI 中最重要的命令行选项之一：'
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we know how to use the `help` command let''s take a look at the `version`
    command. This command-line argument provides us with the version information for
    the Ansible installation we are using:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何使用 `help` 命令，让我们来看一下 `version` 命令。这个命令行参数为我们提供了正在使用的 Ansible 安装的版本信息：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `ansible --version` command will output the version information for the
    installed copy of Ansible. For example, you might see something like the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible --version` 命令会输出安装的 Ansible 副本的版本信息。例如，你可能会看到类似如下内容：'
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we understand the `version` command, let''s see how to check our playbook''s
    syntax and perform a test run of our playbook. This is accomplished through the
    `--check` option:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了 `version` 命令，让我们看看如何检查我们的 playbook 语法并执行 playbook 的测试运行。这是通过 `--check`
    选项完成的：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This command-line option allows you to see what some of the changes Ansible
    would have made would potentially be. This is a great way to simulate the execution
    of a playbook and is a wise first step before actually running one:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令行选项允许你查看 Ansible 在执行 playbook 时可能做出的更改。这是模拟 playbook 执行的好方法，是在实际运行之前的明智第一步：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Specifying an inventory on the command line is important. It is accomplished
    via the `-inventory-file` parameter. This command-line parameter allows us to
    specify a comma-separated list of hostnames that will be targeted by the execution
    of the playbook. This command line allows you to specify a path location to an
    Ansible inventory file (in YAML format). Inside it, you can specify the hostnames
    and groups that combined make up your infrastructure inventory (the host''s Ansible
    will be targeted during execution):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中指定清单是非常重要的。它是通过 `-inventory-file` 参数完成的。这个命令行参数允许我们指定一个逗号分隔的主机名列表，执行 playbook
    时将会针对这些主机进行操作。这个命令行允许你指定一个 Ansible 清单文件的路径（YAML 格式）。在其中，你可以指定主机名和组成你基础设施清单的主机组（Ansible
    会在执行过程中针对这些主机进行操作）：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This command-line option instructs Ansible to display a list of targeted hosts
    for this execution. This can be useful when you have a large number of hosts separated
    into groups and you only want to target a subset of those hosts:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令行选项指示 Ansible 显示此次执行的目标主机列表。如果你有大量主机，并将它们分组管理，而你只想针对其中一部分主机进行操作，这个选项会非常有用：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This command-line option instructs Ansible to condense all logging output to
    one line. This includes the facts-gathering processes, task execution output,
    and all `STDOUT` output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令行选项指示 Ansible 将所有日志输出压缩成一行。这包括事实收集过程、任务执行输出以及所有 `STDOUT` 输出：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This command-line option instructs Ansible to pipe all output to a specific
    file instead of the traditional console location. Output in the file specified
    will be concatenated in the file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令行选项指示 Ansible 将所有输出重定向到一个特定的文件，而不是传统的控制台位置。指定文件中的输出将会被追加到该文件中：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This command-line option instructs Ansible to perform a syntax check on the
    specified playbook instead of executing it. This is useful for developers who
    want to ensure their playbook is in valid YAML format prior to execution:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令行选项指示 Ansible 对指定的 playbook 进行语法检查，而不是执行它。对于开发者来说，在执行之前确保 playbook 是有效的
    YAML 格式非常有用：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This command-line option instructs Ansible to override the default timeout
    (in seconds) from 10 to another number:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令行选项指示 Ansible 将默认超时时间（秒）从 10 秒更改为其他数值：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This command-line option instructs Ansible to use a remote user login instead
    of the default SSH shared keys approach when connecting to remote hosts. This
    can be useful if SSH access is not allowed when connecting to some hosts:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令行选项指示 Ansible 在连接远程主机时使用远程用户登录，而不是默认的 SSH 共享密钥方式。如果某些主机不允许通过 SSH 连接，这个选项会很有用：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This command-line option instructs Ansible to add verbose logging to the output
    of the execution. This is handy when debugging specific host issues or odd behavior
    that isn''t expected from traditional execution:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令行选项指示 Ansible 在执行输出中添加详细日志。在调试特定主机问题或异常行为时，这非常有用，尤其是在传统执行方式下无法预见到这些问题：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For additional command-line options, consult the Ansible CLI online help or
    documentation. Additional online help can be found at [http://www.ansible.com](http://www.ansible.com).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多命令行选项，请参考 Ansible CLI 在线帮助或文档。更多在线帮助可以在 [http://www.ansible.com](http://www.ansible.com)
    查找。
- en: Ansible command-line examples
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 命令行示例
- en: 'Now that we have a pretty good understanding of the various knobs that the
    Ansible command line provides, let''s take a look at a few examples of how to
    use them to enhance the execution of a playbook. The following examples show some
    basic ways in which Ansible can be leveraged to run:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Ansible 命令行提供的各种参数有了相当清晰的理解，接下来让我们看一些示例，展示如何利用这些选项来增强 playbook 的执行。以下示例展示了
    Ansible 执行的一些基本方式：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Configuring Ansible
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Ansible
- en: 'Ansible maintains a central configuration file, which is used to instruct Ansible
    on how to behave. Ansible''s primary configuration file should be located (for
    most Linux distributions) at the following location:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 维护一个中央配置文件，用来指示 Ansible 在运行时如何行为。Ansible 的主要配置文件应该位于（对于大多数 Linux 发行版）以下位置：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This configuration file instructs Ansible on how to behave at runtime. During
    the pre-startup sequences of Ansible's execution, the configuration file is loaded
    into memory and sets a number of environmental flags. These flags and configuration
    options can help you customize the Ansible runtime. The following configuration
    is a snapshot of the `ansible.cfg` file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件指示 Ansible 在运行时如何行为。在 Ansible 执行的预启动序列中，配置文件会被加载到内存中，并设置一系列环境标志。这些标志和配置选项可以帮助你定制
    Ansible 的运行时行为。以下配置是 `ansible.cfg` 文件的快照。
- en: Nearly all Ansible configuration options can be overridden via modifications
    in a playbook. Changes to this configuration file will give you the ability to
    set base functionality/configuration.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有 Ansible 配置选项都可以通过在 playbook 中进行修改来覆盖。对该配置文件的更改将使你能够设置基础功能/配置。
- en: The Ansible configuration file has a pretty detailed set of documentation items
    associated with each configurable option available. As such, it would be redundant
    to provide a complete configuration file walk-through within this section. Instead,
    let's take a look at the more commonly tweaked configuration options.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 配置文件包含与每个可配置选项相关的详细文档项目。因此，在本节中提供完整的配置文件讲解会显得多余。相反，我们来看看一些常见的可调整配置选项。
- en: Common base configuration items
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的基础配置项
- en: 'The most common base configuration items are predefined within Ansible; these
    values however can be overridden through the `ansible.cfg` file and customized
    to suit your specific needs. To override any one of them, simply uncomment the
    line (by removing the `#` symbol in front). These configuration items are provided
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的基础配置项已在Ansible中预定义；然而，这些值可以通过`ansible.cfg`文件覆盖并自定义以满足您的特定需求。要覆盖其中任何一项，只需取消注释该行（即删除行前的`#`符号）。这些配置项如下所示：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In addition to the base configuration overrides, Ansible has a few other interesting
    configuration tweaks that can be made to the base installation that provide some
    level of flexibility in its operational functionality.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基础配置覆盖，Ansible还提供了一些其他有趣的配置调整，可以对基础安装进行修改，从而提供一定程度的灵活性，以支持其操作功能。
- en: 'Disable host key checking (useful for auto provisioning new systems) by using
    this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用以下内容禁用主机密钥检查（对于自动配置新系统很有用）：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'By default, the system is configured to run Ansible playbooks as `root`; however,
    this is not always desirable. To alter this, simply uncomment the following line
    and specify the user you would like to use instead:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，系统配置为以`root`身份运行Ansible playbook；然而，这并不总是理想的。要更改此设置，只需取消注释以下行并指定您希望使用的用户：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Sometimes disabling logging is a good thing (for those with limited space options).
    To disable logging, change the following configuration item:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时禁用日志记录是一个好主意（对于那些空间有限的用户）。要禁用日志记录，请更改以下配置项：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The Ansible Inventory
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible库存
- en: Ansible maintains a central configuration file, which is used to identify and
    maintain the infrastructure identifications. This inventory file allows the Ansible
    administrator/ playbook to easily list, group, and target infrastructure items
    during execution. The default Ansible inventory file created (upon installation
    of Ansible) is `/etc/ansible/hosts`. Inside it are a few examples of basic inventory
    grouping structures and organizational categories for infrastructure.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible维护一个中央配置文件，用于标识和维护基础设施标识。这个库存文件使Ansible管理员/playbook能够在执行过程中轻松列出、分组并定位基础设施项。默认的Ansible库存文件（在安装Ansible时创建）是`/etc/ansible/hosts`。其中包含一些基础的库存分组结构示例和基础设施的组织类别。
- en: 'In general, the Ansible inventory file can be leveraged to organize hosts in
    a couple of specific ways: as a set of defined groups, or as a set of defined
    infrastructure pieces (loosely defined and not in a specific group). The inventory
    file can leverage either of the previously described methods or a combination
    of the two. Let''s look in greater detail on how these two inventory organization
    systems operate.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Ansible库存文件可以通过几种特定方式来组织主机：作为一组定义的组，或作为一组定义的基础设施项（松散定义且不在特定组中）。库存文件可以利用前面描述的任何方法，或两者的组合。让我们更详细地了解这两种库存组织系统如何运作。
- en: Defined inventory groups
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已定义的库存组
- en: 'Ansible provides a robust and feature-rich mechanism for managing the information
    related to the infrastructure it controls. Specifically, inventory files can be
    created to define the infrastructure that will be managed by Ansible. An Ansible
    inventory file as you may have guessed is also in YAML format. Inventory items
    (such as servers or devices) are typically defined within the inventory file and
    are often organized into logically respective groups. An example of these types
    of groups (with inventory items defined within) is shown within the following
    code block:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了一种强大且功能丰富的机制，用于管理与其控制的基础设施相关的信息。具体来说，可以创建库存文件来定义将由Ansible管理的基础设施。如您所料，Ansible的库存文件也是YAML格式的。库存项（如服务器或设备）通常在库存文件中定义，并且通常会组织成逻辑上相关的组。以下代码块中显示了这些类型的组（其中定义了库存项）示例：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Based on this information, we can see there are two groups: a web server and
    a database server group. These groups each have two unique servers assigned to
    them and as such provide us with the ability to target either or both groups of
    infrastructure by group name.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，我们可以看到有两个组：一个是Web服务器组，另一个是数据库服务器组。每个组都有两个唯一的服务器分配给它们，因此我们可以通过组名来定位任一组或两组基础设施。
- en: Ansible inventory items don't have to be unique to one group specifically. Ansible
    supports the idea that hostnames or IPs can belong to one or many groups. For
    example, a hostname may exist both in the web server group and the database group.
    This adds significant flexibility within the Ansible playbook execution system.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 的主机清单条目不需要专门属于一个组。Ansible 支持主机名或 IP 可以属于一个或多个组。例如，一个主机名可能同时存在于 Web 服务器组和数据库组中。这为
    Ansible playbook 执行系统提供了巨大的灵活性。
- en: Ansible by nature allows this grouping to be targeted asynchronously. This means
    that the automation can be executed in parallel across either group to target
    a specific group specified in the hosts inventory file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 本身允许对这些分组进行异步目标定位。这意味着自动化任务可以在两个组之间并行执行，以便针对主机清单文件中指定的特定组。
- en: Loose inventory items/hosts/devices
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散的主机清单条目/主机/设备
- en: 'Ansible provides the ability to not group any specific hosts that you want.
    Or mix and match grouped hosts with ''loose hosts''. This functionality allows
    the Ansible developer or user to simply add raw hostnames into the inventory host
    file and not attach it to a specific group. For this specific implementation,
    the hosts file would look something like the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 提供了不对任何特定主机进行分组的能力。或者将分组主机与“松散主机”混合使用。这一功能允许 Ansible 开发者或用户仅将原始主机名添加到主机清单文件中，而不将其附加到特定的组中。在这种特定实现中，主机文件的内容可能类似于以下示例：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see from the screenshot, the raw entries that are not grouped are
    simply organized by IP address or hostname at the top of the inventory hosts file.
    This allows you to target these hosts by default automatically and without specifying
    a targeted group name on the command line.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如截图所示，未分组的原始条目只是按 IP 地址或主机名在主机清单文件的顶部进行组织。这使得你可以默认自动地定位这些主机，而无需在命令行中指定目标组名。
- en: Executing playbook's and targeting specific inventory files and groups
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 playbook 并定位特定的主机清单文件和组
- en: 'Now that we have a set of inventory groups or raw inventory items defined,
    the next step is to see how to call Ansible and target a specific set of groups
    or even inventory files (if different from the default `/etc/Ansible/hosts` file).
    This functionality is incredibly important as we gain experience using Ansible.
    Let''s take a look at how to target specific groups first. The following example
    provides a simple example of an Ansible command line that executes a playbook
    against a grouped inventory:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一组主机清单分组或原始主机清单条目，下一步是查看如何调用 Ansible 并定位特定的组集或甚至清单文件（如果不同于默认的 `/etc/Ansible/hosts`
    文件）。这一功能在我们使用 Ansible 时非常重要。让我们首先看看如何定位特定的组。以下示例提供了一个简单的 Ansible 命令行示例，用于在分组的主机清单上执行
    playbook：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As we can see from the example, we can execute Ansible playbooks against specific
    infrastructure groups. The outcome of these executions is the execution of a set
    of automated tasks against the group's infrastructure.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从示例中所看到的，我们可以针对特定的基础设施组执行 Ansible playbook。执行结果是对该组基础设施执行一系列自动化任务。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the various architecture types that Ansible provides,
    we talked about how inventory files work, and how to target specific groups and
    servers using the `-l` command. We also talked about how to install, set up, and
    configure Ansible to work under most common conditions. In our examples we look
    at a lot of Ubuntu specific implementations but the conversion to other OS's should
    be easy.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Ansible 提供的各种架构类型，讲解了主机清单文件的工作原理，以及如何使用 `-l` 命令定位特定组和服务器。我们还讲解了如何安装、设置和配置
    Ansible 以适应大多数常见条件。在我们的示例中，我们主要关注 Ubuntu 系统的实现，但转换到其他操作系统应该是容易的。
- en: In the next chapter, we will learn all about playbook files and inventory file
    extensibility as well as how to create additional inventory files to help manage
    your infrastructure more effectively. Playbook's represent the heart and soul
    of the Ansible platform and instruct it on how to behave on a given server or
    infrastructure.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习有关 playbook 文件和主机清单文件扩展性的信息，以及如何创建额外的主机清单文件，以帮助更有效地管理基础设施。Playbook
    是 Ansible 平台的核心，它指示 Ansible 如何在特定的服务器或基础设施上运行。
- en: By the time we complete the next chapter, we should begin to have the skills
    you will need to write a playbook and execute it against one of a few machines.
    In addition, you should be able to perform most basic Configuration Management
    and deployment tasks using Ansible. Also, upon completing this chapter, you should
    have a solid understanding of how Ansible inventories work and how to effectively
    create groups and manage infrastructure at scale.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到我们完成下一章时，你应该已经掌握编写操作手册的技能，并能够在几台机器中执行操作。此外，你应该能够使用Ansible执行大部分基本的配置管理和部署任务。完成本章后，你还应该对Ansible的清单系统有一个扎实的理解，并能够有效地创建分组和管理大规模基础设施。
