- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Publishing Your Changes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布你的更改
- en: '[*Chapter 6*](B21194_06.xhtml#_idTextAnchor140), *Collaborative Development
    with Git* (the previous chapter), taught you how to use Git to work together as
    a team, focusing on repository-to-repository interaction. It described different
    ways of setting up repositories for collaboration, presenting different collaborative
    workflows, such as centralized and integration manager workflows. It also showed
    how Git manages information about remote repositories.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第 6 章*](B21194_06.xhtml#_idTextAnchor140)《与 Git 协作开发》（上一章）教你如何使用 Git 进行团队协作，重点介绍仓库与仓库之间的交互。它描述了不同的仓库协作设置方式，展示了不同的协作工作流，如集中式工作流和集成管理工作流。它还展示了
    Git 如何管理有关远程仓库的信息。'
- en: In this chapter, you will find out how you can exchange information between
    your local repository and remote repositories, and how Git can manage credentials
    that might be needed to access remote repositories.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解如何在本地仓库和远程仓库之间交换信息，以及 Git 如何管理可能需要的远程仓库凭证。
- en: This chapter will also teach you how to provide your changes upstream, so that
    they appear in the official history of the project, in its canonical repository.
    This can be done by pushing your changes to a central repository, pushing them
    to your own publishing repository and sending some kind of a pull request to the
    integration manager, or even exchanging patches.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将教你如何将你的更改推送到上游，使其出现在项目的官方历史中，在其标准仓库中。这可以通过将更改推送到中央仓库，推送到你自己的发布仓库并向集成管理者发送某种拉取请求，或甚至交换补丁来完成。
- en: 'This chapter will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Transport protocols used by Git and their advantages and disadvantages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 使用的传输协议及其优缺点
- en: Managing credentials (passwords, keys) for remote repositories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理远程仓库的凭证（密码、密钥）
- en: 'Publishing changes: push and pull requests, and exchanging patches'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布更改：推送和拉取请求，以及交换补丁
- en: Using bundles for offline transfer and speeding up the initial clone
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用捆绑包进行离线传输和加速初始克隆
- en: Remote transport helpers and their use
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程传输助手及其使用
- en: Transport protocols and remote helpers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输协议和远程助手
- en: In general, URLs in the configuration of remote repository contain information
    about the transport protocol, the address of the remote server (where appropriate),
    and the path to the repository. Sometimes, the server that provides access to
    the remote repository supports various transport protocols; you need to select
    which one to use. This section is intended to help with this choice.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，远程仓库的配置中的 URL 包含有关传输协议、远程服务器地址（如果适用）以及仓库路径的信息。有时，提供对远程仓库访问的服务器支持多种传输协议；你需要选择使用哪种协议。本节旨在帮助做出这一选择。
- en: Local transport
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地传输
- en: 'If the remote repository is on the same local filesystem, you can use either
    the path to the repository or the `file://` schema to specify the repository URL:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果远程仓库位于同一个本地文件系统中，你可以使用仓库的路径或 `file://` 方案来指定仓库 URL：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The former implies the `--local` option to the Git clone, which bypasses the
    smart Git-aware mechanism and simply makes a copy (or a hard link for immutable
    files under `.git/objects`, though you can avoid this with the `--no-hardlinks`
    option); the latter is slower but can be used to get a clean copy of a repository
    (for example, after history rewriting done to remove an accidentally committed
    password or another secret; which is described in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping History Clean*, in the *Rewriting* *history* section).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前者意味着 Git 克隆时使用 `--local` 选项，这会绕过智能的 Git 机制，直接复制（或者对于 `.git/objects` 下不可变文件创建硬链接，虽然可以通过
    `--no-hardlinks` 选项避免）；后者较慢，但可以用于获取一个干净的仓库副本（例如，在历史重写后移除意外提交的密码或其他秘密；这在[*第 10
    章*](B21194_10_split_000.xhtml#_idTextAnchor247)《保持历史清洁》的“重写历史”部分中有描述）。
- en: This transport is a nice option for quickly grabbing work from someone else’s
    working repository, or for sharing work using a shared filesystem with the appropriate
    permissions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种传输是一个不错的选择，适合快速从他人的工作仓库中获取工作，或使用具有适当权限的共享文件系统共享工作。
- en: As a special case, a single dot (`.`) denotes the current repository. This means
    that
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个特殊情况，单个点（`.`）表示当前仓库。这意味着
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: is, assuming that `pull.rebase` is set to false, roughly equivalent to
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `pull.rebase` 设置为 false，基本等价于
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Smart transports
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能传输
- en: When the repository you want to fetch from is on another machine, you need to
    access the Git server. Nowadays, Git-aware smart servers are most commonly encountered.
    The smart downloader negotiates which revisions are necessary, and creates a customized
    `packfile` to send to a client. Similarly, during the push, the Git server talks
    to Git on the user’s machine (to the client) to find which revisions to upload.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想从另一个机器上的代码库获取时，需要访问 Git 服务器。如今，最常见的是遇到支持 Git 的智能服务器。智能下载器会协商哪些版本是必需的，并创建一个定制的
    `packfile` 发送给客户端。类似地，在推送过程中，Git 服务器会与用户机器上的 Git 进行通信（即与客户端）来确定需要上传哪些版本。
- en: Git-aware smart servers use the `git upload-pack` downloader for fetching and
    `git receive-pack` for pushing. You can tell Git where to find them if they are
    not in `PATH` (but, for example, are installed in one’s home directory) with the
    `--upload-pack` and `--receive-pack` options for fetching and pushing, or the
    `uploadpack` and `receivepack` configuration variables in the `remote.<name>`
    section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 Git 的智能服务器使用 `git upload-pack` 下载器来获取数据，使用 `git receive-pack` 来推送数据。如果这些工具不在
    `PATH` 中（但例如安装在用户的主目录中），你可以通过 `--upload-pack` 和 `--receive-pack` 选项来指定获取和推送的路径，或者在
    `remote.<name>` 部分使用 `uploadpack` 和 `receivepack` 配置变量。
- en: With very few exceptions (such as the repository using submodules accessed by
    an ancient Git instance that does not understand them), Git transport is backward-
    and forward-compatible—the client and server negotiate what capabilities they
    can both use.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有例外（例如，代码库使用了被旧版 Git 实例访问的子模块，而该版本无法理解子模块），Git 传输是向后和向前兼容的——客户端和服务器会协商双方都能使用的功能。
- en: The native Git protocol
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原生 Git 协议
- en: The native transport, using `git://` URLs, provides read-only anonymous access
    (though you could, in theory, configure Git to allow pushing by enabling the `receive-pack`
    service, either from the command line via the `--enable=receive-pack` option,
    or via the `daemon.receivePack` boolean-valued configuration variable—using this
    mechanism is not recommended at all, even in a closed local network).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `git://` URLs 的本地传输方式提供了只读的匿名访问权限（尽管理论上，你可以配置 Git 允许推送，通过启用 `receive-pack`
    服务来实现，方法是通过命令行选项 `--enable=receive-pack` 或通过 `daemon.receivePack` 布尔配置变量—不过这种方式完全不推荐，甚至在封闭的本地网络中也不应使用）。
- en: The Git protocol does no authentication, including no server authentication,
    and should be used with caution on unsecured networks. The `git daemon` TCP server
    for this protocol normally listens on port `9418`; you need to be able to access
    this port (through the firewall) to be able to use the native Git protocol.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Git 协议没有进行任何认证，包括没有服务器认证，因此在不安全的网络上使用时需要小心。这个协议的 `git daemon` TCP 服务器通常监听在 `9418`
    端口；你需要能够访问该端口（通过防火墙）才能使用原生 Git 协议。
- en: Trivia
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 小知识
- en: There is no secure version of the **git://** protocol. There is no **git://**
    over TLS like there is for the FTP and HTTP protocols—namely, FTPS and HTTPS.
    On the other hand, one can consider SSH transport, as used by Git, to be the **git://**
    protocol over SSH.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**git://** 协议没有安全版本。与 FTP 和 HTTP 协议不同，**git://** 协议没有像 FTPS 和 HTTPS 那样支持 TLS。另一方面，可以认为
    Git 使用的 SSH 传输就是 **git://** 协议通过 SSH 的实现。'
- en: The SSH protocol
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSH 协议
- en: The `git upload-pack` or `git receive-pack` on the server, using SSH to execute
    the remote command. There is no possibility for anonymous, unauthenticated access,
    though you could, as a workaround, set up a guest account for it (passwordless
    or with an empty password).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上的 `git upload-pack` 或 `git receive-pack` 使用 SSH 执行远程命令。该协议不支持匿名的未认证访问，尽管作为变通方法，你可以为其设置一个访客账户（没有密码或密码为空）。
- en: Using public-private key authentication allows access without requiring you
    to provide a password on every connection. You might, however, need to provide
    it once to unlock a password-protected private key. You can read more about authentication
    in the *Credentials/password management* section in this chapter. Many Git hosting
    sites and software forges require key authentication for accessing repositories
    via SSH.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公钥-私钥认证可以在每次连接时无需提供密码。不过，你可能需要提供密码一次，以解锁受密码保护的私钥。你可以在本章的*凭证/密码管理*部分了解更多关于认证的信息。许多
    Git 托管站点和软件开发平台要求通过 SSH 进行密钥认证来访问代码库。
- en: 'For the SSH protocol, you can use the URL syntax with `ssh://` as the protocol
    part:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SSH 协议，你可以使用 `ssh://` 作为协议部分的 URL 语法：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, you can use the `scp`-like syntax:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用类似于 `scp` 的语法：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The SSH protocol additionally supports the `~username` expansion, just like
    the native Git transport (`~` is the home directory of the user you log in as,
    and `~user` is the home directory of `user`), in both syntax forms:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 协议还支持 `~username` 扩展，就像原生 Git 传输一样（`~` 是你登录的用户的家目录，`~user` 是 `user` 的家目录），有两种语法形式：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: SSH uses the first contact authentication for servers (**TOFU**—short for **Trust
    On First Use**)—it remembers the key that the server side previously used, and
    warns the user if it has changed, asking for confirmation (the server key could
    have been changed legitimately, for example, due to an SSH server reinstall).
    You can check the server key fingerprint on the first connection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 使用首个接触认证用于服务器（**TOFU**——即**首次使用时信任**），它记住服务器端先前使用的密钥，并在密钥更改时提醒用户，要求确认（服务器密钥可能是合法更改的，例如，由于
    SSH 服务器重新安装）。你可以在第一次连接时检查服务器密钥的指纹。
- en: The smart HTTP(S) protocol
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能 HTTP(S) 协议
- en: 'Git also supports the smart HTTP(S) protocol, which requires a Git-aware CGI
    or server module—for example, `git-http-backend` (itself a CGI module). This protocol
    uses the following URL syntax:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Git 还支持智能 HTTP(S) 协议，这需要一个 Git 知识的 CGI 或服务器模块——例如，`git-http-backend`（它本身是一个
    CGI 模块）。该协议使用以下 URL 语法：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By default, without any other configuration, Git allows anonymous downloads
    (`git fetch`, `git pull`, `git clone`, and `git ls-remote`), but requires that
    the client is authenticated for upload (`git push`).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在没有任何其他配置的情况下，Git 允许匿名下载（`git fetch`、`git pull`、`git clone` 和 `git ls-remote`），但要求客户端必须进行身份验证才能上传（`git
    push`）。
- en: Standard HTTP authentication is used if authentication is required to access
    a repository, which is done by the HTTP server software. Using SSL/TLS with HTTPS
    ensures that if the password is required (for example, if the server uses basic
    HTTP authentication), then it is sent encrypted and the server identity is verified
    (using server CA certificate).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要认证才能访问仓库，则使用标准的 HTTP 认证，由 HTTP 服务器软件完成。使用 SSL/TLS 配合 HTTPS 可以确保如果需要密码（例如，如果服务器使用基本
    HTTP 认证），密码会被加密发送，并且服务器身份会被验证（使用服务器的 CA 证书）。
- en: Legacy (dumb) transports
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统（愚蠢）传输
- en: Some transports do not require any Git-aware smart server—they don’t need Git
    installed on the server (for smart transports, at least `git-upload-pack` and/or
    `git-receive-pack` is needed). Those are the FTP(S) and dumb HTTP(S) protocol
    transports (nowadays, implemented using the `remote-curl` helper).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些传输方式不需要任何 Git 知识的智能服务器——它们不需要在服务器上安装 Git（对于智能传输，至少需要 `git-upload-pack` 和/或
    `git-receive-pack`）。这些是 FTP(S) 和“愚蠢”HTTP(S) 协议的传输方式（如今，使用 `remote-curl` 辅助工具实现）。
- en: 'These transports need only the appropriate stock server (an FTP server, or
    a web server), and up-to-date data from `git update-server-info`. When fetching
    from such a server, Git uses the so-called **commit walker** downloader: going
    down from fetched branches and tags, Git walks down the commit chain, and downloads
    objects or packs containing missing revisions and other data (for example, file
    content at revision).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些传输仅需要适当的标准服务器（FTP 服务器或 web 服务器）以及来自 `git update-server-info` 的最新数据。从此类服务器拉取时，Git
    使用所谓的 **提交遍历器** 下载器：从已获取的分支和标签开始，Git 依次向下遍历提交链，下载包含缺失修订版本和其他数据（例如，修订版下的文件内容）的对象或包。
- en: This transport is inefficient (in terms of bandwidth, but especially in terms
    of latency), but on the other hand, it can be resumed if interrupted. Nevertheless,
    there are better solutions than using dumb protocols—namely, involving bundles
    (see the *Offline transport with bundles* section in this chapter), when the network
    connection to the server is unreliable enough that you can’t get the clone operation
    to finish.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种传输方式效率低下（在带宽方面，尤其是在延迟方面），但另一方面，如果被中断，可以恢复。尽管如此，相较于使用“愚蠢”协议，还有更好的解决方案——即使用捆绑包（参见本章中的
    *离线传输与捆绑包* 部分），当网络连接不可靠到无法完成克隆操作时，使用捆绑包可以是一种替代方案。
- en: Pushing to a dumb server is possible only via the HTTP and HTTPS protocols.
    It requires the web server to support WebDAV, and Git has to be built with the
    *expat* library linked. The FTP and FTPS protocols are read-only (supporting only
    `clone`, `fetch`, and `pull`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 向一个“愚蠢”服务器推送仅能通过 HTTP 和 HTTPS 协议进行。这要求 web 服务器支持 WebDAV，并且 Git 必须与 *expat* 库链接编译。FTP
    和 FTPS 协议为只读（仅支持 `clone`、`fetch` 和 `pull`）。
- en: 'As a design feature, Git can automatically upgrade dumb protocol URLs to smart
    URLs. Conversely, a Git-aware HTTP server can downgrade to the backward-compatible
    dumb protocol (at least for fetching: smart HTTP servers don’t support WebDAV-based
    dumb HTTP push operation). This feature allows the use of the same HTTP(S) URL
    for both dumb and smart access:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计特性，Git可以自动将简单协议的URL升级为智能URL。反之，一个支持Git的HTTP服务器也可以降级为向后兼容的简单协议（至少在获取操作时：智能HTTP服务器不支持基于WebDAV的简单HTTP推送操作）。这个特性允许使用相同的HTTP(S)
    URL进行简单和智能访问：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Offline transport with bundles
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离线传输与存档
- en: Sometimes, there is no direct connection between your machine and the server
    holding the Git repository that you want to fetch from. Or, perhaps there is no
    server running, and you want to copy changes to another machine anyway. Maybe
    your network is down. Perhaps you’re working somewhere on-site and don’t have
    access to the local network for security reasons. Maybe your wireless/Ethernet
    card just broke.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的机器和持有你想要获取的Git仓库的服务器之间没有直接连接。或者，服务器可能没有运行，你仍然想将更改复制到另一台机器上。也许你的网络出现故障，或者你在某个现场工作，并且出于安全原因无法访问本地网络。也可能是你的无线/以太网卡坏了。
- en: Enter the `git bundle` command. This command will package up everything that
    would normally be transferred over the wire, putting objects and references into
    a special binary archive file called `bundle` (like `packfile`, only with branches
    and so on). You need to specify which commits are to be packed—something that
    network protocols do automatically for you for online transport.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`git bundle`命令。该命令会将所有通常通过网络传输的内容打包，将对象和引用放入一个特殊的二进制存档文件中，称为`bundle`（类似于`packfile`，只是包含了分支等信息）。你需要指定要打包哪些提交—这是网络协议自动为你完成的操作，通常用于在线传输。
- en: Trivia
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 细节
- en: When you are using one of the smart transports, a **want/have negotiation**
    phase takes place, where the client tells the server what it does have in its
    repository and which advertised references on the server it wants, to find common
    revisions. This is then used by the server to create a packfile, and to send the
    client only what’s necessary, minimizing the bandwidth use.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用智能传输时，会进行一个**want/have协商**阶段，客户端告诉服务器它在自己的仓库中已有的内容，以及它希望从服务器上获取哪些已发布的引用，以找到公共的版本。这些信息将被服务器用于创建一个packfile，并且只发送必要的内容给客户端，从而最小化带宽使用。
- en: Next, you need to move this bundle (this archive) by some means to your machine.
    It can be done, for example, by so-called `git clone` or `git fetch` with the
    filename of the bundle in place of the repository URL.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要通过某种方式将这个包（这个存档）传输到你的机器上。可以通过例如使用`git clone`或`git fetch`命令，替换仓库URL为包的文件名来完成此操作。
- en: Proxies for Git transports
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git传输的代理
- en: When direct access to the server is not possible, for example, from within a
    firewalled LAN, sometimes you can connect via a proxy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当无法直接访问服务器时，例如，在防火墙保护的局域网内部，有时可以通过代理连接。
- en: For the native Git protocol (`git://`), you can use the `core.gitProxy` configuration
    variable, or the `GIT_PROXY_COMMAND` environment variable to specify a proxy command—for
    example, `ssh`. This can be set on a per-remote basis with special syntax for
    the `core.gitProxy` value—namely, `<command> for <remote>;` for example, `"ssh"`
    `for kernel.org`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原生Git协议（`git://`），你可以使用`core.gitProxy`配置变量，或`GIT_PROXY_COMMAND`环境变量来指定代理命令—例如，`ssh`。这可以通过`core.gitProxy`值的特殊语法为每个远程仓库设置，例如，`"ssh"
    for kernel.org`。
- en: You can use the `http.proxy` configuration variable or appropriate *curl* environment
    variables such as `http_proxy` to specify the HTTP proxy server to use for the
    HTTP(S) protocol (`http(s)://`). This can be set on a per-remote basis with the
    `remote.<remote name>.proxy` configuration variable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`http.proxy`配置变量或适当的*curl*环境变量，如`http_proxy`，来指定用于HTTP(S)协议的HTTP代理服务器（`http(s)://`）。这可以通过`remote.<remote
    name>.proxy`配置变量为每个远程仓库单独设置。
- en: You can configure SSH (using its configuration files—for example, `~/.ssh/config`)
    to use tunneling (port forwarding) or a proxy command (for example, the `netcat/nc;`
    or `netcat` mode of SSH—that is, `ssh -W –`—if your SSH implementation supports
    this feature). It is a recommended solution for the SSH proxy; if neither tunneling
    nor using a proxy is possible, you can use the `ext::` transport-helper, as shown
    later in this chapter, in the *Transport relay with remote* *helpers* section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以配置SSH（使用其配置文件，例如`~/.ssh/config`）来使用隧道（端口转发）或代理命令（例如，`netcat/nc;`或SSH的`netcat`模式——即`ssh
    -W –`——前提是你的SSH实现支持此功能）。这是一个推荐的SSH代理解决方案；如果无法使用隧道或代理，你可以使用`ext::`传输助手，正如本章后面*使用远程助手的传输中继*部分所展示的那样。
- en: Cloning and updating with bundles
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用捆绑包克隆和更新
- en: Let’s assume that you want to transfer the history of a project (say, limited
    to the `master` branch for simplicity) from `machineA` (for example, your work
    computer) to `machineB` (for example, an onsite computer). There is, however,
    no direct connection between those two machines.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想将一个项目的历史（为了简单起见，仅限于`master`分支）从`machineA`（例如，你的工作电脑）转移到`machineB`（例如，一个现场电脑）。然而，这两台机器之间没有直接连接。
- en: 'First, we create a bundle that contains the whole history of the `master` branch
    (see [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083), *Exploring Project History*),
    and tag this point of history to know what we bundled, which will be needed later:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包含`master`分支全部历史的捆绑包（见[*第4章*](B21194_04.xhtml#_idTextAnchor083)，*探索项目历史*），并标记这个历史点以便知道我们捆绑了什么，稍后会用到：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the bundle file was created outside the working directory. This is a matter
    of choice; storing it outside of the repository means that you don’t have to worry
    about accidentally adding it to your project history, or having to add a new `ignore`
    rule. The `*.bundle` file extension is OR simply a matter of the naming convention.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，捆绑包文件是在工作目录外创建的。这是一个选择问题；将其存储在仓库外意味着你不必担心不小心将其添加到项目历史中，或者需要添加新的`ignore`规则。`*.bundle`文件扩展名只是命名约定的一部分。
- en: Important note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'For security reasons, to avoid information disclosure about the parts of history
    that were deleted but not purged (for example, an accidentally committed file
    with a password), Git only allows fetching from **git show-ref**-compatible references:
    branches, remote-tracking branches, and tags.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，为了避免泄露已删除但未清除的历史部分（例如，意外提交的含密码的文件），Git只允许从**git show-ref**兼容的引用中获取：分支、远程追踪分支和标签。
- en: The same restrictions apply when creating a bundle. This means, for example,
    that (for implementation reasons) you cannot run **git bundle creates master^1**.
    Though, of course, because you control the server end, as a workaround you can
    create a new branch for **master^**, (temporarily) rewind **master**, or check
    out the detached **HEAD** at **master^**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建捆绑包时适用相同的限制。这意味着，例如，由于实现原因，你不能运行**git bundle creates master^1**。尽管当然，因为你控制着服务器端，作为一种解决方法，你可以为**master^**创建一个新分支，（暂时）回退**master**，或者检出**master^**的分离**HEAD**。
- en: 'Then you transfer the just-created `repo.bundle` file to `machineB` (via email,
    on a USB pen drive, and so on). Because this bundle consists of a self-contained,
    whole subset of the history, down to the first (parent-less) root commit, you
    can create a new repository by cloning from it, by simply putting the bundle filename
    in place of the repository URL:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将刚刚创建的`repo.bundle`文件转移到`machineB`（通过电子邮件、USB闪存驱动器等）。由于这个捆绑包包含了一个完整的、独立的历史子集，直到第一个（没有父提交的）根提交，你可以通过克隆它来创建一个新的仓库，只需将捆绑包文件名替换为仓库URL：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Oops. We didn’t bundle `HEAD`, so the Git clone didn’t know which branch is
    current and therefore should be checked out:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。我们没有捆绑`HEAD`，所以Git克隆时不知道当前应检出的分支：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Because a bundle can be treated as a remote repository, we could have simply
    used the **git ls-remote ../repo.bundle** command here instead of **git bundle**
    **list-heads ../repo.bundle**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因为捆绑包可以视作远程仓库，我们本可以直接使用**git ls-remote ../repo.bundle**命令，而不是**git bundle**
    **list-heads ../repo.bundle**。
- en: 'Therefore, with this bundle being as it is, we need to specify which branch
    to check out to avoid the problem (this would not be necessary if we had bundled
    `HEAD` too):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到这个捆绑包的状态，我们需要指定要检出的分支，以避免问题（如果我们也捆绑了`HEAD`，则不需要这样做）：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Instead of cloning again, we can fix the problem with the failed checkout by
    selecting the current branch:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要再次克隆，我们可以通过选择当前分支来修复失败的检出问题：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, here, Git guessed that when trying to switch to a non-existent
    local branch, `master`, what we actually wanted was to create a local branch to
    create new commits to submit to the remote `master` branch. In other words, create
    a local branch following (tracking) the remote branch with the same name existing
    in the `origin` remote. What Git did is the same as if we ran the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这里Git猜测当我们尝试切换到一个不存在的本地分支`master`时，实际上我们想做的是创建一个本地分支来提交新的提交到远程`master`分支。换句话说，就是创建一个本地分支来跟踪（追踪）远程`origin`中存在的同名分支。Git所做的事情与我们运行以下命令的效果相同：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To update the repository on `machineB` cloned from the bundle, you can fetch
    or pull after replacing the original bundle stored at `/home/user/repo.bundle`
    with the one with incremental updates.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新从包中克隆的`machineB`上的仓库，你可以在替换掉存储在`/home/user/repo.bundle`的原始包后，执行`fetch`或`pull`操作来更新。
- en: 'To create a bundle containing changes since the last transfer in our example,
    go to `machineA` and run the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含自上次传输以来更改的包，在`machineA`上运行以下命令：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will bundle all changes since the `lastbundle` tag; this tag denotes what
    was copied with the previous bundle (see [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083),
    *Exploring Project History*, the *Double-dot notation* section, for an explanation
    of double-dot syntax). After creating a bundle, this will update the tag (using
    `-f` or `--force` to replace it), like was done the first time when creating a
    bundle, so that the next bundle can also be created incrementally from the now
    current point.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打包所有自`lastbundle`标签以来的更改；该标签表示之前包中复制的内容（有关双点语法的解释，请参见[*第4章*](B21194_04.xhtml#_idTextAnchor083)，*探索项目历史*，*双点符号*部分）。创建包后，这将更新标签（使用`-f`或`--force`来替换它），就像第一次创建包时一样，以便下一个包也可以从当前点增量创建。
- en: 'Then, you need to copy the bundle to `machineB`, *replacing* the old one. At
    this point, one can simply perform the pull operation to update the repository,
    as shown in the following example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要将包复制到`machineB`，*替换*旧的包。此时，可以简单地执行拉取操作来更新仓库，示例如下：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using a bundle to update an existing repository
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用包更新现有仓库
- en: Sometimes, you might have a repository cloned already, only for the network
    to fail. Or, perhaps you moved outside the **local area network** (**LAN**), and
    now you have no access to the server. The end result is that you have an existing
    repository, but no direct connection to the upstream (to the repository we cloned
    from).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能已经克隆了一个仓库，但网络出现故障。或者，也许你已经移动到了**局域网**（**LAN**）之外，现在无法访问服务器。最终结果是你有一个现有的仓库，但没有与上游的直接连接（即我们克隆的那个仓库）。
- en: Now, if you don’t want to bundle up the whole repository, which is wasteful,
    like in the *Cloning and updating with bundles* section, you need to find some
    way to specify the cut-off point (the base) in such a way that it is surely present
    in the target repository (which you want to update). You can specify the range
    of revisions to pack into the bundle using almost any technique from [*Chapter
    4*](B21194_04.xhtml#_idTextAnchor083), *Exploring Project History*. The only limitation
    is that the history, as was said earlier, must start at a branch or tag (anything
    that `git show-ref` accepts). You can, of course, check the range with the `git`
    `log` command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你不想将整个仓库打包，这样会浪费空间，就像在*使用包克隆和更新*一节中那样，你需要找到一种方法，指定一个截止点（基点），确保它一定存在于目标仓库中（你想要更新的那个仓库）。你可以使用几乎任何技术来指定要打包到包中的修订范围，参考[*第4章*](B21194_04.xhtml#_idTextAnchor083)，*探索项目历史*。唯一的限制是，如前所述，历史记录必须从一个分支或标签开始（任何`git
    show-ref`接受的内容）。当然，你可以使用`git`的`log`命令检查这个范围。
- en: 'Commonly used solutions for specifying the range of revisions to pack into
    a bundle are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的指定修订范围打包到包中的解决方案如下：
- en: 'Use the tag that is present in both repositories:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两个仓库中都存在的标签：
- en: '`git bundle create ../``repo.bundle v0.1..master`'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`git bundle create ../``repo.bundle v0.1..master`'
- en: 'Create a cut-off based on the time of commit creation:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据提交创建时间创建一个截止点：
- en: '`git bundle create ../repo.bundle --``since=1.week master`'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`git bundle create ../repo.bundle --``since=1.week master`'
- en: 'Bundle just the last few revisions, limiting the revision range by the number
    of commits:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只打包最后几次修订，通过提交次数来限制修订范围：
- en: '`git bundle create ../repo.bundle -``5 master`'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`git bundle create ../repo.bundle -``5 master`'
- en: Tip
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'It’s better to pack in too much than too little. You can check whether the
    repository has the requisite commits to fetch from the bundle with **git bundle
    verify**. If you pack in too little, you’ll get the following error:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 打包时最好多装一点而不是太少。你可以通过**git bundle verify**检查仓库是否包含需要从捆绑包中获取的必要提交。如果打包内容过少，你会收到以下错误：
- en: '**user@machineB repo$ git pull ../****repo.bundle master**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**user@machineB repo$ git pull ../****repo.bundle master**'
- en: '**error: Repository lacks these** **prerequisite commits:**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误：仓库缺少这些** **先决提交：**'
- en: '**error: ca3cdd6bb3fcd0c162a690d5383bdb8e8144b0d2**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误：ca3cdd6bb3fcd0c162a690d5383bdb8e8144b0d2**'
- en: 'Then, after transporting it to `machineB`, you can use the bundle file just
    like a regular repository to do a one-off pull (putting the bundle filename in
    place of the URL or the remote name):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在将其传输到`machineB`后，你可以像使用常规仓库一样使用该捆绑文件来执行一次性拉取（将捆绑文件名代替网址或远程名称）：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you don’t want to deal with the merge, you can fetch into the remote-tracking
    branch (the `<remote branch>:<remote-tracking branch>` notation used here, which
    is known as *refspec*, will be explained in [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196),
    *Advanced* *Branching Techniques*):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想处理合并，你可以将其拉取到远程跟踪分支（这里使用的`<远程分支>:<远程跟踪分支>`符号，称为*refspec*，将在[*第8章*](B21194_08_split_000.xhtml#_idTextAnchor196)，*高级*
    *分支技巧*中解释）：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Alternatively, you can use `git remote add` to create a new shortcut, using
    the path to the bundle file in place of the repository URL. Then, you can simply
    deal with bundles as described in the previous section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用`git remote add`创建一个新的快捷方式，使用捆绑包文件的路径代替仓库URL。然后，你可以像上一节所述那样处理捆绑包。
- en: Utilizing a bundle to help with the initial clone
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用捆绑包帮助进行初始克隆
- en: Smart transports provide much more effective transport than dumb ones. On the
    other hand, the concept of a resumable clone using smart transport remains elusive
    to this day (it is not available in Git version 2.34, though perhaps somebody
    will implement it in the future). For large projects with a long history and with
    a large number of files, the initial clone might be quite large (for example,
    `linux-next` is more than 2.7 GB) and take a pretty long time. This might be a
    problem if the network is unreliable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 智能传输提供比普通传输更有效的传输方式。另一方面，使用智能传输的可恢复克隆概念至今依然难以实现（它在Git版本2.34中不可用，不过也许将来某人会实现它）。对于历史较长、文件众多的大型项目，初次克隆可能非常庞大（例如，`linux-next`超过2.7
    GB）且需要很长时间。如果网络不可靠，这可能成为一个问题。
- en: Tip – workaround
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 – 解决方法
- en: You can work around the issue of an unreliable network by using a shallow clone
    or a sparse clone (see [*Chapter 12*](B21194_12.xhtml#_idTextAnchor302), *Managing*
    *Large Repositories*) and widening it step by step until you arrive at the full
    repository. There are some third-party tools that do this automatically.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用浅克隆或稀疏克隆来绕过不可靠网络的问题（见[*第12章*](B21194_12.xhtml#_idTextAnchor302)，*管理*
    *大型仓库*），并逐步扩展，直到得到完整的仓库。也有一些第三方工具可以自动执行此操作。
- en: 'You can create a bundle from the source repository, for example, with the following
    command (which needs to run on the server):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从源仓库创建一个捆绑包，例如，使用以下命令（需要在服务器上运行）：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Some servers may offer such bundles to help with the initial clone. There is
    a practice where a bundle intended for cloning is available at the same URL as
    the repository, but with a `.bundle` suffix instead of `.git`. For example, `https://git.example.com/user/repo.git`
    has its bundle available at `https://git.example.com/user/repo.bundle`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务器可能提供这样的捆绑包来帮助进行初始克隆。有一种做法是，供克隆使用的捆绑包与仓库位于相同的URL下，但后缀为`.bundle`而非`.git`。例如，`https://git.example.com/user/repo.git`的捆绑包可以在`https://git.example.com/user/repo.bundle`找到。
- en: 'You can then download such a bundle, which is an ordinary static file, using
    any resumable transport: HTTP(S), FTP(S), rsync, or even BitTorrent (with the
    appropriate client that supports resuming the download).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用任何支持断点续传的传输方式下载这种捆绑包，它是一个普通的静态文件：HTTP(S)、FTP(S)、rsync，甚至是BitTorrent（使用适当的客户端，支持断点续传）。
- en: With modern Git, the user can specify the bundle URI with the `--bundle-uri`
    command-line option, or a bundle list can be advertised by a Git server. A list
    of bundle URIs can also be saved in a config file. Fetching from bundle servers
    (such as [https://github.com/git-ecosystem/git-bundle-server](https://github.com/git-ecosystem/git-bundle-server))
    is then automatic.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 Git 中，用户可以通过 `--bundle-uri` 命令行选项指定 bundle URI，或者 Git 服务器可以广告一个 bundle 列表。bundle
    URI 列表也可以保存在配置文件中。然后，从 bundle 服务器（例如 [https://github.com/git-ecosystem/git-bundle-server](https://github.com/git-ecosystem/git-bundle-server)）获取数据将是自动的。
- en: Remote transport helpers
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程传输助手
- en: 'When Git doesn’t know how to handle a certain transport protocol (when one
    tries to use a protocol that doesn’t have built-in support), it attempts to use
    the appropriate **remote helper** for a protocol, if one exists. That’s why if
    there is an error within the protocol part of the repository URL—Git responds
    with an error message that looks like the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Git 不知道如何处理某个传输协议时（即尝试使用一个没有内建支持的协议），它会尝试使用适当的 **远程助手** 来处理该协议（如果有的话）。这就是为什么当仓库
    URL 的协议部分出现错误时，Git 会返回如下错误信息：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This error message means that Git tried to find `git-remote-shh` to handle the
    `shh` protocol (actually a typo for `ssh`), but didn’t find an executable with
    such a name.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息表示 Git 尝试找到 `git-remote-shh` 来处理 `shh` 协议（实际上是 `ssh` 的拼写错误），但是没有找到具有此名称的可执行文件。
- en: You can explicitly request a specific remote helper with the `<transport>::<address>`
    syntax, where `<transport>` defines the helper (`git remote-<transport>`), and
    `<address>` is a string that the helper uses to find the repository.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `<transport>::<address>` 语法显式地请求特定的远程助手，其中 `<transport>` 定义了助手（`git remote-<transport>`），`<address>`
    是助手用来查找仓库的字符串。
- en: 'Modern Git implements support for the dumb HTTP, HTTPS, FTP, and FTPS protocols
    with the `curl` family of remote helpers: `git-remote-http`, `git-remote-https`,
    `git-remote-ftp`, and `git-remote-ftps`, respectively.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 Git 支持通过 `curl` 系列远程助手来处理傻瓜 HTTP、HTTPS、FTP 和 FTPS 协议，分别是 `git-remote-http`、`git-remote-https`、`git-remote-ftp`
    和 `git-remote-ftps`。
- en: Transport relay with remote helpers
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用远程助手进行传输中继
- en: 'Git includes two generic remote helpers that can be used to proxy smart transports:
    the `git-remote-fd` helper to connect to the remote server via either a bidirectional
    socket or a pair of pipes, and the `git-remote-ext` helper to use an external
    command to connect to the remote server.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Git 包括两个通用的远程助手，可以用来代理智能传输：`git-remote-fd` 帮助器通过双向套接字或一对管道连接远程服务器，`git-remote-ext`
    帮助器则使用外部命令连接远程服务器。
- en: In the case of the latter, which uses the `"ext::<command> <arguments">"` syntax
    for the repository URL, Git runs the specified command to connect to the server,
    passing data for the server to the standard input of the command, and receiving
    a response on its standard output. This data is assumed to be passed to a `git://`
    server, `git-upload-pack`, `git-receive-pack`, or `git-upload-archive` (depending
    on the situation).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在后者的情况下，Git 使用 `"ext::<command> <arguments>"` 语法指定仓库 URL，Git 运行指定的命令来连接服务器，将数据传递给命令的标准输入，并从其标准输出接收响应。这些数据假设会传递给
    `git://` 服务器、`git-upload-pack`、`git-receive-pack` 或 `git-upload-archive`（具体取决于情况）。
- en: 'For example, let’s assume that you have your repository on a LAN host where
    you can log in using SSH. However, for security reasons, this host is not visible
    on the internet, and you need to go through the gateway host: `login.example.com`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你的仓库托管在一个局域网主机上，你可以通过 SSH 登录。可是，出于安全原因，这台主机在互联网上不可见，你需要通过网关主机 `login.example.com`：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The trouble is that—also for security reasons—this gateway host either doesn’t
    have Git installed (reducing the attack surface) or doesn’t have your repository
    present (it uses a different filesystem). This means that you cannot use the ordinary
    SSH protocol—not unless you can set up an `ssh -L`). The SSH transport is just
    `git-receive-pack` / `git-upload-pack` accessed remotely via SSH, with the path
    to the repository as a parameter. This means that you can use the `ext::` remote
    helper:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是——同样出于安全原因——这个网关主机要么没有安装 Git（以减少攻击面），要么没有你的仓库（它使用的是不同的文件系统）。这意味着你无法使用普通的
    SSH 协议——除非你能设置 `ssh -L`。SSH 传输实际上是通过 SSH 远程访问的 `git-receive-pack` / `git-upload-pack`，其路径作为参数。这意味着你可以使用
    `ext::` 远程助手：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `%S` will be expanded by Git into the full name of the appropriate service—`git-upload-pack`
    for fetching and `git-receive-pack` for pushing. The `-t` option is needed if
    logging to the internal host uses interactive authentication (for example, a password).
    Note that you need to give the name (`repo`, here) to the result of cloning; otherwise,
    Git will use the command (`ssh`) as the repository name.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`%S`将由Git展开为适当服务的完整名称——`git-upload-pack`用于拉取，`git-receive-pack`用于推送。如果登录到内部主机时使用交互式身份验证（例如密码），则需要使用`-t`选项。请注意，克隆结果时需要为仓库命名（此处为`repo`）；否则，Git将使用命令（`ssh`）作为仓库名称。
- en: Tip
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can also use **"ext::ssh [<parameters>...] %S '<repository>'"** to use specific
    options for SSH transport—for example, selecting the keypair to use without needing
    to edit **.ssh/config**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用**"ext::ssh [<parameters>...] %S '<repository>'"**来为SSH传输使用特定选项——例如，选择要使用的密钥对，而无需编辑**.ssh/config**。
- en: This is not the only possible solution—though there is no built-in support for
    sending the SSH transport through a proxy like there is for the native `git://`
    protocol (among others, `core.gitProxy`) and for HTTP (among others, `http.proxy`),
    you can do it by configuring the SSH using the `ProxyCommand` config option, or
    by creating an SSH tunnel.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是唯一的解决方案——尽管没有像原生`git://`协议那样内建支持通过代理发送SSH传输（例如`core.gitProxy`）和HTTP（例如`http.proxy`），你仍然可以通过配置SSH的`ProxyCommand`选项，或创建SSH隧道来实现。
- en: On the other hand, you can also use the `ext::` remote helper to proxy the `git://`
    protocol—for example, with the help of `socat`—including using a single proxy
    for multiple servers. See the `git-remote-ext(1)` manpage for details and examples.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你还可以使用`ext::`远程助手来代理`git://`协议——例如，借助`socat`——并且可以使用单个代理来处理多个服务器。有关详细信息和示例，请参阅`git-remote-ext(1)`手册页。
- en: Using foreign SCM repositories as remotes
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用外部SCM仓库作为远程仓库
- en: The remote helper mechanism is very powerful. It can also be used to interact
    with other version control systems, transparently using their repositories as
    if they were native Git repositories. Though there is no such built-in helper
    (unless you count the `contrib/` area in the Git sources), you can find the `git-remote-hg`,
    `gitifyhg`, or `git-cinnabar` helper to access Mercurial repositories, and `git-remote-bzr`
    to access Bazaar repositories.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 远程助手机制非常强大。它还可以与其他版本控制系统交互，透明地将其仓库作为本地Git仓库使用。尽管没有内建的助手（除非你考虑Git源代码中的`contrib/`目录），你可以找到`git-remote-hg`、`gitifyhg`或`git-cinnabar`助手来访问Mercurial仓库，以及`git-remote-bzr`来访问Bazaar仓库。
- en: 'Once installed, those remote helper bridges will allow you to clone, fetch,
    and push to and from the Mercurial or Bazaar repositories as if they were Git
    ones, using the `<helper>::<URL>` syntax. For example, to clone the Mercurial
    repository, you can simply run the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，这些远程助手桥接将允许你像操作Git仓库一样，使用`<helper>::<URL>`语法来克隆、拉取和推送Mercurial或Bazaar仓库。例如，要克隆Mercurial仓库，你只需运行以下命令：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There is also the `remote.<remote name>.vcs` configuration variable, if you
    don’t like using the `<helper>::` prefix in the repository URL. With this method,
    you can use the same URL for Git as for the original **version control** **system**
    (**VCS**).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`remote.<remote name>.vcs`配置变量，如果你不喜欢在仓库URL中使用`<helper>::`前缀，可以使用此方法。通过这种方式，你可以对Git和原始**版本控制**系统（**VCS**）使用相同的URL。
- en: Foreign version control system clients
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 外部版本控制系统客户端
- en: The alternative approach to using remote helper bridges is to use a specialized
    client, such as **git-svn** for Subversion, or **git-p4** for Perforce. Those
    clients interact with the foreign VCS (usually a centralized VCS), manage and
    update the Git repository based on this interaction, and update the foreign repository
    based on changes present in the Git repository.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用远程助手桥接的替代方法是使用专用客户端，例如**git-svn**用于Subversion，或**git-p4**用于Perforce。这些客户端与外部VCS（通常是集中式VCS）交互，基于此交互管理并更新Git仓库，同时基于Git仓库中的更改更新外部仓库。
- en: Of course, one needs to remember impedance mismatches between different version
    control systems, and the limitations of the remote helper mechanism. Some features
    do not translate at all or do not translate well—for example, octopus merges (with
    more than two parent commits) in Git, or multiple anonymous branches (heads) in
    Mercurial.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，需要记住不同版本控制系统之间的阻抗不匹配，以及远程助手机制的限制。有些功能根本无法转换，或者转换效果不佳——例如，Git中的章鱼合并（包含多个父提交），或者Mercurial中的多个匿名分支（头）。
- en: With remote helpers, there is also no place to fix mistakes, replace references
    to other revisions with target native syntax, and otherwise clean up artifacts
    created by repository conversions—as can and should be done with one-time conversion
    when changing version control systems. (Such a cleanup can be done with, for example,
    the help of the `reposurgeon` third-party tool.)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过远程助手，还可以没有地方修复错误，用目标原生语法替换对其他版本的引用，并清理由仓库转换创建的其他工件——在更改版本控制系统时应执行一次性转换，可以使用第三方工具`reposurgeon`来执行此类清理操作。
- en: 'With remote helpers, you can even use things that are not version control repositories
    in the strict sense; for example, with the *Git-Mediawiki* project, you can use
    Git to view and edit a MediaWiki-based wiki (for example, Wikipedia), treating
    the history of pages as a Git repository:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过远程助手，甚至可以使用严格意义上不是版本控制仓库的东西；例如，使用*Git-Mediawiki*项目，可以使用Git查看和编辑基于MediaWiki的维基（例如维基百科），将页面历史视为Git仓库：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Besides that, there are remote helpers that allow additional transport protocols,
    or storage options—such as `git-remote-s3bundle` to store the repository as a
    bundle file on Amazon S3, or `git-remote-codecommit` for AWS CodeCommit (if you
    don’t want to or cannot use HTTPS authentication with static credentials). There
    is also `git-ssb` to encode repositories in a peer-to-peer log store via the Secure
    ScuttleButt protocol.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有远程助手允许额外的传输协议或存储选项——例如，`git-remote-s3bundle`将仓库存储为Amazon S3上的捆绑文件，或者`git-remote-codecommit`用于AWS
    CodeCommit（如果不能或不想使用具有静态凭据的HTTPS身份验证）。还有`git-ssb`通过Secure ScuttleButt协议在点对点日志存储中编码仓库。
- en: Credentials/password management
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凭证/密码管理
- en: In most cases, with the exception of the local transport (where filesystem permissions
    control access), publishing changes to the remote repository requires authentication
    (the user identifies itself) and authorization (the given user has permission
    to perform the push operation). Sometimes, fetching the repository also requires
    authentication and authorization, like with private repositories.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，除了本地传输（文件系统权限控制访问），向远程仓库发布更改需要身份验证（用户识别自身）和授权（给定用户有权限执行推送操作）。有时，获取仓库也需要身份验证和授权，例如对私有仓库。
- en: Commonly used **credentials** for authentication are *username* and *password*.
    You can put the username in the HTTP and SSH repository URLs if you are not concerned
    about information leakage (in respect of leaking the information about valid usernames),
    or you can use the **credential helper** mechanism. You should *never* put passwords
    in URLs, even though it is technically possible for HTTP ones—the password can
    be visible to other people, for example when they are listing processes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 用于身份验证的常用**凭证**是*用户名*和*密码*。如果不担心信息泄露（关于有效用户名信息泄露的问题），可以将用户名放在HTTP和SSH存储库URL中，或者可以使用**凭证助手**机制。绝对不应该将密码放在URL中，即使在技术上对于HTTP
    URL也是可能的——例如当它们列出进程时，密码可能会对其他人可见。
- en: Besides the mechanism inherent in the underlying transport engine, be it `SSH_ASKPASS`
    for SSH or the `~/.netrc` file for curl-based transport, Git provides its own
    integrated solutions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了底层传输引擎中固有的机制，如SSH的`SSH_ASKPASS`或基于curl的传输中的`~/.netrc`文件，Git提供了自己的集成解决方案。
- en: Asking for passwords
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求密码
- en: Some of the Git commands that interactively ask for a password (and a username
    if it is not known)—such as `git svn`, the HTTP interface, or IMAP authentication—can
    be told to use an external program. The program is invoked with a suitable prompt
    (a so-called **authentication domain**, describing what the password is for),
    and Git reads the password from the standard output of this program.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Git命令会交互地要求输入密码（如果用户名未知，则需要用户名），例如`git svn`、HTTP接口或IMAP认证——可以告知它们使用外部程序。该程序会使用合适的提示（称为**身份验证域**，描述密码用途），Git从该程序的标准输出中读取密码。
- en: 'Git will try the following places to ask the user for usernames and passwords;
    see the `gitcredentials(7)` manpage:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Git会尝试以下位置来询问用户用户名和密码；参见`gitcredentials(7)`手册页：
- en: The program specified by the **GIT_ASKPASS** environment variable, if set (Git-specific
    environment variables always have higher precedence than configuration variables)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设置了**GIT_ASKPASS**环境变量指定的程序（Git特定的环境变量始终优先于配置变量）
- en: Otherwise, the **core.askpass** configuration variable is used, if set
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果设置了**core.askpass**配置变量，将使用它
- en: Otherwise, the **SSH_ASKPASS** environment variable is used, if set (it is not
    Git-specific, that is why it is consulted later in the sequence)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，使用 **SSH_ASKPASS** 环境变量（如果已设置，且它不是 Git 特有的，因此在序列中稍后会被检查）。
- en: Otherwise, the user is prompted on the terminal
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，系统会提示用户在终端中输入。
- en: 'This `askpass` external program is usually selected according to the desktop
    environment of the user (after installing it, if necessary):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `askpass` 外部程序通常根据用户的桌面环境来选择（如有必要，安装后使用）：
- en: (**x11-**)**ssh-askpass** provides a plain X-window dialog asking for the username
    and password
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (**x11-**)**ssh-askpass** 提供一个简单的 X 窗口对话框，要求输入用户名和密码。
- en: There is **ssh-askpass-gnome** for GNOME and **ksshaskpass** for KDE
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNOME 有 **ssh-askpass-gnome**，KDE 有 **ksshaskpass**。
- en: '**mac-ssh-askpass** can be used for macOS'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mac-ssh-askpass** 可以用于 macOS。'
- en: '**win-ssh-askpass** can be used for MS Windows'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**win-ssh-askpass** 可以用于 MS Windows。'
- en: Git comes with a cross-platform password dialog in Tcl/Tk—`git-gui--askpass`—to
    accompany the `git gui` graphical interface and the `gitk` history viewer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Git 带有一个跨平台的密码对话框，使用 Tcl/Tk 编写——`git-gui--askpass`——用于配合 `git gui` 图形界面和 `gitk`
    历史查看器。
- en: The Git configuration precedence (that we have seen an example of here) will
    be described in more detail in [*Chapter 13*](B21194_13_split_000.xhtml#_idTextAnchor320),
    *Customizing and* *Extending Git*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的 Git 配置优先级将在 [*第 13 章*](B21194_13_split_000.xhtml#_idTextAnchor320)
    中详细描述，*定制和* *扩展 Git*。
- en: Public key authentication for SSH
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSH 的公钥认证。
- en: For the SSH transport protocol, there are additional authentication mechanisms
    besides passwords. One of them is `gitolite` uses—[https://gitolite.com](https://gitolite.com)).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SSH 传输协议，除了密码之外，还有其他认证机制。其中之一是 `gitolite` 使用的—[https://gitolite.com](https://gitolite.com)。
- en: The idea of public key authentication is that the user creates a `ssh-keygen`.
    The public key is then sent to the server, for example, by using `ssh-copy-id`
    (which also adds the public key, `*.pub`, at the end of the `~/.ssh/authorized_keys`
    file on the remote server), or by pasting it into a web form on a hosting service.
    You can then log in with your private key that is on your local machine, for example,
    as `~/.ssh/id_rsa`. You might need to configure SSH (in `~/.ssh/config` on Linux,
    and a similar configuration file on MS Windows) to use a specific identity file
    for a given connection (hostname) if it is not the default identity key.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥认证的思路是，用户创建一个 `ssh-keygen`。然后将公钥发送到服务器，例如，使用 `ssh-copy-id`（它还会将公钥 `*.pub`
    添加到远程服务器的 `~/.ssh/authorized_keys` 文件的末尾），或者将其粘贴到托管服务的网页表单中。然后你可以使用存储在本地机器上的私钥进行登录，例如
    `~/.ssh/id_rsa`。如果不是默认身份密钥，你可能需要配置 SSH（在 Linux 上的 `~/.ssh/config`，在 MS Windows
    上有类似的配置文件）以为给定的连接（主机名）使用特定的身份文件。
- en: Another convenient way to use public key authentication is with an authentication
    agent such as `ssh-agent` (or Pageant from PuTTY on MS Windows). Utilizing an
    agent also makes it more convenient to work with passphrase-protected private
    keys—you need to provide the password only once, to the agent, at the time of
    adding the key (which might require user action, for example, running `ssh-add`
    for `ssh-agent`).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公钥认证的另一种便捷方法是使用认证代理，例如 `ssh-agent`（或者在 MS Windows 上使用 PuTTY 的 Pageant）。利用代理也使得使用带有密码保护的私钥更加方便——你只需在添加密钥时提供一次密码给代理（这可能需要用户操作，例如，运行
    `ssh-add` 对 `ssh-agent`）。
- en: Credential helpers
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 凭据助手。
- en: It can be cumbersome to input the same credentials over and over. For SSH, you
    can use public key authentication, but there is no true equivalent for other transports.
    Git credential configuration provides two methods to at least reduce the number
    of questions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一直重复输入相同的凭据可能会很麻烦。对于 SSH，你可以使用公钥认证，但对于其他传输方式没有真正的等价物。Git 凭据配置提供了两种方法，至少可以减少提问次数。
- en: 'The first is the static configuration of default usernames (if one is not provided
    in the URL) for a given **authentication context**—for example, hostname:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是为给定的 **认证上下文** 配置默认用户名（如果 URL 中没有提供用户名）——例如，主机名：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It helps if you don’t have secure storage for credentials.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安全存储凭据的方法，它会有所帮助。
- en: The second is to use external programs from which Git can request both usernames
    and passwords—**credential helpers**. These programs usually interface with secure
    storage (a keychain, keyring, wallet, credentials manager, and so on) provided
    by the desktop environment or the operating system.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种是使用外部程序，Git 可以从中请求用户名和密码 — **凭据助手**。这些程序通常与桌面环境或操作系统提供的安全存储（钥匙链、密钥环、钱包、凭据管理器等）进行接口。
- en: Git, by default, includes at least the `cache` and `store` helpers. The `cache`
    helper (`git-credential-cache`) stores credentials in memory for a short period
    of time; by default, it caches usernames and passwords for 15 minutes. The `store`
    helper (`git-credential-store`) stores *unencrypted* credentials for an indefinitely
    long time on disk, in files readable only by the user (similar to `~/.netrc`);
    there is also a third-party `netrc` helper (`git-credential-netrc`) for GPG-encrypted
    `netrc/authinfo` files.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Git 至少包含`cache`和`store`助手。`cache`助手（`git-credential-cache`）将凭据存储在内存中，有效期为短暂的时间；默认情况下，它会为用户名和密码缓存15分钟。`store`助手（`git-credential-store`）将*未加密*的凭据永久存储在磁盘上，仅由用户可读的文件中（类似于`~/.netrc`）；还有第三方`netrc`助手（`git-credential-netrc`）用于
    GPG 加密的`netrc/authinfo`文件。
- en: 'Selecting a credential helper to use (and its options) can be configured either
    globally or per authentication context, as in the previous example. Global credentials
    configuration looks like the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可以全局或每个身份验证上下文配置选择要使用的凭据助手及其选项，如前面的示例所示。全局凭据配置如下所示：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will make Git use the `cache` credential helper, which will then cache
    credentials for 300 seconds (5 minutes). If the credential helper name is not
    an absolute path (for example, `/usr/local/bin/git-kde-credentials-helper`), Git
    will prepend the `git credential-` prefix to the helper’s name. You can check
    what types of credential helpers are available with `git help -a | grep credential-`.
    Git for Windows also includes, optionally, `git credential-helper-selection`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使 Git 使用`cache`凭据助手，它会缓存凭据300秒（5分钟）。如果凭据助手名称不是绝对路径（例如，`/usr/local/bin/git-kde-credentials-helper`），Git
    会在助手名称前加上`git credential-`前缀。你可以通过`git help -a | grep credential-`检查可用的凭据助手类型。Git
    for Windows 还包括可选的`git credential-helper-selection`。
- en: There exist credential helpers that use secure storage of the desktop environment.
    When you are using them, you need to provide the password only once, to unlock
    the storage (some helpers can be found in the `contrib/` area in Git sources).
    There is `git-credential-libsecret` for GNOME and KDE, `git-credential-osxkeychain`
    for the macOS Keychain, and `git-credential-manager` for Microsoft’s cross-platform
    **Git Credential** **Manager** (**GCM**).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 存在使用桌面环境安全存储的凭据助手。当你使用它们时，只需提供密码一次，以解锁存储（某些助手可以在 Git 源代码的 `contrib/` 区域找到）。有适用于
    GNOME 和 KDE 的`git-credential-libsecret`，适用于 macOS Keychain 的 `git-credential-osxkeychain`，以及适用于
    Microsoft 跨平台 Git Credential Manager（GCM）的 `git-credential-manager`。
- en: You can also use `git-credential-oauth` to avoid having to set up personal access
    tokens or SSH keys. With this solution, the first time you authenticate, the helper
    opens a browser window to the host. Subsequent access uses cached credentials.
    Here, one can use the fact that Git supports multiple credential helpers. GitHub,
    GitLab, and Bitbucket are among the Git hosting services that support OAuth authentication.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`git-credential-oauth`来避免设置个人访问令牌或 SSH 密钥。使用此解决方案时，第一次验证时，助手会打开浏览器窗口到主机。后续访问使用缓存的凭据。在这里，可以利用
    Git 支持多个凭据助手的特性。GitHub、GitLab 和 Bitbucket 是支持 OAuth 身份验证的 Git 托管服务之一。
- en: Git will use credential configuration for the most specific authentication context,
    though if you want to distinguish the HTTP URL by pathname (for example, providing
    different usernames to different repositories on the same host), you need to set
    the `useHttpPath` configuration variable to `true`. If there are multiple helpers
    configured for context, each will be tried in turn, until Git acquires both a
    username and a password.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Git 将为最特定的身份验证上下文使用凭据配置，但如果你想通过路径名区分 HTTP URL（例如，在同一主机上为不同仓库提供不同的用户名），你需要将`useHttpPath`配置变量设置为`true`。如果为上下文配置了多个助手，则会依次尝试每个，直到
    Git 获取到用户名和密码。
- en: Historical note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 历史注释
- en: Before the introduction of credential helpers, one could use *askpass* programs
    that interface with the desktop environment keychain—for example, **kwalletaskpass**
    (for KDE Wallet) or **git-password** (for the macOS Keychain).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在凭据助手引入之前，人们可以使用与桌面环境钥匙串接口的*askpass*程序——例如，**kwalletaskpass**（用于KDE钱包）或**git-password**（用于macOS钥匙串）。
- en: Publishing your changes upstream
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的更改发布到上游
- en: The *Collaborative workflows* section in [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140),
    *Collaborative Development with Git* explained various repository setups. Here,
    we’ll learn about a few common patterns for contributing to a project. We’ll see
    what our main options for publishing changes are.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 6 章*](B21194_06.xhtml#_idTextAnchor140)中，*Git 协作开发*节解释了各种仓库设置。在这里，我们将了解一些为项目做贡献的常见模式。我们将看到发布更改的主要选项。
- en: Before starting work on new changes, you should usually sync with the main development,
    incorporating the official version into your repository. This, and the work of
    the maintainer, is left to be described in [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229),
    *Merging* *Changes Together*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始新的更改工作之前，你通常应该与主开发版本同步，将官方版本合并到你的仓库中。这部分内容以及维护者的工作将在[*第 9 章*](B21194_09.xhtml#_idTextAnchor229)中，*合并*
    *更改* *一起* 中描述。
- en: Pushing to a public repository
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送到公共仓库
- en: In a **centralized workflow**, publishing your changes consists simply of **pushing**
    them to the central server, as shown in *Figure 6**.2*. Because you share this
    central repository with other developers, it can happen that somebody has already
    pushed to the branch you are trying to update (the non-fast-forward case). In
    this scenario, you need to pull (fetch and merge, or fetch and rebase) others’
    changes, before being able to push yours. This case is shown at the start of the
    *Updating your repository (with merge)* section in [*Chapter 1*](B21194_01.xhtml#_idTextAnchor015),
    *Git Basics* *in Practice*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在**集中式工作流**中，发布你的更改仅仅是将其**推送**到中央服务器，如*图 6.2*所示。因为你与其他开发者共享这个中央仓库，所以有可能其他人已经推送到你试图更新的分支（即非快进的情况）。在这种情况下，你需要拉取（获取并合并，或获取并变基）其他人的更改，然后才能推送你的更改。这种情况在[*第
    1 章*](B21194_01.xhtml#_idTextAnchor015)中“*更新你的仓库（使用合并）*”一节开始时有说明，位于《*Git 基础* *实践*》中。
- en: Another possible system with a similar workflow is when your team submits each
    set of changes to the code review system—for example, Gerrit. One available option
    is to push to a special ref, `refs/for/<branchname>` (which is named after a target
    branch), in a special repository. Then, the change review server makes each set
    of changes land automatically on a separate per-set ref (for example, `refs/changes/<change-id>`
    for commits belonging to a series with the given change ID).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类似工作流的系统是，当你的团队将每一组更改提交到代码审查系统时——例如，Gerrit。一种可用的选项是将更改推送到一个特殊的引用`refs/for/<branchname>`（这个引用是以目标分支命名），并推送到一个特殊的仓库中。然后，变更审查服务器会将每一组更改自动放置到一个单独的每组引用中（例如，`refs/changes/<change-id>`，适用于属于给定更改ID系列的提交）。
- en: Important note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In both peer-to-peer (see *Figure 6**.3*) and maintainer workflows, or the hierarchical
    workflow variant (*Figure 6**.4* and *Figure 6**.5*, respectively), the first
    step in getting your changes included in the project is to perform the push operation,
    but pushing to *your own* “public” repository (visible to the appropriate group)
    of your fork of the project. Then, you need to ask your co-developers, or the
    project maintainer, to merge your changes. You can do this, for example, by generating
    a **pull request**, as described below.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在点对点（见*图 6.3*）和维护者工作流，或分层工作流变体（分别见*图 6.4*和*图 6.5*）中，将更改纳入项目的第一步是执行推送操作，但推送到*你自己的*“公共”仓库（对相应组可见）中的项目分支。然后，你需要请求你的共同开发者或项目维护者合并你的更改。你可以通过生成**拉取请求**来实现这一点，如下所述。
- en: Generating a pull request
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成拉取请求
- en: 'In all workflows other than the centralized workflow, one needs to send a notification
    that changes are available in the public repository to co-developers, to the maintainer,
    or to integration managers. The `git request-pull` command can help with this
    step. Given the starting point (the bottom of the revision range of interest),
    the URL or the name of the remote public repository, and optionally, the commit
    to end at (if it is not the `HEAD`), this command will generate a summary of changes:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在除集中式工作流以外的所有工作流中，需要向共同开发者、维护者或集成经理发送通知，告知公共仓库中有可用的更改。`git request-pull` 命令可以帮助完成此步骤。给定起始点（即感兴趣的修订范围的底部），远程公共仓库的
    URL 或名称，以及可选的提交结束点（如果不是 `HEAD`），此命令将生成更改的摘要：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The pull request contains the SHA-1 of the base of the changes (which is the
    revision just before the first commit, in the series proposed for pull), the title
    of the base commit, the URL, the branch of the public repository (suitable as
    `git pull` parameters), the title of the final commit, the `git shortlog` output),
    and `git diff --stat` output) of the changes. This output can be sent to the maintainer—for
    example, by email.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求包含更改基准的 SHA-1（即提议拉取的系列中第一个提交之前的修订）、基准提交的标题、URL、公共仓库的分支（适合用作 `git pull` 参数）、最终提交的标题、`git
    shortlog` 输出和 `git diff --stat` 输出。这些输出可以发送给维护者——例如，通过电子邮件。
- en: '![](img/B21194_07_01.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21194_07_01.jpg)'
- en: Figure 7.1 – “New pull request” action shown in a list of branches on GitHub
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 在 GitHub 的分支列表中显示的“新建拉取请求”操作
- en: A lot of Git hosting software and services include a built-in equivalent of
    `git request-pull` (for example, the **Create pull request** action in GitHub).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Git 托管软件和服务都包括与 `git request-pull` 相对应的内置功能（例如，GitHub 中的 **创建拉取请求** 操作）。
- en: Exchanging patches
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换补丁
- en: Many larger projects (and many open source projects) have established procedures
    for accepting changes in the form of **patches**, for example, to lower the barrier
    to entry for contributing. If you want to send a one-off code proposal to a project
    but do not plan to be a regular contributor, sending patches might be easier than
    a full collaboration setup (acquiring permission to commit in the centralized
    workflow, setting up a personal public repository for forking and similar workflows—on
    GitHub, that would consist of **forking** the project). Besides, one can generate
    patches with any compatible tool, and the project can accept patches no matter
    what is the version control setup.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 许多大型项目（以及许多开源项目）已经建立了接受补丁形式更改的流程，例如，降低贡献的门槛。如果你想向一个项目发送一次性的代码提案，但不打算成为常规贡献者，发送补丁可能比完整的协作设置更容易（在集中式工作流中获得提交权限、设置个人公共仓库进行分支和类似工作流——在
    GitHub 上，这将包括 **fork** 项目）。此外，任何兼容工具都可以生成补丁，项目可以接受补丁，无论版本控制设置如何。
- en: Tip
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Nowadays, with the proliferation of various free Git hosting services, it might
    be more difficult to set up an email client for sending properly formatted patch
    emails—though services such as *GitGitGadget* (for submitting patches to the Git
    project mailing list), or the older *submitGit* service, could help. Git itself
    also includes commands for sending mail, namely **git send-email** and **git imap-send**,
    both of which need configuration.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，随着各种免费 Git 托管服务的普及，可能更难设置电子邮件客户端以发送格式正确的补丁电子邮件——尽管像 *GitGitGadget*（用于向 Git
    项目的邮件列表提交补丁）或较早的 *submitGit* 服务可以提供帮助。Git 本身也包括发送邮件的命令，即 **git send-email** 和
    **git imap-send**，这两者都需要配置。
- en: 'Additionally, patches, being a text representation of changes, can be easily
    understood by computers and humans alike. This makes them universally appealing,
    and very useful for *code review* purposes. Many open source projects historically
    used the public mailing list for that purpose: you can email a patch to this list
    and the public can review and comment on your changes (with services such as *public-inbox*
    and *lore+lei*, it is possible even without subscribing to the mailing list).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，补丁作为更改的文本表示形式，可以被计算机和人类轻松理解。这使得它们具有普遍的吸引力，并且在 *代码审查* 过程中非常有用。许多开源项目历史上使用公共邮件列表进行此目的：你可以将补丁通过电子邮件发送到这个列表，公众可以审查并评论你的更改（通过
    *public-inbox* 和 *lore+lei* 等服务，即使没有订阅邮件列表，也可以进行此操作）。
- en: 'To generate email versions of each commit series, turning them into mbox-formatted
    patches, you can use the `git format-patch` command, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成每个提交系列的电子邮件版本，并将其转换为 mbox 格式的补丁，可以使用 `git format-patch` 命令，如下所示：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can use any revision range specifier with this command. The most commonly
    used is limiting by the number of commits, as in the preceding example, or by
    using the double-dot revision range syntax—for example, `@{u}..` (see [*Chapter
    4*](B21194_04.xhtml#_idTextAnchor083), *Exploring Project History*, the *Double-dot
    notation* section). When generating a larger number of patches, it is often useful
    to select a directory to save generated patches. This can be done with the `-o
    <directory>` option. The `-M` option for `git format-patch` (passed to `git diff`)
    turns on rename detection; this can make patches smaller and easier to review.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何修订范围说明符与此命令配合使用。最常用的是通过提交数量来限制，如前面的示例所示，或者使用双点修订范围语法——例如，`@{u}..`（见[*第4章*](B21194_04.xhtml#_idTextAnchor083)，*探索项目历史*，*双点符号*部分）。在生成大量补丁时，选择一个目录来保存生成的补丁通常是很有用的。可以使用`-o
    <directory>`选项来实现。`git format-patch`的`-M`选项（传递给`git diff`）开启了重命名检测；这可以使补丁更小、更容易审查。
- en: 'The patch files end up looking like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁文件最终看起来是这样的：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It is actually a complete email in the mbox format. The subject (after stripping
    the `[PATCH]` prefix) and everything up to the three-dash line (`---`) forms the
    commit message—the description of the change. To email this to a mailing list
    or a developer, you can use either `git send-email` or `git imap-send`, or any
    email client capable of sending plain text email. The maintainer can then use
    `git am` to apply the patch series, creating commits automatically; there’s more
    about this in [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229), *Merging Changes
    Together*, in the *Applying a series of commits from* *patches* section.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上是一个完整的mbox格式的电子邮件。主题（去掉`[PATCH]`前缀后）以及三连字符线（`---`）之前的所有内容构成了提交信息——即更改的描述。要将其发送到邮件列表或开发人员，可以使用`git
    send-email`或`git imap-send`，或者任何能够发送纯文本邮件的电子邮件客户端。维护者随后可以使用`git am`来应用补丁系列，自动创建提交；有关更多内容，请参阅[*第9章*](B21194_09.xhtml#_idTextAnchor229)，*合并更改*部分，*应用补丁系列*章节。
- en: Email subject convention for patches
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁的邮件主题约定
- en: The **[PATCH]** prefix is there to make it easier to distinguish patches from
    other emails. This prefix can—and often does—include additional information, such
    as the number in the series (set) of patches, the revision of the series, the
    information about it being a **work in progress** (**WIP**), or the **Request
    For Comments** (**RFC**) status—for example, **[****RFC/PATCHv4 3/8]**.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**[PATCH]**前缀是为了更容易区分补丁与其他电子邮件。这个前缀可以——并且通常会——包括额外的信息，如补丁系列中的编号（集合）、系列的修订版、关于它是**进行中的工作**（**WIP**）或**征求意见**（**RFC**）状态的信息——例如，**[****RFC/PATCHv4
    3/8]**。'
- en: You can also edit these patch files to add more information for prospective
    reviewers—for example, information about alternative approaches, the differences
    between previous revisions of the patch (previous attempts), or a summary and/or
    references to the discussion on implementing the patch (for example, on a mailing
    list). You add such text between the `---` line and the beginning of the patch,
    before the summary of changes (`diffstat`); it will be ignored by `git am`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编辑这些补丁文件，为未来的审阅者添加更多信息——例如，关于替代方法的信息、补丁的前几个版本（之前的尝试）之间的差异，或者实现补丁的讨论的摘要和/或参考资料（例如，邮件列表中的讨论）。你可以在`---`行和补丁开始之间的地方添加此类文本，在更改摘要（`diffstat`）之前；`git
    am`会忽略这些内容。
- en: Tip – range diff
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 提示——范围差异
- en: If the series of patches is undergoing revision and needs to be redone in a
    different way, it is recommended practice to provide in the cover letter the **git
    range-diff** output, showing the differences between one iteration of the series
    and the other.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果补丁系列正在修订并且需要以不同的方式重新执行，推荐的做法是在封面信中提供**git range-diff**输出，显示该系列的一个版本与另一个版本之间的差异。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how to choose a transport protocol (if the
    remote server offers such a choice), and a few tricks such as using foreign repositories
    as if they were native Git repositories and offline transport with bundles.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何选择传输协议（如果远程服务器提供此类选择），以及一些技巧，比如将外部仓库当作本地Git仓库使用和使用离线传输（通过bundle）。
- en: Contact with remote repositories can require providing credentials—usually,
    the username and password, to be able to, for example, push to the repository.
    This chapter described how Git can help make this part easier thanks to credential
    helpers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与远程仓库的联系可能需要提供凭证——通常是用户名和密码，以便能够执行例如推送到仓库等操作。本章描述了Git如何通过凭证助手帮助简化这部分内容。
- en: Publishing your changes and sending them upstream may involve different mechanisms,
    depending on the workflow. This chapter described push, pull request, and patch-based
    techniques.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 发布你的更改并将其推送到上游可能涉及不同的机制，这取决于工作流。本章介绍了 push、pull 请求和基于补丁的技术。
- en: 'The two following chapters expand on the topic of collaboration: [*Chapter
    8*](B21194_08_split_000.xhtml#_idTextAnchor196), *Advanced Branching Techniques*,
    explores relations between local branches and branches in a remote repository,
    and how to set up branches for collaboration, while [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229),
    *Merging Changes Together*, talks about the opposite issue—how to join the results
    of parallel work.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两章扩展了协作主题：[*第8章*](B21194_08_split_000.xhtml#_idTextAnchor196)，*高级分支技巧*，探讨了本地分支和远程仓库分支之间的关系，以及如何为协作设置分支；而
    [*第9章*](B21194_09.xhtml#_idTextAnchor229)，*合并更改*，则讨论了相反的问题——如何将并行工作的结果合并在一起。
- en: Questions
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，以测试你对本章内容的掌握情况：
- en: How can one clone a large repository when the connection to the host is quite
    unreliable, but you can log in to the host with the remote repository?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当连接到主机的网络不太稳定时，如何克隆一个大型仓库，但你可以登录到主机并访问远程仓库？
- en: What do you need to get your changes into the canonical repository in the centralized
    workflow, and what do you need to do in the integration manager workflow?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在集中式工作流中，如何将更改提交到规范仓库？在集成管理者工作流中需要做些什么？
- en: How can you set up Git so you would need to provide a password only once, and
    not for each contact with the remote?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何设置 Git，使得只需提供一次密码，而不是每次与远程连接时都需要输入？
- en: Can you use Git to interact with foreign version-control system repositories,
    to submit commits and download updates?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能否使用 Git 与外国版本控制系统的仓库进行交互，提交提交并下载更新？
- en: Answers
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to the questions given above:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述问题的答案：
- en: One possible solution is to use **git bundle** on the remote host, and send
    the generated file via resumable transport such as HTTPS, rsync, or BitTorrent,
    or simply transport it via removable media such as a USB stick.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是使用 **git bundle** 在远程主机上创建打包文件，并通过可恢复的传输方式（如 HTTPS、rsync 或 BitTorrent）发送该文件，或通过可移动存储介质（如
    USB 闪存驱动器）传输该文件。
- en: In the centralized workflow, you need to push to said central canonical repository,
    which might require merging changes from others first; in the integration manager
    workflow, you need to either push to your public repository and send some kind
    of pull request (for example, with **git request-pull** and email) against the
    canonical repository, or send patches by email to the maintainer.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在集中式工作流中，你需要将更改推送到指定的中央规范仓库，这可能需要先合并其他人的更改；在集成管理者工作流中，你需要将更改推送到公共仓库，并发送某种形式的
    pull 请求（例如，使用 **git request-pull** 和电子邮件）到规范仓库，或者通过电子邮件将补丁发送给维护者。
- en: You can set up a credential helper appropriate for the operating system and
    desktop environment used; for SSH transport, you can also use **ssh-agent** or
    the equivalent.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以根据操作系统和桌面环境设置合适的凭证助手；对于 SSH 传输，你还可以使用 **ssh-agent** 或等效工具。
- en: With appropriate tools, you can either use Git to work as a client for a foreign
    version control system (for example, **git svn**) or use a remote transport helper
    to treat a foreign repository as a Git remote (for example, **git-cinnabar**).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的工具，你可以使用 Git 作为外部版本控制系统的客户端（例如，**git svn**），或使用远程传输助手将外部仓库当作 Git 远程仓库来使用（例如，**git-cinnabar**）。
- en: Further reading
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解本章中涉及的更多内容，请查看以下资源：
- en: 'Scott Chacon and Ben Straub: *Pro Git, 2nd Edition* (2014) [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Scott Chacon 和 Ben Straub: *Pro Git（第2版）*（2014年）[https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)'
- en: '*Chapter 7.12 Git Tools –* *Bundling*'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第7.12章 Git 工具 –* *打包*'
- en: '*Chapter 7.14 Git Tools -* *Credential Storage*'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第7.14章 Git 工具 -* *凭证存储*'
- en: 'Bundle URI: [https://git-scm.com/docs/bundle-uri](https://git-scm.com/docs/bundle-uri)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '打包 URI: [https://git-scm.com/docs/bundle-uri](https://git-scm.com/docs/bundle-uri)'
- en: 'Anthony Heddings: *Should You Use HTTPS or SSH For Git?* (2021) [https://www.howtogeek.com/devops/should-you-use-https-or-ssh-for-git/#why-use-https](https://www.howtogeek.com/devops/should-you-use-https-or-ssh-for-git/#why-use-https)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Anthony Heddings: *你应该使用 HTTPS 还是 SSH 来进行 Git 操作？*（2021年）[https://www.howtogeek.com/devops/should-you-use-https-or-ssh-for-git/#why-use-https](https://www.howtogeek.com/devops/should-you-use-https-or-ssh-for-git/#why-use-https)'
- en: '*A visual guide to SSH* *tunnels* [https://robotmoon.com/ssh-tunnels/](https://robotmoon.com/ssh-tunnels/)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SSH隧道* 的视觉指南 [https://robotmoon.com/ssh-tunnels/](https://robotmoon.com/ssh-tunnels/)'
- en: 'Carl Tashian: *SSH Tips & Trick* – *Add a second factor to your SSH login*
    (2020) [https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh](https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Carl Tashian: *SSH技巧与窍门* – *为你的SSH登录添加第二因素认证*（2020） [https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh](https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh)'
- en: 'Greg Kroah-Hartman: *“Patches carved into stone tablets”, or why the Linux
    kernel developers rely on plain text email*, a Kernel Recipes 2016 talk [https://kernel-recipes.org/en/2016/talks/patches-carved-into-stone-tablets/](https://kernel-recipes.org/en/2016/talks/patches-carved-into-stone-tablets/)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Greg Kroah-Hartman: *“刻入石板的补丁”*，或为何Linux内核开发者依赖纯文本邮件，2016年Kernel Recipes演讲
    [https://kernel-recipes.org/en/2016/talks/patches-carved-into-stone-tablets/](https://kernel-recipes.org/en/2016/talks/patches-carved-into-stone-tablets/)'
