- en: Rebasing Regularly and Interactively, and Other Use Cases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定期和交互式变基，及其他使用场景
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下操作：
- en: Rebasing commits to another branch
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将提交变基到另一个分支
- en: Continuing a rebase with merge conflicts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续处理合并冲突的变基操作
- en: Rebasing selected commits interactively
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式变基选定提交
- en: Squashing commits using an interactive rebase
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用交互式变基压缩提交
- en: Changing the author of commits using a rebase
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变基更改提交的作者
- en: Autosquashing commits
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动压缩提交
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Rebase is an incredibly strong Git feature. Hopefully, you have used it before;
    if not, you might have heard about it. Rebasing is exactly what the word implies.
    So, if you have a certain commit, `A`, which is based on commit `B`, then rebasing
    `A` to `C` would result in commit `A` being based on commit `C`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 变基是一个非常强大的Git功能。希望你之前已经使用过它；如果没有，你也许听说过它。变基正如它的字面意思。如果你有一个基于提交`B`的提交`A`，那么将`A`变基到`C`，最终结果就是提交`A`基于提交`C`。
- en: As you will see in the different examples in this chapter, it is not always
    as simple as that.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在本章的不同示例中看到的那样，情况并不总是那么简单。
- en: Rebasing commits to another branch
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将提交变基到另一个分支
- en: To start with, we are going to perform a very simple rebase, where we will introduce
    a new file, commit that file, make a change to it, and then commit it again so
    that we end up with two new commits.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将执行一个非常简单的变基操作，在这个过程中，我们将引入一个新文件，提交该文件，对其进行修改，然后再次提交，这样我们最终会得到两个新的提交。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we start, we need a repository to work in. You can use a previous clone
    of `jgit`, but to get a close-to-identical output from the example, you can clone
    the `jgit` repository.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要一个可以操作的仓库。你可以使用之前克隆的`jgit`仓库，但为了得到与示例尽可能相同的输出，你可以克隆`jgit`仓库。
- en: 'The `jgit` repository can be cloned as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`jgit`仓库可以通过以下方式克隆：'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We start by creating a local branch and then make two commits by performing
    the following steps; these are the commits that we want to rebase onto another
    branch:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个本地分支，然后通过以下步骤进行两个提交；这些提交是我们希望变基到另一个分支上的：
- en: 'Check out a new branch, `rebaseExample`, which tracks `origin/stable-3.1`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检出一个新的分支`rebaseExample`，它跟踪`origin/stable-3.1`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Make two commits on the `rebaseExample` branch, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`rebaseExample`分支上做两个提交，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we rebase the change on top of the `origin/stable-3.2` branch instead:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将把更改变基到`origin/stable-3.2`分支上：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When you execute `git rebase`, Git starts by finding the common ancestor of
    the current `HEAD` branch and the branch you want to rebase to. When Git finds
    `merge-base`, it will find the commits that are not available in the branch you
    are rebasing onto. Git will simply try to apply those commits one by one.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行`git rebase`时，Git首先会查找当前`HEAD`分支和你希望变基的目标分支的公共祖先。当Git找到`merge-base`时，它会查找那些在目标分支中不可用的提交。Git会逐个应用这些提交。
- en: Continuing a rebase with merge conflicts
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续处理合并冲突的变基操作
- en: When you rebase a commit or a branch on top of a different `HEAD`, you may eventually
    see a conflict.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个提交或分支变基到另一个`HEAD`上时，你可能最终会遇到冲突。
- en: If there is a conflict, you will be asked to solve the merge conflict and continue
    with the rebase using `git rebase --continue`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生冲突，系统会要求你解决合并冲突，然后使用`git rebase --continue`继续变基操作。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will be creating a commit that adds the same `fishtank.txt` file on top
    of the `origin/stable-3.1` branch; then, we will try to rebase this on top of
    the `rebaseExample` branch we created in the *Rebasing commits to another branch*
    section:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个提交，将相同的`fishtank.txt`文件添加到`origin/stable-3.1`分支上；然后，我们将尝试将它变基到我们在*将提交变基到另一个分支*部分中创建的`rebaseExample`分支上：
- en: 'Check out the branch named `rebaseExample2`, which tracks `origin/stable-3.1`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检出名为`rebaseExample2`的分支，它跟踪`origin/stable-3.1`：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Make a commit on the branch:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分支上进行提交：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Try to rebase the branch on top of the `rebaseExample` branch:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将分支变基到`rebaseExample`分支上：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can solve the conflict in your preferred editor. Then, add the file to the
    index using `git add` and continue with the rebase.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在你喜欢的编辑器中解决冲突。然后，使用`git add`将文件添加到索引，并继续进行变基操作。
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can now check with `gitk` to see whether our change is rebased on top of
    the `rebaseExample` branch, as shown in the following screenshot:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`gitk`检查我们的更改是否已经变基到`rebaseExample`分支上，如下图所示：
- en: '![](img/a936be88-0c44-4f1c-987a-563944183fa7.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a936be88-0c44-4f1c-987a-563944183fa7.png)'
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As we learned from the first example, Git will apply the commits that are not
    available in the branch you are rebasing onto. In our example, it is only our
    commit, as we made it, that is available on the `rebaseExample2` branch.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一个例子中所学到的，Git 会应用那些在你重新基准的目标分支中不存在的提交。在我们的例子中，只有我们自己创建的提交存在于`rebaseExample2`分支上。
- en: There's more...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: You might have noticed in the output of the failing rebase that you have two
    extra options for the commit.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在失败的重新基准输出中注意到，你有两个额外的选项来处理提交。
- en: When you have resolved this problem, run `git rebase --continue`. If you prefer
    to skip this patch, run `git rebase --skip` instead. To check out the original
    branch and stop rebasing, run `git rebase --abort`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你解决了这个问题后，运行`git rebase --continue`。如果你希望跳过这个补丁，可以运行`git rebase --skip`。要检出原始分支并停止重新基准，运行`git
    rebase --abort`。
- en: The first extra option we have is to totally ignore this patch by skipping it;
    you can do this using `git rebase --skip`. In our example, this will cause our
    branch to be fast-forwarded to the `rebaseExample` branch. So, both our branches
    will point to the same commit hash.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个额外选项是完全忽略这个补丁并跳过它；你可以使用`git rebase --skip`来实现。在我们的例子中，这将导致我们的分支快进到`rebaseExample`分支。因此，我们的两个分支将指向相同的提交哈希值。
- en: The second option is to abort the rebasing. If we choose to do this, then we
    will go back to the branch as it was prior to starting the rebase. This can be
    done using `git rebase --abort`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是中止重新基准。如果我们选择这样做，我们将返回到重新基准开始之前的分支状态。可以使用`git rebase --abort`来实现。
- en: Rebasing selected commits interactively
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式地重新基准选定的提交
- en: When you are working on a new feature and have branched from an old release
    into a feature branch, you might want to rebase this branch onto the latest release.
    When looking into the list of commits on the feature branch, you may realize that
    some of the commits are not suitable for the new release. In that case, when you
    want to rebase the branch onto a new release, you will need to remove some commits.
    This can be achieved with interactive rebasing, where Git gives you the option
    to pick the commits you wish to rebase.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在开发新特性并从旧版本分支出来时，你可能希望将此分支重新基准到最新的发布版本。当查看特性分支上的提交列表时，你可能会发现一些提交不适用于新的发布版本。在这种情况下，当你想要将分支重新基准到新版本时，你需要删除一些提交。这可以通过交互式重新基准来实现，Git
    会给你选择你希望重新基准的提交的选项。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started with this example, you need to check the previously created
    branch, `rebaseExample`; if you don''t have this branch, follow the steps from
    the *Rebasing commits to another branch* section and use the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个例子，你需要检查之前创建的分支`rebaseExample`；如果你没有这个分支，可以按照*将提交重新基准到另一个分支*部分的步骤操作，并使用以下命令：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that, because we are tracking `origin/stable-3.1`, the Git checkout will
    tell us how far ahead we are in comparison with that branch.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，因为我们正在跟踪`origin/stable-3.1`，所以 Git 检出会告诉我们与该分支相比，我们超前了多少。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will try to rebase our current branch, `rebaseExample`, on top of the `origin/stable-3.1`
    branch by performing the following steps. Remember that Git will apply the commits
    that are not available on the branch we are rebasing to; so, in this case, there
    will be a lot of commits:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试将当前分支`rebaseExample`重新基准到`origin/stable-3.1`分支，通过执行以下步骤。记住，Git 会应用那些在我们重新基准的目标分支上不存在的提交；因此，在这种情况下，会有很多提交：
- en: 'Rebase the branch onto `origin/stable-3.1` by using the following command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将分支重新基准到`origin/stable-3.1`：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What you will see now is a list of all the commits you will be rebasing onto
    the `origin/stable-3.1` branch. These commits are all the commits between the
    `origin/stable-3.1` and `rebaseExample` branches. The commits will be applied
    from top to bottom, hence, the commits will be listed in reverse order—at least
    compared to what you would normally see in Git. This actually makes good sense.
    The commits have the keyword `pick` to the left and then the abbreviated commit
    hash, and finally the title of the commit subject.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在看到的是所有将被重新基准到`origin/stable-3.1`分支上的提交列表。这些提交是`origin/stable-3.1`和`rebaseExample`分支之间的所有提交。提交将从上到下应用，因此提交会按相反的顺序列出——至少与
    Git 中通常看到的顺序相反。这其实是有道理的。提交左侧有`pick`关键字，接着是简短的提交哈希值，最后是提交的标题。
- en: 'If you scroll down to the bottom, you will see a list along the lines of the
    following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向下滚动到页面底部，你会看到类似以下内容的列表：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, if we only want our `fishtank` commits to be based on top of the `origin/stable-3.1`
    branch, we should remove all the commits except for our two.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们只希望我们的`fishtank`提交基于`origin/stable-3.1`分支，那么我们应该移除所有提交，除了我们这两个提交。
- en: 'Remove all the lines except for the two commits at the bottom; for now, leave
    `pick` as the keyword. Save the file and close the editor, and you will get the
    following message from Git:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除底部两个提交之外的所有行；暂时保持`pick`作为关键字。保存文件并关闭编辑器，Git 会给出以下信息：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, with `gitk`, check whether we accomplished what we predicted. The next
    screenshot shows our two `fishtank` commits on top of the `origin/stable-3.1`
    branch. The following screenshot is what we expected:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`gitk`检查我们是否达到了预期的效果。下图展示了我们两个`fishtank`提交位于`origin/stable-3.1`分支之上。接下来的截图就是我们预期的效果：
- en: '![](img/2fa6ba1e-496b-4bc2-8814-ed2f55c70ce5.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fa6ba1e-496b-4bc2-8814-ed2f55c70ce5.png)'
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The same thing could actually be achieved with a single short Git command.
    We have been rebasing commits from the `origin/stable-3.2` branch to the `rebaseExample`
    branch onto the `origin/stable-3.2` branch. This can also be achieved in the following
    manner:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，使用一个简单的 Git 命令也可以实现相同的效果。我们已经将`origin/stable-3.2`分支的提交变基到`rebaseExample`分支，并将其合并到`origin/stable-3.2`分支。这也可以通过以下方式实现：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `--onto origin/stable-3.2` flag tells Git to rebase onto `origin/stable-3.2`,
    and it has to be from `origin/stable-3.1` to the `rebaseExample` branch. So, we
    end up having the `rebaseExample` branch to the branch of the `origin/stable-3.1`
    and so on. The next diagram illustrates both before the rebase example, where
    we have our two commits on top of `origin/stable-3.2`, and after the rebase, where
    our commits are on top of `origin/stable-3.1`, as we wanted:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`--onto origin/stable-3.2`标志告诉 Git 变基到`origin/stable-3.2`，并且它必须从`origin/stable-3.1`分支到`rebaseExample`分支。因此，最终我们会得到`rebaseExample`分支位于`origin/stable-3.1`分支上，依此类推。下图展示了变基前的状态，其中我们有两个提交位于`origin/stable-3.2`之上，而变基后的状态是我们的提交位于`origin/stable-3.1`之上，正如我们所期望的那样：'
- en: '![](img/49a5c6d8-ec59-4496-8d7b-8864d0d28c6a.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49a5c6d8-ec59-4496-8d7b-8864d0d28c6a.png)'
- en: Squashing commits using an interactive rebase
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用交互式变基来压缩提交
- en: When I work on a local branch, I prefer to commit in small increments with a
    few comments on what I did in the commits; however, as these commits do not build
    or pass any test requirements, I cannot submit them for review and verification
    one by one. I have to merge them in my branch, but still, cherry-picking my fix
    would require me to cherry-pick twice the number of commits, which is not very
    handy.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在本地分支上工作时，我喜欢以小增量提交，每次提交都带上一些关于我所做工作的评论；然而，由于这些提交不能构建或通过任何测试要求，我无法逐个提交它们进行审查和验证。我必须在我的分支中将它们合并，但如果要逐一挑选我的修复，就必须挑选两倍数量的提交，这样做不太方便。
- en: What we can do is rebase and squash the commits into a single commit, or at
    least fewer commits.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的是变基并将提交压缩为一个提交，或者至少减少提交数量。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To get started with this example, we need a new branch, namely `rebaseExample3`,
    which tracks `origin/stable-3.1`. Create the branch with the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个示例，我们需要一个新的分支，即`rebaseExample3`，它跟踪`origin/stable-3.1`。使用以下命令创建该分支：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To really showcase this Git feature, we will start off six commits ahead of
    the `origin/stable-3.1` branch. This is to simulate the fact that we have just
    created six commits on top of the `rebaseExample3` branch; to do this, perform
    the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正展示这个 Git 特性，我们将从`origin/stable-3.1`分支的六个提交开始。这是为了模拟我们刚刚在`rebaseExample3`分支上创建了六个提交；为此，请执行以下步骤：
- en: 'Find a commit that is between `origin/stable-3.1` and `origin/stable-3.2`,
    and list the commits in reverse order. Alternatively, you can scroll down to the
    bottom of the output and find the commit we will use, as shown in the following
    snippet:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个介于`origin/stable-3.1`和`origin/stable-3.2`之间的提交，并按逆序列出提交。或者，您可以滚动到底部，找到我们将使用的提交，如下所示：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Reset the `rebaseExample3` branch to the `5218f7b` commit; this will simulate
    having six commits on top of the `origin/stable-3.1` branch. This can be tested
    by running the status of Git as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`rebaseExample3`分支重置为`5218f7b`提交；这将模拟在`origin/stable-3.1`分支上有六个提交。可以通过如下命令检查
    Git 的状态来验证：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, we have these six commits on top of the `origin/stable-3.1` branch, and
    we want to squash these commits into two different commits. This can be done by
    simply running `git rebase --interactive`. Note that we are not specifying which
    branch we want to rebase to, since we have already set up a tracking branch when
    we created the branch using `--track`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在`origin/stable-3.1`分支上有了这六个提交，我们希望将这些提交压缩成两个不同的提交。只需运行`git rebase --interactive`即可完成。请注意，我们没有指定要rebase到哪个分支，因为在创建分支时我们已经使用`--track`设置了跟踪分支。
- en: 'To continue, let''s execute the rebase command as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为继续操作，让我们执行如下的rebase命令：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The editor will open, and you will see four commits, not six as you would expect.
    This is because the rebase, in general, refuses to take merged commits as part
    of the rebase scenario. Although you can use the `--preserve-merges` flag, as
    per the Git Help section, this is not recommended.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑器将打开，你将看到四个提交，而不是你预期的六个。这是因为通常情况下，rebase会拒绝将合并的提交作为rebase的一部分。虽然你可以使用`--preserve-merges`标志，但根据Git帮助文档，这并不推荐。
- en: According to the Git Help section, instead of ignoring merges, `--preserve-merges` tries
    to recreate them. The `--preserve-merges` flag uses the `--interactive` machinery
    internally, but combining it with the `--interactive` option explicitly is generally
    not a good idea, unless you know what you are doing (see the bugs in the following
    snippet).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Git帮助文档，`--preserve-merges`并不是忽略合并，而是尝试重新创建它们。`--preserve-merges`标志内部使用`--interactive`机制，但通常不建议将其与`--interactive`选项显式结合使用，除非你知道自己在做什么（参见下面代码段中的bug）。
- en: 'Edit the file so that it looks as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑文件，使其看起来如下所示：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that commits are listed in reverse order compared to the Git log. So,
    when squashing commits, we squash up into the commits we have marked with the
    `pick`. When you close the editor, Git will start the rebase from top to bottom.
    First, apply `8a51c44` and then squash `f045a68` into the commit `8a51c44`. This
    will open the commit message editor, which contains both of the commit messages.
    You can edit the commit messages, but for now, let's just close the editor to
    finish with the rebase and the squashing of these two commits. The editor will
    open one more time to complete the squashing of `5218f7b` into `7995d87`. Use
    `gitk` to verify the result.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，提交是按与Git日志相反的顺序列出的。所以，在压缩提交时，我们将提交合并到我们标记为`pick`的提交中。当你关闭编辑器时，Git将从上到下开始rebase。首先，应用`8a51c44`，然后将`f045a68`压缩到`8a51c44`提交中。这将打开提交信息编辑器，其中包含两个提交信息。你可以编辑提交信息，但现在我们只是关闭编辑器，以完成这两个提交的rebase和压缩操作。编辑器将再次打开，完成将`5218f7b`压缩到`7995d87`的操作。使用`gitk`验证结果。
- en: 'The following screenshot is as expected; now, we only have two commits on top
    of the `origin/stable-3.1` branch:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图符合预期；现在，我们只在`origin/stable-3.1`分支上有两个提交：
- en: '![](img/e5490c91-8648-43ec-b575-50a267630a57.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5490c91-8648-43ec-b575-50a267630a57.png)'
- en: 'If you check the commit message of the `HEAD` commit, you will see that it
    has the information of two commits, as shown in the following command. This is
    because we decided not to change the commit message when we made the change:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果查看`HEAD`提交的提交信息，你会看到它包含了两个提交的信息，如以下命令所示。这是因为我们决定在进行更改时不更改提交信息：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There's more...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Now we have squashed two commits, but we could have used other keywords when
    editing the rebase's to-do list.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经压缩了两个提交，但我们本可以在编辑rebase的待办列表时使用其他关键字。
- en: 'We will try the fixup functionality, which works like the squash functionality,
    by performing the following steps; the exception is that Git will select the commit
    message of the commits using the `pick` keyword:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试修复功能（fixup），它的工作方式类似于squash功能，通过执行以下步骤；唯一的区别是，Git将使用`pick`关键字选择提交的提交信息：
- en: 'Start by resetting back to our starting point:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从重置回我们的起点开始：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, we are back at the starting point, that is, we''re six commits
    ahead of the `origin/stable-3.1` branch. Now we can try the fixup functionality.
    Start the interactive rebase and change the file according to the following output.
    Notice that you can use `f` instead of `fixup`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们已经回到了起点，即我们比`origin/stable-3.1`分支多了六个提交。现在我们可以尝试fixup功能。启动交互式rebase并根据以下输出更改文件。注意，你可以使用`f`代替`fixup`：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you close the editor, you will see rebase''s progress through Git. As
    predicted, the commit message editor will not open. Git will just rebase the changes
    into two commits on top of the `origin/stable-3.1` branch. Using `git status`,
    you can confirm that you have just two commits:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你关闭编辑器，你将看到Git显示变基的进度。正如预期的那样，提交信息编辑器不会打开。Git会将变基操作合并到`origin/stable-3.1`分支的两个提交上。使用`git
    status`命令，你可以确认你现在有两个提交：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another difference is that the commit message from the two commits we marked
    with fixup has disappeared. So, if you compare this with the previous example,
    it''s very clear what the difference is; it''s shown in the following command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个不同点是，我们用`fixup`标记的两个提交的提交信息已消失。所以，如果你将其与之前的示例进行比较，差异非常明显；差异可以通过以下命令查看：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we can also confirm that we still have the same source code, but with
    different commits. This can be done by comparing this commit with the commit we
    created via `5218f7b`, using the following command:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还可以确认我们仍然拥有相同的源代码，但提交已发生变化。这可以通过使用以下命令，将此提交与通过`5218f7b`创建的提交进行比较来完成：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As predicted, there is no output from `git diff`, so we still have the same
    source code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预测的那样，`git diff`没有输出，所以我们仍然保留着相同的源代码。
- en: This check can also be performed on the previous example.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个检查也可以在之前的示例中进行。
- en: Changing the author of commits using a rebase
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变基更改提交的作者
- en: When starting to work on a new project, it is common to forget to set the author
    name and author email address for the specified project. Therefore, you will often
    have commits in your local branch that have been committed with the wrong username
    and/or email ID.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始一个新项目时，常常会忘记为该项目设置作者姓名和电子邮件地址。因此，你可能会在本地分支中看到一些使用错误的用户名和/或电子邮件ID进行提交的记录。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we begin this exercise, we need a branch, as always with Git. Name the
    branch `resetAuthorRebase` and make it track `origin/master`. Use the following
    command to achieve this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要一个分支，像Git中一样，创建一个名为`resetAuthorRebase`的分支，并使其跟踪`origin/master`。可以使用以下命令来完成：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行...
- en: Now, we want to change the author of all the commits from `origin/stable-3.2` to
    our `HEAD`, which is `master`. This is just an example; you will rarely have to
    change the author of commits that have already been published to a remote repository.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要将所有从`origin/stable-3.2`到我们的`HEAD`（即`master`）的提交作者进行更改。这只是一个示例；你通常不会需要更改已经发布到远程仓库的提交作者。
- en: 'You can change the author of the `HEAD` commit by using `git commit --amend
    --reset-author`; however, this will only change the author of `HEAD` and leave
    the rest of the commits as they were. We will start by changing the author of
    the `HEAD` commit and then verify why that is wrong by performing the following
    steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`git commit --amend --reset-author`来更改`HEAD`提交的作者；然而，这只会更改`HEAD`的作者，并保持其余提交不变。我们将从更改`HEAD`提交的作者开始，然后通过执行以下步骤验证为什么这样做是错误的：
- en: 'Change the author of the `HEAD` commit as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示更改`HEAD`提交的作者：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Verify that you have changed it using the Git log command:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Git log命令验证你是否已经更改了作者信息：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will list all the commits from `origin/stable-3.2` to `HEAD` and we will
    define a format with `%h` as the abbreviated commit hash, `%an` for the author''s
    name, and `%ae` for the author''s email address. From the output, you can see
    that I am now the author of the `HEAD` commit, but what we really wanted was to
    change the author of all the commits. To do this, we will rebase onto the `origin/stable-3.2`
    branch; then, for each commit, we will stop to amend and reset the author. Git
    can do most of that work with `--exec option` for the `git` rebase, as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将列出从`origin/stable-3.2`到`HEAD`的所有提交，并定义一个格式，`%h`代表简短的提交哈希值，`%an`代表作者的名字，`%ae`代表作者的电子邮件地址。从输出中你可以看到，我现在是`HEAD`提交的作者，但我们真正想要的是更改所有提交的作者。为此，我们将基于`origin/stable-3.2`分支进行变基；然后，对于每个提交，我们将停止并修正作者。Git可以通过`--exec`选项帮助我们完成大部分工作，具体命令如下：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, Git has opened the rebase's to-do list for you, and between
    every commit, you have the `exec` keyword and the command we specified on the
    command line. You can have more `exec` lines between commits if you have a use
    case for them. Closing the editor will start the rebase.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，Git为你打开了变基的待办列表，在每个提交之间，你都可以看到`exec`关键字和我们在命令行中指定的命令。如果有需要，你还可以在提交之间添加更多`exec`行。关闭编辑器将开始变基操作。
- en: 'As you will see, this process is not very good, as the commit message editor
    opens every time and you have to close the editor to allow Git to continue with
    the rebase. To stop the rebase, clear the commit message editor and Git will return
    to the command line; then, you can use `git rebase --abort` as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，这个过程并不理想，因为每次都会打开提交消息编辑器，你必须关闭编辑器以让 Git 继续变基。要停止变基，请清空提交消息编辑器，Git 将返回到命令行；然后，你可以使用
    `git rebase --abort`，如下所示：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To achieve what we really want, you can add the `--reuse-message` option for
    `git commit`; this will reuse the commit message for the commit you will specify.
    We want to use the message of `HEAD`, as we are going to amend it to the `HEAD`
    commit. So, try again, as shown in the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们真正想要的，你可以为 `git commit` 添加 `--reuse-message` 选项；这将重用你指定提交的提交消息。我们想要使用
    `HEAD` 的消息，因为我们将其修改到 `HEAD` 提交。所以，再试一次，如下所示：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Git provides an output indicating that the action was a success; however, to
    verify this, you can execute the previous Git log command and you should see that
    the email address has changed on all the commits, as shown in the following command:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Git 提供了一个输出，表示操作成功；然而，为了验证这一点，你可以执行之前的 Git 日志命令，你应该看到所有提交的电子邮件地址都已经改变，如下所示：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'It works as you would expect! There is one thing to remember: when using the
    `exec` option, Git will check the work area for unstaged and staged changes. Consider
    the following command line:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它按你预期的方式工作！有一点需要记住：当使用 `exec` 选项时，Git 会检查工作区中未暂存和已暂存的更改。请看以下命令行：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you were to have a line as illustrated in the preceding command, the first
    `exec` would be executed and you would then have an unstaged change in your work
    area. Git would complain and you would have to solve that before continuing with
    the next `exec`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像前面的命令那样有一行，第一次 `exec` 将被执行，接着你会在工作区有一个未暂存的更改。Git 会抱怨，你必须解决这个问题才能继续下一个 `exec`。
- en: So, if you want to do something like this, you must create a single exec line
    that executes all the things you want. Besides this, the rebase functionality
    is fairly simple; it just tries to apply the changes in the order specified in
    the rebase's to-do list. Git will only apply the changes specified in the list,
    so if you remove some of them, they will not be applied. This is a way to clean
    up a feature branch for unwanted commits, for instance, commits that enable you
    to debug.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你想做类似的事情，你必须创建一行执行所有你想做的操作的 `exec`。除此之外，变基功能相当简单；它只是尝试按变基待办列表中指定的顺序应用更改。Git
    只会应用列表中指定的更改，因此，如果你移除其中的一些，它们将不会被应用。这是一种清理功能分支中不需要的提交的方法，比如调试过程中生成的提交。
- en: Autosquashing commits
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动合并提交
- en: When I work with Git, I often create a lot of commits for a single bug fix,
    but when making the delivery to the remote repository, I prefer—and recommend—delivering
    the bug fix as one commit. This can be achieved with an interactive rebase, but
    since this should be a common workflow, Git has a built-in feature called autosquash,
    which will help you squash the commits together.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我使用 Git 时，我经常为一个单独的 bug 修复创建许多提交，但在将修改推送到远程仓库时，我更喜欢——并且推荐——将 bug 修复作为一个提交来交付。这可以通过交互式变基来实现，但由于这应该是一个常见的工作流程，Git
    提供了一个内置功能，叫做 autosquash，它可以帮助你将提交合并在一起。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we begin with this exercise, we will create a branch from `origin/master`
    so we are ready to add commits to our fix.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始这个操作之前，我们将从 `origin/master` 创建一个分支，以便准备将提交添加到我们的修复中。
- en: 'Let''s start with something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这样的例子开始：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'After checking the branch, we will create the first commit that we want to
    squash other commits to. We need to use the abbreviated commit hash from this
    commit to automatically create other commits that will squash to this commit by
    performing the following steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 检查分支后，我们将创建我们想要合并其他提交的第一个提交。我们需要使用此提交的缩写提交哈希值，按照以下步骤自动创建其他将合并到此提交的提交：
- en: 'Start by echoing some text into `README.md`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从将一些文本写入 `README.md` 开始：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will append more information to `README.md` for developers; verify that
    the file has changed using the Git status as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将为开发者向 `README.md` 添加更多信息；使用 Git 状态验证文件是否已更改，如下所示：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we want to add and commit this. We can do this with the `commit` command
    using the `-a` flag, which will add any unstaged changes to the commit, as shown
    in the following command:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要添加并提交这些更改。我们可以使用 `commit` 命令，并加上 `-a` 标志，这将把任何未暂存的更改加入提交，正如以下命令所示：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After you create the commit, remember the abbreviated commit hash; we have highlighted
    it in bold in the command output. The abbreviation will be different in your environment,
    and you should have your own abbreviation once you finish the exercise.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建提交后，请记住简短的提交哈希；我们已经在命令输出中以粗体标出了它。该简短哈希在你的环境中会有所不同，一旦完成练习，你应该会有自己的简短哈希。
- en: 'To continue, we will add three commits to the branch, and we would like to
    squash two of these with the first commit, as shown in the following command:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了继续，我们将向分支添加三个提交，并希望将其中的两个与第一个提交进行 squash，正如以下命令所示：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is the first commit. Pay attention to why we needed to store the abbreviated
    hash of the first commit—we used it with the `--squash` option for `git commit`.
    This option will create the commit with the subject of the commit specified. It
    will also add `squash!` to the start of the subject. This is to indicate that
    Git should squash this commit when performing a rebase. Now, create the second
    commit, as shown in the following command:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是第一个提交。注意我们为什么需要存储第一个提交的简短哈希——我们将其与 `git commit` 的 `--squash` 选项一起使用。该选项会使用指定的提交主题来创建提交，同时会在主题开头加上
    `squash!`，表示在执行 rebase 时 Git 应该 squash 该提交。现在，创建第二个提交，正如以下命令所示：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We have added two commits that we would like to squash with the first commit.
    When committing, I also used the `--no-edit` option; this skips the opening of
    the commit''s message editor. If you leave the flag out, the editor will open
    as it usually does when committing. The difference is that the commit subject
    has already been set, and you only need to write the commit message. Now, we will
    create the last commit; we don''t want to squash this commit:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了两个提交，并希望将它们与第一个提交一起 squash。在提交时，我还使用了 `--no-edit` 选项；该选项会跳过打开提交信息编辑器。如果不使用这个标志，编辑器将照常打开。不同之处在于，提交主题已经设置好，你只需要填写提交信息。现在，我们将创建最后一个提交，我们不希望将这个提交进行
    squash：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We add the final commit, which does not have anything to do with the first
    three commits we added. This is why we did not use the `--squash` option. We can
    now squash the commits together using `git rebase -i`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了最后一个提交，它与我们添加的前三个提交没有任何关系。这就是我们为什么没有使用 `--squash` 选项的原因。现在，我们可以使用 `git
    rebase -i` 将这些提交进行 squash：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You will get the rebase''s to-do list up in the configured commit editor. What
    we would have expected was to have Git configure a squash for the commits we wanted
    to squash, as shown in the following command:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会在配置的提交编辑器中看到 rebase 的待办事项列表。我们原本期望 Git 会为我们想要 sqush 的提交配置 squash，正如以下命令所示：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'What you can see is that Git inserted `squash` to the subject of two of the
    commits, but besides this, we did not get what we had expected. Git requires you
    to specify `--autosquash` to the `git rebase -i` command. Close the editor and
    Git will perform the rebase and give the following output:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到，Git 已经将 `squash` 插入到两个提交的主题中，但除此之外，我们没有得到预期的结果。Git 要求你在 `git rebase -i`
    命令中指定 `--autosquash`。关闭编辑器后，Git 将执行 rebase 操作，并给出以下输出：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s try again with `--autosquash` and see what happens with the rebase''s
    to-do list:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再试一次使用 `--autosquash`，看看 rebase 的待办事项列表会发生什么：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, the rebase's to-do list looks much more as we expected. Git has preconfigured
    the to-do list to show which commits it will squash and which commits it will
    keep.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，rebase 的待办事项列表看起来更符合我们的预期。Git 已经预先配置了待办事项列表，显示出它将会 squash 哪些提交，保留哪些提交。
- en: 'Closing the to-do list now will start the rebase, and we don''t want that (the
    next step will show what we really want). If you clear the to-do list (deleting
    all lines), save and close the editor, the rebase will be aborted. This is what
    we want. The output will be as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在关闭待办事项列表将开始执行 rebase，但我们不想这样做（下一步会展示我们真正想要的结果）。如果你清空待办事项列表（删除所有行），然后保存并关闭编辑器，rebase
    将会被中止。这正是我们想要的。输出将如下所示：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'What we really want to do is just run `git rebase -i` and Git will use `--autosquash`
    as the default. This can be achieved with `git config rebase.autosquash true`;
    try it and then run `git rebase -i`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们真正想要做的只是运行 `git rebase -i`，Git 会默认使用 `--autosquash`。这可以通过 `git config rebase.autosquash
    true` 来实现；试试看，然后运行 `git rebase -i`：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The rebase''s to-do list pops up, and we have the expected result as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变基的待办事项列表弹出，我们得到了预期的结果，如下所示：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now close the editor and allow the rebase to start. The editor opens and you
    can change the commit message for the combined message, as shown in the following
    command:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在关闭编辑器并允许变基开始。编辑器打开后，你可以更改合并消息的提交消息，如下命令所示：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Modify the message and close the editor; Git continues with the rebase and
    ends with the following message:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改消息并关闭编辑器；Git 会继续进行变基操作并以以下消息结束：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As expected, we now have two commits on top of the `origin/master` commit.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们现在在 `origin/master` 提交之上有两个提交。
- en: Hopefully, this will assist you when you are just making changes and committing
    them, but want to deliver the code as one commit.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能帮助你在进行更改并提交时，但仍想将代码作为一个提交来交付。
- en: There's more...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you want to avoid opening the commit message editor, as in step 17 of the
    *Autosquashing commits* recipe, you can use `--fixup=d539645`. This will use the
    commit message from the first commit and totally disregard any message written
    in the commits.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想避免像在 *自动压缩提交* 配方的第17步那样打开提交消息编辑器，可以使用 `--fixup=d539645`。这将使用第一个提交的提交消息，完全忽略其他提交中编写的消息。
