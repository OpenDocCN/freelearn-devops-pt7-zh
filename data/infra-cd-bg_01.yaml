- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Choosing the Right Approach – Declarative or Imperative
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的方法——声明式还是命令式
- en: Welcome to the first chapter of *Infrastructure as Code for Beginners*. In this
    book, we will be going on a journey that will take you through your first Infrastructure-as-Code
    deployment, and it is an honor to be accompanying you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到*基础设施即代码入门*的第一章。在本书中，我们将进行一次旅程，带你完成第一次基础设施即代码的部署，非常荣幸能与您同行。
- en: Before we dive into the tools we will be using throughout the book, we are first
    going to discuss some of the key concepts to try and get an understanding of the
    problems that you could try to solve by introducing Infrastructure as Code into
    your deployments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论我们在本书中将使用的工具之前，我们首先要讨论一些关键概念，尝试理解通过将基础设施即代码引入您的部署，您可能希望解决的一些问题。
- en: 'We will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: The challenges of managing infrastructure manually
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动管理基础设施的挑战
- en: What is meant by declarative and imperative?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式和命令式是什么意思？
- en: Pets versus cattle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宠物与牲畜
- en: What does all this mean for our Infrastructure-as-Code deployments?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些对于我们的基础设施即代码部署意味着什么？
- en: The challenges of managing infrastructure manually
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动管理基础设施的挑战
- en: Before we look at some of the challenges you may be facing, I quickly wanted
    to take you through my journey with Infrastructure as Code before it was really
    what we now know as Infrastructure as Code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看看你可能面临的一些挑战之前，我想快速带你回顾一下我与基础设施即代码的历程，虽然那时它还不是现在我们所知道的基础设施即代码。
- en: 'When I talk about Infrastructure as Code, I mean the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我谈到基础设施即代码时，我指的是以下内容：
- en: '*Infrastructure as Code is an approach to infrastructure management where it
    is provisioned and managed using code and automation tools rather than manually
    configuring resources through a* *user interface.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*基础设施即代码是一种基础设施管理方法，通过代码和自动化工具来提供和管理基础设施，而不是通过用户界面手动配置资源。*'
- en: '*This allows you to version control, track, and manage your infrastructure
    in the same way you do with application code and, in many cases, use the same
    tooling, processes, and procedures you already have* *in place.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*这使得你可以像管理应用代码一样对基础设施进行版本控制、追踪和管理，并且在很多情况下，使用你已经拥有的相同工具、流程和程序来完成这项工作。*'
- en: '*Infrastructure as Code can help improve your infrastructure operations’ efficiency,
    reliability, and reproducibility by introducing consistency across your deployments
    and reducing deployment times versus more traditional* *manual deployments.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*基础设施即代码可以通过在部署中引入一致性，减少与传统* *手动部署相比的部署时间，帮助提高基础设施操作的效率、可靠性和可重复性。*'
- en: My own journey
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我的历程
- en: I have been working with servers of all types for longer than I care to remember;
    back when I first started working with servers, it was all very much a manual
    process to do pretty much anything.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我从事服务器相关工作已经超过了我能记住的时间；当我第一次接触服务器时，几乎所有的工作都是完全手动的。
- en: The bare-metal days
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 裸机时代
- en: Before *virtualization* became a common practice, I remember having to block
    out a whole day to build a customer’s server. This process would generally start
    with ensuring that the hardware I was given to work with was of the correct specification
    – if for some reason it wasn’t, which was quite common, then I would typically
    have to replace RAM and hard drives, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在*虚拟化*成为一种常见实践之前，我记得曾经需要花上一整天时间来构建客户的服务器。这个过程通常从确保我手头的硬件符合正确规格开始——如果由于某种原因硬件不符合要求，而这在当时是很常见的，我通常需要更换内存、硬盘等等。
- en: This was to ensure that I didn’t get too far into configuring the server, only
    to find that I had to tear it down and start from scratch; once the hardware was
    confirmed as being correct, it was time to start on the build itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了确保我不会在配置服务器时深入到一定程度，结果发现必须拆掉重做；一旦确认硬件无误，就可以开始实际构建了。
- en: Typically, to build the server, I sat in a tiny, hot, and noisy build room surrounded
    by equipment, bits of computer, and what felt like reams of paper, which contained
    not only instructions on how to manually install the various operating systems
    we supported but also build sheets containing configuration and information on
    the customer’s required software stack I was deploying.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在构建服务器时，我坐在一个狭小、闷热且嘈杂的机房里，周围是各种设备、电脑零件，还有感觉像是成堆的纸张，这些纸张不仅包含了如何手动安装我们支持的各种操作系统的指令，还包括了构建表格，里面记录了客户所需软件堆栈的配置信息。
- en: Once built, the server was packed back into its box, put in the back of someone’s
    car, and taken to a data center. From there the server was racked and cabled for
    both power and networking and then powered the server on – if everything was configured
    correctly, it would spring into life and be available on the network.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，服务器被重新打包，放回某人的车里，送到数据中心。从那里，服务器被安装到机架上，并连接电力和网络，然后启动服务器——如果一切配置正确，它将启动并在网络上可用。
- en: After some quick testing, it was back to the comfort of the office to complete
    the build steps and, finally, hand the server over to the customer for them to
    deploy their software on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些快速测试后，回到办公室舒适的环境中完成构建步骤，最后将服务器交给客户，让他们在上面部署他们的软件。
- en: While this process was fine when there was one or two of these deployments,
    once in a blue moon, as things got busier, it quickly became unmanageable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种流程在偶尔只有一两次部署时还算可以，但随着事情变得更加繁忙，它很快变得难以管理。
- en: The next logical step was to have a build server that contained drive images
    for all the supported operating systems and base software stack configurations,
    with some custom scripts that ran when the server first booted to customize the
    base configuration and get it onto the network when the server was racked in the
    data center.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的逻辑步骤是拥有一个构建服务器，其中包含所有支持的操作系统和基础软件堆栈配置的驱动镜像，并且当服务器首次启动时运行一些自定义脚本，以自定义基础配置，并在服务器安装到数据中心机架时将其接入网络。
- en: Enter virtualization
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进入虚拟化
- en: Once we started to move from provisioning bare metal servers for customers to
    virtualized servers, things got a lot easier – for a start, as you didn’t have
    to physically connect RAM, CPUs, or hard drives to the servers, assuming the cluster
    you were building the server in had the resource available, it made quite a dramatic
    change to the deployment time and also resulted in less time in the build room
    and data center.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始从为客户提供裸机服务器转向虚拟化服务器，事情变得更容易了——首先，因为不需要物理连接 RAM、CPU 或硬盘到服务器上，只要你构建服务器的集群中有足够的资源，这就大大改变了部署时间，同时也减少了在构建室和数据中心的时间。
- en: At this point, we had built up a collection of custom scripts that connected
    to both the virtualization hypervisors and virtual machines – these were shared
    between the team members in our subversion repository and documented in our internal
    wiki.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经积累了一系列自定义脚本，这些脚本连接到虚拟化管理程序和虚拟机——它们在我们的子版本控制库中与团队成员共享，并记录在我们的内部 Wiki
    中。
- en: This was my first, extremely basic by today’s standards, introduction to Infrastructure
    as Code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我第一次接触“基础设施即代码”，按今天的标准来看非常基础。
- en: Virtual machine configuration
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟机配置
- en: The next logical steps were to add a remote configuration into the mix by using
    a tool, such as **Puppet** or **Chef**; we could deploy our virtual machines using
    our custom scripts and then have the servers call back to our main management
    server, and then bootstrap itself as per the customer’s desired configuration
    state.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的逻辑步骤是通过使用工具（如**Puppet**或**Chef**）将远程配置加入其中；我们可以使用自定义脚本部署虚拟机，然后让服务器回调到我们的主管理服务器，按照客户的需求配置状态自启动。
- en: Putting it all together
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将一切整合在一起
- en: This was the final piece of the puzzle, which took our deployments from taking
    a few days per server to an hour or so, with the bulk of that time waiting for
    automated tasks to complete – though, as a lot of the initial stages of the deployments
    were initiated by our in-house DIY scripts, we still had to keep a careful eye
    on the progress.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是拼图的最后一块，它将我们的部署时间从每台服务器几天缩短到大约一个小时，其中大部分时间都在等待自动化任务完成——尽管部署的初期阶段大多由我们的内部自制脚本启动，但我们仍然需要仔细关注进度。
- en: This was because there wasn’t much logic built in to handle errors or other
    unexpected hiccups during the deployment, which, in some cases, resulted in some
    challenging post-deployment problems – but the least said about those, the better.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以这样，是因为在部署过程中并没有太多逻辑来处理错误或其他意外问题，这在某些情况下导致了许多挑战性的部署后问题——不过关于这些问题，越少提越好。
- en: Today’s challenges
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 今天的挑战
- en: So, how do today’s challenges differ from my own experiences? During my day
    job, I get to work with a lot of internal and external teams who are nearly all
    technical and are very hands-on with the day-to-day management and development
    of their own applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，今天的挑战与我自己的经验有什么不同呢？在我的日常工作中，我与许多内部和外部团队合作，这些团队几乎都是技术人员，并且非常注重自己应用程序的日常管理和开发。
- en: It’s all documented
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一切都有文档
- en: 'When discussing Infrastructure as Code with teams, one of the most common answers
    I get is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在与团队讨论基础设施即代码时，我最常听到的答案是：
- en: “*We have the process to deploy our infrastructure documented, and anyone in
    the team can work through it to quickly deploy* *a resource.*”
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: “*我们已经将基础设施部署过程文档化，团队中的任何人都可以按照文档快速部署* *资源*。”
- en: While it is great that there is documentation and that it is accessible by all
    of the members of the team, you would be surprised, even with the presence of
    comprehensive and easy-to-follow documentation, at just how much variance there
    is when people come to actually implement it. They don’t fully understand it because
    it is simply a set of tasks that lack any context as to why the tasks are being
    actioned.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有文档并且所有团队成员都可以访问它是件好事，但即便是有了全面且易于遵循的文档，你也会惊讶于当人们实际执行时，结果差异有多大。他们并没有完全理解文档，因为它只是一个任务清单，缺乏任务为何要执行的背景信息。
- en: Another potential issue is that the process is followed so often by a member
    of the team that they simply just get on with it, missing any updates or steps
    that have been added to the documentation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在的问题是，团队成员如此频繁地遵循这个过程，以至于他们只是照做，错过了文档中已添加的任何更新或步骤。
- en: Worst still – and this is more common than you may think – giving three technical
    people the same set of tasks to do can sometimes result in three very different
    outputs, as everyone has different experiences, which normally feeds into how
    we do things – for example, *last time I tried to A, B, and C, X happened, so
    now I do it C, B, and A* or *I think it would better to do it B, A, and then C
    – but don’t have time at the moment to update* *the documentation*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是——这比你想象的更常见——给三个技术人员相同的任务，有时会导致三种截然不同的结果，因为每个人的经验不同，而这些经验通常会影响我们做事的方式——例如，*上次我尝试做A、B和C时，发生了X，所以现在我按C、B和A的顺序做*，或者*我认为按B、A然后C做会更好——但现在没有时间更新*
    *文档*。
- en: All of these can introduce inconsistencies in your deployments, which may go
    unnoticed as everyone thinks they are doing it correctly because they are all
    following the same set of documentation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可能在你的部署中引入不一致，而这些问题可能不会被察觉，因为每个人都认为自己做得正确，因为他们都在遵循相同的文档。
- en: Next, next, next
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下一步，下一步，下一步
- en: 'The *next* (pun very much intended) answer I normally get is this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常听到的*下一个*（非常有意的双关）答案是：
- en: “*We don’t need to do it very often, and when we do, it’s just clicking ‘next,
    next, next’ in an interface – anyone can* *do it*.”
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “*我们不需要经常做这个，每次做时，只需在界面中点击‘下一步，下一步，下一步’——任何人都可以* *做*。”
- en: When I get this answer, what I actually hear is, *The process to deploy the
    resource is so easy that we didn’t bother to document it*. While this might be
    the case for some members of the team, not everyone may have the experience or
    confidence to simply click *next, next, next* to deploy and configure the resources
    without a guide.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我听到这个答案时，实际上我听到的是，*部署资源的过程太简单了，以至于我们没有费心去记录它*。虽然对于团队中的某些成员来说可能确实是这样，但并不是每个人都有经验或信心仅凭点击*下一步，下一步，下一步*就能部署和配置资源，而不需要指导。
- en: As I am sure you can imagine, if it is possible for inconsistencies to be present
    when everyone is following the same set of documentation, then doing the deployment
    without any of the guardrails that the documentation puts in place is going to
    introduce even more potential issues further down the line.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你能想象的那样，如果在每个人都在遵循相同文档的情况下还可能出现不一致，那么在没有文档所提供的防护措施的情况下进行部署，将会在后续过程中引入更多潜在的问题。
- en: Just because a resource has been deployed without error and works does not mean
    that it has been deployed securely and in such a way that could support your production
    workloads.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为资源已部署且没有错误并且能正常工作，并不意味着它已安全地部署并能够支持你的生产工作负载。
- en: We have everything we need
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们拥有所需的一切
- en: 'The final most common answer when discussing Infrastructure as Code is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论基础设施即代码时，最后一个最常见的答案是：
- en: “*We have deployed everything we need and don’t need any* *further resources.*”
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: “*我们已经部署了所需的一切，不需要任何* *额外的资源*。”
- en: Again, when I get this answer, I normally hear something slightly different
    – in my experience, this normally means that, a while ago, someone deployed something
    that is more than capable of the task and has now moved on, either going on to
    another project or department or has left the company altogether.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，当我得到这个回答时，我通常听到的是略微不同的说法——根据我的经验，这通常意味着，早些时候，有人部署了某个完全能够完成任务的东西，并且现在已经离开，要么转向了其他项目或部门，要么完全离开了公司。
- en: While it is great that the resources are running fine, this approach can cause
    issues if you ever need to redeploy or, worse still, firefight an issue with production,
    as a lot of knowledge of the underlying configuration is missing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然资源运行良好很棒，但这种方法可能会导致问题，特别是当你需要重新部署或，情况更糟时，解决生产环境中的问题时，因为很多关于底层配置的知识都缺失了。
- en: So, while you know *what’s there*, you may not necessarily know *why*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然你知道*存在什么*，但你不一定知道*为什么*。
- en: Conclusion
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: There are many more examples, but the previous ones are the most common ones
    I see when working with teams who may not have considered Infrastructure as Code
    to be a foundation of their deployment pipelines, and if you are reading this,
    then you may have already come across some of the examples and want to move onto
    the next step.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多其他例子，但前面这些是我在与那些可能未将基础设施即代码视为其部署管道基础的团队合作时最常见的例子，如果你正在阅读这篇文章，可能已经遇到了一些这样的例子，并且希望继续迈向下一步。
- en: 'So why would you take an Infrastructure-as-Code approach to your deployments?
    Well, there are several reasons, which include the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么你要采用基础设施即代码的方法来进行部署呢？其实有几个原因，包括以下几点：
- en: '**Documentation**: While we have already mentioned documentation, it’s important
    to note that if you employ Infrastructure as Code, your deployment is documented
    as part of your code as it defines the desired state of your infrastructure in
    a human-readable format.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：虽然我们已经提到过文档，但需要注意的是，如果你使用基础设施即代码（Infrastructure as Code），你的部署将作为代码的一部分被文档化，因为它以人类可读的格式定义了基础设施的期望状态。'
- en: '**Repeatable and consistent**: You should be able to pick up your code and
    deploy it repeatedly – sure, you may make some changes to things such as resource
    SKUs and names, but that should just be a case of updating some variables that
    are read at the time of execution rather than rewriting your entire code base.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重复和一致性**：你应该能够反复使用你的代码进行部署——当然，你可能会对资源的 SKU 和名称等进行一些修改，但这应该只是更新一些在执行时读取的变量，而不是重写整个代码库。'
- en: '**Time-saving**: As I mentioned, in my own experience, it sometimes took days
    to deploy resources – eventually, that got down to hours and, with more modern
    cloud-based resources, minutes.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节省时间**：正如我提到的，在我自己的经验中，部署资源有时需要几天——最终，部署时间缩短到几小时，而使用现代的云资源，甚至可以缩短到几分钟。'
- en: '**Secure**: Because you have your infrastructure defined in code, you know
    that you will have a well-documented end-to-end configuration ready to review
    as needed. Because it is easily deployable, you can quickly spin up an environment
    to review or deploy your latest fixes into, safe in the knowledge that it is consistent
    with your production configuration, as you are not relying on someone manually
    working through a step-by-step document where something may get missed or misinterpreted.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：因为你的基础设施在代码中定义，你知道你将拥有一个文档完备的端到端配置，随时可以查看。由于它可以轻松部署，你可以快速创建一个环境来查看或部署你的最新修复，并且放心，它与你的生产配置一致，因为你不依赖于某人手动执行逐步的文档，其中可能会遗漏或误解某些步骤。'
- en: '**Cost savings**: I think you should never approach an Infrastructure-as-Code
    deployment with cost savings being at the top of the list of things you would
    like to achieve – but it is a most welcome nice-to-have. Depending on your approach,
    cost savings can be a byproduct of the preceding points. For example, do you need
    to run your development or testing infrastructure 24/7 when your developers may
    only need it for a few days a week at most?'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节省成本**：我认为你不应以节省成本为首要目标来进行基础设施即代码的部署——但它无疑是一个非常受欢迎的“锦上添花”。根据你的方法，节省成本可以是前面各点的副产品。例如，你是否需要全天候运行你的开发或测试基础设施，而你的开发人员最多只在一周内的几天内需要它？'
- en: Well, that infrastructure can be deployed as part of your build pipeline with
    next to no or little effort. In that case, you may find yourself in the enviable
    position of only paying for the resources when you need them rather than paying
    for them to be available 24/7.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这些基础设施可以作为你构建管道的一部分，几乎无需或只需很少的努力就能部署。在这种情况下，你可能会发现自己处于一个令人羡慕的境地，只在需要时支付资源费用，而不是为了24/7可用性支付费用。
- en: So, now that we have discussed my personal journey with Infrastructure as Code
    and also gotten an idea of the different scenarios where Infrastructure as Code
    may come in useful and the potential reasons why you would want to incorporate
    it into your day-to-day workflows, let’s now discuss some of the basic concepts
    you need to know about before we start to talk about the tools we are going to
    look at for the remainder of the book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了我个人在基础设施即代码中的历程，并且了解了基础设施即代码在不同场景下可能的用途，以及你可能希望将其融入日常工作流的潜在原因，接下来我们来讨论一些在开始讲解本书剩余部分工具之前你需要了解的基本概念。
- en: What is meant by declarative and imperative?
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式和命令式是什么意思？
- en: In programming, there are different ways to give instructions to a computer
    to achieve the programmer’s desired result. These ways of telling the computer
    what to do are known as **programming paradigms**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，有多种方式向计算机下达指令以实现程序员期望的结果。这些向计算机指示操作的方式被称为**编程范式**。
- en: 'In general, they refer to how we build programs from logical ideas such as
    `if` statements or loops. There are other classifications as well: functional,
    structured, object-oriented, and so on. Each of these describes a different kind
    of task that programmers might perform when writing code or thinking about code.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，它们指的是我们如何从逻辑概念（如`if`语句或循环）构建程序。还有其他分类：函数式编程、结构化编程、面向对象编程等等。每种方式描述了程序员在编写代码或思考代码时可能执行的不同任务。
- en: '**Imperative** and **declarative** programming is the most fundamental way
    in which programmers think about defining their tasks and the two main ways in
    which we need to think about how we write and structure our Infrastructure as
    Code.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令式**和**声明式**编程是程序员在定义任务时最基本的思考方式，也是我们在编写和构建基础设施代码时需要思考的两种主要方式。'
- en: Before we discuss each way, let us define a quick Infrastructure-as-Code project.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论每种方式之前，让我们先定义一个简单的基础设施即代码项目。
- en: Basic Infrastructure-as-Code project
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本的基础设施即代码项目
- en: 'The following diagram shows the basic infrastructure for deploying a single
    virtual machine in Microsoft Azure:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了在 Microsoft Azure 中部署单个虚拟机的基本基础设施：
- en: '![Figure 1.1 – The basic Infrastructure-as-Code project diagram](img/Figure_1.01_B19537.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 基本的基础设施即代码项目示意图](img/Figure_1.01_B19537.jpg)'
- en: Figure 1.1 – The basic Infrastructure-as-Code project diagram
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 基本的基础设施即代码项目示意图
- en: 'As you can see, the project is made up of the following components:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，项目由以下组件组成：
- en: '`rg-iac-example-uks-001`) – This is a logical container in Azure to store the
    resources.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rg-iac-example-uks-001`) – 这是一个在 Azure 中存储资源的逻辑容器。'
- en: '`vnet-iac-example-uks-001`) – This is a virtual network that will host our
    example virtual machine.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vnet-iac-example-uks-001`) – 这是一个虚拟网络，将托管我们的示例虚拟机。'
- en: '`snet-iac-example-uks-001`) – This is not shown in the diagram, but the virtual
    network contains a single subnet.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snet-iac-example-uks-001`) – 这一部分在图中没有显示，但虚拟网络包含一个子网。'
- en: '`nsg-iac-example-uks-001`) – As we don’t want management ports such as `3389`
    (RDP) or `22` (SSH) open to anyone on the internet, this will add some basic rules
    to only accept traffic on these ports from trusted sources. This will be attached
    to the subnet, so the rules apply to all resources deployed there.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nsg-iac-example-uks-001`) – 由于我们不希望像`3389`（RDP）或`22`（SSH）这样的管理端口对任何互联网用户开放，这将添加一些基本规则，仅允许来自可信源的流量通过这些端口。此规则将附加到子网，因此适用于部署在该子网中的所有资源。'
- en: '`vm-iac-example-uks-001`) – This, as you may have guessed, is the virtual machine
    itself.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vm-iac-example-uks-001`) – 如你所料，这就是虚拟机本身。'
- en: '`nic-iac-example-uks-001`) – Here, we have the network interface, which will
    be attached to the virtual machine and the subnet within the virtual network.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nic-iac-example-uks-001`) – 这里我们有网络接口，它将连接到虚拟机和虚拟网络中的子网。'
- en: '`pip-iac-example-uks-001`) – Finally, we have the public IP address; this is
    going to be attached to the network interface, which will allow us to route to
    the virtual machine from the trusted locations defined in the network security
    group.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip-iac-example-uks-001`) – 最后，我们部署了公共IP地址；它将附加到网络接口上，从而允许我们从网络安全组中定义的受信任位置路由到虚拟机。'
- en: While this is a basic infrastructure example, there are quite a few different
    resources involved in the deployment. Also, as we are going to be talking at a
    very high level about how this could be deployed, we won’t be going into too much
    detail on Azure itself just yet, as this will be covered in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to* *Microsoft Azure*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个基础的基础设施示例，但部署中涉及了相当多的不同资源。此外，由于我们将从非常高层次讨论如何部署，因此目前不会详细讨论Azure本身，Azure的具体内容将在[*第4章*](B19537_04.xhtml#_idTextAnchor151)中讨论，*部署到*
    *Microsoft Azure*。
- en: Declarative approach
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明式方法
- en: When talking about my own experiences, I mentioned that I used a configuration
    tool; in my case, this was Puppet. Puppet uses declarative language to define
    the target configuration – be it a software stack or infrastructure – but what
    does that mean?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到我自己的经验时，我提到我使用了一个配置工具；在我的案例中，这个工具是Puppet。Puppet使用声明性语言来定义目标配置——无论是软件堆栈还是基础设施——但这到底意味着什么呢？
- en: Rather than try and give an explanation, let’s jump straight in and describe
    how a declarative tool would deploy our infrastructure.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与其试图给出一个解释，不如直接跳进来，描述一下一个声明性工具如何部署我们的基础设施。
- en: In its most basic configuration, a declarative tool only cares about the end
    state and not necessarily how it gets to that point. This means the tool, unless
    it is told to be, isn’t resource-aware, meaning that when the tool is executed,
    it decides the order in which the resources are going to be deployed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的配置中，声明性工具只关心最终状态，而不一定关心如何到达这个状态。这意味着，除非明确要求，否则工具并不关心资源的具体情况，即当工具执行时，它决定资源的部署顺序。
- en: 'For our example, let us assume that the tool uses the following order to deploy
    our resources:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，假设工具使用以下顺序来部署我们的资源：
- en: Virtual network
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟网络
- en: Resource group
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源组
- en: Network security group
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络安全组
- en: Subnet
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子网
- en: Public IP address
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共IP地址
- en: Virtual machine
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机
- en: Network interface
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络接口
- en: On the face of it, that doesn’t look too bad; let us explore how this ordering
    affects the deployment of our resources in Azure.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，这似乎没什么问题；让我们探讨一下这种顺序如何影响我们在Azure中的资源部署。
- en: 'The following figure shows the results of the deployments:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了部署结果：
- en: '![Figure 1.2 – The results of deploying our infrastructure using a declarative
    tool](img/Figure_1.02_B19537.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 使用声明性工具部署我们的基础设施的结果](img/Figure_1.02_B19537.jpg)'
- en: Figure 1.2 – The results of deploying our infrastructure using a declarative
    tool
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 使用声明性工具部署我们的基础设施的结果
- en: As you can see, it took three deployments for all the resources to be successfully
    deployed, so why was that?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有资源成功部署花了三次部署，那么为什么会这样呢？
- en: '**Deployment 1**: The virtual network failed to be deployed as it needed to
    be placed with the resource group, which wasn’t deployed yet. As all the remaining
    resources had a dependency on the virtual network, they also failed, meaning the
    only successful resource to be deployed during the first execution was the resource
    group, as that had no dependencies.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署 1**：虚拟网络未能成功部署，因为它需要与资源组一起部署，而资源组还没有被部署。由于所有剩余资源都依赖于虚拟网络，它们也都失败了，这意味着在第一次执行过程中唯一成功部署的资源是资源组，因为它没有任何依赖。'
- en: '**Deployment 2**: As we had the resource group in place from **Deployment 1**,
    then this time around, the virtual network and subnet both deployed; however,
    because the deployment of the network security group was attempted before the
    subnet was successfully deployed, that failed. The remaining failed resources
    – the public IP address and virtual machine – both failed because the network
    interface hadn’t been created yet.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署 2**：由于我们已经有了**部署 1**中的资源组，因此这次虚拟网络和子网都成功部署；然而，因为在子网成功部署之前就尝试部署网络安全组，导致网络安全组部署失败。剩余失败的资源——公共IP地址和虚拟机——都失败了，因为网络接口还没有被创建。'
- en: '**Deployment 3**: With the final set of dependencies in place from **Deployment
    2**, the remaining resources – the network security group, public IP address,
    and virtual machine – all launched successfully, which finally left us with our
    desired end state.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署 3**：在**部署 2**的最后一组依赖项到位后，其余资源——网络安全组、公共 IP 地址和虚拟机——都成功启动，最终让我们达到了预期的最终状态。'
- en: The term for this is **eventual consistency**, as our desired end state is eventually
    deployed after several executions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个术语叫做**最终一致性**，因为我们期望的最终状态是在经过几次执行后最终部署完成。
- en: In some cases, the failures during the initial deployment of the resources don’t
    really matter too much as our desired end state is eventually reached – however,
    with infrastructure, and depending on your target cloud environment, that may
    not always be true.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，资源初始部署时的失败并不太重要，因为我们期望的最终状态最终会达到——然而，对于基础设施来说，根据你的目标云环境，这种情况并不总是成立。
- en: In the early days of Infrastructure as Code, this was quite a large issue as
    you had to build logic to consider dependencies for the resources you were deploying
    – which not only meant that you had to know what the dependencies were but the
    bigger your deployment, the more inefficient it became.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础设施即代码的早期，这确实是一个大问题，因为你需要构建逻辑来考虑你部署的资源之间的依赖关系——这不仅意味着你需要知道依赖关系是什么，而且你的部署规模越大，效率就越低。
- en: This is because the more logic you start adding to the code, the more you start
    working against the declarative nature of the tool, which also carries the risk
    of introducing race conditions when the code is executed. For example, if you
    have one resource that takes five minutes to deploy – how do you know it’s ready?
    This would mean even more logic, which, if you got it wrong or something unexpected
    happened, you could be sat waiting for the execution to eventually time out.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为你在代码中添加的逻辑越多，就越是与工具的声明性特性背道而驰，这也带来了在执行代码时引入竞争条件的风险。例如，如果你有一个资源需要五分钟才能部署——你怎么知道它已经准备好？这意味着需要更多的逻辑，而如果你搞错了或者发生了意外情况，你可能会一直等着执行最终超时。
- en: Fear not; things have most definitely improved as the development of the tools
    has matured, and the tools have become more resource-aware. A lot of the manual
    logic you had to employ is now unnecessary, but there are still some considerations
    that we will go into in more detail in [*Chapter 2*](B19537_02.xhtml#_idTextAnchor085),
    *Ansible and Terraform beyond* *the Documentation*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心；随着工具的不断发展，情况已经有了显著改善，工具变得更加注重资源。很多你曾经需要手动处理的逻辑现在已经不再必要，但仍然有一些需要注意的事项，我们将在[*第
    2 章*](B19537_02.xhtml#_idTextAnchor085)《超越文档的 Ansible 和 Terraform》中详细讨论。
- en: Imperative approach
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式方法
- en: 'As you may have already guessed, when using an imperative approach, the tasks
    execute in the order you define them – and we know the order in which we need
    to run the tasks to deploy our resources, which is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，使用命令式方法时，任务按你定义的顺序执行——而我们知道需要按照什么顺序运行任务来部署我们的资源，顺序如下：
- en: Resource group
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源组
- en: Virtual network
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟网络
- en: Subnet
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子网
- en: Network security group
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络安全组
- en: Network interface
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络接口
- en: Public IP address
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共 IP 地址
- en: Virtual machine
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机
- en: 'It means that the result of running our first deployment will look like the
    following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们第一次部署的结果将如下所示：
- en: '![Figure 1.3 – The results of deploying our infrastructure using an imperative
    tool](img/Figure_1.03_B19537.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 使用命令式工具部署基础设施的结果](img/Figure_1.03_B19537.jpg)'
- en: Figure 1.3 – The results of deploying our infrastructure using an imperative
    tool
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 使用命令式工具部署基础设施的结果
- en: Great, you may be thinking to yourself, it works the first time! Well, sort
    of; there is a big assumption that you know the order in which your resources
    need to be deployed, and you need to structure the code in such a way that takes
    that into account.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，你可能会想，这次第一次就成功了！嗯，某种程度上是这样；不过这里有一个很大的假设，那就是你知道你的资源需要按什么顺序部署，而且你需要以考虑到这一点的方式来结构化代码。
- en: So, while this way would typically work first when executed, there could potentially
    be a little more upfront work to get the scripts in the right order using a little
    trial and error – however, once they are in the correct order, you can be confident
    that each time you execute them, they will work the first time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管这种方法通常在执行时能够有效，但可能需要稍微多一点前期工作，通过一些试错来将脚本调整到正确的顺序——然而，一旦它们按正确的顺序排列，你可以放心，每次执行时，它们都会成功。
- en: Now that we have discussed the key differences between declarative and imperative
    when it comes to Infrastructure as Code, let’s now talk about the differences
    between another deployment approach, pets versus cattle.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了声明式和命令式在基础设施即代码中的关键区别，接下来让我们讨论另一种部署方式——宠物与牲畜的区别。
- en: Pets versus cattle
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宠物与牲畜
- en: Traditionally, *pets or cattle* has been a way of defining your data center
    resources. It’s an analogy that describes a collection of hardware or virtualized
    resources as either pets or cattle.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，*宠物与牲畜*一直是定义数据中心资源的一种方式。这个类比描述了一组硬件或虚拟化资源是作为宠物还是作为牲畜。
- en: Pets
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宠物
- en: Pets are resources that are owned by individual users/teams or managed on an
    individual basis.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 宠物是由个人用户/团队拥有或单独管理的资源。
- en: 'Normally, they are seen as important fixed points within any application architecture
    and, like with a pet, you do the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，它们被视为任何应用架构中重要的固定点，就像宠物一样，你会做以下事情：
- en: '`backendapplication.server.domain.com`, so it is easily identifiable.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backendapplication.server.domain.com`，这样它就很容易被识别。'
- en: '**You feed and water them**: For example, you take and keep backups that you
    review regularly. You keep a close eye on resource utilization and add more RAM
    and drive space as required.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你喂养和照顾它们**：例如，你会定期进行备份并进行审查。你密切关注资源的利用情况，并根据需要增加更多的RAM和磁盘空间。'
- en: '**If they get ill, you care for them**: They have monitoring agents installed,
    meaning you are alerted if there is a problem – sometimes 24/7 – and if there
    is an issue, you do everything you can to restore service by having troubleshooting
    procedures in place.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果它们生病了，你会照顾它们**：它们已安装监控代理，意味着如果出现问题，你会收到警报——有时是24小时全天候——如果出现问题，你会尽力恢复服务，确保有故障排除流程。'
- en: '**You expect them to live for a long time**: Given their importance within
    your application architecture and that you are caring for them, you expect them
    to be around for quite a while.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你希望它们活得很长时间**：鉴于它们在你的应用架构中的重要性以及你对它们的照料，你希望它们能存在很长时间。'
- en: Resources that are now considered pets have typically been around for some time,
    and their configuration has organically evolved over that time based on their
    utilization, making them each a unique deployment, which is why you care for them,
    just like having a real pet – a good example of this is a long-running server.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在被视为宠物的资源通常已经存在一段时间，它们的配置随着时间的推移根据使用情况有机地发展，成为每个独特的部署，这就是为什么你像照顾宠物一样照顾它们——一个很好的例子就是长时间运行的服务器。
- en: Cattle
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 牲畜
- en: 'With resources that have been deployed to be treated as cattle, you only care
    about the health of the herd and not an individual resource:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些被部署并当作牲畜处理的资源，你只关心整体健康状况，而不是个别资源的健康：
- en: '`beapp001.server.domain.com` to `beapp015.server.domain.com`; you just keep
    incrementing the number rather than assigning a unique name that makes them easily
    identifiable.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beapp001.server.domain.com` 到 `beapp015.server.domain.com`；你只是不断增加数字，而不是分配一个独特的名称来让它们容易识别。'
- en: '**You watch them from afar**: Given the number of resources, you only really
    care about the availability of the herd, meaning you probably only just ship performance
    stats and logs from the resources, and you do not need to back them up as it would
    be quick to replace them.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你远远地观察它们**：考虑到资源的数量，你只关心整体的可用性，这意味着你可能只会从资源中获取性能统计数据和日志，而不需要备份它们，因为它们的替换速度很快。'
- en: '**If they get ill, you replace them**: As already mentioned, if there is an
    issue with a resource, rather than troubleshoot the problem, you terminate it
    and replace it with another resource ASAP. Typically, this process is automated
    so that a resource is quickly taken out of service and another one put in place.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果它们生病了，你会替换它们**：如前所述，如果资源出现问题，你不会对问题进行故障排除，而是立即终止它并用另一个资源替换。通常这个过程是自动化的，这样资源可以迅速下线并被替换。'
- en: '**You don’t expect them to live for a long time**: Given their numbers, they
    can be quite short-lived – in some cases, resources may only exist for a short
    amount of time to handle an increase in the workload. Once the demand for additional
    resources has ceased, some of the resources are terminated.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**您不期望它们长时间存活**：鉴于它们的数量，它们的生命周期可能相当短——在某些情况下，资源可能只存在短时间，用来应对工作负载的增加。一旦额外资源的需求消失，一些资源就会被终止。'
- en: Conclusion
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: '*Pets versus cattle* mainly applies to application deployment strategies rather
    than purely just the underlying infrastructure. After all, let’s say your application,
    for whatever reason, needs to run as a single fixed point – for example, your
    application does the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*宠物与牲畜* 主要适用于应用部署策略，而不仅仅是基础设施本身。毕竟，假设您的应用出于某种原因需要作为一个固定点运行——例如，您的应用执行以下操作：'
- en: Writes essential files to the local disc, which can’t be lost if an instance
    is terminated
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入本地磁盘的重要文件，如果实例被终止，这些文件不能丢失。
- en: Has manual steps for bringing an application instance online after it has been
    deployed
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用实例部署后，需要手动步骤才能让其上线。
- en: Is licensed to a MAC address or CPU ID of a host
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是根据主机的MAC地址或CPU ID授权的。
- en: In this case, you may not be able to treat your deployments as cattle, but you
    can write your Infrastructure as Code so that the bulk of your deployment is as
    automated as possible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可能无法将您的部署视为“牲畜”，但您可以将您的基础设施作为代码来编写，从而使大部分部署尽可能地自动化。
- en: These are technical reasons, but there are some considerations from a business
    point of view as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是技术原因，但从商业角度来看也有一些考虑因素。
- en: The one that will get most businesses’ attention is cost efficiency. Your choice
    of either a pets or cattle approach could have a significant impact on your hosting
    costs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最能吸引大多数企业注意的是成本效益。您选择“宠物”还是“牲畜”方法，可能会对您的托管成本产生重大影响。
- en: The cattle approach, which treats servers as ephemeral resources, allows for
    better resource utilization and automated scaling, potentially reducing costs.
    On the other hand, deploying pets, which emphasizes individual server care, may
    result in higher maintenance and management costs but could be justified for mission-critical
    applications that demand special attention.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: “牲畜”方法将服务器视为短暂的资源，它允许更好的资源利用和自动扩展，可能减少成本。另一方面，部署“宠物”方法则强调对单个服务器的维护，可能导致更高的维护和管理成本，但对于需要特别关注的关键任务应用，可能是可以接受的。
- en: Taking a cattle approach enables faster deployment and scaling of your workloads;
    this allows businesses to respond more quickly to market changes and customer
    needs. Deploying pets might lead to longer deployment times, potentially impacting
    a company’s competitiveness.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 采取“牲畜”方法可以更快地部署和扩展您的工作负载；这使得企业能够更迅速地应对市场变化和客户需求。部署“宠物”方法可能导致更长的部署时间，从而影响公司的竞争力。
- en: Regulatory and security requirements could also influence the choice between
    pet and cattle deployments. The pets approach, focusing on managing individual
    resources, may be more appropriate for businesses with strict regulatory or security
    requirements, as it allows for more fine-grained control and auditing of server
    configurations. However, the cattle approach, emphasizing automation and rapid
    scaling, might not provide the same level of control and may require additional
    efforts to ensure compliance and security.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 合规性和安全要求也可能会影响选择“宠物”与“牲畜”部署之间的决策。专注于管理单一资源的“宠物”方法，可能更适合有严格合规或安全要求的企业，因为它允许对服务器配置进行更细粒度的控制和审计。然而，强调自动化和快速扩展的“牲畜”方法，可能无法提供同样程度的控制，并且可能需要额外的努力来确保合规性和安全性。
- en: Now that we have a good idea of the type of deployments you could be dealing
    with, let’s now talk about what this means for an Infrastructure-as-Code deployment.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经大致了解了您可能处理的部署类型，我们来谈谈这对基础设施即代码部署意味着什么。
- en: What does all this mean for our Infrastructure-as-Code deployments?
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这对我们的基础设施即代码部署意味着什么？
- en: So far, we have spoken a lot about some of the approaches and journeys people
    take to get to the point where they are considering using Infrastructure as Code,
    so before we look at some of the toolings in *Chapter 2*, *Ansible and Terraform
    beyond the Documentation*, let’s talk about some of the actual use cases.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了人们在考虑使用基础设施即代码之前所采用的一些方法和路径，那么在我们深入探讨*第2章*，“*Ansible和Terraform超越文档*”中的一些工具之前，让我们先谈谈一些实际的使用案例。
- en: In my opinion, the most significant advantage of using Infrastructure as Code
    is **consistency** – if you need to repeat a process or deployment more than once,
    then define your deployment as Infrastructure as Code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，使用基础设施代码的最大优势是**一致性**——如果你需要重复执行某个过程或部署多次，那么将部署定义为基础设施代码。
- en: This will make sure that resources are deployed the same every time, no matter
    who is deploying them; if everyone is using the same set of code, then it stands
    to reason that the outputs will be the same (apart from variables you allow to
    override the values on such as SKUs, resource names, etc.).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保每次资源部署时的结果都相同，无论是谁在进行部署；如果每个人都在使用相同的代码集，那么合理推断，输出结果会是相同的（除了你允许覆盖的变量值，例如SKU、资源名称等）。
- en: An Infrastructure-as-Code approach not only gives you consistency between team
    members deploying the code but also between environments. Before I started defining
    my deployments as Infrastructure as Code, configuration drift between environments
    was quite a significant issue – environments were online for so long that *tweaks*
    were being applied and not carried through, so when code moved between my development,
    test, and finally, production environments, unexpected things would start to happen.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施代码方法不仅能确保团队成员在部署代码时的一致性，还能确保不同环境之间的一致性。在我开始将我的部署定义为基础设施代码之前，环境之间的配置漂移是一个相当严重的问题——环境上线的时间太长，以至于*调整*被应用却没有被同步，因此当代码在开发、测试，最后是生产环境之间迁移时，意外的事情开始发生。
- en: Next up is **collaboration**; as your infrastructure is defined in code, you
    can use the same development workflows you use for your applications. I am sure
    that most of you use a version control system for your code, more than likely
    Git via hosted services such as GitHub, GitLab, BitBucket, or Azure DevOps – if
    so, you have everything in place to track changes and collaborate on your infrastructure
    configuration.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是**协作**；因为你的基础设施是用代码定义的，你可以使用你为应用程序所用的相同开发工作流程。我相信你们大多数人都会使用版本控制系统来管理代码，可能会通过GitHub、GitLab、BitBucket或Azure
    DevOps等托管服务使用Git——如果是这样，那么你已经具备了一切，能够跟踪更改并协作进行基础设施配置。
- en: You can also extend this further by introducing branching and pull requests
    based on your existing procedures to encourage change and testing, making the
    ongoing maintenance and development of your Infrastructure-as-Code projects genuinely
    **collaborative**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过引入分支和拉取请求，基于现有流程来促进变更和测试，从而进一步扩展此功能，使你的基础设施代码项目的持续维护和开发真正变得**协作性**。
- en: Once you have your Infrastructure as Code hosted in version control, you can
    also take advantage of **automation**, again using the same processes and pipelines
    you use to build your application – using services such as GitHub Actions or Azure
    DevOps Pipelines.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将基础设施代码托管在版本控制中，你还可以利用**自动化**，同样使用你用于构建应用程序的相同流程和管道——使用GitHub Actions或Azure
    DevOps Pipelines等服务。
- en: Using services such as these gives you the ability to execute tasks from a single
    location that is covered by the service’s role-based access control, rather than
    being reliant on each member of the team downloading and running the Infrastructure-as-Code
    deployments locally.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些服务，你可以从一个由服务角色基础访问控制（RBAC）保护的单一位置执行任务，而不需要依赖团队中的每个成员在本地下载并运行基础设施代码的部署。
- en: If a team member would be running it locally, then that would mean that each
    team member who needs access to deploy would also need quite a high level of access
    to target resources – such as the public cloud you are deploying to.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个团队成员需要在本地运行这项操作，那么这意味着每个需要访问并进行部署的团队成员，也需要拥有相当高的目标资源访问权限——例如你部署到的公共云。
- en: Using **automation** solutions such as the ones mentioned previously means that
    you can allow people to use credentials in their pipelines without them having
    to know what the credentials are. This means you can grant the individuals a lower
    level of access to your resources – such as *read-only* – as they only need to
    view resources rather than manage them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**自动化**解决方案，例如前面提到的那些，意味着你可以让人们在他们的管道中使用凭据，而不需要他们知道凭据的具体内容。这意味着你可以为个人授予较低级别的访问权限——例如*只读*——因为他们只需要查看资源，而不是管理它们。
- en: One significant side effect of this approach is that because people don’t have
    a level of access outside of the automation, they won’t be tempted to *quickly
    jump into the portal and make a change to fix something manually* and instead
    will need to update the code and do a deployment, meaning that the change is tracked
    and the execution logged, so you know who did what, when, and why.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个显著副作用是，由于人们没有超出自动化的访问权限，他们就不会轻易*跳进门户手动修复某个问题*，而是需要更新代码并进行部署，这意味着更改得到了跟踪，执行过程被记录，因此你可以知道是谁、何时、为何做了什么。
- en: Finally, something that we have already mentioned – **cost savings**. If you
    have your Infrastructure-as-Code deployments in version control and automated,
    then it’s not a stretch to deploy your infrastructure as needed rather than running
    it 24/7.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经提到过的一点——**节省成本**。如果你的基础设施即代码部署在版本控制中并且自动化，那么部署你的基础设施按需进行，而不是24/7全天候运行，这一点并不困难。
- en: For example, if you have a pipeline to build your application, once that pipeline
    has successfully executed, then it can trigger, which builds the infrastructure
    – once built, that in turn triggers a deployment, and from there, your tests can
    run against the deployment and freshly deployed resources. The results of the
    test can be stored, and the infrastructure is then torn down as it is no longer
    needed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个用于构建应用程序的管道，一旦管道成功执行，它就可以触发构建基础设施——一旦基础设施构建完成，它又会触发一个部署，接着，你的测试可以在这个部署和新部署的资源上运行。测试结果可以被存储，而基础设施随后会被拆除，因为它不再需要。
- en: This end-to-end process may take half an hour – but that’s that half an hour’s
    worth of resource cost versus paying for 24/7 resource costs – which I am sure
    you will agree is quite a saving.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端到端的过程可能需要半小时——但这是那半小时的资源成本，而不是支付全天候资源成本——我相信你会同意，这实际上是相当省钱的。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed and covered some of the core concepts we will
    be following throughout the remainder of the book. We talked about my own journey
    with Infrastructure as Code, which we will be picking up in further chapters.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论并介绍了一些我们将在书中余下部分中跟随的核心概念。我们谈到了我自己在基础设施即代码方面的旅程，这部分内容将在后续章节继续展开。
- en: We discussed some of the common questions that get raised when discussing Infrastructure-as-Code
    projects, along with some of the positive and negative feedback you may get. Then
    we went on to talk about the differences between the two deployment approaches.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了一些在讨论基础设施即代码项目时常见的问题，以及你可能会得到的一些正面和负面反馈。然后，我们继续讨论了两种部署方法之间的区别。
- en: The first is **declarative** and **imperative**, which is how your deployment
    code is executed and in which order.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个概念是**声明式**和**命令式**，它们决定了你的部署代码如何执行以及执行的顺序。
- en: The second approach we discussed, pets versus cattle, while not strictly an
    Infrastructure-as-Code method, does have relevance to the approach you would take
    to writing your Infrastructure-as-Code scripts.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的第二种方法，宠物与牲畜，虽然严格来说不是基础设施即代码的方法，但它与编写基础设施即代码脚本时采用的方法是相关的。
- en: As we get more hands-on, I will share some of my own challenges and successes
    with Infrastructure as Code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入更多的实操环节，我将分享我自己在基础设施即代码方面的一些挑战和成功经验。
- en: Speaking of getting more hands-on, in our next chapter, [*Chapter 2*](B19537_02.xhtml#_idTextAnchor085),
    *Ansible and Terraform beyond the Documentation*, we are going to look at two
    of the most common Infrastructure-as-Code tools and start looking at some actual
    Infrastructure-as-Code examples, as well as get an idea of how concepts such as
    **declarative** and **imperative** apply to them. Plus, we will be covering some
    tips and tricks based on my own experience with the two tools.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 说到更多实操内容，在下一章，[*第2章*](B19537_02.xhtml#_idTextAnchor085)，*超越文档的 Ansible 和 Terraform*，我们将介绍两种最常见的基础设施即代码工具，并开始查看一些实际的基础设施即代码示例，同时了解**声明式**和**命令式**等概念如何应用于这些工具。此外，我们还将基于我自己使用这两个工具的经验，分享一些技巧和窍门。
- en: Further reading
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延伸阅读
- en: 'Here are links to more information on some of the topics, tools, and services
    that we have covered in this chapter:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些关于本章中我们讨论的主题、工具和服务的更多信息链接：
- en: 'Puppet: [https://www.puppet.com/](https://www.puppet.com/)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Puppet: [https://www.puppet.com/](https://www.puppet.com/)'
- en: 'Chef: [https://www.chef.io/](https://www.chef.io/)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Chef: [https://www.chef.io/](https://www.chef.io/)'
- en: 'Microsoft Azure: [https://azure.microsoft.com/](https://azure.microsoft.com/)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '微软 Azure: [https://azure.microsoft.com/](https://azure.microsoft.com/)'
- en: 'GitHub: [https://github.com/about](https://github.com/about)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GitHub: [https://github.com/about](https://github.com/about)'
- en: 'GitLab: [https://about.gitlab.com](https://about.gitlab.com)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GitLab: [https://about.gitlab.com](https://about.gitlab.com)'
- en: 'BitBucket: [https://bitbucket.org/product](https://bitbucket.org/product)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'BitBucket: [https://bitbucket.org/product](https://bitbucket.org/product)'
- en: 'Azure DevOps Repos: [https://azure.microsoft.com/en-us/products/devops/repos/](https://azure.microsoft.com/en-us/products/devops/repos/)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure DevOps Repos: [https://azure.microsoft.com/en-us/products/devops/repos/](https://azure.microsoft.com/en-us/products/devops/repos/)'
- en: 'GitHub Actions: [https://github.com/features/actions](https://github.com/features/actions)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GitHub Actions: [https://github.com/features/actions](https://github.com/features/actions)'
- en: 'Azure DevOps Pipelines: [https://protect-eu.mimecast.com/s/8fwmCjvkghnR9PJIRuMq_?domain=azure.microsoft.com/](https://protect-eu.mimecast.com/s/8fwmCjvkghnR9PJIRuMq_?domain=azure.microsoft.com/)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure DevOps Pipelines: [https://protect-eu.mimecast.com/s/8fwmCjvkghnR9PJIRuMq_?domain=azure.microsoft.com/](https://protect-eu.mimecast.com/s/8fwmCjvkghnR9PJIRuMq_?domain=azure.microsoft.com/)'
