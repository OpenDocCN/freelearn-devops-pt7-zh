- en: '*Chapter 11*: Beyond Automation; an Introduction to Scripting'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 11 章*：超越自动化；脚本编写简介'
- en: In this book, we have focused on automating everyday tasks in Jira using a code-free
    approach. This automation functionality is native to Jira Cloud and is available
    in Jira Server and Jira Data Center with the addition of the *Automation for Jira*
    app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书重点介绍了使用无代码的方法在 Jira 中自动化日常任务。这种自动化功能原生支持 Jira Cloud，并且在 Jira Server 和 Jira
    Data Center 中可以通过添加 *Automation for Jira* 应用程序来使用。
- en: This approach makes it very easy for Jira administrators to get up and running
    with automation quickly as they require no specialist coding knowledge. In addition,
    the ability to create automations can be delegated to project administrators,
    thereby allowing Jira administrators to focus on other tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使得 Jira 管理员能够非常轻松地快速启动自动化，因为它不需要任何专业的编程知识。此外，创建自动化的能力可以委派给项目管理员，从而使 Jira
    管理员可以专注于其他任务。
- en: However, any book on automation in Jira would not be complete if it did not
    mention scripting and, in particular, **ScriptRunner for Jira**, which is arguably
    the most well-known automation app available.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，任何关于 Jira 自动化的书籍，如果没有提到脚本编写，尤其是 **ScriptRunner for Jira**，就无法算作完整，因为它无疑是最知名的自动化应用程序。
- en: In this chapter, we'll provide a brief introduction to ScriptRunner for Jira
    and to the Groovy scripting language, which ScriptRunner uses under the hood.
    In addition, we'll look at the differences between scripting for Jira Cloud and
    Jira Server.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将简要介绍 ScriptRunner for Jira 及其背后使用的 Groovy 脚本语言。此外，我们还将探讨 Jira Cloud
    与 Jira Server 在脚本编写上的差异。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing advanced automations with ScriptRunner
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ScriptRunner 引入高级自动化
- en: Exploring scripting in Jira Cloud
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Jira Cloud 中的脚本编写
- en: Exploring scripting in Jira Server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Jira Server 中的脚本编写
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The requirements for this chapter are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求如下：
- en: '**Jira cloud environment**: If you don''t already have access to Jira, you
    can create a free Jira Cloud account at [https://www.atlassian.com/software/jira/free](https://www.atlassian.com/software/jira/free)
    and ensure that you have both Jira Software and Jira Service Management selected.
    You will also need to install *ScriptRunner for Jira* from the Atlassian Marketplace.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jira 云环境**：如果你还没有 Jira 访问权限，你可以在[https://www.atlassian.com/software/jira/free](https://www.atlassian.com/software/jira/free)创建一个免费的
    Jira Cloud 账户，并确保选择了 Jira Software 和 Jira Service Management。你还需要从 Atlassian Marketplace
    安装 *ScriptRunner for Jira*。'
- en: '**Jira Server environment**: If you are using Jira Server (available from [https://www.atlassian.com/software/jira/download](https://www.atlassian.com/software/jira/download)),
    ensure that you have licenses for both Jira Software and Jira Service Desk. In
    addition, you will also need to ensure that you install the *ScriptRunner for
    Jira* app available from the Atlassian Marketplace.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jira Server 环境**：如果你使用的是 Jira Server（可从[https://www.atlassian.com/software/jira/download](https://www.atlassian.com/software/jira/download)下载），请确保你拥有
    Jira Software 和 Jira Service Desk 的许可证。此外，你还需要确保安装了从 Atlassian Marketplace 获取的
    *ScriptRunner for Jira* 应用程序。'
- en: You will need to be a global Jira administrator in order to follow the examples
    in this chapter. In addition, we have used the *IT Service Management project
    template* to create the Service Desk project that these examples run against.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要成为全球 Jira 管理员才能跟随本章节中的示例进行操作。此外，我们使用了 *IT 服务管理项目模板* 来创建本示例中使用的服务台项目。
- en: 'You can download the latest code samples for this chapter from this book''s
    official GitHub repository at [https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira](https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira).
    Please visit the following link to check the CiA videos: [https://bit.ly/39L6BIB](https://bit.ly/39L6BIB)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从本书的官方 GitHub 仓库下载本章的最新代码示例：[https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira](https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira)。请访问以下链接查看
    CiA 视频：[https://bit.ly/39L6BIB](https://bit.ly/39L6BIB)
- en: Introducing advanced automations with ScriptRunner
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ScriptRunner 引入高级自动化
- en: '**ScriptRunner** for Jira allows you to extend the functionality of both Jira
    Cloud and Jira Server or Jira Data Center using scripts written in the **Groovy**
    language.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**ScriptRunner** for Jira 允许你通过编写 **Groovy** 脚本来扩展 Jira Cloud、Jira Server 或
    Jira Data Center 的功能。'
- en: The ability to use the Groovy language in your automations gives you access
    to the underlying Java platform and the Jira API, as well as providing the full
    power of the scripting language itself.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化中使用 Groovy 语言的能力使您可以访问底层 Java 平台和 Jira API，同时还可以发挥脚本语言本身的全部功能。
- en: As we'll see, in the case of Jira Cloud, access to the Jira API is limited to
    the interaction with the REST API provided by Jira. In Jira Server, however, your
    scripts gain access to the entire API that Jira exposes to developers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在 Jira Cloud 中，访问 Jira API 仅限于与 Jira 提供的 REST API 进行交互。而在 Jira Server
    中，您的脚本可以访问 Jira 向开发者开放的整个 API。
- en: We'll begin this section with a quick introduction to the Groovy language, which
    underpins ScriptRunner, followed by an overview of the ScriptRunner for Jira app.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将首先简要介绍支撑 ScriptRunner 的 Groovy 语言，然后概述 ScriptRunner for Jira 应用程序。
- en: Introducing Groovy
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Groovy
- en: '**Groovy**, or **Apache Groovy** to give it its full name, is a programming
    language built on the Java platform. It is both a static language, in that it
    can be compiled to bytecode, as well as a dynamic language in that it can be interpreted
    at runtime.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Groovy**，或者称为 **Apache Groovy**，是一种建立在 Java 平台上的编程语言。它既是静态语言，因为它可以编译成字节码，又是动态语言，因为它可以在运行时解释执行。'
- en: Groovy is syntax-compatible with Java. This means that it integrates and operates
    seamlessly with Java and, more importantly, with third-party libraries. It also
    means that you can write Java code in a Groovy script and have it correctly interpreted
    and executed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 语法与 Java 兼容。这意味着它与 Java 和更重要的第三方库能够无缝集成和运行。这也意味着您可以在 Groovy 脚本中编写 Java
    代码，并且代码会被正确解释和执行。
- en: In addition, Groovy supports functional programming and optional typing, meaning
    it can infer the object type at runtime. It also has a much more concise and expressive
    syntax than Java and is able to efficiently process both XML and JSON.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Groovy 支持函数式编程和可选类型，这意味着它可以在运行时推断对象类型。它还具有比 Java 更简洁和表达力更强的语法，并且能够高效地处理 XML
    和 JSON。
- en: Let's take a look at an example that highlights both the differences and similarities
    between Java and Groovy.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，突出显示 Java 和 Groovy 之间的差异和相似性。
- en: 'In this example, we will create a list of names and then iterate that list,
    printing each name out to the console, prepended with the word `"Hello"`, using
    the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个包含名字的列表，然后遍历该列表，将每个名字打印到控制台，前面加上 `"Hello"` 这个词，代码如下：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although this code is written in Java, it can run entirely unmodified in Groovy.
    When writing scripts, an execution context is usually provided by the application.
    This execution context is essentially an empty method within a class and our script
    is the method body, so we do not need to declare a surrounding class or method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码是用 Java 编写的，但它可以在 Groovy 中完全不做修改地运行。在编写脚本时，应用程序通常提供一个执行上下文。这个执行上下文本质上是一个类中的空方法，我们的脚本就是方法体，因此不需要声明周围的类或方法。
- en: 'Now, let''s take a look at the Groovy version of the previous code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下上面代码的 Groovy 版本：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This Groovy script is equivalent to the Java code we saw previously. Let''s
    take a quick look at what is going on in this example line by line:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Groovy 脚本与我们之前看到的 Java 代码等效。让我们逐行快速查看这个示例中发生了什么：
- en: '`def nameList = ["Andrew", "Evelyn", "Tony"]`: We have used optional typing
    for the `nameList` variable by declaring it using the `def` keyword. In addition,
    we have initialized the variable with a list of strings using square brackets.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def nameList = ["Andrew", "Evelyn", "Tony"]`：我们通过使用 `def` 关键字声明 `nameList`
    变量来使用可选类型。此外，我们使用方括号初始化该变量，并赋值为一个字符串列表。'
- en: '`nameList.each { name ->`: Here we are calling the `each` closure on the list,
    and naming the closure parameter `name`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nameList.each { name ->`：在这里，我们对列表调用 `each` 闭包，并将闭包参数命名为 `name`。'
- en: Closures are identified by the use of curly braces, while the arrow (`->`) separates
    the closure parameters from the code.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 闭包通过使用大括号标识，而箭头（`->`）将闭包参数与代码分开。
- en: When using a closure with only a single parameter, and where you do not need
    to reference the parameter in an inner closure, you can omit both the parameter
    and the separating arrow.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用仅包含一个参数的闭包，并且您不需要在内部闭包中引用该参数时，可以省略该参数和分隔箭头。
- en: 'In this case, the parameter name defaults to the word `it`, as seen in the
    following example:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，参数名默认为 `it`，如下所示：
- en: '`nameList.each { println "Hello ${it}" }`'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`nameList.each { println "Hello ${it}" }`'
- en: '`println "Hello ${name}"`: This line is using string interpolation to print
    the word `"Hello"` followed by the name currently being iterated.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`println "Hello ${name}"`：这一行使用字符串插值打印出 `"Hello"` 字符串，后跟当前正在迭代的名字。'
- en: Additionally, you will notice that the semicolon used in Java to terminate a
    statement is not required in Groovy.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你会注意到，在 Java 中用于终止语句的分号，在 Groovy 中并不需要。
- en: Tip
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can learn more about Groovy on the official Apache Groovy website at [https://groovy-lang.org/learn.html](https://groovy-lang.org/learn.html),
    where there are numerous books, presentations, and courses available to help you
    learn and get the most out of the Groovy language.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方的 Apache Groovy 网站 [https://groovy-lang.org/learn.html](https://groovy-lang.org/learn.html)
    上了解更多关于 Groovy 的信息，那里有许多书籍、演示文稿和课程，帮助你学习并最大限度地利用 Groovy 语言。
- en: As we have learned, Groovy allows you to write concise, easily readable code
    in addition to enabling you to write your scripts in Java. Next, let's take a
    look at how ScriptRunner for Jira leverages this to allow us to create automation
    scripts in Jira.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学到的，Groovy 使你能够编写简洁、易读的代码，并且支持你在 Java 中编写脚本。接下来，让我们看看 ScriptRunner for
    Jira 如何利用这一点，帮助我们在 Jira 中创建自动化脚本。
- en: Understanding ScriptRunner
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 ScriptRunner
- en: Adaptavist's **ScriptRunner** is an app in the Atlassian ecosystem that has
    been around for over a decade. It incorporates the Groovy scripting engine and
    configures it in a manner that facilitates scripted access to Jira via the available
    APIs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Adaptavist 的 **ScriptRunner** 是 Atlassian 生态系统中的一款应用，已有十多年历史。它结合了 Groovy 脚本引擎，并以一种便于通过可用
    API 对 Jira 进行脚本访问的方式配置它。
- en: It has been the go-to app for many Jira administrators looking to both automate
    and extend the base functionality of Jira, and indeed other Atlassian tools, including
    Confluence, Bitbucket, and Bamboo.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它已经成为许多 Jira 管理员的首选应用，帮助他们自动化并扩展 Jira 的基本功能，实际上，它也适用于其他 Atlassian 工具，包括 Confluence、Bitbucket
    和 Bamboo。
- en: In a nutshell, ScriptRunner gives you access to the Jira application by providing
    a ready-made framework with all the underlying plumbing already in place, thereby
    allowing you to concentrate on the business logic of your automations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，ScriptRunner 通过提供一个现成的框架，其中所有底层基础设施已经就绪，从而让你能够专注于自动化的业务逻辑，进而让你能够访问 Jira
    应用程序。
- en: Important note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: ScriptRunner provides a lot more functionality than just the ability to create
    scripted automations. It provides the ability to create workflow functions using
    both built-in and custom Groovy scripts. In addition, it also provides a number
    of powerful additional JQL features to make searching Jira easier. It also allows
    you to make customizations to the user interface using script fragments, the complexity
    of which will vary depending on whether you use Jira Cloud or Jira Server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ScriptRunner 提供的功能远不止于创建脚本化自动化。它还提供了使用内置和自定义 Groovy 脚本创建工作流函数的能力。此外，它还提供了一些强大的额外
    JQL 功能，便于更轻松地搜索 Jira。它还允许你使用脚本片段对用户界面进行自定义，具体的复杂度会根据你使用的是 Jira Cloud 还是 Jira Server
    而有所不同。
- en: Adaptavist provides comprehensive documentation and tutorials for ScriptRunner
    for both Jira Cloud and Jira Server. You can learn more about *ScriptRunner for
    Jira Cloud* at [https://scriptrunner-docs.connect.adaptavist.com/jiracloud/quickstart.html](https://scriptrunner-docs.connect.adaptavist.com/jiracloud/quickstart.html).
    To learn more about *ScriptRunner for Jira Server*, you can find the documentation
    at [https://scriptrunner.adaptavist.com/latest/jira/quickstart.html](https://scriptrunner.adaptavist.com/latest/jira/quickstart.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Adaptavist 为 ScriptRunner 提供了全面的文档和教程，适用于 Jira Cloud 和 Jira Server。你可以在 [https://scriptrunner-docs.connect.adaptavist.com/jiracloud/quickstart.html](https://scriptrunner-docs.connect.adaptavist.com/jiracloud/quickstart.html)
    上了解更多关于 *ScriptRunner for Jira Cloud* 的内容。要了解关于 *ScriptRunner for Jira Server*
    的更多信息，你可以在 [https://scriptrunner.adaptavist.com/latest/jira/quickstart.html](https://scriptrunner.adaptavist.com/latest/jira/quickstart.html)
    查阅文档。
- en: Tip
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Adaptavist provides a library of scripts that you can use as is or as a starting
    point for your own scripts. You can find these at [https://library.adaptavist.com](https://library.adaptavist.com).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Adaptavist 提供了一个脚本库，你可以直接使用其中的脚本，或者将它们作为自己脚本的起点。你可以在 [https://library.adaptavist.com](https://library.adaptavist.com)
    上找到这些脚本。
- en: Now that we've had a brief introduction to ScriptRunner and the Groovy scripting
    language, let's look at how we can create automations using scripts in Jira Cloud.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要了解了 ScriptRunner 和 Groovy 脚本语言，接下来让我们看看如何在 Jira Cloud 中使用脚本创建自动化。
- en: Exploring scripting in Jira Cloud
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Jira Cloud 中的脚本
- en: ScriptRunner for Jira Cloud enables you to create automations in response to
    events that occur in Jira, such as when an issue is created or updated, among
    others. It also has an escalation service, which allows you to perform a scheduled
    action against a list of issues provided by a JQL query.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ScriptRunner for Jira Cloud 使你能够根据 Jira 中发生的事件创建自动化任务，例如创建或更新问题等。它还具有升级服务，允许你对由
    JQL 查询提供的问题列表执行预定的操作。
- en: ScriptRunner also provides the ability to run scripts at scheduled intervals.
    This differs from the escalation service in that it does not require a list of
    issues on which to perform actions, allowing you to perform tasks such as creating
    issues on a recurring basis.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ScriptRunner 还提供了在预定时间间隔运行脚本的功能。这与升级服务不同，因为它不需要一个问题列表来执行操作，从而使你能够执行如定期创建问题等任务。
- en: In this section, we'll take a high-level overview of how the Jira Cloud API
    works and then recreate the *Incident priority matrix* example from [*Chapter
    2*](B16551_02_Final_ASB_ePub.xhtml#_idTextAnchor038), *Automating Jira Issues*,
    to understand how to write automations using scripting.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要概述 Jira Cloud API 的工作原理，然后重建来自[*第 2 章*](B16551_02_Final_ASB_ePub.xhtml#_idTextAnchor038)的
    *事件优先级矩阵* 示例，*自动化 Jira 问题*，以了解如何使用脚本编写自动化任务。
- en: Understanding the Jira Cloud API
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Jira Cloud API
- en: In order for an app to integrate with Jira Cloud, it needs to be built using
    the *Atlassian Connect framework*. This framework allows apps to extend the Jira
    user interface, access the Jira APIs, and respond to events from Jira Cloud.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用能够与 Jira Cloud 集成，它需要使用 *Atlassian Connect 框架* 来构建。该框架允许应用扩展 Jira 用户界面，访问
    Jira API，并响应来自 Jira Cloud 的事件。
- en: An app built using the Connect framework is a web application that operates
    remotely over the HTTP protocol. This means that when you build a Connect app
    for Jira, it needs to be hosted on a publicly accessible web server that can receive
    requests over HTTP from Jira Cloud, and which can send REST API requests to Jira
    Cloud.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Connect 框架构建的应用程序是一个通过 HTTP 协议远程操作的 web 应用程序。这意味着，当你为 Jira 构建一个 Connect 应用时，它需要托管在一个可以通过
    HTTP 从 Jira Cloud 接收请求的公开可访问的 web 服务器上，并且能够向 Jira Cloud 发送 REST API 请求。
- en: 'The basic interaction between Jira Cloud and an app built using the Connect
    framework can be seen in the following diagram. This is a simplified representation
    as it pertains to automation with ScriptRunner:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Connect 框架构建的应用与 Jira Cloud 之间的基本交互可以从以下图示中看到。这是关于使用 ScriptRunner 进行自动化的简化表示：
- en: '![Figure 11.1 – App interaction with the Atlassian Connect framework'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – 应用与 Atlassian Connect 框架的交互'
- en: '](img/Figure_11.1_B16551.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B16551.jpg)'
- en: Figure 11.1 – App interaction with the Atlassian Connect framework
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 应用与 Atlassian Connect 框架的交互
- en: When an event occurs in Jira Cloud, a webhook is sent over HTTP to notify the
    ScriptRunner app that the event has occurred. This prevents the app from needing
    to poll Jira periodically to determine whether changes have occurred.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Jira Cloud 中发生事件时，Webhook 会通过 HTTP 发送，通知 ScriptRunner 应用该事件已发生。这避免了应用程序需要定期轮询
    Jira 以确定是否发生了更改。
- en: In response, ScriptRunner will initiate the execution of any scripts that are
    configured to listen for the specific events. In turn, these scripts make use
    of the Jira REST API to retrieve additional information and to update data in
    Jira.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为响应，ScriptRunner 会启动执行配置为监听特定事件的任何脚本。反过来，这些脚本利用 Jira REST API 获取附加信息并更新 Jira
    中的数据。
- en: Scripts that make use of ScriptRunner's scheduled or escalation service will
    only require access to the Jira REST API to interact with data in Jira.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ScriptRunner 的预定或升级服务的脚本只需要访问 Jira REST API 来与 Jira 中的数据进行交互。
- en: Tip
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can learn more about the webhooks available in Jira Cloud at [https://developer.atlassian.com/cloud/jira/platform/webhooks/](https://developer.atlassian.com/cloud/jira/platform/webhooks/),
    while you can learn about the Jira Cloud REST API at [https://developer.atlassian.com/cloud/jira/platform/rest/v3/intro/](https://developer.atlassian.com/cloud/jira/platform/rest/v3/intro/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://developer.atlassian.com/cloud/jira/platform/webhooks/](https://developer.atlassian.com/cloud/jira/platform/webhooks/)
    上了解有关 Jira Cloud 中 Webhook 的更多信息，而可以在 [https://developer.atlassian.com/cloud/jira/platform/rest/v3/intro/](https://developer.atlassian.com/cloud/jira/platform/rest/v3/intro/)
    上了解 Jira Cloud REST API 的相关信息。
- en: Now that we've learned how the Jira Cloud API basically works, let's take a
    look at how we can use this to create a scripted automation in Jira Cloud.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Jira Cloud API 的基本工作原理，让我们来看看如何利用它在 Jira Cloud 中创建脚本自动化。
- en: Creating a scripted automation in Jira Cloud
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Jira Cloud 中创建脚本自动化
- en: In this example, we are going to recreate the incident priority matrix automation
    that we first introduced in the *If/else block* section in [*Chapter 2*](B16551_02_Final_ASB_ePub.xhtml#_idTextAnchor038),
    *Automating Jira Issues*. If you have a similar rule using Jira Automation, you
    should disable it before implementing this rule.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将重新创建我们在[*第 2 章*](B16551_02_Final_ASB_ePub.xhtml#_idTextAnchor038)《自动化
    Jira 问题》章节中首次介绍的事件优先级矩阵自动化。如果你已经有类似的 Jira 自动化规则，请在实施此规则前禁用该规则。
- en: This example will show you how to achieve a similar automation in Jira Cloud
    utilizing a Groovy script and the Jira Cloud API.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将展示如何利用 Groovy 脚本和 Jira Cloud API 在 Jira Cloud 中实现类似的自动化。
- en: 'The Groovy script we will use to achieve this is shown in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的 Groovy 脚本在下面的截图中展示：
- en: '![Figure 11.2 – The incident priority matrix script in Jira Cloud'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – Jira Cloud 中的事件优先级矩阵脚本]'
- en: '](img/Figure_11.2_B16551.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.2_B16551.jpg)'
- en: Figure 11.2 – The incident priority matrix script in Jira Cloud
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – Jira Cloud 中的事件优先级矩阵脚本
- en: 'Let''s take a look at what''s going on in this script:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个脚本的执行过程：
- en: The first thing we do is use Jira's REST API to retrieve all the custom fields
    into a list stored in the `customFields` variable.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们做的第一件事是使用 Jira 的 REST API 将所有自定义字段检索到一个存储在`customFields`变量中的列表中。
- en: Using the list of custom fields, we then ascertain the IDs of the `Impact` and
    `Urgency` fields and save them in the corresponding variables.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自定义字段列表后，我们可以确定`Impact`和`Urgency`字段的 ID，并将其保存到相应的变量中。
- en: Now that we have the IDs for the `Impact` and `Urgency` fields, we can use these
    to extract their respective values from the issue, which is represented as a `Map`
    object.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经获得了`Impact`和`Urgency`字段的 ID，我们可以利用这些 ID 从问题中提取相应的值，这些值表示为`Map`对象。
- en: In this block, we are using the values of the fields to determine the correct
    priority according to the priority matrix.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个代码块中，我们使用字段的值来根据优先级矩阵确定正确的优先级。
- en: We're making use of the Groovy `switch` statement to make the code more readable
    than if we had used an if/else block.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 Groovy 的`switch`语句，使代码比使用 if/else 语句更具可读性。
- en: Finally, we use Jira's REST API to update the issue with the new priority calculated
    in *step 4*.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 Jira 的 REST API 来更新问题，并使用*第 4 步*中计算出的新优先级。
- en: 'Now that we''ve created the automation script in Groovy, we need to create
    a script listener in ScriptRunner to actually get the automation working:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了 Groovy 中的自动化脚本，我们需要在 ScriptRunner 中创建一个脚本监听器来实际启动自动化：
- en: As a Jira administrator, click on the **Apps** menu in the top menu bar, and
    then select **Manage your apps**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为 Jira 管理员，点击顶部菜单栏中的**应用程序**菜单，然后选择**管理你的应用程序**。
- en: From the left-hand menu, select the **Script Listeners** tab under the **ScriptRunner**
    section, and then click the **Add Listener** button.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧菜单中，选择**ScriptRunner**部分下的**脚本监听器**标签，然后点击**添加监听器**按钮。
- en: 'Complete the script listener fields as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成脚本监听器字段如下：
- en: '`Incident priority matrix`'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`事件优先级矩阵`'
- en: '`Issue Created` and `Issue Updated`'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`问题已创建`和`问题已更新`'
- en: '`IT Service Desk (DESK)`'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IT 服务台 (DESK)`'
- en: '`Current User`'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`当前用户`'
- en: We only want this listener to be called if the issue is an incident, so we need
    to add a condition to the listener, which will evaluate to `true` only if we're
    dealing with an incident.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只希望在问题为事件时才调用该监听器，因此我们需要向监听器添加一个条件，只有在处理事件时它才会评估为`true`。
- en: In the `issue.issueType.name == 'Incident'`
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`issue.issueType.name == 'Incident'`
- en: This will ensure that this listener only continues to execute if the name of
    the issue type is `Incident`.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将确保该监听器仅在问题类型名称为`Incident`时继续执行。
- en: Finally, type the script into the `11.1 Incident priority matrix – Cloud.groovy`
    from this chapter's GitHub repository and then copy and paste the code into the
    field.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将脚本输入到本章节 GitHub 仓库中的`11.1 事件优先级矩阵 – Cloud.groovy`文件中，然后将代码复制并粘贴到字段中。
- en: 'Your script listener should now look similar to the following screenshot:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的脚本监听器现在应该类似于以下截图：
- en: '![Figure 11.3 – Creating a script listener in Jira Cloud'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3 – 在 Jira Cloud 中创建脚本监听器]'
- en: '](img/Figure_11.3_B16551.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.3_B16551.jpg)'
- en: Figure 11.3 – Creating a script listener in Jira Cloud
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 在 Jira Cloud 中创建脚本监听器
- en: In this section, we have learned how to recreate the incident priority matrix
    using a Groovy script in a script listener in Jira Cloud. You should now understand
    how scripting can also be used to automate tasks in Jira.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何在 Jira Cloud 中使用 Groovy 脚本在脚本监听器中重新创建事例优先级矩阵。现在，您应该了解如何使用脚本编写自动化任务。
- en: In the following section, we will take a look at how we can create scripted
    automations in Jira Server, and we'll reuse the incident priority matrix example
    so you can see the differences between the platforms.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将查看如何在 Jira Server 中创建脚本自动化，并重新使用事例优先级矩阵示例，以便您可以看到两个平台之间的区别。
- en: Exploring scripting in Jira Server
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Jira Server 中的脚本编写
- en: Similar to ScriptRunner for Jira Cloud, ScriptRunner for Jira Server allows
    you to create automations in response to events within Jira.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Jira Cloud 的 ScriptRunner 类似，ScriptRunner for Jira Server 允许您根据 Jira 中的事件创建自动化。
- en: Unlike in Jira Cloud, however, you are able to create automations against a
    much wider range of events in Jira Server due to the fact that you have access
    to the full Jira API.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与 Jira Cloud 不同的是，由于您可以访问完整的 Jira API，因此您能够在 Jira Server 中对更广泛的事件创建自动化。
- en: In this section, we'll take a look at the API available to scripts on the Jira
    Server platform. We'll then take another look at the incident priority matrix
    example so that we can more easily understand the differences between scripting
    between the platforms.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看 Jira Server 平台上脚本可用的 API。然后，我们将再次查看事例优先级矩阵示例，以便更容易理解两个平台之间脚本编写的区别。
- en: Understanding the Jira Server API
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Jira Server API
- en: In contrast to the Jira Cloud API, apps written using the Jira Server API run
    in the same Java process as the core Jira application and therefore have full
    access to the underlying application via the public Java-based API.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Jira Cloud API 相反，使用 Jira Server API 编写的应用程序在与核心 Jira 应用程序相同的 Java 进程中运行，因此可以通过公共基于
    Java 的 API 充分访问底层应用程序。
- en: ScriptRunner for Jira Server is an app built using the Jira **Plugins2** (**P2**)
    framework. This framework allows apps to register as listeners for events within
    Jira, as well as provide access to the underlying API and public third-party libraries
    shipped with the application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ScriptRunner for Jira Server 是使用 Jira **Plugins2** (**P2**) 框架构建的应用程序。该框架允许应用程序注册为
    Jira 中事件的监听器，并提供访问应用程序随附的底层 API 和公共第三方库的能力。
- en: The Jira API is vast, and fully understanding every aspect of it could fill
    a couple of books. For our purposes, however, we will concentrate on the `ComponentAccessor`
    class, which is documented at [https://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/component/ComponentAccessor.html](https://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/component/ComponentAccessor.html).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Jira API 非常庞大，要全面理解它的每个方面可能需要几本书。然而，出于我们的目的，我们将集中精力讨论 `ComponentAccessor` 类，其文档位于
    [https://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/component/ComponentAccessor.html](https://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/component/ComponentAccessor.html)。
- en: This class is the entry point to most of the components you will require when
    writing scripts in ScriptRunner. It gives you a handle of things such as the `IssueService`
    and `IssueManager` classes, which deal with creating, updating, and modifying
    issues. You will also use it to get access to the `CustomFieldManager` class,
    which allows you to manipulate most custom fields you define in Jira.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该类是在 ScriptRunner 中编写脚本时您将需要的大多数组件的入口点。它为您提供了诸如 `IssueService` 和 `IssueManager`
    类的操作权限，这些类用于创建、更新和修改问题。您还将使用它获取 `CustomFieldManager` 类的访问权限，该类允许您操作 Jira 中定义的大多数自定义字段。
- en: Tip
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can learn more about how to use `IssueService` and `IssueManager` to interact
    with issues in Jira in the official *Performing issue operations* tutorial located
    at [https://developer.atlassian.com/server/jira/platform/performing-issue-operations/](https://developer.atlassian.com/server/jira/platform/performing-issue-operations/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方的 *执行问题操作* 教程中了解如何使用 `IssueService` 和 `IssueManager` 与 Jira 中的问题进行交互，位于
    [https://developer.atlassian.com/server/jira/platform/performing-issue-operations/](https://developer.atlassian.com/server/jira/platform/performing-issue-operations/)。
- en: 'To get access to `ComponentAccessor`, you will need to explicitly import the
    class at the start of your script as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `ComponentAccessor`，您需要在脚本的开头显式导入该类，如下所示：
- en: '`import com.atlassian.jira.component.ComponentAccessor`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`import com.atlassian.jira.component.ComponentAccessor`'
- en: As you will see in the example we present in the next section, `ComponentAccessor`
    is integral to our ability to find and manipulate data in Jira Server.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一部分的示例中看到的那样，`ComponentAccessor`是我们在Jira Server中查找和操作数据的核心工具。
- en: Now that we've had a brief introduction to the Jira Server API, let's take a
    look at how we can create an automation script using the API.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要介绍了Jira Server API，接下来让我们看看如何使用API创建自动化脚本。
- en: Creating a scripted automation in Jira Server
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Jira Server中创建脚本自动化
- en: In this example, we are again going to recreate the incident priority matrix
    using a Groovy script so that we can learn about the differences between scripting
    in Jira Server and Jira Cloud.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用Groovy脚本重新创建事件优先级矩阵，这样我们可以了解在Jira Server和Jira Cloud中编写脚本的区别。
- en: 'The script we are going to use for this example is presented in the following
    screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的脚本示例如下所示：
- en: '![Figure 11.4 – The incident priority matrix script in Jira Server'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4 – Jira Server中的事件优先级矩阵脚本'
- en: '](img/Figure_11.4_B16551.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.4_B16551.jpg)'
- en: Figure 11.4 – The incident priority matrix script in Jira Server
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – Jira Server中的事件优先级矩阵脚本
- en: 'Let''s examine what this script is doing:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个脚本在做什么：
- en: The first thing we need to do is import the Jira API classes that we'll need
    for this script. Without these, the script will not compile and will not be able
    to access the Jira API.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是导入Jira API类，这些类是我们脚本所需的。如果没有这些类，脚本将无法编译并无法访问Jira API。
- en: Script listeners in ScriptRunner for Jira Server present an event object to
    the script. The event object contains the underlying issue in the issue field.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jira Server中的ScriptRunner脚本监听器会将事件对象传递给脚本。该事件对象在`issue`字段中包含底层问题。
- en: Additionally, we are ensuring that the `issue` variable is cast as a `MutableIssue`
    type, which will allow us to make changes to the issue.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们还确保将`issue`变量强制转换为`MutableIssue`类型，这将允许我们对问题进行更改。
- en: Custom script listeners in ScriptRunner for Jira Server do not have a condition
    field, so we need to use an `if` statement to ensure that we only continue execution
    if we're dealing with an incident issue type.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ScriptRunner中的自定义脚本监听器没有条件字段，因此我们需要使用`if`语句确保只有在处理事故问题类型时才继续执行。
- en: Here we are retrieving the custom field objects for the `Impact` and `Urgency`
    fields by using the `CustomFieldManager` component accessible from `ComponentAccessor`.
    In this example, I am retrieving the fields by name rather than by ID, but you
    could use either method.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里我们通过使用`ComponentAccessor`中的`CustomFieldManager`组件来获取`Impact`和`Urgency`字段的自定义字段对象。在这个例子中，我通过名称而不是ID来获取字段，但你也可以使用任一方法。
- en: Now that we have the custom field objects for the `Impact` and `Urgency` fields,
    we can use these to retrieve their respective values from the issue.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了`Impact`和`Urgency`字段的自定义字段对象，可以使用这些对象从问题中检索它们各自的值。
- en: In addition, we are also extracting the string representations of the value
    so that we can compare them in the next block.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们还提取了这些值的字符串表示形式，以便在接下来的代码块中进行比较。
- en: In this block, we are using the values of the fields to determine the correct
    priority according to the priority matrix.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码块中，我们使用字段的值根据优先级矩阵来确定正确的优先级。
- en: We're making use of the Groovy `switch` statement to make the code more readable
    than if we had used an if/else block.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们利用Groovy的`switch`语句使代码比使用if/else块更加易读。
- en: In Jira Server, the priority field is an object of the priority type, so we
    need to find the `Priority` object that corresponds to the string value we calculated
    in *step 6*.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Jira Server中，优先级字段是优先级类型的对象，因此我们需要找到与我们在*步骤6*中计算的字符串值相对应的`Priority`对象。
- en: We do this by retrieving all the priorities in the system using the `ConstantsManager`
    class available from `ComponentAccessor`.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过使用`ComponentAccessor`提供的`ConstantsManager`类来检索系统中所有的优先级。
- en: We then use the `find` closure to search for the priority object whose name
    field matches the priority we have calculated.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们使用`find`闭包来搜索名称字段匹配我们计算出的优先级的优先级对象。
- en: Once we have found the correct priority object, we can update the issue accordingly.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦找到正确的优先级对象，我们就可以相应地更新问题。
- en: Finally, we need to persist the changes to the database, and we do this by calling
    the `updateIssue` method on the `IssueManager` object, again obtained from `ComponentAccessor`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将更改持久化到数据库中，我们通过调用从`ComponentAccessor`获取的`IssueManager`对象上的`updateIssue`方法来实现。
- en: We do not want this particular update to cause any more update events to fire,
    so we use the `EventDispatchOption.DO_NOT_DISPATCH` option to indicate this.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不希望此特定更新导致更多的更新事件被触发，因此我们使用 `EventDispatchOption.DO_NOT_DISPATCH` 选项来表示这一点。
- en: We also do not want any email notifications to be sent when we update the issue,
    so we set the final parameter to `false`.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还不希望在更新问题时发送任何电子邮件通知，因此我们将最后一个参数设置为 `false`。
- en: As we have learned in this example, scripts written for Jira Server can take
    advantage of the full Jira API rather than the simpler REST API available to scripts
    written for Jira Cloud.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这个示例中所学到的，针对 Jira Server 编写的脚本可以利用完整的 Jira API，而不是针对 Jira Cloud 编写的脚本所能使用的简化版
    REST API。
- en: Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Having access to the complete Jira API is both powerful and dangerous at the
    same time. You should exercise caution when writing scripts in Jira Server as
    a badly written script could cause severe performance degradation or worse.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有完整的 Jira API 访问权限既强大又危险。您在 Jira Server 中编写脚本时应谨慎操作，因为编写不当的脚本可能会导致严重的性能下降，甚至更糟的后果。
- en: 'Let''s complete this example by attaching the script to a listener so that
    it executes whenever an incident is created or updated:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将脚本附加到监听器上来完成此示例，这样它就会在每次创建或更新事件时执行：
- en: As a Jira administrator, click on the settings menu (cog) icon and then select
    **Manage apps**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为 Jira 管理员，点击设置菜单（齿轮）图标，然后选择 **管理应用**。
- en: From the left-hand menu, select the **Listeners** tab under the **ScriptRunner**
    section, click the **Create Listeners** button, and then select **Custom listener**.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，选择 **ScriptRunner** 部分下的 **监听器** 标签，点击 **创建监听器** 按钮，然后选择 **自定义监听器**。
- en: 'Complete the listener fields as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式填写监听器字段：
- en: '`Incident priority matrix`'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`事件优先级矩阵`'
- en: '`IT Service Desk`'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IT 服务台`'
- en: '`Issue Created` and `Issue Updated`'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`问题创建` 和 `问题更新`'
- en: Type the Groovy script into the `11.2 Incident priority matrix - Server.groovy`
    from this chapter's GitHub repository and then copy and paste the code into the
    field.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章的 GitHub 仓库中输入 `11.2 事件优先级矩阵 - Server.groovy` 中的 Groovy 脚本，然后将代码复制粘贴到字段中。
- en: 'The new script listener should now look similar to the following screenshot:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的脚本监听器现在应该类似于以下截图：
- en: '![Figure 11.5 – Creating a script listener in Jira Server'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.5 – 在 Jira Server 中创建脚本监听器'
- en: '](img/Figure_11.5_B16551.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.5_B16551.jpg)'
- en: Figure 11.5 – Creating a script listener in Jira Server
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 在 Jira Server 中创建脚本监听器
- en: Now that we have completed this section, you have learned how to create automations
    using Groovy scripts in ScriptRunner for Jira Server. You should also now understand
    some of the core differences in scripting between the Jira Cloud and Jira Server
    platforms.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了本节内容，您已经学会了如何在 ScriptRunner for Jira Server 中使用 Groovy 脚本创建自动化。您现在应该也能理解
    Jira Cloud 和 Jira Server 平台在脚本方面的一些核心差异。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have introduced ScriptRunner for Jira, an app that allows
    us to create advanced automations within Jira using scripting.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 ScriptRunner for Jira，这是一款允许我们在 Jira 中使用脚本创建高级自动化的应用程序。
- en: We have learned about the Groovy language, which ScriptRunner uses to enable
    scripting within Jira, and how Groovy can execute both Java and Groovy statements,
    which makes it easier to get started without needing to learn Groovy up front.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了 Groovy 语言，ScriptRunner 使用它在 Jira 中启用脚本化，并且我们了解到 Groovy 可以执行 Java 和 Groovy
    语句，这使得即使不先学习 Groovy，也能更容易入门。
- en: To understand how scripts interact with Jira Cloud, we learned about the Atlassian
    Connect framework, which is used to build apps for Jira Cloud, and how this enables
    ScriptRunner to provide scripted access to Jira.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解脚本如何与 Jira Cloud 进行交互，我们了解了 Atlassian Connect 框架，它用于为 Jira Cloud 构建应用程序，并且我们了解了它如何使
    ScriptRunner 提供对 Jira 的脚本化访问。
- en: We then learned how to create a scripted automation by recreating the incident
    priority matrix example from [*Chapter 2*](B16551_02_Final_ASB_ePub.xhtml#_idTextAnchor038),
    *Automating Jira Issues*, and we learned how the interactions with Jira Cloud
    are performed by dissecting the script.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们通过重新创建 [*第 2 章*](B16551_02_Final_ASB_ePub.xhtml#_idTextAnchor038) 中的事件优先级矩阵示例，学习了如何创建一个脚本自动化，并且通过解析脚本，我们了解了与
    Jira Cloud 进行交互的方式。
- en: Next, we introduced you to scripting on Jira Server and learned how this differs
    from scripting for Jira Cloud by taking a very brief look at the Jira Server API.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向您介绍了 Jira Server 上的脚本，并通过简要了解 Jira Server API，学习了它与 Jira Cloud 的脚本有什么不同。
- en: To make it easier to understand the differences between the platforms, we reused
    the incident priority matrix example script and again, dissected the script to
    understand how to interact with the Jira Server API.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易理解不同平台之间的差异，我们重新使用了事件优先级矩阵示例脚本，并再次分析了该脚本，以了解如何与 Jira Server API 进行交互。
- en: Understanding how to create advanced automations using Groovy scripts will empower
    you to create automations beyond the no-code approach, which has been the focus
    of this book and will enable you to customize your Jira instance to your own specifications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用 Groovy 脚本创建高级自动化，将使你能够创建超越无代码方法的自动化，而这正是本书的重点，它将使你能够根据自己的需求定制 Jira 实例。
- en: That brings us to the end of this book, and my hope is that it has both inspired
    you and given you some ideas on how to take your automations to the next level.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这也标志着本书的结束，我希望它不仅激励了你，还能给你一些关于如何将自动化提升到新水平的想法。
