- en: What&#x27;s in a Role?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 role 里有什么？
- en: 'In [Chapter 3](4b15cefb-8d9c-48b7-8927-126501886315.xhtml), *Your First Ansible
    Container Project*, we learned the basics about Ansible Container roles, what
    they do, and how to download, install, and tweak them from Ansible Galaxy. In
    this chapter, we will look at writing our own Ansible Container roles that we
    can use to build custom container images from scratch. You will learn that Ansible
    provides an easy-to-learn, expressive language for defining desired states, and
    service configurations. To illustrate how Ansible Container can be used to quickly
    build services and run containers, over the course of this chapter we will write
    a role that builds a MariaDB MySQL container that can be run on your local workstation.
    In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](4b15cefb-8d9c-48b7-8927-126501886315.xhtml)，*Your First Ansible Container
    Project*，我们学习了关于 Ansible Container roles 的基础知识，它们的功能及如何从 Ansible Galaxy 下载、安装和调整它们。在本章中，我们将学习如何编写我们自己的
    Ansible Container roles，用于从头开始构建自定义的容器镜像。您将了解到，Ansible 提供了一种易于学习、表达力强的语言，用于定义所需的状态和服务配置。为了说明
    Ansible Container 如何快速构建服务和运行容器，本章的过程中我们将编写一个 role，用于构建一个可以在您的本地工作站上运行的 MariaDB
    MySQL 容器。在本章中，我们将涵盖以下内容：
- en: Custom roles with Ansible Container
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible Container 的自定义 roles
- en: A brief overview of MariaDB
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MariaDB 的简要概述
- en: Initializing an Ansible Container role
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个 Ansible Container role
- en: What's in a container-enabled role?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个容器化 role 里有什么？
- en: Creating the MariaDB project and role
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 MariaDB 项目和 role
- en: Writing a container-enabled role
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个容器化 role
- en: Customizing a container-enabled role
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义一个容器化 role
- en: Custom roles with Ansible Container
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible Container 的自定义 roles
- en: One growing theme throughout the course of this book is how much freedom Ansible
    Container gives you to build and deploy custom container images quickly, efficiently,
    securely, and reliably. So far, we have looked at using Ansible Container to define
    and run services from prebuilt community containers, as well as leveraging community-written
    roles to instantiate, build, and customize our containers. This is an excellent
    way to get started with Ansible Container and get a head start in familiarizing
    yourself with the Ansible Container workflow. However, the real power of Ansible
    Container begins to really show itself when you start writing roles that build
    custom container images.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书内容逐渐深入时的一个主题是 Ansible Container 给予您多大的自由，可以快速、高效、安全和可靠地构建和部署自定义的容器镜像。到目前为止，我们已经学习了使用
    Ansible Container 来定义和运行来自预构建社区容器的服务，以及利用社区编写的 roles 来实例化、构建和定制我们的容器。这是开始使用 Ansible
    Container 并熟悉 Ansible Container 工作流程的绝佳方式。然而，当您开始编写构建自定义容器镜像的 roles 时，Ansible
    Container 的真正力量开始显现出来。
- en: If you have experience using Ansible as a configuration management tool, you
    might be familiar with writing Ansible playbooks and roles already. This will
    definitely give you a head start with writing containerized roles, but it is not
    a prerequisite for working through the examples in this chapter. To put everyone
    on a level playing field, I am going to assume that you have no experience writing
    Ansible playbooks or roles, and we will essentially start from scratch. For those
    of you who are Ansible veterans, a lot of this will be a review, but hopefully
    you may learn something new. For Ansible beginners, I hope this chapter will excite
    your curiosity, not only to go forward into building more advanced Ansible Container
    roles but also to go further and explore Ansible Core configuration management
    concepts as well.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有使用 Ansible 作为配置管理工具的经验，您可能已经熟悉了编写 Ansible playbook 和 roles。这肯定会让您在编写容器化
    roles 方面有一定的优势，但这并不是本章示例工作的先决条件。为了让每个人都处于同一起跑线上，我假设您没有编写 Ansible playbook 或 roles
    的经验，我们将从头开始。对于那些 Ansible 老手来说，这些内容很大程度上会是回顾，但希望您也能学到一些新东西。对于 Ansible 初学者，我希望本章能激发您的好奇心，不仅仅是进一步构建更高级的
    Ansible Container roles，还要深入探索 Ansible Core 配置管理概念。
- en: 'The original motivation behind Ansible was to create a configuration management
    and orchestration system that is easy for just about anyone to pick up and start
    working with. Ansible quickly became immensely popular amongst software developers,
    system administrators, and DevOps engineers as a tool that is not only easy to
    adopt, but also easy to customize, and even incorporate into existing platforms
    and configuration management tools. I first started using Ansible because, at
    the time, I was working on projects that required me to log into numerous bare-metal
    servers and virtual machines to perform the same set of commands over and over
    again. At that time, I was trying to hack my way into making this easier by writing
    flaky shell scripts that would use SSH to push remote commands to the servers.
    Over the course of my research into how to make these scripts more resilient,
    I discovered Ansible, which I immediately adopted and it made my work far easier
    and more reliable then I had imagined. I believe there are two primary reasons
    that Ansible is so popular in the IT industry:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 的最初动机是创建一个配置管理和编排系统，使得几乎任何人都能轻松上手并开始使用。Ansible 很快在软件开发人员、系统管理员和 DevOps
    工程师中变得极为流行，因为它不仅易于采用，而且易于定制，甚至能够集成到现有的平台和配置管理工具中。我第一次开始使用 Ansible 是因为当时我在做的项目需要我登录到大量的裸机服务器和虚拟机上，反复执行同一组命令。当时，我试图通过编写不稳定的
    shell 脚本来简化这一过程，这些脚本会使用 SSH 将远程命令推送到服务器。通过研究如何使这些脚本更加可靠，我发现了 Ansible，并立即采用了它，它使我的工作变得比我想象的更加简单和可靠。我相信，Ansible
    在 IT 行业如此受欢迎的原因有两个主要方面：
- en: Easy to understand YAML syntax for playbooks and roles. YAML is easy to learn
    and write, which makes it perfect for Ansible.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于理解的 YAML 语法，适用于 playbook 和角色。YAML 易于学习和编写，非常适合 Ansible。
- en: Hundreds, if not thousands, of built-in modules that come with Ansible Core.
    These modules allow us to do almost anything you can imagine, right out of the
    box.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数百个，如果不是成千上万的，Ansible Core 内置模块。这些模块使我们能够开箱即用地做几乎任何你能想象的事情。
- en: Let's look at these two unique aspects of Ansible and understand how we can
    leverage this ease of use in our own projects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Ansible 的这两个独特方面，理解我们如何在自己的项目中利用这种易用性。
- en: YAML syntax
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAML 语法
- en: 'YAML is a data serialization format that recursively stands for, *YAML Ain''t
    Markup Language*. You may have worked with other serialization formats in the
    past, such as XML or JSON. What makes YAML unique is that it is easy to write,
    and quite possibly the most human-readable data format currently used. Ansible
    chose to use YAML as the basis for defining its playbook syntax and language due
    to the fact that, even if you do not come from a programming background, YAML
    is super-easy to get started with writing, using, and understanding. YAML is unique
    in the way that it uses a series of colons (`:`), dashes (`-`), and indentations
    (spaces, not tabs) to define key-value pairs. These key-value pairs can be used
    to define almost every type of computer science data types, such as integers,
    Booleans, strings, arrays, and hash tables. Following is an example of a YAML
    document, illustrating some of these constructs:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 是一种数据序列化格式，其递归地代表了 *YAML Ain't Markup Language*。你可能以前使用过其他序列化格式，例如 XML
    或 JSON。YAML 的独特之处在于它易于编写，而且可能是当前最人类可读的数据格式。Ansible 选择使用 YAML 作为定义其 playbook 语法和语言的基础，原因是即使你没有编程背景，YAML
    也非常容易入门，编写、使用和理解都很简单。YAML 的独特之处在于它通过使用一系列冒号（`:`）、破折号（`-`）和缩进（空格，不是制表符）来定义键值对。这些键值对可以用来定义几乎所有类型的计算机科学数据类型，例如整数、布尔值、字符串、数组和哈希表。以下是一个
    YAML 文档的示例，展示了这些构造的一些用法：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding example demonstrates a simple YAML file consisting of the most
    basic constructs: a string variable, an array (list of items), a Boolean (true/false)
    variable, an integer variable, and a hash table holding a series of key-value
    pairs. This may look quite similar to work we have done previously in this book
    when modifying the `container.yml` files, as well as the Docker Compose files.
    These formats are also defined in YAML and consist of many of the same constructs.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例展示了一个简单的 YAML 文件，包含最基本的构造：一个字符串变量，一个数组（项目列表），一个布尔值（真/假）变量，一个整数变量，以及一个包含一系列键值对的哈希表。这可能看起来与我们在本书中修改
    `container.yml` 文件以及 Docker Compose 文件时做的工作非常相似。这些格式也是定义在 YAML 中，并且包含许多相同的构造。
- en: 'A few things that I would like to call your attention to in the preceding example
    (you should also keep in them mind when you begin writing Ansible playbooks and
    roles) are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我想要提醒您一些事情（当您开始编写 Ansible playbook 和角色时，也应该注意到这些）：
- en: 'All YAML documents begin with three dashes: `---`. This is important because
    you may have multiple YAML documents defined in the same single file. Documents
    would then be separated using the three dashes.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 YAML 文档都以三个破折号开头：`---`。这很重要，因为您可以在同一个文件中定义多个 YAML 文档。文档之间用三个破折号分隔。
- en: 'Comments are defined using the hash sign: `#`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释使用井号符号`#`定义。
- en: Strings are surrounded by quotation marks. This separates strings from literals,
    such as Booleans (true or false words without quotation marks), or integers (numbers
    without quotation marks). If you surrounded the words *true*/*false*, or a numerical
    value with quotation marks, they will be interpreted as strings.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串被引号包围。这将字符串与字面值（例如没有引号的布尔值（true或false）或整数（没有引号的数字））分开。如果您将单词*true*/*false*或数值用引号包围起来，它们将被解释为字符串。
- en: Colons (`:`) are used to separate key-value pairs, which define almost everything.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒号（`:`）用于分隔键值对，几乎定义了所有内容。
- en: Indentation is indicated by two spaces. Tabs are not recognized in the YAML
    format. When getting started with writing YAML documents, make sure your text
    editor is configured to place two spaces into your document when you hit the *Tab*
    key. This makes it easy to quickly and naturally indent text as you type.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进用两个空格表示。在 YAML 格式中不识别制表符。开始编写 YAML 文档时，请确保您的文本编辑器配置为在按下*Tab*键时将两个空格插入到文档中。这样可以在输入时快速自然地缩进文本。
- en: 'I realize that there is much more to YAML syntax than what I have provided
    in this example. My goal here is to dig a little deeper than in the earlier chapters
    to help give the reader a deeper understanding of the YAML format going forward.
    This is by no means a full description of the entire YAML format. If you want
    to read more about YAML, I would recommend you check out the official YAML specification
    website: [http://yaml.org](http://yaml.org/).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到 YAML 语法比我在这个示例中提供的要多得多。我在这里的目标是比早期章节更深入地挖掘，以帮助读者更深入地理解 YAML 格式。这绝不是整个 YAML
    格式的完整描述。如果您想了解更多关于 YAML 的信息，我建议您访问官方 YAML 规范网站：[http://yaml.org](http://yaml.org/)。
- en: Ansible modules
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 模块
- en: 'The second part of what makes Ansible so popular and easy to use is the plethora
    of modules that Ansible can leverage right out of the box, which can do almost
    anything the user can think of. Think of modules as the building blocks of Ansible,
    that define what your playbook does. There are Ansible modules that can edit the
    content of files on remote systems, add or delete users, install service packages,
    and even interact with APIs for remote applications. Modules themselves are written
    in Python and get called in a scripted format from YAML playbooks. The playbooks
    themselves are simply just a series of calls to Ansible modules that perform a
    specific series of tasks. Let''s look at a very simple playbook to understand
    how this works in practice:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使得 Ansible 如此受欢迎且易于使用的第二部分是 Ansible 可以利用的大量模块，这些模块可以做用户能想到的几乎任何事情。将模块视为 Ansible
    的构建块，定义您的 playbook 的操作。Ansible 模块可以编辑远程系统上文件的内容，添加或删除用户，安装服务包，甚至与远程应用程序的 API 进行交互。模块本身是用
    Python 编写的，并以脚本格式从 YAML playbook 中调用。Playbook 本身只是对 Ansible 模块的一系列调用，执行特定的任务序列。让我们看一个非常简单的
    playbook，以了解这在实践中是如何工作的：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This simple playbook consists of two separate tasks: creating a user account
    and installing the Vim text editor. Each task in Ansible calls for exactly one
    module to perform an action. Tasks in Ansible are defined using YAML dashes, followed
    by the name of the task, the name of the module, and all of the parameters you
    want to feed into that module indented as mentioned in the following. In our first
    task, we are creating a user account by calling the `user` module. We are giving
    the user module two parameters: `name` and `state`. The `name` represents the
    name of the user we want to create, and the `state` represents how we want the
    desired state on our remote system or container to look. In this case, we want
    a user to exist called `MyUser` and the state we want that user to be in is `present`.
    If this Ansible playbook gets executed and the user called `MyUser` already exists,
    Ansible will take no action since the system is in the desired state.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的 playbook 由两个独立的任务组成：创建一个用户账户和安装 Vim 文本编辑器。Ansible 中的每个任务都调用恰好一个模块来执行操作。Ansible
    中的任务使用 YAML 中的短横线来定义，接着是任务的名称、模块的名称以及所有要传递给该模块的参数，缩进格式如下所示。在我们的第一个任务中，我们通过调用 `user`
    模块来创建一个用户账户。我们为 `user` 模块提供了两个参数：`name` 和 `state`。`name`表示我们要创建的用户的名称，而 `state`表示我们希望远程系统或容器中的用户状态。此时，我们希望存在一个名为
    `MyUser` 的用户，且该用户的状态为 `present`。如果这个 Ansible playbook 执行时，名为 `MyUser` 的用户已经存在，Ansible
    将不会采取任何操作，因为系统已经处于期望状态。
- en: The second task in this playbook installs the text editor Vim on our remote
    system or container. To accomplish this, we are going to use the `apt` module
    to install a Debian APT package. If this was a Red Hat or CentOS system, we would
    similarly use the `yum` or `dnf` module. The name represents the name of the package
    we want to install, and the state represents the desired state of the server or
    container. Thus, we would like the Vim Debian package to be installed. As we mentioned
    earlier, there are hundreds, if not thousands, of Ansible modules that can be
    leveraged in playbooks and roles. You can find the full list of Ansible modules
    by category as well as excellent examples of parameters that the modules take,
    in the Ansible documentation at [http://docs.ansible.com/ansible/latest/modules_by_category.html](http://docs.ansible.com/ansible/latest/modules_by_category.html).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本手册中的第二个任务是在我们的远程系统或容器上安装文本编辑器 Vim。为此，我们将使用`apt`模块来安装一个 Debian APT 包。如果这是一个
    Red Hat 或 CentOS 系统，我们也会使用`yum`或`dnf`模块。`name`表示我们要安装的包的名称，`state`表示服务器或容器的期望状态。因此，我们希望
    Vim Debian 包能够被安装。如前所述，Ansible 有成百上千的模块可以在 playbook 和角色中使用。你可以在 Ansible 文档中找到按类别组织的完整模块列表，以及这些模块所需参数的优秀示例，网址为[http://docs.ansible.com/ansible/latest/modules_by_category.html](http://docs.ansible.com/ansible/latest/modules_by_category.html)。
- en: The `state` parameter also takes the value `absent` to remove a user, package,
    or almost anything else that could be defined.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`state` 参数还可以取 `absent` 值，用于删除用户、包或几乎任何可以定义的东西。'
- en: One of the major benefits of Ansible Container is that, in writing container
    configuration using Ansible roles, you have the entire universe of Ansible modules
    available to you to choose from. Unfortunately, not all Ansible modules work in
    the context of a container. A traditional example of this is modules that manage
    the state of running services, such as the `service` module. The `service` module
    does not run in containers, since application containers typically lack traditional
    init systems that you would find in a full operating system to start, stop, and
    restart running services. In a containerized context, this is handled by starting
    your container with a `CMD` or `entrypoint` statement that directly executes a
    service binary.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Container 的一个主要优势是，在编写容器配置时使用 Ansible 角色，你可以使用所有可用的 Ansible 模块。不幸的是，并不是所有的
    Ansible 模块都能在容器环境中工作。一个典型的例子是管理运行中服务状态的模块，比如 `service` 模块。`service` 模块在容器中无法运行，因为应用容器通常缺少传统的初始化系统（你会在完整操作系统中找到它们），这些系统负责启动、停止和重启运行中的服务。在容器化的环境中，这个过程通过使用
    `CMD` 或 `entrypoint` 语句直接执行服务二进制文件来处理。
- en: Furthermore, almost any module that manages the orchestration of cloud services
    or call external APIs will not run in a containerized context. This is pretty
    straightforward since you would usually not want to orchestrate the state of external
    services when you are building an independent containerized microservice. Of course,
    if you are writing an Ansible playbook that deploys a containerized application
    you previously built using Ansible Container, you can use these orchestration
    modules to react in certain ways when the container comes online. However, for
    the purposes of this chapter, we will limit our discussion only to writing roles
    that build containerized services.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，几乎所有管理云服务编排或调用外部 API 的模块都无法在容器化环境中运行。这一点非常直接，因为在构建一个独立的容器化微服务时，通常不会想要编排外部服务的状态。当然，如果你正在编写一个
    Ansible 剧本来部署一个之前使用 Ansible Container 构建的容器化应用，你可以使用这些编排模块来在容器上线时作出响应。不过，在本章中，我们将仅限于讨论编写构建容器化服务的角色。
- en: A brief overview of MariaDB
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MariaDB 简要概述
- en: Throughout this chapter, we will be writing an Ansible Role that builds a MariaDB
    database container. MariaDB is a fork of the MySQL relational database server,
    which provides numerous customizations and optimizations that are not found in
    vanilla MySQL. Out of the box, MariaDB supports numerous optimizations, such as
    replication, query optimization, encryption, performance, and speed improvements
    over standard MySQL, yet remains fully MySQL-compatible, leveraging a free and
    open source GPL license. MariaDB was chosen for this example due to its relative
    simplicity to deploy and the free nature of the application itself. In this chapter,
    we will build a relatively basic single-node MariaDB installation that does not
    contain a lot of features and performance tweaks that you would find in a production-ready
    installation. The purpose of this chapter is not how to build a production-ready
    MariaDB container, but rather to illustrate the concepts of building a containerized
    service using Ansible Container. If you want to go further with this example,
    feel free to tweak this code in any way you see fit. Extra credit to those of
    you who build production-ready containers!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个 Ansible 角色来构建 MariaDB 数据库容器。MariaDB 是 MySQL 关系数据库服务器的一个分支，提供了许多
    MySQL 中没有的自定义功能和优化。开箱即用，MariaDB 支持多种优化，如复制、查询优化、加密、性能和速度上的提升，相比标准的 MySQL 更具优势，但仍然完全兼容
    MySQL，采用免费开源的 GPL 许可证。选择 MariaDB 作为示例，是因为它相对容易部署，而且该应用本身是免费的。在本章中，我们将构建一个相对基础的单节点
    MariaDB 安装，这个安装不包含很多你在生产环境安装中会找到的功能和性能优化。本文的目的不是教你如何构建一个生产就绪的 MariaDB 容器，而是通过
    Ansible Container 构建容器化服务的概念。如果你想进一步拓展这个示例，可以根据自己的需求调整这段代码。对那些能够构建生产就绪容器的朋友，将会额外加分！
- en: Initializing an Ansible Container role
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化一个 Ansible Container 角色
- en: As discussed previously, Ansible roles are a self-contained, reusable set of
    playbooks, templates, variables, and other metadata that defines an application
    or service. Since Ansible roles are designed to work with Ansible Galaxy, Ansible
    Galaxy command-line tools have built-in functionality to initialize roles that
    contain all of the proper directories, default files, and scaffolding designed
    to create a functioning Ansible role with minimal hassle. This works very similarly
    to the `ansible container init` command for creating Ansible Container projects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Ansible 角色是一个自包含的、可重用的一组剧本、模板、变量和其他元数据，用于定义一个应用或服务。由于 Ansible 角色是为与 Ansible
    Galaxy 配合使用而设计的，Ansible Galaxy 命令行工具具有内置功能，可以初始化包含所有正确目录、默认文件和结构的角色，从而创建一个功能齐全的
    Ansible 角色，且无需过多的麻烦。这与 `ansible container init` 命令创建 Ansible Container 项目时的工作方式非常相似。
- en: What's in a container-enabled role?
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器启用角色中包含什么？
- en: 'To create a new container-enabled role in Ansible Container, we are going to
    use the `ansible-galaxy init` command with the `container-enabled` flag to create
    the new role directory structure for us. To examine what happens when we use this
    command, let''s initialize a role in the `/tmp` directory on our Vagrant VM and
    see what Ansible creates for us:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Ansible Container 中创建一个新的容器启用角色，我们将使用带有 `container-enabled` 标志的 `ansible-galaxy
    init` 命令来为我们创建新的角色目录结构。为了了解当我们使用这个命令时发生了什么，我们将在我们的 Vagrant 虚拟机的 `/tmp` 目录中初始化一个角色，看看
    Ansible 为我们创建了什么：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Upon successful execution of the `init` command, Ansible should return a message
    indicating that your new role was `created successfully`. If you run the `ls`
    command, you will find a new directory named after the role we just initialized.
    Everything that comprises of the role resides in this directory, according to
    the default directory structure. When you call a role from Ansible, Ansible will
    look in all of the locations you indicated your roles should live in and will
    look for a directory with the same name as your role. We will see this in more
    detail later in this chapter. If you navigate inside this directory, you will
    find a folder structure similar to the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行 `init` 命令后，Ansible 应返回一条消息，指示你的新角色已 `创建成功`。如果你运行 `ls` 命令，你会看到一个新目录，目录名就是我们刚刚初始化的角色的名称。根据默认的目录结构，角色的所有组成部分都位于此目录中。当你从
    Ansible 调用一个角色时，Ansible 会查找你指定的角色所在的所有位置，并查找一个与角色同名的目录。稍后在本章中，我们将更详细地了解这一点。如果你进入该目录，你将看到类似于以下的文件夹结构：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s take a look at what each of these directories and files does:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下这些目录和文件的作用：
- en: '`defaults/`: `defaults` is a directory that contains variables specific to
    your role and has the lowest priority for overriding the values. Any variables
    that you want to place in your role that you definitely want or require the user
    to override should go in the `main.yml` file of this directory. This is not to
    be confused with the `vars/` directory.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaults/`：`defaults` 是一个包含特定于你角色的变量的目录，并且在覆盖值时具有最低优先级。如果你希望将一些变量放入角色中，并且希望用户一定要重写这些变量，则应将它们放在该目录的
    `main.yml` 文件中。这与 `vars/` 目录不同，不要混淆。'
- en: '`handlers/`: `handlers` are a concept in Ansible that defines tasks that should
    be executed in response to notify events sent from other tasks during a role execution.
    For example, you may have a task that updates a configuration file in your role.
    If your service needs to be restarted in response to that configuration file update,
    you could specify a `notify:` the step in your task, as well as the name of your
    handler. If the parent task executes and resolves a `CHANGED` status, Ansible
    will look inside of the `handlers/` directory for the task specified by the notify
    statement and then execute that task. Please note that handlers do not execute
    unless another playbook task specifically calls that task using the `notify:`
    statement and results in a changed status. Handlers are not quite as common in
    container-enabled roles since containers usually aren''t dependent on external
    events and circumstances.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handlers/`：`handlers` 是 Ansible 中的一个概念，定义了在角色执行过程中，响应其他任务发送的通知事件时应执行的任务。例如，你可能有一个任务用于更新角色中的配置文件。如果服务需要因该配置文件更新而重启，你可以在任务中指定一个
    `notify:` 步骤，并指定处理程序的名称。如果父任务执行并且状态为 `CHANGED`，Ansible 会在 `handlers/` 目录中查找由通知语句指定的任务，并执行该任务。请注意，除非另一个
    playbook 任务通过 `notify:` 语句明确调用该任务并且导致状态改变，否则 handlers 不会执行。由于容器通常不依赖于外部事件和情况，handlers
    在启用容器的角色中并不常见。'
- en: '`meta`: `Meta` is a directory which contains the metadata for Ansible roles.
    In a container-enabled role, it contains two primary files: `main.yml` which contains
    general metadata about the role, such as dependencies, Ansible Galaxy data, and
    conditions upon which the role is contingent. For the purposes of this example,
    we will not do very much with this file. The second file, `container.yml`, is
    more important to us. This `container.yml` is specific to container-enabled roles
    and is critical for specifying the default values that will be injected into the
    project-level `container.yml` file when we call our role. Here, we can specify
    the container image, volume information, as well as the default command and `entrypoint`
    data that we want our container to run with by default. All of this data can be
    overridden in our parent `container.yml` file if we so choose.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta`：`Meta` 是一个包含 Ansible 角色元数据的目录。在启用容器的角色中，它包含两个主要文件：`main.yml`，该文件包含关于角色的一般元数据，例如依赖关系、Ansible
    Galaxy 数据以及角色所依赖的条件。为了这个示例的目的，我们不会对这个文件做太多处理。第二个文件，`container.yml`，对我们来说更为重要。这个
    `container.yml` 文件是专门针对启用容器的角色的，它对于指定当我们调用角色时将被注入到项目级 `container.yml` 文件中的默认值至关重要。在这里，我们可以指定容器镜像、卷信息，以及我们希望容器默认运行的命令和
    `entrypoint` 数据。如果我们愿意，所有这些数据都可以在父级 `container.yml` 文件中覆盖。'
- en: '`tasks`: The `tasks` directory is where we specify the tasks that actually
    get executed inside our container and build the service. By default, Ansible will
    execute the `main.yml` file and execute all tasks in the order as specified. Any
    other task files can go into this directory as well and can be executed using
    the `include:` statement from our `main.yml` file.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks`：`tasks` 目录是我们指定实际在容器中执行的任务，并构建服务的地方。默认情况下，Ansible 会执行 `main.yml` 文件，并按照指定的顺序执行所有任务。任何其他的任务文件也可以放入此目录，并可以通过在
    `main.yml` 文件中使用 `include:` 语句来执行。'
- en: '`templates`: The templates directory stores the configuration file templates
    we want to use in our role. Since Ansible is Python-based, it uses the Jinja2
    templating engine to place configuration templates into the container and update
    values based on variables identified in the `defaults/` and `vars/` directories.
    All files in this directory should have the `.j2` file extension, although this
    is not required.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates`：`templates` 目录存储我们希望在角色中使用的配置文件模板。由于 Ansible 是基于 Python 的，它使用 Jinja2
    模板引擎将配置模板放入容器，并根据 `defaults/` 和 `vars/` 目录中识别的变量更新值。此目录中的所有文件应该具有 `.j2` 文件扩展名，尽管这并不是强制要求的。'
- en: '`tests`: Any automated testing that you would like a CICD tool to perform would
    go here. Usually, developers would put any custom Ansible configurations, parameters,
    or inventories that the CI/CD tool will requires as input in the directories and
    files that are autogenerated in this directory.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests`：任何您希望 CICD 工具执行的自动化测试都应该放在这里。通常，开发者会将任何自定义的 Ansible 配置、参数或清单文件放入这个目录中，以供
    CI/CD 工具作为输入使用，这些文件通常是自动生成的。'
- en: '`vars`: The `vars/` directory is the location in which a developer can specify
    other variables available to the role here. It is important to note that the `vars/`
    directory has a lower precedence than the `defaults/` directory, so variables
    defined here are more difficult to override than the ones specified in `defaults`.
    Usually, when I write a role, I will make all of my variables available in the
    `defaults` directory, as I want the user to have full power to override anything
    they desire. There might be circumstances in which you may not want your variables
    as easy to access, in which case they could be specified in the `vars/` directory.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars`：`vars/` 目录是开发者可以在此指定其他可用于角色的变量的位置。需要注意的是，`vars/` 目录的优先级低于 `defaults/`
    目录，因此在这里定义的变量比在 `defaults` 中指定的变量更难覆盖。通常，当我编写角色时，我会将所有变量都放在 `defaults` 目录中，因为我希望用户能够完全覆盖他们想要的任何内容。但在某些情况下，您可能不希望让变量太容易被访问，这时它们可以被指定在
    `vars/` 目录中。'
- en: Any file in your role named, `main.yml` indicates that the file is a default
    and will be executed automatically.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在您的角色中名为 `main.yml` 的文件都表示该文件是默认文件，并会被自动执行。
- en: Now that we know what makes up a container-enabled role, we can take this knowledge
    and create a new Ansible Container project that will build our MariaDB MySQL role.
    To accomplish this, we are going to initialize a new project and create a subdirectory
    called `roles/`, which will contain the role we will create. When we build our
    project, Ansible will know to look inside of our `roles/` directory and find all
    of the roles we have specified and created there. Please note that the following
    sections of this chapter will get quite code-heavy. To make the process of following
    along easier, the completed example can be found in the official book GitHub repository
    under the `AnsibleContainer/mariadb_demo` directory. However, the best way to
    learn how to write Ansible code is by repetition and practice, which can only
    be attained by writing the code yourself. It is strongly suggested that, while
    it may not be practical to copy the code written in this chapter verbatim, one
    should obtain practice writing Ansible code by using these examples to create
    your own project or modifying the example in the Git repository. The more code
    you write, the better and more fluent of an Ansible developer you will become.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了容器启用角色的组成部分，我们可以利用这些知识创建一个新的 Ansible 容器项目，来构建我们的 MariaDB MySQL 角色。为此，我们将初始化一个新项目，并创建一个名为`roles/`的子目录，里面将包含我们要创建的角色。当我们构建项目时，Ansible
    会知道去我们的`roles/`目录中查找我们指定并创建的所有角色。请注意，本章节的以下部分会包含大量代码。为了让跟随过程更容易，完整的示例可以在官方书籍的
    GitHub 仓库中找到，位于`AnsibleContainer/mariadb_demo`目录下。然而，学习如何编写 Ansible 代码的最佳方式是通过重复和实践，而这一点只有通过自己编写代码才能实现。强烈建议，尽管逐字复制本章编写的代码可能不太实际，但应该通过使用这些示例创建自己的项目或修改
    Git 仓库中的示例来练习编写 Ansible 代码。你写的代码越多，成为更好、更流利的 Ansible 开发者的机会就越大。
- en: Initializing the MariaDB project and role
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化 MariaDB 项目和角色
- en: 'Now that we have a feel for how a container-enabled role is structured, we
    can start our MariaDB container by initializing a new Ansible Container project.
    In a new directory on your Vagrant host, start a new project as usual by using
    the `ansible-container init` command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了容器启用角色的结构，我们可以通过初始化一个新的 Ansible 容器项目来启动我们的 MariaDB 容器。在 Vagrant 主机上的新目录中，像往常一样使用`ansible-container
    init`命令启动一个新项目：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside of our `project` directory, we can create a directory that will store
    our roles. In the Ansible Core, the default location for a role is in the `/etc/ansible/roles`
    or a `roles/` directory relative to the playbook you are executing. It should
    be noted, however, that roles can be stored in any location provided the Ansible
    installation has read access to the path. For the purposes of this demonstration,
    we are going to create our roles path as a `child` directory of our project. Within
    our `project` directory, create a new directory called `roles` and initialize
    our Ansible Container role inside of that directory. We will call our role `mariadb_role`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`project`目录中，我们可以创建一个目录来存储我们的角色。在 Ansible 核心中，角色的默认位置是在`/etc/ansible/roles`或相对于你正在执行的
    playbook 的`roles/`目录中。然而，需要注意的是，角色可以存储在任何位置，只要 Ansible 安装能够读取该路径。为了本示范，我们将把角色路径创建为项目的`子`目录。在我们的`project`目录中，创建一个名为`roles`的新目录，并在该目录中初始化我们的
    Ansible 容器角色。我们将把我们的角色命名为`mariadb_role`：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that our role has been created inside of our project, we need to modify
    our project `container.yml` file so that it knows the path we are sourcing our
    roles from, as well as to create a service that we will build using our role.
    The roles location can be specified using the `roles_path` option as a child parameter
    of `settings:` in the `container.yml` file. Here, we can specify the paths we
    want Ansible to search for roles as list items of `roles_path` using the hyphen
    notation (`-`). We will specify the `roles` directory we just created. Under the
    `services:` subsection, we can create a new service called `MySQL_database_container`.
    This will leverage the role `mariadb_role` that we just created. We also want
    to make sure that we specify the base image we want to use for our service.  For
    this example, the MariaDB container will be based on Ubuntu 16.04, so we want
    to make sure our `conductor_base` image is the same to ensure compatibility.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的角色已经在项目中创建，我们需要修改项目中的`container.yml`文件，让它知道我们从哪里加载角色的路径，并创建一个我们将使用角色构建的服务。角色的位置可以通过在`container.yml`文件的`settings:`下设置`roles_path`选项来指定。这里，我们可以使用短横线表示法（`-`）将Ansible需要查找角色的路径列出为`roles_path`的列表项。我们将指定刚才创建的`roles`目录。在`services:`子部分下，我们可以创建一个名为`MySQL_database_container`的新服务。该服务将利用我们刚刚创建的`mariadb_role`角色。我们还需要确保指定我们希望用于服务的基准镜像。在本示例中，MariaDB容器将基于Ubuntu
    16.04，因此我们需要确保我们的`conductor_base`镜像与之相同，以确保兼容性。
- en: container.yml
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: container.yml
- en: 'Following is a sample of the `container.yml` file that provides these settings:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是提供这些设置的`container.yml`文件示例：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, we could build our project, but it would result in an empty container
    since our role contains no tasks from which we can build a container image. Let's
    make things interesting by adding tasks as well as updating the role-specific
    `container.yml` file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，我们可以构建我们的项目，但这将导致一个空容器，因为我们的角色没有任何任务可以用来构建容器镜像。让我们通过添加任务并更新角色特定的`container.yml`文件来使事情变得有趣。
- en: Always remember to use the same conductor base image that your service containers
    will use. This will ensure maximum compatibility when building your project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记得使用与服务容器相同的主机基准镜像。这将确保在构建项目时最大程度的兼容性。
- en: Writing a container-enabled role
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个支持容器的角色
- en: 'As we discussed previously, it is quite difficult to walk the reader through
    writing code from scratch, due to the fact that file paths can get complicated
    rather quickly, making it easy to lose your place. In this section, I will show
    what the modified files look like and draw the reader''s attention to the parts
    of the files that require explanation. Since it is quite easy to get lost, I will
    direct the reader to follow along in the official book GitHub repository located
    at the following URL: [https://github.com/aric49/ansible_container_lab/tree/master/AnsibleContainer/mariadb_demo](https://github.com/aric49/ansible_container_lab/tree/master/AnsibleContainer/mariadb_demo).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的，由于文件路径很容易变得复杂，导致很容易迷失在其中，因此从零开始编写代码并引导读者是相当困难的。在本节中，我将展示修改后的文件内容，并引导读者关注需要解释的文件部分。由于很容易迷失，我会指导读者前往以下网址的官方书籍
    GitHub 仓库进行跟随：[https://github.com/aric49/ansible_container_lab/tree/master/AnsibleContainer/mariadb_demo](https://github.com/aric49/ansible_container_lab/tree/master/AnsibleContainer/mariadb_demo)。
- en: As developers of a container-enabled role, the most important parts of writing
    a role is the role-specific `container.yml` file, which specifies the default
    values the container will run with, as well as the tasks that are used to build
    the container and put all of the pieces in place. The tasks you build the container
    with will often determine the parameters in the role-specific `container.yml`
    file. When writing a role, developers will often tweak and modify the `container.yml`
    file as they are writing the playbook tasks. When you call a role from the project-specific
    `container.yml` file, the contents of the role-specific `container.yml` file will
    be used to build your container. At any point, a developer can override the role-specific
    `container.yml` file by simply modifying the parameters in the project `container.yml`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个容器启用的角色的开发者，编写角色最重要的部分是角色特定的`container.yml`文件，该文件指定了容器运行时的默认值，以及用于构建容器并将所有组件放置到位的任务。你用来构建容器的任务通常会决定角色特定的`container.yml`文件中的参数。在编写角色时，开发者通常会在编写
    playbook 任务时调整和修改`container.yml`文件。当你从项目特定的`container.yml`文件中调用一个角色时，角色特定的`container.yml`文件的内容将被用来构建你的容器。在任何时候，开发者都可以通过简单地修改项目`container.yml`中的参数来覆盖角色特定的`container.yml`文件。
- en: 'It is important as a role developer to write sane defaults for your role''s
    `container.yml` to enable other users to leverage your role quickly. For our MariaDB
    demonstration, we will create a simple role-specific `container.yml` file that
    resembles the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为角色开发者，为你的角色编写合理的默认值在`container.yml`中是很重要的，这样可以帮助其他用户迅速使用你的角色。对于我们的 MariaDB
    示例，我们将创建一个简单的角色特定`container.yml`文件，其内容如下所示：
- en: roles/mariadb_role/meta/container.yml
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: roles/mariadb_role/meta/container.yml
- en: 'This file is located in the `meta` directory of the MariaDB role:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件位于 MariaDB 角色的`meta`目录中：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The parameters we are defining in the role-specific `container.yml` should immediately
    jump out at you in the exact same way in which we would define them in the project-specific
    `container.yml` services section. Here, we are using the Ubuntu 16.04 base image,
    which is the same as our conductor container. In order to make our MySQL service
    accessible to outside users, we are going to expose the MySQL ports `3306` on
    the host to ports `3306` on the container. Finally, we are going to specify a
    default entry point and command that the container should run when it starts.
    A common practice among container developers recently is to leverage lightweight
    init systems to start and manage processes inside of containers. A popular init
    system for containers is `dumb-init`, written by Yelp in 2013 to provide an easy
    to install, lightweight init binary for managing processes inside of containers.
    `dumb-init` essentially starts as PID 1 inside of the container and takes the
    container service executable as an argument provided to it. The benefit is that,
    since `dumb-init` is running as PID 1, all kernel signals will first be intercepted
    by `dumb-init` and forwarded to the container service (`mysqld`). `dumb-init`
    will also provide reaping services for our child process, should our container
    be suddenly stopped or restarted ungracefully. Keep in mind, using a container
    `init` system is not a requirement when building containers, but in some cases,
    it will help with running, stopping, and restarting containers if the processes
    don't exit cleanly. In this example, we will use `dumb-init` as our `entrypoint`
    for the container, and use the `command:` parameter to specify the `/usr/sbin/MySQLd`
    command as an argument into it. This will start the `mysqld` process under the
    supervision of `dumb-init`, which will intercept all of the POSIX signals and
    forward them over to `mysqld`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在角色特定的`container.yml`中定义的参数应该立即引起你的注意，其方式与在项目特定的`container.yml`服务部分中定义参数是完全一致的。在这里，我们使用的是
    Ubuntu 16.04 基础镜像，它与我们的 conductor 容器相同。为了使 MySQL 服务能够被外部用户访问，我们将会把主机上的 MySQL 端口
    `3306` 映射到容器内的 `3306` 端口。最后，我们将指定一个默认的入口点和命令，当容器启动时应该运行这些命令。最近，容器开发人员中常见的做法是利用轻量级的初始化系统来启动和管理容器内的进程。一个流行的容器初始化系统是
    `dumb-init`，它由 Yelp 在 2013 年编写，目的是提供一个易于安装的轻量级初始化二进制文件，用于管理容器内的进程。`dumb-init`
    本质上作为 PID 1 在容器内启动，并将容器服务可执行文件作为参数传递给它。这样做的好处是，由于 `dumb-init` 作为 PID 1 运行，所有内核信号将首先被
    `dumb-init` 拦截并转发给容器服务（`mysqld`）。如果容器被突然停止或不规范地重启，`dumb-init` 还将为我们的子进程提供回收服务。请记住，使用容器
    `init` 系统并不是构建容器的要求，但在某些情况下，它有助于在进程没有正常退出时，运行、停止和重启容器。在这个示例中，我们将使用 `dumb-init`
    作为容器的 `entrypoint`，并使用 `command:` 参数将 `/usr/sbin/MySQLd` 命令作为参数传递给它。这样，`mysqld`
    进程将在 `dumb-init` 的监督下启动，`dumb-init` 将拦截所有 POSIX 信号并转发给 `mysqld`。
- en: The second most important aspect of a containerized role is actually writing
    tasks that are executed in our base image to create the project container. All
    tasks are YAML files in the `tasks` directory of the role. Each task has a name
    and calls a single Ansible module with parameters to perform a unit of work in
    the container. Although there are no strict requirements on how to name tasks,
    or which order to place them in, you do want to keep in mind the flow of the playbook
    in terms of dependencies on other tasks that may come before or after certain
    steps. You also want to make sure you name tasks in such a way that any user watching
    the build process has a fairly good idea what is going on, even if they are not
    an Ansible developer. Named tasks are what give Ansible the reputation of being
    *self-documenting*. This means that, as you write code, the code basically documents
    itself since almost any user reading your code should know immediately what it
    does based on the naming of the tasks. It should also be noted that, as all services
    and applications are different, they are all deployed and configured differently
    as well. With Ansible and containerization, there is no *one-size-fits-all* approach
    that can adequately capture the best practices for deploying and configuring your
    application.  One of the benefits of Ansible is that Ansible provides the tools
    needed to automate almost any configuration one can think of to ensure applications
    get built and deployed reliably. The following is the content of the `tasks/main.yml`
    file in the MariaDB role we are in the process of writing. Take a moment and read
    through the playbook as it is; we will go through each of these tasks one-by-one
    to provide more detail as to how the playbook runs. As I describe how the playbook
    works, it would be helpful to glance back at each task as you read the description.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化角色的第二个最重要的方面是实际编写在我们的基础镜像中执行的任务，以创建项目容器。所有任务都是位于角色的 `tasks` 目录中的 YAML 文件。每个任务都有一个名称，并调用一个单一的
    Ansible 模块，使用参数执行容器中的一项工作。虽然对任务命名或排列顺序没有严格的要求，但你确实需要考虑到 playbook 的流程，特别是与其他任务的依赖关系，这些任务可能会在某些步骤之前或之后执行。你还需要确保任务的命名方式，使得任何查看构建过程的用户，即使他们不是
    Ansible 开发人员，也能大致了解发生了什么。命名任务是 Ansible 被誉为 *自文档化* 的原因之一。这意味着，当你编写代码时，代码基本上会自动进行文档化，因为几乎任何阅读你代码的用户，凭借任务命名，都会立刻明白它的作用。还应注意的是，由于所有服务和应用程序都不同，它们的部署和配置方式也不同。使用
    Ansible 和容器化技术，没有一种 *一刀切* 的方法能够充分捕捉部署和配置应用程序的最佳实践。Ansible 的一个优势是，它提供了所需的工具，能够自动化几乎任何人能想到的配置，以确保应用程序能可靠地构建和部署。以下是我们正在编写的
    MariaDB 角色中 `tasks/main.yml` 文件的内容。花一点时间阅读当前的 playbook；我们将逐个任务进行解析，详细说明 playbook
    是如何运行的。在我描述 playbook 的工作原理时，回顾每个任务的内容会对你理解描述有帮助。
- en: tasks/main.yml
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tasks/main.yml
- en: 'This file is located in `roles/mariadb_role/tasks/main.yml`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件位于 `roles/mariadb_role/tasks/main.yml`：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Task breakdown (main.yml)
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务细分（main.yml）
- en: '`Install Base Packages`: Since we are building an Ubuntu 16.04 image, the `Install
    Base Packages` task calls the `apt` package module to install two packages: `ca-certificates` and
    `apt-utils`, which are required for the preceding tasks. We want the state of
    these packages to be present and installed in the `container` and the `apt` database
    cache to be updated prior to installing the packages as well. We are able to install
    multiple packages using the `with_items` operator. `with_items` iterates over
    the list items specified and run each value through the apt module. Using `with_items`,
    we don''t have to create two or more separate tasks to perform the same action
    repeatedly. In the `name` section of the task, we specify `{{ item }}`, which
    is a Jinja2 keyword variable that tells Ansible that it is about to iterate over
    a list.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`安装基础包`：由于我们正在构建一个 Ubuntu 16.04 镜像，`安装基础包` 任务调用 `apt` 包管理模块来安装两个包：`ca-certificates`
    和 `apt-utils`，它们是后续任务所必需的。我们希望这些包的状态在 `container` 中是存在的，并且 `apt` 数据库缓存已更新，以便在安装这些包之前使用。我们可以使用
    `with_items` 操作符来安装多个包。`with_items` 会遍历指定的列表项，并通过 `apt` 模块运行每个值。使用 `with_items`
    后，我们不需要创建两个或更多独立的任务来重复执行相同的操作。在任务的 `name` 部分，我们指定了 `{{ item }}`，这是一个 Jinja2 关键字变量，它告诉
    Ansible 即将遍历一个列表。'
- en: '`Install dumb-init for the Container Init System`: This task leverages the
    `get_url` module in order to download a remote file from the internet into the
    container. In this particular case, we are downloading the `dumb-init` binary
    and placing it in the container at the destination `/usr/bin/dumb-init`. We are
    changing the permissions so the file will be owned by root, in the root group,
    and will be executable. Ansible allows us to perform all of these actions in a
    single module call.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`为容器初始化系统安装dumb-init`：此任务利用`get_url`模块从互联网下载远程文件到容器中。在这个特定的情况下，我们下载`dumb-init`二进制文件，并将其放置在容器中的目标位置`/usr/bin/dumb-init`。我们更改文件权限，使其归root所有，属于root组，并且可以执行。Ansible允许我们通过一次模块调用执行所有这些操作。'
- en: '`Create MySQL User and Group`: The next two tasks are quite similar. With these
    tasks, we are starting to lay the groundwork for installing our MariaDB MySQL
    service. We are calling the `user` and `group` module to create a user called
    `mysql`, create a group also called `mysql`, and add the user to the group. Notice
    that, in the group module, we specify `append: true`. This indicates that whatever
    groups are already assigned to the `mysql` user, we also want to append `mysql`.
    This is a safe option to add to any group declaration so that we don''t accidentally
    remove users from other groups they may need to belong to.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建MySQL用户和组`：接下来的两个任务非常相似。通过这些任务，我们开始为安装MariaDB MySQL服务铺设基础。我们调用`user`和`group`模块创建一个名为`mysql`的用户，创建一个同名的组，并将用户添加到该组中。请注意，在组模块中，我们指定了`append:
    true`。这意味着我们希望将`mysql`组附加到`mysql`用户已经分配的任何组中。这个选项是添加到任何组声明中的安全选择，以确保我们不会意外地将用户从他们可能需要加入的其他组中移除。'
- en: '`Install the MySQL Server`: This task functions in a very similar way to the
    first task that we saw in the playbook. However, instead of installing multiple
    packages, we are calling the apt module to install only one package, the MariaDB
    server. As usual, we want the package to be installed and present, as well as
    having the package cache updated. Arguably, we could have added this package to
    the list of installed packages in our very first task, and that would definitely
    work. However, as a matter of development style, I like to provide a logical distinction
    between steps in my playbooks so that things do not get confusing further on.
    After all, installing the base packages is usually a separate and distinct step
    from installing the core service package.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`安装MySQL服务器`：此任务的功能与我们在剧本中看到的第一个任务非常相似。然而，我们并不是安装多个软件包，而是调用apt模块只安装一个软件包——MariaDB服务器。像往常一样，我们希望软件包已安装并存在，并且更新软件包缓存。可以说，我们本可以在第一个任务中将该软件包添加到已安装软件包列表中，这也会起作用。然而，从开发风格上讲，我更喜欢在剧本的步骤之间提供逻辑上的区分，以免之后的操作变得混乱。毕竟，安装基础软件包通常与安装核心服务包是两个不同且独立的步骤。'
- en: '`Change permissions on directories`: This task is one of the more complex tasks
    in the playbook. In this task, we have a handful of directory paths that need
    to have their permissions changed so that the MySQL service can write data to
    them. The `file` module allows us to create, delete, or modify any file present
    in our container. Similarly to our first task, we are going to call the file module
    on our `{{ item }}` keyword variable so that each list item specified in our `with_items`
    will have the same permissions and attributes applied to it. If the paths specified
    do not exist, Ansible will create them with the state `directory` and apply the
    appropriate permissions to them. We are also providing the `recurse: true` option
    so that the permissions will apply to all subdirectories from those locations
    specified.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`更改目录权限`：此任务是剧本中较为复杂的任务之一。在这个任务中，我们需要更改一些目录路径的权限，以便MySQL服务能够向其中写入数据。`file`模块允许我们创建、删除或修改容器中任何文件。类似于第一个任务，我们将调用文件模块对`{{
    item }}`关键字变量进行操作，以便在`with_items`中指定的每个列表项都应用相同的权限和属性。如果指定的路径不存在，Ansible将以`directory`状态创建这些路径，并应用适当的权限。我们还提供了`recurse:
    true`选项，这样权限将应用到指定位置的所有子目录。'
- en: '`Remove my.cnf`: `my.cnf` is the primary configuration file that is used by
    MySQL to configure how the database service operates. When MariaDB is first installed,
    it creates `my.cnf` as a symlink, which leads to another configuration file it
    uses instead. We don''t want this behavior; hence, we are going to delete the
    default `my.cnf` file using the file module and set the state value to `absent`.
    We will use our own `my.cnf` file instead.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`移除my.cnf`：`my.cnf`是MySQL用来配置数据库服务操作的主要配置文件。当MariaDB首次安装时，它会创建一个指向其他配置文件的`my.cnf`符号链接。我们不希望出现这种行为，因此我们将使用文件模块删除默认的`my.cnf`文件，并将状态值设置为`absent`。我们将使用自己的`my.cnf`文件。'
- en: '`Install the MySQL Configuration File`: Now that the default `my.cnf` symlink
    has been removed, we can call the template module to place a new `my.cnf` file
    in its place. The `templates` module works by leveraging the local `templates`
    directory and looking for a file that matches the name of the source file we are
    specifying, `my.cnf.j2`. Templates use the Jinja2 templating language to put the
    new configuration in place and replace any variables sourced from the role. The
    location for the new configuration file will be `/etc/MySQL/my.cnf` and will have
    the appropriate permissions applied to it.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`安装MySQL配置文件`：现在默认的`my.cnf`符号链接已被移除，我们可以调用模板模块，将新的`my.cnf`文件放置在其位置。`templates`模块通过利用本地`templates`目录，并查找与我们指定的源文件名称`my.cnf.j2`匹配的文件来工作。模板使用Jinja2模板语言来放置新的配置，并替换任何来自角色的变量。新配置文件的位置将是`/etc/MySQL/my.cnf`，并会应用适当的权限。'
- en: '`Initialize the Database`: The final task in this playbook is known as an `include`
    task. Include statements, logically enough, include other playbook YAML files
    for execution. Usually, include statements are a great way to break down your
    playbooks into logically grouped blocks of similar tasks. In this scenario, we
    want to include the playbook `initialize_database.yml`, based on the logical condition
    that the variable `initialize_database` is set to true. In other programming languages
    constructs such as *if, else...if*, and *else* exist, to indicate logical evaluations.
    Ansible handles this using the keyword `when` to list the conditions for *when*
    an action will occur. In this case, *when* the variable `initialize_database`
    is true, the playbook `initialize_database.yml` will be executed. If the variable
    is set to false, it will skip those tasks.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`初始化数据库`：该剧本中的最终任务被称为`include`任务。`include`语句，顾名思义，会包含其他剧本的YAML文件以供执行。通常，`include`语句是将剧本分解成逻辑上分组的相似任务块的好方法。在此场景中，我们希望根据逻辑条件（即变量`initialize_database`设置为true），包含剧本`initialize_database.yml`。在其他编程语言中，存在如*if,
    else...if*和*else*的结构，用于表示逻辑评估。Ansible通过关键字`when`来处理此类逻辑，列出执行某个操作的条件。在本例中，当变量`initialize_database`为true时，将执行剧本`initialize_database.yml`；如果变量为false，则跳过这些任务。'
- en: 'Now that we have a good understanding of what the tasks inside of the `main.yml`
    playbook are running, let''s take a look at the tasks inside of the `initialize_database.yml`
    playbook to see what will happen if the `initialize_database` variable evaluates
    to true:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地理解了`main.yml`剧本中的任务执行内容，让我们来看一下`initialize_database.yml`剧本中的任务，看看当`initialize_database`变量评估为true时会发生什么：
- en: tasks/initialize_database.yml
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tasks/initialize_database.yml
- en: This file is located in `roles/mariadb_role/tasks/initialize_database.yml`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件位于`roles/mariadb_role/tasks/initialize_database.yml`。
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Task breakdown (initialize_database.yml)
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务细分（initialize_database.yml）
- en: '`Temporarily Start MariaDB Server`: By default, when MariaDB is first installed,
    there are no databases created and no users have access to the database. In some
    cases, we may want to spin up a vanilla MariaDB server and have an external user
    or tool create the default databases and access credentials. However, there may
    also be an equal number of circumstances in which we might need to create database
    instances that come with built-in databases and user credentials. In order to
    create these defaults, we will first need to start the MySQL server so that it
    can be accessed from the command line. To start the server temporarily, we will
    call the `shell` module, which evaluates shell commands in a very similar manner,
    as if you were typing them on a Bash prompt. We will run the command `mysqld`,
    specifying the user to run as `mysql`, and force the server to run in the background
    using the ampersand indicator (`&`). The MySQL server will continue to run at
    this point until the build has completed and the container has been shut down.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`临时启动MariaDB服务器`：默认情况下，当MariaDB首次安装时，未创建任何数据库，且没有用户访问数据库。在某些情况下，我们可能希望启动一个干净的MariaDB服务器，并让外部用户或工具创建默认的数据库和访问凭据。然而，也可能有相同数量的情况，我们需要创建带有内置数据库和用户凭据的数据库实例。为了创建这些默认项，我们首先需要启动MySQL服务器，以便能够通过命令行访问它。为了临时启动服务器，我们将调用`shell`模块，该模块以类似于在Bash提示符下输入命令的方式执行shell命令。我们将运行命令`mysqld`，指定以`mysql`用户身份运行，并使用符号`&`强制服务器在后台运行。此时，MySQL服务器将继续运行，直到构建完成并且容器被关闭。'
- en: '`Create Initial Accounts`: The create initial accounts step similarly calls
    the shell module in order to leverage the MySQL command-line client. The `-e`
    flag allows us to pass in executable SQL commands, which will be evaluated by
    the server. We will use this particular command to create a default username and
    password that we can use to log in to the database. The default credentials will
    be sourced from our variables, hence the double curly braces.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建初始账户`：创建初始账户的步骤类似地调用了shell模块，以便利用MySQL命令行客户端。`-e`标志允许我们传入可执行的SQL命令，这些命令将由服务器进行评估。我们将使用此命令来创建一个默认的用户名和密码，用于登录数据库。默认凭据将从我们的变量中获取，因此使用了双大括号。'
- en: '`Grant Privileges to New Account`: Using the `shell` module again, we can call
    the MySQL client to grant privileges on the new account we created previously.
    In this example, we will grant all privileges, connecting from any network interface
    to have access to this MySQL server.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`授予新账户权限`：再次使用`shell`模块，我们可以调用MySQL客户端，授予我们之前创建的新账户权限。在此示例中，我们将授予所有权限，允许从任何网络接口连接并访问该MySQL服务器。'
- en: '`Create Default Databases`: Using our iteration or looping operator `with_items`,
    we can pass in a list of databases we want the MySQL client to create. In our
    `defaults/main.yml` file, we have specified the databases variable as an array
    or list of items. Ansible will identify the fact that our databases variable is
    actually a list of strings and iterate over that. The result is that any number
    of databases we specify as a list item of the databases variable will be iterated
    over and created in our MySQL container.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建默认数据库`：通过使用我们的迭代或循环操作符`with_items`，我们可以传入一个我们希望MySQL客户端创建的数据库列表。在我们的`defaults/main.yml`文件中，我们将数据库变量指定为一个数组或项列表。Ansible将识别我们的数据库变量实际上是一个字符串列表，并对其进行迭代。结果是，任何我们指定为数据库变量列表项的数据库都将被迭代并创建在我们的MySQL容器中。'
- en: '`Flush Privileges`: One final call to the shell module will allow us to execute
    the SQL command, `FLUSH PRIVILEGES`, which allows the new user accounts to take
    effect in the database. After this command executes, the container build will
    have finished, signaling Ansible Container to shut down the intermediate container
    and commit the final changes to the container we just finished building.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`刷新权限`：最后一次调用shell模块将允许我们执行SQL命令`FLUSH PRIVILEGES`，使新用户账户在数据库中生效。此命令执行完毕后，容器构建将完成，通知Ansible
    Container关闭中间容器，并将最终更改提交到我们刚刚构建的容器中。'
- en: 'Now that we have had a look inside the `tasks` directory and learned about
    how the role executes tasks, let''s look inside of the `templates/` directory
    to learn about the templated configuration files we are generating and passing
    into the container. You will observe that, in the `roles` templates directory,
    there is one file: `my.cnf.j2`. This is the template for `my.cnf` file that we
    want Ansible to compile and pass into the container during the build process.
    It is a best practice to always name your Ansible template file after the destination
    filename with the `.j2` extension. This indicates the file is a Jinja2 template
    and contains variables and Jinja2 logic for Ansible to evaluate.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了`tasks`目录并了解了角色如何执行任务，接下来我们看看`templates/`目录，了解我们正在生成并传递到容器中的模板化配置文件。你会发现，在`roles`的templates目录中，有一个文件：`my.cnf.j2`。这是我们希望Ansible在构建过程中编译并传递到容器中的`my.cnf`文件的模板。最佳实践是始终将你的Ansible模板文件命名为目标文件名，并使用`.j2`扩展名。这表示该文件是一个Jinja2模板，包含变量和Jinja2逻辑，供Ansible进行评估。
- en: Jinja2 is a powerful templating language that can do some pretty neat stuff
    in your projects. Although not strictly required, having a working understanding
    of Jinja2 can help you a lot in your Ansible development. You can read more about
    the Jinja2 language at the official website:  [http://jinja.pocoo.org/.](http://jinja.pocoo.org/)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2是一个功能强大的模板语言，可以在你的项目中做很多很酷的事情。虽然不是严格要求，但对Jinja2有一定了解会对你的Ansible开发大有帮助。你可以在官方网站上了解更多关于Jinja2语言的信息：[http://jinja.pocoo.org/.](http://jinja.pocoo.org/)
- en: 'The following is the content of the `my.cnf.j2` file in the `templates` directory:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`templates`目录中`my.cnf.j2`文件的内容：
- en: templates/my.cnf.j2
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: templates/my.cnf.j2
- en: 'This file is located in `roles/mariadb_role/templates/my.cnf.j2`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件位于`roles/mariadb_role/templates/my.cnf.j2`：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that, in the first line of the file, we are spelling out to the user
    in a comment block that the file is an *Ansible Container-Generated MariaDB Config
    File*. If you have experience of connecting into remote servers to troubleshoot
    problems, you will know how handy it is to know exactly where the files come from,
    where the values are populated from, and which configuration management tool is
    responsible for putting those files there. While not strictly required, and surely
    as a matter of taste, I like to place such banners on files that Ansible touches.
    This way, someone, later on, will know exactly how this container came to be in
    this state.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在文件的第一行，我们通过注释块明确告诉用户该文件是*Ansible容器生成的MariaDB配置文件*。如果你有连接远程服务器并排查问题的经验，你会知道确切了解文件来源、值的来源以及哪个配置管理工具负责将这些文件放到那里的重要性。虽然这不是严格要求的，当然也是个人喜好的问题，但我喜欢在Ansible触及的文件上添加这样的标语。这样，稍后有人查看时，会清楚地知道这个容器是如何以这种状态创建的。
- en: The next thing you will notice is that the last four lines of the configuration
    file have values set to double curly braces with the name of the configuration
    file key in between them. As we discussed earlier, the double curly braces indicate
    Jinja2 variable parameters. When Ansible evaluates this template prior to installing
    it in its destination inside the container, Ansible will parse the file for all
    Jinja2 blocks and execute the instructions it reads to bring the template into
    the desired state. This could mean populating the values of variables, evaluating
    logical conditions, or even sourcing environment information that the template
    requires. In this case, Ansible will see the double curly braces and replace them
    with the values defined for those variables. By changing or overriding the variables,
    Ansible makes it quite easy to change the way containers and applications function.
    Also, notice that the names of the variables match the configuration option they
    are modifying. Variable names are purely up to the developer, and as such, the
    developer may choose what they want the names to be. However, it is usually a
    best practice to use descriptive variable names so that it is very clear to the
    user what settings they are overriding or modifying.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你会注意到，配置文件的最后四行的值被设置为双大括号，其中夹着配置文件的键名。如我们之前讨论的，双大括号表示 Jinja2 变量参数。当 Ansible
    在将模板安装到容器中的目标位置之前进行评估时，Ansible 会解析文件中的所有 Jinja2 块，并执行读取到的指令，将模板带到所需的状态。这可能意味着填充变量的值、评估逻辑条件，甚至获取模板所需的环境信息。在这种情况下，Ansible
    会看到双大括号并用这些变量的定义值替换它们。通过修改或覆盖变量，Ansible 使得更改容器和应用程序的功能变得非常容易。此外，请注意，变量的名称与它们修改的配置选项相匹配。变量名完全由开发人员决定，因此开发人员可以自由选择变量名。然而，通常的最佳实践是使用描述性强的变量名，以便用户清楚地了解他们正在覆盖或修改哪些设置。
- en: 'Reading through these role files, it is probably very clear to you that variables
    have a lot to do with how Ansible runs, how templates are populated, and even
    how tasks are executed and controlled. Let''s now take a look at how variables
    are defined in roles and how we can leverage variables to make roles more flexible
    and enable their reuse. As stated before, role variables can be stored in two
    places: the `defaults/` directory or the `vars/` directory. As the developer,
    you can choose which location (or both locations) you want to store your variables
    in. The only difference is the variable precedence in which the variables are
    evaluated in. The variables stored in `defaults/` are the easiest to override.
    Variables stored in `vars/` have a slightly lower precedence and thus are more
    difficult to override. In this example, I have opted to store all variables in
    the `defaults/` directory in the `main.yml` file. Let''s see what that file looks
    like:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这些角色文件时，你可能已经很清楚，变量与 Ansible 的运行方式、模板的填充方式，甚至任务的执行和控制方式都有很大关系。现在让我们看看变量是如何在角色中定义的，以及我们如何利用变量使角色更加灵活，并使其能够复用。如前所述，角色变量可以存储在两个地方：`defaults/`
    目录或 `vars/` 目录。作为开发人员，你可以选择将变量存储在哪个位置（或者两个位置）。唯一的区别在于变量的优先级顺序，这决定了变量的评估顺序。存储在
    `defaults/` 目录中的变量最容易被覆盖，而存储在 `vars/` 目录中的变量优先级稍低，因此更难覆盖。在这个例子中，我选择将所有变量存储在 `defaults/`
    目录中的 `main.yml` 文件里。让我们看看这个文件长什么样：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, you can see that these are all the variables we have seen before, referenced
    in the role tasks as well as the templated file for `my.cnf`. Variable YAML files
    are essentially just static YAML files that use exactly the same YAML constructs
    we explored in the beginning of the chapter. For example, this file is, by default,
    initializing the database by setting the `initialize_database` variable to the
    Boolean value of true. We also can see that the default credentials that will
    be created in the database are set to the strings `root` and `password`, as well
    as a list of test databases that will get created during the initialize database
    tasks. Finally, towards the bottom, we have a grouping of variables that define
    the values that will be incorporated into the template. If we build the role as-is,
    without providing any variable overrides, we will get a container built with exactly
    these specifications. However, this book would not be complete without exploring
    exactly how we can go about customizing the role we just wrote!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到这些都是我们之前见过的变量，它们在角色任务以及 `my.cnf` 模板文件中都有引用。变量 YAML 文件本质上只是使用我们在章节开始时探索的相同
    YAML 结构的静态 YAML 文件。例如，默认情况下，该文件通过将 `initialize_database` 变量设置为布尔值 `true` 来初始化数据库。我们还可以看到，数据库中将创建的默认凭据设置为字符串
    `root` 和 `password`，以及在初始化数据库任务期间将创建的测试数据库列表。最后，在文件底部，我们有一组变量，用于定义将被纳入模板的值。如果我们按原样构建角色，而不提供任何变量覆盖，我们将得到一个完全符合这些规格的容器。然而，如果不探索如何定制我们刚刚编写的角色，这本书将不完整！
- en: Building the container-enabled role
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器启用角色
- en: 'Before we begin customizing our role, let''s first build the role and demonstrate
    the default functionality using the default variables we specified. Let''s go
    ahead and return to our Ansible Container workflow and execute `ansible-container
    build`, followed by the `ansible-container run` commands from the `root` directory
    of our project:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始定制角色之前，让我们先构建该角色并演示使用我们指定的默认变量的默认功能。我们继续回到我们的 Ansible 容器工作流程，执行 `ansible-container
    build`，然后在项目的 `root` 目录下执行 `ansible-container run` 命令：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You may note from the build output that Ansible is taking the list items we
    provided in the task using the `with_items` iteration operator and exactly building
    our image, bringing it into the desired state based on the variables we have provided
    in our role, which for now, are the default variables.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到从构建输出中，Ansible 正在使用 `with_items` 迭代运算符将我们在任务中提供的列表项准确地构建成镜像，并根据我们在角色中提供的变量将其带入所需状态，暂时来说，这些是默认变量。
- en: 'Let''s run our project and attempt to access the MySQL services:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的项目并尝试访问 MySQL 服务：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Executing `docker ps -a` will show that our container is running with port
    `3306` exposed on the host:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `docker ps -a` 会显示我们的容器正在运行，并且在主机上暴露了端口 `3306`：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To test to ensure everything is working, we can download and install the `mariadb-client`
    package, or any MySQL client of your choosing:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试确保一切正常，我们可以下载并安装 `mariadb-client` 包，或者选择任何你喜欢的 MySQL 客户端：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once the MariaDB client has been installed, you can use the following command
    to connect to the MariaDB container exposed on the localhost of the Vagrant VM.
    If you''re unfamiliar with the MySQL client, remember that all flags passed into
    the client do not have spaces after them. It looks a little strange, but it should
    drop you into a MySQL console:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 MariaDB 客户端后，你可以使用以下命令连接到暴露在 Vagrant 虚拟机 localhost 上的 MariaDB 容器。如果你不熟悉 MySQL
    客户端，请记住，传递给客户端的所有标志后面不带空格。这看起来有点奇怪，但它应该会把你带入 MySQL 控制台：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s run the `show databases;` command to see if the test databases we have
    specified in our default variables are being created:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 `show databases;` 命令，看看我们在默认变量中指定的测试数据库是否已经创建：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It appears as though everything was created properly and is working as expected.
    When you are done working in this session, you can exit from the MySQL CLI using
    the `exit` command. Use `ansible-container destroy` to reset your environment.
    Let's make things interesting by customizing our role and sourcing external variable
    values.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都已经正确创建并按预期工作。当你完成此会话工作时，可以使用 `exit` 命令退出 MySQL CLI。使用 `ansible-container
    destroy` 来重置你的环境。让我们通过定制我们的角色并引入外部变量值来让事情变得有趣。
- en: Customizing the container-enabled role
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制容器启用角色
- en: As we saw in the previous chapter, it is very easy to abstract away from changes
    in Ansible Container projects by adding variables directly to the project `container.yml`
    file and rebuilding the project. This provides the added convenience of having
    all of our configuration changes in a single location and functioning effectively
    as a single point of truth. This might be sufficient for some use cases, but what
    about circumstances in which one would need to provide containers configured differently
    to support multiple environments or locations, such as the development, testing,
    QA, and production environments? You could simply update the `container.yml` file
    and build separate images for these scenarios. However, Ansible Container provides
    us with a better way to handle this by providing the ability to source external
    variable files. A part of the `ansible-container` parent command is the `--var-files`
    flag, which provides the option to source an external YAML file for variable definitions.
    This provides us with an abstraction that allows separate builds to run and exist
    in parallel using different configuration options. This also allows us to customize
    our role using separate variable files for almost any circumstance that can be
    version-controlled along with our project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章看到的那样，通过将变量直接添加到项目的`container.yml`文件并重新构建项目，抽象掉 Ansible 容器项目中的变化非常简单。这提供了将所有配置更改集中在一个位置的额外便利，并有效地作为单一的真相来源。对于某些用例来说，这可能已经足够，但如果需要为不同的环境或位置（例如开发、测试、QA
    和生产环境）提供配置不同的容器呢？你可以简单地更新`container.yml`文件，并为这些场景构建不同的镜像。然而，Ansible Container
    提供了更好的处理方式，允许我们通过外部变量文件来管理这一切。`ansible-container`父命令的一部分是`--var-files`标志，它允许为变量定义提供外部
    YAML 文件的选项。这为我们提供了一个抽象，允许不同配置选项的独立构建并行运行。这还允许我们使用不同的变量文件来定制我们的角色，几乎可以针对任何能够与项目一起版本控制的情况。
- en: 'To enable this functionality, let''s create a directory in the root of our
    project (the same level as the project-specific `container.yml`) called `variable_files`.
    Inside of this directory, we will create three separate files: `dev.yml`, `test.yml`,
    and `prod.yml` with slightly different configuration options. The following are
    examples of these three files. Do enjoy my Star Trek references!'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用此功能，让我们在项目根目录（与项目特定的`container.yml`同级）创建一个名为`variable_files`的目录。在此目录内，我们将创建三个独立的文件：`dev.yml`、`test.yml`和`prod.yml`，它们具有略有不同的配置选项。以下是这三个文件的示例。希望你喜欢我的《星际迷航》引用！
- en: Before we begin, it would be a good idea to perform an `ansible-container destroy` action
    before rebuilding the containers using different variables. This way, you can
    see exactly what is being changed during the build process.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，最好先执行`ansible-container destroy`操作，然后使用不同的变量重新构建容器。这样，你可以清楚地看到在构建过程中究竟发生了什么变化。
- en: 'In the development, the primary user of our database will be Yeoman Rand. She
    will be primarily concerned with Starfleet data:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发环境中，我们数据库的主要用户将是叶曼·兰德。她将主要关注星际舰队数据：
- en: variable_files/dev.yml
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: variable_files/dev.yml
- en: 'This file is located in `<project_root>/variable_files/dev.yml`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件位于`<project_root>/variable_files/dev.yml`：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In `System Test`, Mr. Spock will be the primary user of our database. He has
    slightly more interest in data related to Planet Vulcan, ship ordinances, shuttlecraft,
    as well as federation data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`系统测试`中，斯波克先生将是我们数据库的主要用户。他对与火山星、舰船条例、穿梭机以及联邦数据相关的数据更感兴趣。
- en: variable_files/test.yml
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: variable_files/test.yml
- en: 'This is located in `<project_root>/variable_files/test.yml`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件位于`<project_root>/variable_files/test.yml`：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: variable_files/prod.yml
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: variable_files/prod.yml
- en: 'In production, Captain Kirk is going to need to store vastly different data
    than the other crew members. We will need to enhance our MySQL configuration from
    a bit to support the added overhead of storing the Captain''s Logs, Enterprise
    data, as well as federation mandates. This file is located  in: `<project_root>/variable_files/prod.yml`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，柯克舰长将需要存储与其他船员完全不同的数据。我们需要稍微增强我们的 MySQL 配置，以支持存储舰长日志、企业数据以及联邦指令所增加的负载。该文件位于：`<project_root>/variable_files/prod.yml`：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You may also notice that not all variables are being overridden in every example
    shown here. In cases where variables are not being overridden by the sourced files,
    Ansible will take the values present in `defaults/main.yml` in the role. It is
    important that your role defaults provide values for all variables, as variables
    referenced without values will break the build process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到，并不是所有的变量在这里显示的每个示例中都被覆盖。在变量没有被源文件覆盖的情况下，Ansible 将使用角色中的 `defaults/main.yml`
    中的值。重要的是，您的角色默认值必须为所有变量提供值，因为没有值的变量会导致构建过程失败。
- en: Variable files can be named anything you want. Since we are sourcing these files
    during the build process, and they are not something that Ansible Container will
    automatically discover, the naming convention is entirely up to you.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 变量文件的名称可以是你想要的任何名称。由于我们在构建过程中引用这些文件，并且它们不是 Ansible Container 会自动发现的文件，所以命名规则完全由你决定。
- en: 'We can build containers based on any of these variables by executing our `ansible-container
    build` command and adding the `--vars-files` flag as a parameter of the `ansible-container`
    command. Remember, we always run `build` commands in the same directory as the
    project-specific `container.yml` file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行 `ansible-container build` 命令，并将 `--vars-files` 标志作为 `ansible-container`
    命令的参数来基于这些变量中的任何一个构建容器。记住，我们始终在与项目特定的 `container.yml` 文件位于同一目录下运行 `build` 命令：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'During the build, you should notice that many of the tasks look slightly different
    based on the variables we are providing. For example, when sourcing development
    variables, you will see that only one database gets created: `starfleet_data`.
    This is an indication that the new variables have been sourced and are populated
    correctly in the build process. Let''s perform an `ansible-container run` of the
    new version of our container and try to log in with the same credentials as before:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，你应该注意到，根据我们提供的变量，许多任务的执行方式略有不同。例如，当引用开发变量时，你会看到只创建了一个数据库：`starfleet_data`。这表明新的变量已经被正确引用并在构建过程中正确填充。现在让我们执行一个新的容器版本的
    `ansible-container run`，并尝试使用与之前相同的凭证登录：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, to log in using the MariaDB client:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要使用 MariaDB 客户端登录：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It is very clear to see that the default credentials we have in the role defaults
    are no longer working. Let''s try again using the credentials we specified in
    our development variable file for the Yeoman Rand user:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们在角色默认值中设置的默认凭证不再有效。让我们再试一次，使用我们在开发变量文件中为 Yeoman Rand 用户指定的凭证：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It looks like our new container is working using the sourced variable files
    for development. Let''s run the `show databases;` command to make sure the database
    was properly created and exists:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的新容器使用开发环境的源变量文件工作正常。让我们运行 `show databases;` 命令，确保数据库已正确创建并存在：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, the database `starfleet_data` exists alongside the default
    MariaDB databases such as `information_schema`, `MySQL`, and `performance_schema`.
    It appears that the container was built properly and is ready for deployment in
    our development environment (for the purposes of this example). We can now push
    the image to a container registry of our choosing. For this example, I will add
    Docker Hub to the `registries` section of our project-specific `container.yml`
    file, specifying the namespace as my Docker Hub username (remember to remove the
    curly braces after the start of the registries stanza). Once that file is saved,
    let''s tag the image as `dev` and `push` it up to our Docker Hub repository so
    that we have a build image artifact that we can use to deploy our application:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，数据库 `starfleet_data` 存在，并与 MariaDB 默认的数据库（如 `information_schema`、`MySQL`
    和 `performance_schema`）一起显示。这表明容器已正确构建，并且已准备好在我们的开发环境中部署（以本示例为目的）。现在我们可以将镜像推送到我们选择的容器注册表。在这个例子中，我将在项目特定的
    `container.yml` 文件的 `registries` 部分添加 Docker Hub，指定命名空间为我的 Docker Hub 用户名（记得在
    registries 段落开始时删除大括号）。保存该文件后，让我们将镜像标记为 `dev` 并将其推送到我们的 Docker Hub 仓库，以便我们有一个可以用来部署应用程序的构建镜像工件：
- en: container.yml
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: container.yml
- en: 'The project-specific `container.yml` file is located in the `root` directory
    of your project:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 项目特定的 `container.yml` 文件位于项目的 `root` 目录中：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Push the image using the `--push-to` flag:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--push-to` 标志推送镜像：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It's not completely necessary to configure Docker Hub as the image registry
    in the `container.yml` file, as Ansible Container will default to using Docker
    Hub. However, I like to make sure I don't accidentally push images to the wrong
    registries, so it is best practice to always provide the image repository in the
    `container.yml` file and always push using the `-–push-to` flag command to specify
    the correct repository.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`container.yml`文件中配置Docker Hub作为镜像仓库并不是完全必要的，因为Ansible Container默认会使用Docker
    Hub。不过，我喜欢确保不会不小心将镜像推送到错误的仓库，因此最佳实践是始终在`container.yml`文件中提供镜像仓库，并始终使用`-–push-to`标志命令来指定正确的仓库进行推送。
- en: 'We can do the same build process for our `test.yml` configuration as well as
    our `prod.yml` configurations and push those up to the Docker Hub repository (remembering
    to do a `destroy` between builds). Notice that, while uploading a different version
    of the image, Docker will automatically identify layers of the image that is identical
    to the previously uploaded version. In this case, Docker will help you to save
    bandwidth and resources by not pushing layers that are identical, but only the
    layers that have changed, as shown in the following. Note the `Layer already exists`
    lines:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对`test.yml`配置文件以及`prod.yml`配置文件执行相同的构建过程，并将它们推送到Docker Hub仓库（记得在构建之间执行`destroy`操作）。注意，在上传不同版本的镜像时，Docker会自动识别与先前上传版本相同的镜像层。在这种情况下，Docker会通过不推送相同的镜像层，仅推送已更改的层，帮助你节省带宽和资源，如下所示。请注意`Layer
    already exists`行：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We should now have three different container image artifacts available to download.
    These images are available to download and deploy in our imaginary development
    lab, system test lab, as well as our production environment. These container images
    are guaranteed to run in these environments in the exact same way as they do in
    our local workstations. At this point, we can do a final exercise and run all
    three of these containers on different ports in order to simulate these containers
    running in different environments with different configurations. To quickly demonstrate
    this, we will use the native `docker run` command to specify our tagged image
    and the ports we want the container service to use; we also specify that our service
    should run in the background using the `-d` flag. Notice that each instance of
    our container that we are creating uses the `dev`, `test`, and `prod` tags as
    well as our user repository address. In my case, it is `aric49`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该有三个不同的容器镜像可供下载。这些镜像可以在我们假想的开发实验室、系统测试实验室以及生产环境中下载和部署。这些容器镜像保证在这些环境中以与我们本地工作站完全相同的方式运行。此时，我们可以进行最终的操作，并在不同的端口上运行这三个容器，以模拟这些容器在不同环境中、使用不同配置的运行方式。为了快速演示，我们将使用本地的`docker
    run`命令来指定我们打标签的镜像以及容器服务要使用的端口；我们还指定我们的服务应该使用`-d`标志在后台运行。请注意，我们正在创建的每个容器实例都使用`dev`、`test`和`prod`标签以及我们的用户仓库地址。在我的例子中是`aric49`：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Testing the container functionality is exactly the same process as before.
    We can use the MariaDB client to log into an instance of our containers. This
    time, however, we will need to specify which port our service is listening on
    since all three instances cannot listen on the default port `3306` on the host
    networking side. If we wanted to log into our production container, we could specify
    the credentials for Captain Kirk using port `33010` and the `ussenterprise` password:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 测试容器功能的过程与之前完全相同。我们可以使用MariaDB客户端登录到我们容器的一个实例。不过这次，我们需要指定我们的服务监听的端口，因为所有三个实例不能在主机网络端口`3306`上监听。如果我们想登录到生产容器，我们可以使用`33010`端口和`ussenterprise`密码为Captain
    Kirk指定凭据：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Leveraging the same Ansible Container project and container-enabled role, we
    were able to use the Ansible Container default primitives in order to build containers
    with a variety of configurations that are available for use under different circumstances
    and use cases. This approach enables us to be certain that the build process will
    remain exactly the same throughout future build iterations, but we will have the
    flexibility to supply new configuration values into our role without modifying
    the code we wrote previously. Using container tagging, a snapshot of container
    configurations can be captured and shared with other users. We now have a tremendously
    useful and repeatable pipeline to ensure that future versions of our application
    containers have traceability back to the source roles used to generate them. Even
    if the container images are accidentally deleted from our image registry, we can
    easily build and rebuild our containers at any time, since all configuration in
    our containers is declared as code using the Ansible playbook language. If you
    have worked in an IT-related DevOps or a systems administrator position for very
    long, you will understand how valuable it is to have this level of insight into
    your infrastructure.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 利用相同的 Ansible 容器项目和容器启用角色，我们能够使用 Ansible 容器默认的原语构建多种配置的容器，这些容器可以在不同的环境和用例中使用。这种方法使我们能够确保构建过程在未来的所有构建迭代中保持完全相同，但我们也能灵活地为我们的角色提供新的配置值，而无需修改之前编写的代码。通过使用容器标签，可以捕获容器配置的快照并与其他用户共享。现在，我们拥有了一个极其有用且可重复的流水线，确保未来版本的应用程序容器可以追溯到用于生成它们的源角色。即使容器镜像不小心从镜像注册中心被删除，我们也可以随时轻松构建和重建我们的容器，因为所有容器中的配置都是以代码形式声明的，使用的是
    Ansible playbook 语言。如果你曾在 IT 相关的 DevOps 或系统管理员岗位工作过很长时间，你会明白，拥有这种级别的基础设施洞察力是多么宝贵。
- en: References
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: '**Official YAML Standard Guide**: [http://yaml.org](http://yaml.org)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**官方 YAML 标准指南**: [http://yaml.org](http://yaml.org)'
- en: '**Ansible Module Index**: [http://docs.ansible.com/ansible/latest/modules_by_category.html](http://docs.ansible.com/ansible/latest/modules_by_category.html)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ansible 模块索引**: [http://docs.ansible.com/ansible/latest/modules_by_category.html](http://docs.ansible.com/ansible/latest/modules_by_category.html)'
- en: '**Ansible Playbook Specification**: [http://docs.ansible.com/ansible/latest/playbooks.html](http://docs.ansible.com/ansible/latest/playbooks.html)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ansible Playbook 规范**: [http://docs.ansible.com/ansible/latest/playbooks.html](http://docs.ansible.com/ansible/latest/playbooks.html)'
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Over the course of this chapter, we looked at how roles not only enable reuse
    in Ansible Container but are actually the bread and butter of what makes Ansible
    Container a powerful tool for building and managing containers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了角色如何不仅使 Ansible 容器中的重用成为可能，而且实际上是 Ansible 容器成为一个强大工具的核心，帮助构建和管理容器。
- en: We first looked at how we can use the Ansible Galaxy command-line tools to create
    the shell for a container-enabled role, all necessary directories, and default
    YAML files from which we can build our role. From there, we wrote a custom role
    that builds a MariaDB container using a sane set of default configuration options.
    Finally, we developed an abstraction layer on top of our role by passing in custom
    variable configuration options, from which we can customize our container project
    without modifying any code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先了解了如何使用 Ansible Galaxy 命令行工具创建容器启用角色的基础框架，包括所有必需的目录和默认的 YAML 文件，从中我们可以构建我们的角色。接着，我们编写了一个自定义角色，使用合理的默认配置选项构建
    MariaDB 容器。最后，我们在角色上方开发了一个抽象层，通过传递自定义的变量配置选项，使我们能够在不修改任何代码的情况下定制我们的容器项目。
- en: I hope this chapter has effectively demonstrated the raw power available to
    you using the Ansible Container project. Up until this point, I think it is easy
    to make the assumption that it is easier to build container images using Dockerfiles
    and not worrying about the added overhead of Ansible Container. I hope you will
    now understand that the benefits of using Ansible Container far outweigh the slight
    layer of additional complexity required. Using Ansible Container, you can create
    a powerful pipeline for building, running, testing, and pushing container images.
    By leveraging the easy-to-understand Ansible playbook syntax language, we have
    a basis from which we can start building a modern, agile, containerized infrastructure
    that gives us the ability to deploy changes quickly and truly begin to embrace
    the promise of genuinely modular infrastructure.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望本章能够有效展示使用Ansible Container项目所能提供的强大功能。到目前为止，我认为很容易做出假设，认为使用Dockerfiles构建容器镜像会更简单，而不必担心Ansible
    Container带来的额外开销。希望你现在能够理解，使用Ansible Container的好处远远超过了所需的少许额外复杂性。通过使用Ansible Container，你可以创建一个强大的管道，用于构建、运行、测试和推送容器镜像。通过利用易于理解的Ansible
    playbook语法语言，我们有了一个基础，可以开始构建现代化、敏捷的容器化基础设施，这使得我们能够快速部署变更，并真正开始拥抱真正模块化基础设施的承诺。
- en: Now that we understand how to build and deploy truly custom containers we can
    start to look at Kubernetes, an open source framework for automating the deployment,
    orchestration, and management of containers at scale.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了如何构建和部署真正自定义的容器，我们可以开始了解Kubernetes，一个开源框架，用于自动化容器的大规模部署、编排和管理。
