- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Playbooks and Roles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剧本与角色
- en: So far in this book, we have worked mostly with ad hoc Ansible commands for
    simplicity and to help you to understand the fundamentals. However, the lifeblood
    of Ansible is most certainly the playbook, which is a logical organization of
    tasks (think ad hoc commands) in a structure that creates a useful outcome. This
    might be to deploy a web server on a newly built virtual machine, or it might
    be to apply a security policy. It might even involve handling the whole build
    process for a virtual machine! The possibilities are endless. Ansible playbooks,
    as we have already covered, are designed to be simple to write and easy to read
    – they are intended to be self-documenting and, as such, will form a valuable
    part of your IT processes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书大部分内容使用的是简单的临时 Ansible 命令，以帮助你理解基础概念。然而，Ansible 的核心无疑是剧本，它是将任务（类似临时命令）按逻辑组织起来的结构，目的是产生有用的结果。比如，它可以部署一个
    Web 服务器到一个新建的虚拟机，或者应用安全策略，甚至可能涉及到整个虚拟机的构建过程！可能性是无穷的。正如我们之前讨论的，Ansible 剧本旨在简洁易写且易读——它们旨在自我文档化，因此，它们将成为你
    IT 流程中宝贵的一部分。
- en: In this chapter, we will explore playbooks in greater depth, from the basics
    of their creation to more advanced concepts such as running tasks in loops and
    blocks, performing conditional logic, and – perhaps one of the most important
    concepts for playbook organization and code reuse – Ansible roles. We will cover
    roles in more detail later, but just know that this is something you will want
    to use as much as possible when creating manageable playbook code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将更深入地探讨剧本，从剧本创建的基础知识到更高级的概念，例如在循环和块中运行任务、执行条件逻辑，以及——可能是剧本组织和代码复用中最重要的概念之一——Ansible
    角色。我们稍后会更详细地介绍角色，但请记住，这是你在创建可管理的剧本代码时希望尽可能多使用的功能。
- en: 'Specifically, in this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将特别讨论以下主题：
- en: Understanding the playbook framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解剧本框架
- en: Understanding roles – the playbook organizer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解角色——剧本的组织者
- en: Using conditions in your code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中使用条件
- en: Repeating tasks with loops
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环重复任务
- en: Grouping tasks using blocks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用块来分组任务
- en: Configuring play execution via strategies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过策略配置剧本执行
- en: Using `ansible-pull`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ansible-pull`
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [*Chapter 1*](B20846_01.xhtml#_idTextAnchor015), *Getting Started
    with Ansible*, and are using the most recent version available – the examples
    in this chapter were tested with Ansible 8.0 and `ansible-core` 2.15\. This chapter
    also assumes that you have at least one additional host to test against, and this
    should be Linux-based. Although we will give specific examples of hostnames in
    this chapter, you are free to substitute them with your own hostnames and/or IP
    addresses, and details of how to do this will be provided in the appropriate places.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你已经按照[*第一章*](B20846_01.xhtml#_idTextAnchor015)《与 Ansible 入门》的详细说明设置了控制主机，并且使用的是最新版本——本章中的示例在
    Ansible 8.0 和 `ansible-core` 2.15 上进行了测试。本章还假设你至少有一个额外的主机进行测试，且该主机应为基于 Linux 的。尽管本章将给出特定主机名的示例，你可以根据需要将其替换为自己的主机名和/或
    IP 地址，相关的替换方法将在适当的地方提供。
- en: 'The code bundle for this chapter is available here: [https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%204](https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%204).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包可以在此找到：[https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%204](https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%204)。
- en: Understanding the playbook framework
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解剧本框架
- en: A playbook allows you to manage multiple configurations and complex deployments
    on many machines simply and easily. This is one of the key benefits of using Ansible
    for the delivery of complex applications. With playbooks, you can organize your
    tasks in a logical structure, as tasks are (generally) executed in the order they
    are written, allowing you to have a good deal of control over your automation
    processes. With that said, it is possible to perform tasks asynchronously, so
    where tasks are not executed in sequence, we will highlight this. Our goal is
    that once you complete this chapter, you will understand the best practices to
    write your own Ansible playbooks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个playbook允许你在许多机器上简单轻松地管理多个配置和复杂的部署。这是使用Ansible进行复杂应用交付的关键优势之一。通过playbook，你可以以逻辑结构组织任务，因为任务（通常）按它们的书写顺序执行，从而让你对自动化过程有较高的控制度。话虽如此，仍然可以异步执行任务，因此如果任务不是按顺序执行的，我们将特别指出这一点。我们的目标是，在完成本章后，你将理解编写自己的Ansible
    playbook的最佳实践。
- en: 'Although YAML format is easy to read and write, it is very pedantic when it
    comes to spacing. For example, you cannot use tabs to set indentation even though
    on the screen a tab and four spaces might look identical – in YAML, they are not.
    We recommend that you adopt an editor with YAML support to aid you in writing
    your playbooks if you are doing this for the first time – perhaps Vim, Visual
    Studio Code, or Eclipse – as these will help you to ensure that your indentation
    is correct. To test the playbooks we develop in this chapter, we will create a
    variant of the inventory created in [*Chapter 3*](B20846_03.xhtml#_idTextAnchor158),
    *Defining Your Inventory* (unless stated otherwise):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然YAML格式易于阅读和编写，但在缩进方面要求非常严格。例如，尽管在屏幕上，制表符和四个空格看起来可能是相同的，但在YAML中它们并不相同。我们建议，如果你第一次编写playbook，可以采用支持YAML的编辑器来帮助你，可能是Vim、Visual
    Studio Code或Eclipse，因为这些编辑器会帮助你确保缩进正确。如果要测试我们在本章中开发的playbook，我们将创建一个变体的清单，基于[*第3章*](B20846_03.xhtml#_idTextAnchor158)，*定义你的清单*（除非另有说明）：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s dive right in and get started writing a playbook. In [*Chapter 2*](B20846_02.xhtml#_idTextAnchor099),
    *Understanding the Fundamentals of Ansible*, we covered some of the basic aspects
    of the YAML syntax and structure required to create a playbook, so we won’t repeat
    these in detail here. Rather, we will build on them to show you what playbook
    development is all about:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始编写playbook。在[*第2章*](B20846_02.xhtml#_idTextAnchor099)，*理解Ansible的基础知识*中，我们介绍了创建playbook所需的YAML语法和结构的基本知识，因此这里不再重复。相反，我们将在此基础上继续，展示playbook开发的核心内容：
- en: 'Create a simple playbook (called `myplaybook.yml`) to run on the hosts in the
    `frontends` host group defined in our inventory file. We can set the user that
    will access the hosts using the `remote_user` directive in the playbook, as demonstrated
    in the following (you can also use the `--user` switch on the command line, but
    as this chapter is about playbook development, we’ll ignore that for now):'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的playbook（称为`myplaybook.yml`），在我们清单文件中定义的`frontends`主机组上的主机上运行。我们可以使用playbook中的`remote_user`指令设置访问主机的用户，如下所示（你也可以在命令行上使用`--user`开关，但因为本章是关于playbook开发的，我们暂时忽略这个）：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add another task below the first, which will run the `ansible.builtin.shell`
    module (that will, in turn, run the `ls` command on the remote hosts). We’ll also
    add the `ignore_errors` directive to this task to ensure that our playbook doesn’t
    fail if the `ls` command fails (for example, if the directory we’re trying to
    list doesn’t exist). Be careful with the indentation and ensure that it matches
    that of the first part of the file:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个任务下方添加另一个任务，运行`ansible.builtin.shell`模块（该模块将依次在远程主机上运行`ls`命令）。我们还将向该任务添加`ignore_errors`指令，确保如果`ls`命令失败（例如，如果我们尝试列出的目录不存在），playbook不会失败。注意缩进，确保它与文件的第一部分匹配：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s see how our newly created playbook behaves when we run it with the following
    command:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看新创建的playbook在使用以下命令运行时的表现：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output from this playbook run should look something like the following
    screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该playbook运行的输出应类似于以下截图：
- en: '![Figure 4.1 – Demonstrating the execution of a playbook where errors are willfully
    ignored](img/B20846_04_001.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 演示执行一个故意忽略错误的playbook](img/B20846_04_001.jpg)'
- en: Figure 4.1 – Demonstrating the execution of a playbook where errors are willfully
    ignored
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 演示执行一个故意忽略错误的playbook
- en: From the output of the playbook run, you can see that our two tasks were executed
    in the order in which they were specified. We can see that the `ls` command failed
    because we tried to list a directory that did not exist, but the playbook did
    not register any `failed` tasks because we set `ignore_errors` to `true` for this
    task (and only this task).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从剧本运行的输出中，你可以看到我们的两个任务是按照指定的顺序执行的。我们可以看到`ls`命令失败了，因为我们尝试列出一个不存在的目录，但剧本并没有记录任何`failed`任务，因为我们为该任务（仅此任务）设置了`ignore_errors`为`true`。
- en: Most Ansible modules (with the exception of those that run user-defined commands
    such as `ansible.builtin.shell`, `ansible.builtin.command`, and `ansible.builtin.raw`)
    are coded to be idempotent – that is to say, if you run the same task twice, the
    results will be the same, and the task will not make the same change twice; if
    it detects that the action it is being requested to perform has been completed,
    then it does not perform it a second time. This, of course, is not possible for
    the aforementioned modules, as they could be used to perform just about any conceivable
    task – hence, how could the module know it was being performed twice?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Ansible模块（除了运行用户自定义命令的模块，如`ansible.builtin.shell`、`ansible.builtin.command`和`ansible.builtin.raw`）都被编写为幂等的——也就是说，如果你运行相同的任务两次，结果将是相同的，且该任务不会两次做出相同的更改；如果它检测到请求它执行的操作已经完成，则不会第二次执行。当然，这对前述模块来说不可能，因为它们可以用于执行几乎所有可以想象的任务——因此，模块怎么知道它被执行了两次呢？
- en: 'Every module returns a set of results, and among these results is the task
    status. You can see these summarized at the bottom of the preceding playbook run
    output, and their meaning is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都会返回一组结果，其中包括任务状态。你可以在前面剧本运行的输出底部看到这些结果的总结，它们的含义如下：
- en: '`ok`: The task ran successfully and no changes were made'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ok`：任务成功运行且没有进行任何更改'
- en: '`changed`: The task ran successfully and changes were made'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`changed`：任务成功运行且进行了更改'
- en: '`failed`: The task failed to run (but the host was reachable)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failed`：任务未能成功运行（但主机是可连接的）'
- en: '`unreachable`: The host was unreachable to run the task on'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unreachable`：无法连接主机以运行该任务'
- en: '`skipped`: This task was skipped'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipped`：此任务被跳过'
- en: '`ignored`: This task was ignored (for example, in the case of `ignore_errors`)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignored`：此任务被忽略（例如，在`ignore_errors`的情况下）'
- en: '`rescued`: We will see an example of this later when we look at blocks and
    rescue tasks'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rescued`：稍后我们将在查看块和恢复任务时看到一个例子'
- en: 'These statuses can be very useful – for example, if we have a task to deploy
    a new Apache configuration file from a template, we know we must restart the Apache
    service for the changes to be picked up. However, we only want to do this if the
    file was actually changed – if no changes were made, we don’t want to needlessly
    restart Apache, as it would interrupt people who might be using the service. Hence,
    we can use the `notify` action, which tells Ansible to call a `handler` when (and
    only when) the result from a task is `changed`. In brief, a handler is a special
    type of task that is run as a result of a `notify`. However, unlike Ansible playbook
    tasks, which are performed in sequence, handlers are all grouped together and
    run at the very end of the play. Also, they can be notified more than once but
    will only be run once regardless, again preventing needless service restarts.
    Consider the following playbook:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态非常有用——例如，如果我们有一个任务是从模板部署新的Apache配置文件，我们知道必须重启Apache服务才能使更改生效。然而，我们只希望在文件实际被更改的情况下才重启Apache——如果没有更改，我们不希望不必要地重启Apache，因为这会打断可能正在使用该服务的用户。因此，我们可以使用`notify`动作，这会告诉Ansible在任务结果为`changed`时（且仅在此时）调用`handler`。简而言之，处理程序是一种特殊类型的任务，它是在`notify`的结果下运行的。然而，与Ansible剧本任务按顺序执行不同，处理程序会被聚集在一起并在剧本结束时统一执行。此外，处理程序可以被通知多次，但无论如何只会执行一次，从而防止不必要的服务重启。考虑以下剧本：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To keep the output concise, I’ve turned off fact-gathering for this playbook
    (we won’t use facts in any of the tasks). I’m also running this on just one host
    again for conciseness, but you are welcome to expand the demo code as you wish.
    If we run this task for the first time, we will see the following results:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我已关闭了此剧本的事实收集（我们在任何任务中都不会使用事实）。我也再次仅在一台主机上运行，以简化演示，但你可以根据需要扩展演示代码。如果我们第一次运行这个任务，我们将看到以下结果：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note how the handler was run at the end, as the configuration file was updated.
    However, if we run this playbook a second time without making any changes to the
    template or configuration file, we will see something like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意处理程序是在最后执行的，因为配置文件已被更新。然而，如果我们第二次运行这个 Playbook 而不对模板或配置文件做任何更改，我们将看到如下内容：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This time, the handler was not called, as the result from the configuration
    task was `ok`. All handlers should have a globally unique name so that the `notify`
    action can call the correct handler. You can also call multiple handlers by setting
    a common name to use the `listen` directive – this way, you can call either the
    handler `name` or the `listen` string, as demonstrated in the following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，处理程序没有被调用，因为配置任务的结果是 `ok`。所有处理程序应该具有全局唯一的名称，以便 `notify` 动作能够调用正确的处理程序。你还可以通过设置公共名称并使用
    `listen` 指令来调用多个处理程序——这样，你可以通过 `name` 或 `listen` 字符串来调用处理程序，如以下示例所示：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We only have one task in the playbook, but when we run it, both handlers are
    called. Also, remember that we said earlier that `ansible.builtin.command` was
    among a set of modules that were a special case because they can’t detect whether
    a change has occurred – as a result, they always return the `changed` value, and
    so, in this demo playbook, the handlers will always be notified, even when we
    run it a second time:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Playbook 中只有一个任务，但当我们运行它时，两个处理程序都会被调用。此外，记住我们之前说过 `ansible.builtin.command`
    是一组特殊模块中的一部分，因为它们无法检测是否发生了变化——因此，它们始终返回 `changed` 值，在这个示范 Playbook 中，即使我们第二次运行，处理程序也会始终被通知：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These are some of the fundamentals that you need to know to start writing your
    own playbooks. With these under your belt, let’s run through a comparison of ad
    hoc commands and playbooks in the next section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你开始编写自己 Playbooks 所需了解的一些基础知识。掌握这些后，让我们在下一节中对比临时命令和 Playbooks。
- en: Comparing playbooks and ad hoc tasks
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较 Playbooks 和临时任务
- en: Ad hoc commands allow you to quickly create and execute one-off commands, without
    keeping any record of what was done (other than perhaps your shell history). These
    serve an important purpose and can be very valuable in getting small changes made
    quickly and for learning Ansible and its modules.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 临时命令允许你快速创建并执行一次性命令，而无需保留任何记录（除了可能的 shell 历史）。这些命令具有重要意义，对于快速完成小的变更，以及学习 Ansible
    和其模块非常有价值。
- en: Playbooks, by contrast, are logically organized sets of tasks (each could conceivably
    be an ad hoc command), put together in a sequence that performs one bigger action.
    The addition of conditional logic, error handling, and so on means that, very
    often, the benefits of playbooks outweigh the usefulness of ad hoc commands. In
    addition, provided you keep them organized, you will have copies of all previous
    playbooks that you run, so you will be able to refer back (if you ever need to)
    to see what you ran and when.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Playbooks 是逻辑组织的任务集（每个任务都可以是临时命令），按顺序组合在一起，执行一个更大的操作。添加条件逻辑、错误处理等功能意味着，通常情况下，Playbooks
    的优势要超过临时命令的实用性。此外，只要保持组织得当，你将拥有所有之前运行过的 Playbooks 的副本，因此你可以回溯（如果有需要的话）查看你曾执行过的操作和时间。
- en: Let’s develop a practical example – suppose you want to install Apache 2.4 on
    Ubuntu Server. There are a number of steps involved even if the default configuration
    is sufficient (which is unlikely, but for now, we’ll keep the example simple).
    If you were to perform the basic installation by hand, you would need to install
    the package, open up the firewall, and ensure the service is running (and runs
    at boot time).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来开发一个实际的例子——假设你想在 Ubuntu Server 上安装 Apache 2.4。即使默认配置足够（尽管这不太可能，但为了简化示例，我们暂时保持这个假设），也需要进行一些步骤。如果你手动进行基本安装，你需要安装软件包，打开防火墙，并确保服务正在运行（并且能够在启动时运行）。
- en: 'To perform these commands in the shell, you might do the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 shell 中执行这些命令，你可能会这样做：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, for each of these commands, there is an equivalent ad hoc Ansible command
    that you can run. We won’t go through all of them here in the interests of space;
    however, let’s say you want to restart the Apache service – if so, you could run
    an ad hoc command similar to the following (again, we will perform it only on
    one host for conciseness):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于这些命令，每个都可以通过一个等效的临时 Ansible 命令来执行。为了节省空间，我们不在这里详细介绍所有命令；不过，假设你想重启 Apache
    服务——如果是这样，你可以运行一个类似以下的临时命令（同样，为了简洁，我们只在一个主机上执行）：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When run successfully, you will see pages of shell output containing all of
    the variable data returned from running the `ansible.builtin.service` module.
    A snippet of the output from running this ad hoc command is shown here for you
    to check yours against – the key thing being that the command resulted in the
    `changed` status, meaning that it ran successfully and that the service was indeed
    restarted:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 成功运行后，你将看到页面上显示着shell输出，包含从运行`ansible.builtin.service`模块返回的所有变量数据。这里显示了一部分来自运行此临时命令的输出，以供你对照检查——关键在于该命令的执行结果是`changed`状态，意味着它成功运行并且服务确实被重启：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You, of course, could create and execute a series of ad hoc commands to replicate
    the multiple shell commands given previously and run them all individually. With
    a bit of cleverness, you should reduce this from four commands (for example, the
    Ansible `ansible.builtin.service` module can both enable a service at boot time
    and restart it in one ad hoc command). However, you would still ultimately end
    up with at least two or three ad hoc commands, and if you want to run these again
    later on another server, you will need to refer to your notes to figure out how
    you did it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以创建并执行一系列临时命令，以重复之前给出的多个shell命令，并分别运行它们。稍加巧妙，你可以将四个命令合并为更少的命令（例如，Ansible的`ansible.builtin.service`模块可以在一个临时命令中同时启用服务并重启它）。然而，你最终仍然会得到至少两三个临时命令，如果你希望稍后在另一台服务器上运行这些命令，你将需要查阅你的笔记以了解如何执行的。
- en: 'A playbook is, hence, a far more valuable way to approach this – not only will
    it perform all of the steps in one go but it will also give you a record of how
    it was done for you to refer to later on. There are multiple ways to do this,
    but consider the following as an example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，playbook是更有价值的解决方案——它不仅会一次性完成所有步骤，还会为你提供一个记录，供你以后参考。有多种方法可以做到这一点，但以下是一个示例：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, when you run this, you should see that all of our installation requirements
    have been completed by one fairly simple and easy-to-read playbook. There is a
    new concept here, loops, which we haven’t covered yet, but don’t worry – we will
    cover this later in the chapter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行此命令时，你应该会看到我们所有的安装要求都通过一个相当简单且易于阅读的playbook完成了。这里有一个新概念——循环（loops），我们尚未讲解，但不用担心——我们会在本章后续部分讲解它：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, this is far better to capture what was actually done and document
    it in a format that someone else can easily pick up. Even though we will cover
    loops later on in the book, it’s fairly easy to see from the preceding example
    how they might work. With this established, let’s proceed to the next section
    to look in more detail at a couple of terms we have used several times to ensure
    you are clear on their meanings – **plays** and **tasks**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种方式比实际完成的工作更加有效，并且可以以其他人容易理解的格式进行记录。尽管我们会在书中的后面部分讲解循环（loops），但从前面的例子中，你可以很容易地看出它们是如何工作的。明确这一点后，让我们进入下一部分，详细了解我们多次使用的几个术语，确保你能清楚它们的含义——**play**和**task**。
- en: Defining plays and tasks
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义plays和tasks
- en: So far, when we have worked with playbooks, we have created one single play
    per playbook (which logically is the minimum you can do). However, you can have
    more than one play in a playbook, and a “*play*” in Ansible terms is simply a
    set of tasks (and roles, handlers, and other Ansible facets) associated with a
    host (or group of hosts). A task is the smallest possible element of a play, and
    it is responsible for running a single module with a set of arguments to achieve
    a specific goal. Of course, in theory, this sounds quite complex, but when backed
    up by a practical example, it becomes quite simple to understand.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们处理playbooks时，每个playbook里我们只创建了一个play（这在逻辑上是最基本的做法）。然而，你可以在一个playbook中拥有多个play，而在Ansible术语中，一个“*play*”只是与某个主机（或一组主机）关联的一组tasks（以及角色、处理器和其他Ansible相关内容）。一个task是一个play中最小的元素，它负责运行一个单独的模块，并传递一组参数以实现特定目标。当然，理论上这听起来很复杂，但有了实际的例子，它会变得非常容易理解。
- en: If we refer to our example inventory, this describes a simple two-tier architecture
    (we’ve left out the database tier for now). Now, suppose we want to write a single
    playbook to configure both the frontend servers and the application servers. We
    could use two separate playbooks to configure the frontend and application servers,
    but this risks fragmenting your code and making it difficult to organize. However,
    frontend servers and application servers are going to be (by their very nature)
    fundamentally different and so are unlikely to be configured with the same set
    of tasks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们参考我们的示例清单，它描述了一个简单的两层架构（我们暂时省略了数据库层）。现在，假设我们想编写一个单一的剧本来配置前端服务器和应用服务器。我们可以使用两个单独的剧本来配置前端和应用服务器，但这有可能使代码碎片化并且难以组织。然而，前端服务器和应用服务器（本质上）是完全不同的，因此不太可能使用相同的任务集进行配置。
- en: The solution to this problem is to create a single playbook with two plays in
    it. The start of each play can be identified by the line at the lowest indentation
    (that is, zero spaces in front of it).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是创建一个包含两个任务的单一剧本。每个任务的开始可以通过最低缩进的行来识别（即前面没有空格的行）。
- en: 'Let’s get started with building up our playbook:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们的剧本吧：
- en: 'Add the first play to the playbook and define some simple tasks to set up the
    Apache server on the frontend, as shown here:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个任务添加到剧本中，并定义一些简单的任务以在前端设置Apache服务器，如下所示：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Immediately below this, in the same file, add the second play to configure
    the application tier servers:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此下方的同一个文件中，添加第二个任务，用于配置应用层服务器：
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, you have two plays – one to install web servers in the `frontends` group
    and one to install application servers in the `apps` group, all combined into
    one simple playbook.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有两个任务——一个用于在`frontends`组中安装Web服务器，另一个用于在`apps`组中安装应用服务器，所有这些都结合成一个简单的剧本。
- en: 'When we run this playbook, we’ll see the two plays performed sequentially,
    in the order they appear in the playbook. Note the presence of the `PLAY` keyword,
    which denotes the start of each play. Use the following command to run the playbook:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个剧本时，我们会看到两个任务按顺序执行，顺序与它们在剧本中出现的顺序一致。请注意`PLAY`关键字的存在，它表示每个任务的开始。使用以下命令来运行剧本：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output from your playbook run should look something like the following
    screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您的剧本运行输出应该类似于以下截图：
- en: '![Figure 4.2 –  Demonstrating the execution of a playbook containing two plays](img/B20846_04_002.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 演示包含两个任务的剧本执行](img/B20846_04_002.jpg)'
- en: Figure 4.2 – Demonstrating the execution of a playbook containing two plays
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 演示包含两个任务的剧本执行
- en: There we have it – one playbook, yet two distinct plays operating on different
    sets of hosts from the provided inventory. This is very powerful, especially when
    combined with roles (which will be covered later in this book). Of course, you
    can have just one play in your playbook – you don’t have to have multiple ones,
    but it is important to be able to develop multi-play playbooks, as you will almost
    certainly find them useful as your environment gets more complex.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有了一个剧本，但其中包含两个在提供的清单中操作不同主机集的任务。这非常强大，尤其是当它与角色结合使用时（将在本书后面介绍）。当然，您的剧本中可以只有一个任务——不一定要有多个任务，但能够开发多任务剧本是很重要的，因为随着环境的复杂性增加，您几乎肯定会发现它们非常有用。
- en: Playbooks are the lifeblood of Ansible automation – they extend it beyond single
    tasks/commands (which in themselves are incredibly powerful) to a whole series
    of tasks organized logically. As you extend your library of playbooks, however,
    how do you keep your work organized? How do you efficiently reuse the same blocks
    of code? In the preceding example, we installed Apache, and this might be a requirement
    on a number of your servers. However, should you attempt to manage them all from
    one playbook? Or should you perhaps keep copying and pasting the same block of
    code over and over again? There is a better way, and in Ansible terms, we need
    to start looking at roles, which we shall do in the very next section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 剧本是Ansible自动化的生命线——它们将自动化从单一任务/命令（本身非常强大）扩展到一系列逻辑组织的任务。然而，随着您扩展剧本库，如何保持工作有序呢？如何高效地重用相同的代码块？在前面的示例中，我们安装了Apache，而这可能是多个服务器的要求。然而，您是否应该尝试从一个剧本管理所有这些服务器？还是应该不断地复制和粘贴相同的代码块？有一种更好的方法，在Ansible术语中，我们需要开始看角色，我们将在下一个部分讨论这个问题。
- en: Understanding roles – the playbook organizer
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解角色——剧本组织者
- en: Roles are designed to enable you to efficiently and effectively reuse Ansible
    code. They always follow a known structure and often will include sensible default
    values for variables, error handling, handlers, and so on. Taking our Apache installation
    example from the previous chapter, we know that this is something that we might
    want to do over and over again, perhaps with a different configuration file each
    time, and perhaps with a few other tweaks on a per-server (or per-inventory group)
    basis. In Ansible, the most efficient way to support the reuse of this code in
    this way would be to create it as a role.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 角色的设计旨在使你能够高效且有效地重用 Ansible 代码。它们总是遵循已知的结构，并且通常会包含合理的默认值，比如变量、错误处理、处理程序等。在上一章的
    Apache 安装示例中，我们知道这是我们可能想要反复执行的操作，可能每次使用不同的配置文件，并且可能在每个服务器（或每个库存组）上进行一些其他调整。在 Ansible
    中，支持以这种方式重用代码的最有效方法是将其创建为角色。
- en: The process of creating roles is in fact very simple – Ansible will (by default)
    look within the same directory that you are running your playbook from for a `roles/`
    directory, and in here, you will create one subdirectory for each role. The role
    name is derived from the subdirectory name. There is no need to create complex
    metadata or anything else – it really is that simple. Within each subdirectory
    goes a fixed directory structure that tells Ansible what the tasks, default variables,
    handlers, and so on are for each role.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建角色的过程其实非常简单——Ansible 默认会在运行 playbook 的同一目录中查找`roles/`目录，然后在其中为每个角色创建一个子目录。角色名称来源于子目录名称。不需要创建复杂的元数据或其他任何东西——就是这么简单。在每个子目录中会有一个固定的目录结构，告诉
    Ansible 每个角色的任务、默认变量、处理程序等内容。
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `roles/` directory is not the only place Ansible will look for roles – this
    is the first directory it will look in, but it will then look in `/etc/ansible/roles`
    for any additional roles. This can be further customized through the Ansible configuration
    file, as discussed in [*Chapter 2*](B20846_02.xhtml#_idTextAnchor099), *Understanding
    the Fundamentals* *of Ansible*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`roles/`目录并不是 Ansible 查找角色的唯一地方——这是它首先会查找的目录，但它随后会在`/etc/ansible/roles`中查找任何额外的角色。通过
    Ansible 配置文件，这个位置还可以进一步自定义，正如在[*第 2 章*](B20846_02.xhtml#_idTextAnchor099)中所讨论的，*理解
    Ansible 基础知识*。'
- en: 'Let’s explore this in a little more detail. Consider the following directory
    structure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨一下这个问题。考虑以下目录结构：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding directory structure shows two roles defined in our hypothetical
    playbook directory, called `installapache` and `installtomcat`. Within each of
    these directories, you will see a series of subdirectories. These subdirectories
    do not need to exist (there’ll be more on what they mean in a minute, but, for
    example, if your role has no handlers, then `handlers/` does not need to be created).
    However, where you do require such a directory, you should populate it with a
    YAML file named `main.yml`. Each of these `main.yml` files will be expected to
    have certain contents, depending on the directory that contained them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的目录结构展示了我们假设的 playbook 目录中定义的两个角色，分别是`installapache`和`installtomcat`。在这些目录中的每一个，你会看到一系列的子目录。这些子目录不一定要存在（稍后会详细说明它们的意义，但是例如，如果你的角色没有处理程序，则`handlers/`目录不需要创建）。然而，当你需要这样的目录时，你应该在其中放置一个名为`main.yml`的
    YAML 文件。根据目录的不同，每个`main.yml`文件的内容会有所不同。
- en: 'The subdirectories that can exist inside of a role are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 角色内部可以存在的子目录如下：
- en: '`tasks`: This is the most common directory to find in a role, and it contains
    all of the Ansible tasks that the role should perform.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks`：这是角色中最常见的目录，包含角色应执行的所有 Ansible 任务。'
- en: '`handlers`: All handlers used in the role should go into this directory.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handlers`：所有在角色中使用的处理程序应放入此目录。'
- en: '`defaults`: All default variables for the role go in here.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaults`：所有角色的默认变量都放在这里。'
- en: '`vars`: These are other role variables – these override those declared in the
    `defaults/` directory, as they are higher up the precedence order.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars`：这些是其他角色变量——它们会覆盖`defaults/`目录中声明的变量，因为它们的优先级更高。'
- en: '`files`: Files needed by the role should go in here – for example, any configuration
    files that need to be deployed to the target hosts.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files`：角色所需的文件应放在这里，例如需要部署到目标主机的配置文件。'
- en: '`templates`: Distinct from the `files/` directory, this directory should contain
    all templates used by the role.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates`：与`files/`目录不同，此目录应包含角色使用的所有模板。'
- en: '`meta`: Any metadata needed for the role goes in here. For example, roles are
    normally executed in the order they are called from the parent playbook; however,
    sometimes, a role will have dependency roles that need to be run first, and if
    this is the case, they can be declared within this directory.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta`：所有需要的元数据都应放在这里。例如，角色通常按从父剧本调用的顺序执行；然而，有时一个角色会有依赖的其他角色需要先执行，如果是这种情况，它们可以在此目录中声明。'
- en: 'For the examples we will develop in this part of this chapter, we will need
    an inventory, so let’s reuse the inventory we used in the previous section (included
    here for convenience):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中我们要开发的示例，我们需要一个清单，所以我们将重用上一节中使用的清单（为方便起见，附在此处）：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let’s get started with some practical exercises to help you to learn how to
    create and work with roles. We’ll start by creating a role called `installapache`,
    which will handle the Apache installation process we looked at in the previous
    section. However, here, we will expand it to cover the installation of Apache
    on both Fedora and Ubuntu. This is a good practice, especially if you are looking
    to submit your roles back to the community, as the more general-purpose they are
    (and the wider the range of systems they will work on), the more useful they will
    be to people.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些实际练习来帮助你学习如何创建和使用角色。我们将从创建一个名为`installapache`的角色开始，这个角色将处理我们在上一节中看到的Apache安装过程。然而，在这里，我们将扩展它，以覆盖在Fedora和Ubuntu上安装Apache。这是一个很好的实践，特别是如果你打算将你的角色提交回社区，因为它们越通用（适用的系统范围越广），对大家的帮助就越大。
- en: 'Step through the following process to create your first role:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建你的第一个角色：
- en: 'Create the directory structure for the `installapache` role from within your
    chosen playbook directory – this is as simple as this:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你选择的剧本目录中为`installapache`角色创建目录结构——这非常简单：
- en: '[PRE19]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '---'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '---'
- en: '- name: import a tasks based on OS platform'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- name: 根据操作系统平台导入任务'
- en: 'import_tasks: fedora.yml'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'import_tasks: fedora.yml'
- en: 'when: ansible_distribution == ''Fedora'''
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'when: ansible_distribution == ''Fedora'''
- en: '- import_tasks: ubuntu.yml'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- import_tasks: ubuntu.yml'
- en: 'when: ansible_distribution == ''Ubuntu'''
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'when: ansible_distribution == ''Ubuntu'''
- en: '[PRE20]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create `fedora.yml` in `roles/installapache/tasks` to install the latest version
    of the Apache web server via the `dnf` package manager. This should contain the
    following content:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`roles/installapache/tasks`目录下创建`fedora.yml`，通过`dnf`包管理器在Fedora上安装最新版本的Apache
    web服务器。这个文件应包含以下内容：
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a file called `ubuntu.yml` in `roles/installapache/tasks` to install
    the latest version of the Apache web server via the `apt` package manager on Ubuntu.
    Note how the content differs between Fedora and Ubuntu hosts:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`roles/installapache/tasks`目录下创建一个名为`ubuntu.yml`的文件，通过`apt`包管理器在Ubuntu上安装最新版本的Apache
    web服务器。注意Fedora和Ubuntu主机之间内容的差异：
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For now, we’re keeping our code for a role really simple – however, you can
    see that the preceding tasks’ files are just like an Ansible playbook, except
    that they lack the play definition. As they do not come under a play, they are
    also at a lower indentation level than in a playbook, but apart from this difference,
    the code should look very familiar to you. In fact, this is part of the beauty
    of roles – as long as you pay attention to getting the indentation level right,
    you can more or less use the same code in a playbook or a role.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将角色的代码保持得非常简单——然而，你可以看到前面的任务文件就像一个Ansible剧本，只是缺少了play定义。由于它们不属于某个play，它们的缩进级别也比在剧本中的要低，但除了这个差异，代码对你来说应该非常熟悉。事实上，这就是角色的一个优点——只要你注意缩进级别的正确性，你基本可以在剧本或角色中使用相同的代码。
- en: 'Now, roles can’t be run directly – we have to create a playbook to call them,
    so let’s write a simple playbook to call our newly created role. This has a play
    definition just like we saw before, but rather than having a `tasks:` section
    within the play, we have a `roles:` section where the roles are declared instead.
    Convention dictates that this file is called `site.yml`, but you are free to call
    it whatever you like:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，角色不能直接运行——我们必须创建一个剧本来调用它们，所以让我们编写一个简单的剧本来调用我们新创建的角色。这个剧本有一个像我们之前看到的play定义，但与其在play中有一个`tasks:`部分，我们改为有一个`roles:`部分来声明角色。约定俗成地，这个文件被称为`site.yml`，但你可以根据需要命名：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For clarity, your final directory structure should look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，你最终的目录结构应该如下所示：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this completed, you can now run your `site.yml` playbook using `ansible-playbook`
    in the normal way – you should see output similar to this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你可以像往常一样使用 `ansible-playbook` 运行 `site.yml` playbook——你应该看到类似以下的输出：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That’s it – you have created, at the simplest possible level, your first role.
    Of course (as we discussed earlier), there is much more to a role than just the
    simple tasks that we have added here, and we will see expanded examples as we
    work through this chapter. However, the preceding example is intended to show
    you how quick and easy it is to get started with roles.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——你已经在最简单的层次上创建了你的第一个角色。当然（正如我们之前讨论的那样），角色远不止我们在这里添加的简单任务，我们将在本章的其他部分看到更多扩展的例子。然而，前面的例子旨在向你展示如何快速且轻松地开始使用角色。
- en: 'Before we look at some of the other aspects relating to roles, let’s take a
    look at some other ways to call your role. Ansible allows you to statically import
    or dynamically include roles when you write a playbook. The syntax between importing
    or including a role is subtly different, and notably, both go in the `tasks` section
    of your playbook rather than in the `roles` section. The following is a hypothetical
    example that shows both options in a really simple playbook. The `roles/` directory
    structure, including both the `common` and `approle` roles, is created in a similar
    manner to the preceding example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看与角色相关的其他方面之前，先来看看调用角色的其他方式。Ansible 允许你在编写 playbook 时静态导入或动态包含角色。导入或包含角色的语法略有不同，特别是两者都放在
    playbook 的 `tasks` 部分，而不是 `roles` 部分。以下是一个假设的示例，展示了在一个非常简单的 playbook 中使用这两种方式。`roles/`
    目录结构，包括 `common` 和 `approle` 角色，创建方式与前面的例子类似：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These features were not available in versions of Ansible earlier than 2.3, and
    their usage changed slightly in version 2.4 for consistency with the way that
    some other Ansible features work. We will not worry about the details of this
    here, as the core is now on release 2.15, so unless you absolutely have to run
    a much earlier version of Ansible, it is sufficient to assume that these two statements
    work, as we shall outline in the following.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能在 2.3 版本之前的 Ansible 中是不可用的，并且在 2.4 版本中为了与某些其他 Ansible 功能的工作方式保持一致，使用方式略有变化。我们这里不需要过多关注这些细节，因为核心版本已经更新到
    2.15，因此除非你确实需要运行一个更早版本的 Ansible，否则可以假设这两个语句会像我们接下来将概述的那样正常工作。
- en: Fundamentally, the `ansible.builtin.import_role` statement performs a static
    import of the role you specify at the time when all playbook code is parsed. Hence,
    roles brought into your playbook using the `ansible.builtin.import_role` statement
    are treated just like any other code in a play or role when Ansible begins parsing.
    Using `ansible.builtin.import_role` is basically the same as declaring your roles
    after the `roles:` statement in `site.yml`, just as we did in the preceding example.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，`ansible.builtin.import_role` 语句在解析所有 playbook 代码时执行你指定角色的静态导入。因此，使用 `ansible.builtin.import_role`
    引入的角色在 Ansible 开始解析时就像 play 或 role 中的其他任何代码一样处理。使用 `ansible.builtin.import_role`
    基本上与在 `site.yml` 中的 `roles:` 语句后声明角色相同，就像我们在前面的例子中所做的那样。
- en: '`ansible.builtin.include_role` is subtly but fundamentally different in that
    the role you specify is not evaluated when the playbook is parsed initially –
    rather, it is processed dynamically during the playbook run, at the point at which
    `ansible.builtin.include_role` is encountered.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible.builtin.include_role` 有一个微妙但根本的不同之处，即你指定的角色不会在初始解析 playbook 时进行评估——而是在
    playbook 执行过程中，当遇到 `ansible.builtin.include_role` 时动态处理。'
- en: Probably the most fundamental reason to choose between the `include` or `import`
    statements given in the preceding is looping – if you need to run a role within
    a loop, you cannot do so with `import_role`, so you must use `include_role`. There
    are, however, both benefits and limitations to both, and you will need to choose
    the most appropriate one for your scenario – the official Ansible documentation
    ([https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.xhtml#dynamic-vs-static](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.xhtml#dynamic-vs-static))
    will help you to make the right decision.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `include` 或 `import` 语句的最根本原因可能是循环——如果你需要在循环中运行角色，则无法使用 `import_role`，因此必须使用
    `include_role`。然而，二者各有优缺点，你需要根据你的场景选择最合适的一个——官方的 Ansible 文档（[https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.xhtml#dynamic-vs-static](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.xhtml#dynamic-vs-static)）将帮助你做出正确的决策。
- en: As we have seen in this section, roles are incredibly simple to get started
    with and yet offer an incredibly powerful way in which to organize and reuse your
    Ansible code. In the next section, we will expand upon our simple task-based example
    by looking at adding role-specific variables and dependencies to your code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节中所见，角色非常容易上手，并且提供了一种极其强大的方式来组织和重用你的Ansible代码。在下一节中，我们将通过查看如何向代码中添加特定角色的变量和依赖项，来扩展我们的简单任务示例。
- en: Setting up role-based variables and dependencies
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置基于角色的变量和依赖项
- en: Variables are at the heart of making Ansible playbooks and roles reusable, as
    they allow the same code to be repurposed with slightly different values or configuration
    data. The Ansible role directory structure allows for role-specific variables
    to be declared in two locations. Although, at first, the difference between these
    two locations may not seem obvious, it is of fundamental importance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是使Ansible playbook和角色可重用的核心，因为它们允许使用相同的代码，只是值或配置数据略有不同。Ansible角色目录结构允许在两个位置声明特定于角色的变量。虽然一开始这两个位置之间的区别可能并不明显，但它是至关重要的。
- en: 'Role-based variables can go in one of two locations:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 基于角色的变量可以放在两个位置之一：
- en: '`defaults/main.yml`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaults/main.yml`'
- en: '`vars/main.yml`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars/main.yml`'
- en: The difference between these two locations is their position in Ansible’s variable
    order of precedence ([https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable)).
    Variables that go in the `defaults/` directory are one of the lowest in terms
    of precedence so are easily overridden. This location is where you would put variables
    that you want to override easily, but where you don’t want to leave a variable
    undefined. For example, if you install Apache Tomcat, you might build a role to
    install a specific version. However, you don’t want the role to exit with an error
    if someone forgets to set the version – rather, you would prefer to set a sensible
    default, such as `9.0`, that can then be overridden with inventory variables or
    on the command line (using the `-e` or `--extra-vars` switches). In this way,
    you know the role will work even without someone explicitly setting this variable,
    but it can easily be changed to a newer Tomcat version if desired.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个位置之间的区别在于它们在Ansible变量优先级顺序中的位置（[https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable)）。放在`defaults/`目录中的变量在优先级上是最低的，因此很容易被覆盖。这个位置是你放置那些希望容易被覆盖的变量的地方，但你又不希望让一个变量未定义。例如，如果你安装Apache
    Tomcat，你可能会构建一个角色来安装特定版本。然而，如果有人忘记设置版本，你不希望角色因错误而退出——相反，你更希望设置一个合理的默认值，比如`9.0`，然后可以通过清单变量或命令行（使用`-e`或`--extra-vars`选项）进行覆盖。这样，即使没有人明确设置这个变量，你也知道角色会正常工作，但如果需要，可以轻松地更改为更新的Tomcat版本。
- en: Variables that go in the `vars/` directory, however, come much higher up on
    Ansible’s variable precedence ordering. These will not be overridden by inventory
    variables, and so it should be used for variable data that it is more important
    to keep static. Of course, this is not to say they can’t be overridden – the `-e`
    or `--extra-vars` switches are the highest order of precedence in Ansible so will
    override anything else that you define.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，放在`vars/`目录中的变量在Ansible的变量优先级排序中排得更高。这些变量不会被清单变量覆盖，因此应将其用于需要保持静态的变量数据。当然，这并不是说它们不能被覆盖——`-e`或`--extra-vars`选项具有最高的优先级，因此可以覆盖你定义的任何其他内容。
- en: Most of the time, you will probably make use of the `defaults/` based variables
    alone, but there will doubtless be times when having the option of variables higher
    up the precedence ordering becomes valuable to your automation, and so it is vital
    to know that this option is available to you.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你可能只会使用`defaults/`目录中的变量，但肯定会有一些情况下，将变量放在更高优先级的位置对自动化变得有价值，因此知道你可以使用这个选项是非常重要的。
- en: In addition to the role-based variables described previously, there is also
    the option to add metadata to a role using the `meta/` directory. As before, to
    make use of this, simply add a file called `main.yml` into this directory. To
    explain how you might make use of the `meta/` directory, let’s build and run a
    practical example that will show how it can be used. Before we get started though,
    it is important to note that, by default, the Ansible parser will only allow you
    to run a role once.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前描述的基于角色的变量外，还有一个选项，可以通过`meta/`目录向角色添加元数据。像之前一样，要使用这个功能，只需在该目录中添加一个名为`main.yml`的文件。为了说明如何使用`meta/`目录，让我们构建并运行一个实际示例，展示它是如何使用的。不过，在开始之前，需要注意的是，默认情况下，Ansible解析器只允许你运行一次角色。
- en: 'This is somewhat similar to the way in which we discussed handlers earlier,
    which can be called multiple times but ultimately are only run once at the end
    of the play. Roles are the same in that they can be referred to multiple times
    but will only actually get run once. There are two exceptions to this – the first
    is if the role is called more than once but with different variables or parameters,
    and the other is if the role being called has `allow_duplicates` set to `true`
    in its `meta/` directory. We shall see examples of both as we build our example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点类似于我们之前讨论的处理程序，处理程序可以多次调用，但最终只会在剧本结束时运行一次。角色也是如此，它们可以多次引用，但实际上只会运行一次。对此有两个例外——第一个是如果角色被多次调用，但使用了不同的变量或参数；另一个是如果被调用的角色在其`meta/`目录中设置了`allow_duplicates`为`true`。在构建示例时，我们将看到这两种情况的示例：
- en: 'At the top level of our practical example, we will have a copy of the same
    inventory we have used throughout this chapter. We will also create a simple playbook
    called `site.yml`, which contains the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们实际示例的最高层次，我们将有一个与本章中使用的相同的库存副本。我们还将创建一个名为`site.yml`的简单剧本，内容如下：
- en: '[PRE27]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we are simply calling one role called `platform` from this playbook
    – nothing else is called from the playbook itself.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在此剧本中只是调用了一个名为`platform`的角色——剧本本身没有调用其他任何内容。
- en: 'Let’s go ahead and create the `platform` role – unlike our previous role, this
    will not contain any tasks or even any variable data; instead, it will just contain
    a `meta` directory:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续创建`platform`角色——与我们之前的角色不同，它将不包含任何任务，甚至不包含任何变量数据；它只会包含一个`meta`目录：
- en: '[PRE28]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside this directory, create a file called `main.yml` with the following contents:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在此目录中，创建一个名为`main.yml`的文件，内容如下：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code will tell Ansible that the platform role is dependent on the `linuxtype`
    role. Note that we specify the dependency twice, but each time we specify it,
    we pass it a variable called `type` with a different value – in this way, the
    Ansible parser allows us to call the role twice because a different variable value
    has been passed to it each time it is referred to as a dependency.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将告诉Ansible，`platform`角色依赖于`linuxtype`角色。请注意，我们指定依赖关系时，重复指定了两次，每次我们都传递了一个名为`type`的变量，且值不同——通过这种方式，Ansible解析器允许我们调用该角色两次，因为每次传递给它的变量值不同。
- en: 'Let’s now go ahead and create the `linuxtype` role – again, this will contain
    no tasks but more dependency declarations:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建`linuxtype`角色——同样，它不会包含任务，只会有更多的依赖声明：
- en: '[PRE30]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Again, create a `main.yml` file in the `meta` directory but this time containing
    the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在`meta`目录中创建一个`main.yml`文件，但这次内容如下：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once again, we create more dependencies – this time, when the `linuxtype` role
    is called, it, in turn, declares dependencies on roles called `version` and `network`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们创建更多的依赖——这次，当调用`linuxtype`角色时，它反过来又声明了对`version`和`network`角色的依赖。
- en: 'Let’s create the `version` role first – this will have both `meta` and `tasks`
    directories in it:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建`version`角色——它将包含`meta`和`tasks`两个目录：
- en: '[PRE32]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `meta` directory, we’ll create a `main.yml` file with the following
    contents:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`meta`目录中，我们将创建一个名为`main.yml`的文件，内容如下：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This declaration is important in this example – as discussed earlier, normally,
    Ansible will only allow a role to be executed once, even if it is called multiple
    times. Setting `allow_duplicates` to `true` tells Ansible to allow the execution
    of the role more than once. This is required because, in the `platform` role,
    we call (via a dependency) the `linuxtype` role twice, which means, in turn, we
    will call the `version` role twice.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明在本示例中非常重要——如前所述，通常情况下，Ansible只允许角色执行一次，即使它被多次调用。将`allow_duplicates`设置为`true`告诉Ansible允许角色执行多次。这是必需的，因为在`platform`角色中，我们通过依赖关系调用了两次`linuxtype`角色，这意味着我们也将两次调用`version`角色。
- en: 'We’ll also create a simple `main.yml` file in the `tasks/` directory, which
    prints the value of the `type` variable that gets passed to the role:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`tasks/`目录中创建一个简单的`main.yml`文件，它打印传递给角色的`type`变量的值：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will now repeat the process with the `network` role – to keep our example
    code simple, we’ll define it with the same contents as the `version` role:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将重复`network`角色的处理过程——为了保持示例代码的简单性，我们将其定义为与`version`角色相同的内容：
- en: '[PRE35]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `meta` directory, we’ll again create a `main.yml` file with the following
    contents:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`meta`目录中，我们将再次创建一个`main.yml`文件，内容如下：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Again, we’ll create a simple `main.yml` file in the `tasks` directory, which
    prints the value of the `type` variable that gets passed to the role:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将在`tasks`目录中创建一个简单的`main.yml`文件，打印传递给角色的`type`变量的值：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At the end of this process, your directory structure should look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程的最后，你的目录结构应如下所示：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let’s see what happens when we run this playbook. The flow should be as follows
    – our initial playbook statically imports the `platform` role. The `platform`
    role then states that it depends upon the `linuxtype` role, and the dependency
    is declared twice with a different value in a variable called `type` each time.
    The `linuxtype` role then states that it depends upon both the `network` and `version`
    roles, which are allowed to run more than once and print the value of `type`.
    Hence, we see the `network` and `version` roles called twice, printing `fedora`
    on the first call and `ubuntu` the second time (as this is how we originally specified
    the dependencies in the `platform` role). You can execute the playbook using the
    following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们运行这个playbook时会发生什么。流程应该是这样的——我们初始的playbook静态导入了`platform`角色。然后，`platform`角色声明它依赖于`linuxtype`角色，并且在一个名为`type`的变量中声明了两次不同的依赖关系。接着，`linuxtype`角色声明它依赖于`network`和`version`角色，这些角色允许多次执行并打印`type`的值。因此，我们看到`network`和`version`角色被调用两次，第一次调用时打印`fedora`，第二次调用时打印`ubuntu`（因为这就是我们在`platform`角色中最初指定的依赖关系）。你可以使用以下命令来执行playbook：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output should look something like this from this playbook execution:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该playbook执行后的输出应该类似于以下内容：
- en: '![Figure 4.3 – An example of running a playbook using roles with dependencies](img/B20846_04_003.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 使用具有依赖关系的角色运行playbook的示例](img/B20846_04_003.jpg)'
- en: Figure 4.3 – An example of running a playbook using roles with dependencies
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 使用具有依赖关系的角色运行playbook的示例
- en: This is distinctly different from earlier versions of Ansible (for example,
    Ansible 2.7), where if you had run the same code, you would have seen only the
    `type` printed on the screen as `ubuntu`. This demonstrates an important point
    about looking at the code porting guidelines between releases of Ansible/`ansible-core`
    and understanding how the behavior may have changed. While, in most cases (excepting
    the fundamental change around collections), your automation code will work without
    changes from one version of Ansible to the next, this is not guaranteed, and a
    subtle change such as this could have catastrophic consequences in a production
    environment. Ansible code should be treated just as code, including testing new
    releases of Ansible when they are deployed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这与早期版本的Ansible（例如Ansible 2.7）有显著不同，如果你运行相同的代码，你只会看到屏幕上打印出`type`为`ubuntu`。这展示了一个关于查看Ansible/`ansible-core`不同版本之间代码迁移指南的重要点，并帮助我们理解行为可能发生的变化。虽然在大多数情况下（除了关于集合的根本变化），你的自动化代码在从一个版本升级到下一个版本时会正常工作，但这并不保证，而且像这样的微小变化可能在生产环境中造成灾难性后果。因此，Ansible代码应当像代码一样被对待，包括在部署新版本时进行测试。
- en: This is quite an advanced example of Ansible role dependencies, but it has been
    provided to you to demonstrate the importance of knowing a little about variable
    precedence (that is, where the variable is scoped) and how the parser works. If
    you write simple, sequentially parsed tasks, then you may never need to know this,
    but I recommend that you make extensive use of the `debug` statement and test
    your playbook design to make sure that you don’t fall foul of this during your
    playbook development.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当高级的 Ansible 角色依赖示例，但提供这个示例是为了展示了解变量优先级（即变量的作用范围）以及解析器如何工作的知识有多么重要。如果你写的是简单的、按顺序解析的任务，可能永远不需要了解这些内容，但我建议你广泛使用
    `debug` 语句，并测试你的 playbook 设计，以确保在 playbook 开发过程中不会遇到这些问题。
- en: Now that we have looked in great detail at a number of role aspects, let’s take
    a look in the following section at a centralized store for publicly available
    Ansible roles – **Ansible Galaxy**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细了解了多个角色方面的内容，让我们在下一部分中看看公开的 Ansible 角色集中存储——**Ansible Galaxy**。
- en: Ansible Galaxy
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible Galaxy
- en: No section on Ansible roles would be complete without a mention of Ansible Galaxy.
    Ansible Galaxy is a community-driven collection of Ansible roles and collections,
    hosted by Red Hat at [https://galaxy.ansible.com/](https://galaxy.ansible.com/).
    It contains a great many community-contributed Ansible roles and collections,
    and if you can conceive of an automation task, there is a good chance someone
    has already written code to do exactly what you want. It is well worth exploring
    and can get your automation project off the ground quickly, as you can start to
    work with a set of ready-made roles.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 任何关于 Ansible 角色的部分都不能不提 Ansible Galaxy。Ansible Galaxy 是一个由社区驱动的 Ansible 角色和集合的集合，托管在
    Red Hat 的 [https://galaxy.ansible.com/](https://galaxy.ansible.com/) 上。它包含了大量由社区贡献的
    Ansible 角色和集合，如果你能想象一个自动化任务，很可能有人已经写了代码来完成你所需要的功能。它非常值得探索，能迅速推动你的自动化项目起步，因为你可以开始使用一套现成的角色。
- en: 'In addition to the website, the `ansible-galaxy` client is included in Ansible,
    and this provides a quick and convenient way for you to download and deploy roles
    into your playbook structure. Let’s say that you want to update the `arillso.motd`),
    we can download it into our roles directory using the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网站，`ansible-galaxy` 客户端也包含在 Ansible 中，它为你提供了一种快速便捷的方式，将角色下载并部署到你的 playbook
    结构中。假设你想更新 `arillso.motd`，我们可以使用以下命令将它下载到我们的角色目录中：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That’s all you need to do – once the download is complete, you can import or
    include the role in your playbook, just as you would for the manually created
    roles we have discussed in this chapter. Note that if you don’t specify `-p roles/`,
    `ansible-galaxy` will install the roles into `~/.ansible/roles`, the central roles
    directory for your user account. This might be what you want, of course, but if
    you want the role downloaded directly into your playbook directory structure,
    you would add this parameter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的就是这些——下载完成后，你可以像我们在本章讨论的手动创建的角色那样，将角色导入或包含到你的 playbook 中。请注意，如果你没有指定 `-p
    roles/`，`ansible-galaxy` 会将角色安装到 `~/.ansible/roles`，即你用户账户的中央角色目录。当然，这可能是你想要的，但如果你希望角色直接下载到你的
    playbook 目录结构中，你需要添加这个参数。
- en: 'Another neat trick is to use `ansible-galaxy` to create an empty role directory
    structure for you to create your own roles in – this saves all of the manual directory
    and file creation we undertook in this chapter, as shown in this example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的小技巧是使用 `ansible-galaxy` 为你创建一个空的角色目录结构，供你创建自己的角色——这可以节省我们在本章中进行的所有手动目录和文件创建工作，以下是这个示例：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That should give you enough information to get started on your journey into
    Ansible roles. I cannot stress highly enough how important it is to develop your
    code as roles – it might not seem important initially, but as your automation
    use cases expand, and your requirement to reuse code grows, you will be glad that
    you did. In the next section, let’s expand our look at Ansible playbooks with
    a discussion of the ways in which conditional logic can be used in your Ansible
    code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息应该足够让你开始进入 Ansible 角色的学习旅程。我不能过分强调开发代码为角色的重要性——一开始可能看起来不重要，但随着自动化用例的扩展，以及对代码重用的需求增加，你会为当初做出的决定而感到欣慰。在下一部分，我们将扩展对
    Ansible playbook 的理解，讨论如何在 Ansible 代码中使用条件逻辑。
- en: Using conditions in your code
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的代码中使用条件
- en: In most of our examples so far, we have created simple sets of tasks that always
    run. However, as you generate tasks (whether in roles or playbooks) that you want
    to apply to a wider array of hosts, sooner or later, you will want to perform
    some kind of conditional action. This might be to only perform a task in response
    to the results of a previous task, or it might be to only perform a task in response
    to a specific fact gathered from a managed node. In this section, we will provide
    some practical examples of conditional logic to apply to your Ansible tasks to
    demonstrate how to use this feature.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的示例中，我们创建了始终运行的简单任务集。然而，当你生成任务（无论是在角色还是剧本中），并希望将其应用于更多主机时，迟早你会希望执行某种条件操作。这可能是仅在前一个任务的结果基础上执行某个任务，或者仅在从托管节点收集到特定信息时执行任务。在本节中，我们将提供一些实用的条件逻辑示例，以应用于你的
    Ansible 任务，并展示如何使用这一功能。
- en: 'As ever, we’ll need an inventory to get started, and we’ll reuse the inventory
    we have used throughout this chapter:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，我们需要一个清单来开始，并且我们将重用本章中使用过的清单：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Suppose that you want to perform an Ansible task only on certain operating systems.
    We have already discussed Ansible facts, and these provide the perfect platform
    to start exploring conditional logic in your playbooks. Consider this – an urgent
    patch has been released for all of your Fedora systems, and you want to apply
    it immediately. You could, of course, go through and create a special inventory
    (or host group) for Fedora hosts, but this is additional work that you don’t necessarily
    need to do.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你只希望在某些操作系统上执行 Ansible 任务。我们已经讨论过 Ansible 的事实，它们为在剧本中开始探索条件逻辑提供了完美的平台。想象一下——针对所有
    Fedora 系统，已经发布了一个紧急补丁，你希望立即应用它。当然，你可以通过创建一个特别的清单（或主机组）来处理 Fedora 主机，但这会是额外的工作，并非必要。
- en: 'Instead, let’s define the task that will perform our update, adding a `when`
    clause containing a Jinja2 expression to it, so that the update is only performed
    on Fedora-based hosts:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们定义一个执行更新的任务，添加一个包含 Jinja2 表达式的 `when` 子句，使得更新仅在基于 Fedora 的主机上执行：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, when we run this task, if your test system(s) are Fedora-based (and one
    of mine is), you should see output similar to the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这个任务时，如果你的测试系统是基于 Fedora 的（而我的其中一个是），你应该看到类似以下的输出：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding output shows that only one of our systems was Fedora-based, and
    it returned an `ok` status, meaning the patch had already been applied. Now, we
    can make our logic more precise – perhaps it is only our legacy systems that run
    on Fedora 35 that need the patch applied. In this case, we can expand the logic
    in our playbook to check both the distribution and major versions, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，我们的系统中只有一个是基于 Fedora 的，它返回了 `ok` 状态，表示补丁已经应用。现在，我们可以使逻辑更加精确——也许只有运行
    Fedora 35 的遗留系统需要应用补丁。在这种情况下，我们可以扩展剧本中的逻辑，检查发行版和主要版本，如下所示：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, if we run our modified playbook, depending on the systems you have in
    your inventory, you might see output similar to the following. In this case, all
    systems were skipped because they did not match my logical expression (and, hence,
    I am safe in the knowledge that I have no legacy systems in this inventory to
    worry about):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行修改后的剧本，根据你清单中的系统，可能会看到类似以下的输出。在这种情况下，所有系统都被跳过了，因为它们没有匹配我的逻辑表达式（因此，我可以放心，知道这个清单中没有遗留系统需要担心）：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Of course, this conditional logic is not limited to Ansible facts and can be
    incredibly valuable when using the `ansible.builtin.shell` or `ansible.builtin.command`
    modules. When you run *any* Ansible module, the module returns data detailing
    the results of its run. You can capture this in an Ansible variable using the
    `register` keyword and then process it further later on in the playbook.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种条件逻辑不仅限于 Ansible 的事实，在使用 `ansible.builtin.shell` 或 `ansible.builtin.command`
    模块时也非常有价值。当你运行 *任何* Ansible 模块时，该模块会返回一个数据，详细描述其运行结果。你可以使用 `register` 关键字将其捕获到
    Ansible 变量中，然后在剧本后续中进一步处理。
- en: 'Consider the following playbook code. It contains two tasks, the first of which
    is to obtain the listing of the current directory and capture the output of the
    `ansible.builtin.shell` module in a variable called `shellresult`. We then print
    a simple `ansible.builtin.debug` message, but only on the condition that the `hosts`
    string is in the output of the `ansible.builtin.shell` module run:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下的 playbook 代码。它包含两个任务，第一个任务是获取当前目录的文件列表，并将 `ansible.builtin.shell` 模块的输出捕获到名为
    `shellresult` 的变量中。然后，我们打印一个简单的 `ansible.builtin.debug` 消息，但只有在 `ansible.builtin.shell`
    模块执行的输出中包含 `hosts` 字符串时才会打印：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, when we run this in the current directory, which if you work from the
    GitHub repository that accompanies this book will contain a file named `hosts`,
    then you should see output similar to the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在当前目录中运行这个任务时，如果你从本书随附的 GitHub 仓库工作，当前目录将包含一个名为 `hosts` 的文件，那么你应该会看到类似于以下的输出：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Yet, if the file doesn’t exist, you’ll see that the `ansible.builtin.debug`
    message gets skipped:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果文件不存在，你会看到 `ansible.builtin.debug` 消息被跳过：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can also create complex conditions for IT operational tasks in production;
    however, remember that in Ansible, variables are not cast to any particular type
    by default, so even though the contents of a variable (or fact) might look like
    a number, Ansible will treat it as a string by default. If you need to perform
    an integer comparison instead, you must first cast the variable to an integer
    type. For example, here is a fragment of a playbook that will run a task only
    on Fedora 35 and newer:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为生产环境中的 IT 运维任务创建复杂的条件；然而，请记住，在 Ansible 中，变量默认不会被转换为特定类型，所以即使一个变量（或事实）的内容看起来像数字，Ansible
    也会默认将其视为字符串。如果你需要进行整数比较，必须先将变量转换为整数类型。例如，这里是一个 playbook 的片段，它只会在 Fedora 35 及更新版本上运行任务：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There are many different types of conditionals you can apply to your Ansible
    tasks, and this section just scratches the surface; however, it should give you
    a sound basis on which to expand your knowledge of applying conditions to your
    tasks in Ansible. Not only can you apply conditional logic to Ansible tasks but
    you can also run them in loops over a set of data, which we shall explore in the
    following section.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对 Ansible 任务应用许多不同类型的条件，这一节只是简单介绍了其中的一些；然而，它应该为你提供一个坚实的基础，帮助你扩展在 Ansible
    中应用条件的知识。不仅可以将条件逻辑应用于 Ansible 任务，还可以将任务在数据集上循环运行，这一点我们将在下一节中进行探讨。
- en: Repeating tasks with loops
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用循环重复任务
- en: Oftentimes, we will want to perform a single task but use it to iterate over
    a set of data. Perhaps you are creating new 15 new user groups on a server for
    various teams to utilize. It would be incredibly inefficient to have to write
    15 individual tasks within an Ansible play to achieve this – and Ansible is all
    about efficiency and saving the user time. To enable this level of efficiency,
    Ansible supports looping over datasets to ensure that you can perform large-scale
    operations using tightly defined code. In this section, we will explore how to
    make practical use of loops in your Ansible playbooks.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，我们需要执行一个单独的任务，但希望它能遍历一组数据。也许你正在为不同的团队在服务器上创建 15 个新的用户组。要实现这一目标，如果你需要在一个
    Ansible play 中编写 15 个单独的任务，那将是非常低效的——而 Ansible 的核心理念就是提高效率，节省用户时间。为了实现这一效率，Ansible
    支持对数据集进行循环，以确保你可以使用简洁的代码执行大规模的操作。在本节中，我们将探讨如何在 Ansible playbook 中实际应用循环。
- en: 'As ever, we must start with an inventory to work against, and we will use our
    by-now familiar inventory, which we have consistently used throughout this chapter:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，我们必须从一个清单开始工作，我们将使用我们目前已熟悉的清单，这也是本章中一直在使用的清单：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Let’s start with a really simple playbook to show you how to loop over a set
    of data in a single task. Although this is quite a contrived example, it is intended
    to be simple to show you the fundamentals of how loops work in Ansible. We will
    define a single task that runs the `ansible.builtin.command` module on a single
    host from the inventory and uses the `ansible.builtin.command` module to `echo`
    the numbers 1 through 6 in turn on the remote system (with some imagination, this
    could easily be extended to adding user accounts or creating a sequence of files).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的 playbook 开始，向你展示如何在单个任务中遍历一组数据。虽然这是一个非常牵强的例子，但它的目的是简单地展示如何在 Ansible
    中使用循环的基本原理。我们将定义一个单一任务，它会在清单中的单台主机上运行 `ansible.builtin.command` 模块，并使用 `ansible.builtin.command`
    模块在远程系统上依次 `echo` 数字 1 到 6（稍加想象，这个例子可以很容易扩展为添加用户账户或创建一系列文件）。
- en: 'Consider the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下代码：
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `loop:` statement defines the start of the loop, and the items in the loop
    are defined as a YAML list. Also, note the higher indentation level, which tells
    the parser they are part of the loop. When working with the loop data, we use
    a special variable called `item`, which contains the current value from the loop
    iteration to be echoed. When we run this playbook, we should see output similar
    to the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop:`语句定义了循环的开始，循环中的项目被定义为 YAML 列表。还要注意更高的缩进级别，这告诉解析器它们是循环的一部分。当我们处理循环数据时，我们使用一个名为`item`的特殊变量，它包含当前循环迭代的值。在运行这个
    playbook 时，我们应该看到类似以下的输出：'
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can combine the conditional logic we discussed in the preceding section
    with loops, to make the loop operate on just a subset of its data. For example,
    consider the following iteration of the playbook:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将我们在前一节中讨论的条件逻辑与循环结合起来，使循环仅作用于其数据的一个子集。例如，考虑以下的 playbook 迭代：
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, when we run this, we can see that the task is skipped until we reach the
    integer value of `4` and higher in the loop contents:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这个时，我们可以看到任务会被跳过，直到我们在循环内容中达到整数值`4`及更高：
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can, of course, combine this with the conditional logic based on Ansible
    facts and other variables in the manner we discussed previously. Just as we captured
    the results of a module’s execution using the `register` keyword before, we can
    do so with loops. The only difference is that the results will now be stored in
    a dictionary, with one dictionary entry for each iteration of the loop rather
    than just one set of results.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以像我们之前讨论的那样，将其与基于 Ansible facts 和其他变量的条件逻辑结合使用。就像我们之前用`register`关键字捕获模块执行结果一样，我们也可以在循环中做到这一点。唯一的不同是，结果现在将存储在一个字典中，每次循环迭代都会有一个字典项，而不是只有一组结果。
- en: 'Hence, let’s see what happens if we further enhance the playbook, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们来看一下如果我们进一步增强这个 playbook 会发生什么，如下所示：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, when we run the playbook, you will see pages of output containing the
    dictionary with the contents of `loopresult`. The following output is truncated
    in the interests of space but demonstrates the kind of results you should expect
    from running this playbook:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行 playbook 时，你会看到包含`loopresult`内容的字典输出的多页内容。以下输出因空间原因进行了截断，但展示了你运行这个
    playbook 后应当期待的结果：
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, the `results` section of the output is a dictionary, and we
    can clearly see that the first two items in the list were `skipped` because the
    result of our `when` clause (conditional) was `false`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，输出中的`results`部分是一个字典，我们可以清楚地看到列表中的前两个项目被`跳过`，因为我们的`when`子句（条件）的结果为`false`。
- en: Hence, we can see so far that loops are easy to define and work with – but you
    may be asking, *can you create nested loops?* The answer to that question is *yes*,
    but there is a catch – the special variable named `item` would clash, as both
    the inner and outer loops would use the same variable name. This would mean the
    results from your nested loop run would be, at best, unexpected.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止我们可以看到，循环是容易定义和使用的——但你可能会问，*你能创建嵌套循环吗？* 答案是*可以*，但有一个问题——名为`item`的特殊变量会发生冲突，因为内外层的循环都会使用相同的变量名。这意味着，最好的情况是你的嵌套循环的结果会是意外的。
- en: Fortunately, there is a `loop` parameter called `loop_control`, which allows
    you to change the name of the special variable containing the data from the current
    `loop` iteration from `item` to something of your choosing. Let’s create a nested
    loop to see how this works.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个名为`loop_control`的`loop`参数，它允许你将包含当前`loop`迭代数据的特殊变量的名称从`item`更改为你选择的名称。让我们创建一个嵌套循环来看看它是如何工作的。
- en: 'First of all, we’ll create a playbook in the usual manner, with a single task
    to run in a loop. To generate our nested loop, we’ll use the `include_tasks` directive
    to dynamically include a single task from another YAML file, which will also contain
    a loop. As we intend to use this playbook in a nested loop, we’ll use the `loop_var`
    directive to change the name of the special loop contents variable from `item`
    to `second_item`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将按照通常的方式创建一个 playbook，里面包含一个在循环中运行的单个任务。为了生成我们的嵌套循环，我们将使用`include_tasks`指令动态地从另一个
    YAML 文件中包含一个单一任务，这个文件也将包含一个循环。因为我们打算在嵌套循环中使用这个 playbook，所以我们将使用`loop_var`指令将特殊循环内容变量的名称从`item`更改为`second_item`：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, we’ll create a second file called `loopsubtask.yml`, which contains the
    inner loop and is included in the preceding playbook. As we already changed the
    loop item variable name in the outer loop, we don’t need to change it again here.
    Note that the structure of this file is very much like a tasks file in a role
    – it is not a complete playbook but, rather, simply a list of tasks:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个名为 `loopsubtask.yml` 的第二个文件，它包含内部循环，并被包含在之前的 playbook 中。由于我们已经在外部循环中更改了循环项变量名，因此在此不需要再次更改。请注意，这个文件的结构非常像角色中的任务文件——它不是完整的
    playbook，而仅仅是任务的列表：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now you should be able to run the playbook, and you will see Ansible iterate
    over the outer loop first and then process the inner loop over the data defined
    by the outer loop. Test this playbook by running the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够运行 playbook，你会看到 Ansible 首先迭代外部循环，然后在外部循环定义的数据上处理内部循环。通过运行以下命令测试此 playbook：
- en: '[PRE60]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As the loop variable names do not clash, everything works exactly as we would
    expect:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于循环变量名没有冲突，一切如我们预期的那样运行：
- en: '![Figure 4.4 – Demonstrating nested loops in an Ansible playbook](img/B20846_04_004.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 演示在 Ansible playbook 中嵌套循环的示例](img/B20846_04_004.jpg)'
- en: Figure 4.4 – Demonstrating nested loops in an Ansible playbook
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 演示在 Ansible playbook 中嵌套循环的示例
- en: Loops are simple to work with and yet very powerful, as they allow you to easily
    use one task to iterate over a large dataset. In the next section, we’ll look
    at another construct of the Ansible language to control playbook flow – blocks.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 循环很容易使用，却非常强大，因为它们允许你轻松地使用一个任务来迭代大量数据集。在下一节中，我们将探讨 Ansible 语言的另一种结构，用于控制 playbook
    流程——块。
- en: Grouping tasks using blocks
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用块对任务进行分组
- en: Blocks in Ansible allow you to logically group a set of tasks together, primarily
    for one of two purposes. One might be to apply conditional logic to an entire
    set of tasks; in this example, you could apply an identical `when` clause to each
    of the tasks, but this is cumbersome and inefficient – it’s far better to place
    all of the tasks in a block and apply the conditional logic to the block itself.
    In this way, the logic only needs to be declared once. Blocks are also valuable
    when it comes to error handling and especially when it comes to recovering from
    an error condition. We shall explore both of these through simple practical examples
    in this chapter to get you up to speed with blocks in Ansible.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 中的块允许你将一组任务逻辑地组合在一起，主要有两个目的。一个目的是将条件逻辑应用于整个任务集；在这个示例中，你可以对每个任务应用相同的
    `when` 子句，但这样做既繁琐又低效——将所有任务放在一个块中，并将条件逻辑应用于块本身要更好。这样，逻辑只需要声明一次。当涉及到错误处理，尤其是从错误条件中恢复时，块也非常有价值。我们将在本章中通过简单的实践示例来探讨这两种情况，帮助你快速掌握
    Ansible 中的块。
- en: 'As ever, let’s ensure we have an inventory to work from:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，我们确保有一个可用的清单来进行操作：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, let’s dive straight in and look at an example of how you would use blocks
    to apply conditional logic to a set of tasks. At a high level, suppose we want
    to perform the following actions on all of our Fedora Linux hosts:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们直接深入，看看如何使用块将条件逻辑应用于一组任务的示例。从高层次来说，假设我们想要在所有 Fedora Linux 主机上执行以下操作：
- en: Install the package for the Apache web server
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Apache Web 服务器的包
- en: Install a templated configuration
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装模板化配置
- en: Start the appropriate service
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动适当的服务
- en: 'We could achieve this with three individual tasks, all with a `when` clause
    associated with them, but blocks provide us with a better way. The following example
    playbook shows the three tasks discussed contained in a block (note the additional
    level of indentation required to denote their inclusion in the block):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过三个独立的任务来实现，每个任务都带有一个 `when` 子句，但块为我们提供了更好的方式。以下示例 playbook 展示了三个任务，它们被包含在一个块中（注意需要额外的缩进级别来表示它们包含在块内）：
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Run your playbook with the following command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行你的 playbook：
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You should find that the Apache-related tasks are only run on any Fedora hosts
    you might have in your inventory; you should see that either all three tasks are
    run or are skipped – depending on the makeup and contents of your inventory, it
    might look something like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该发现，涉及 Apache 的任务只会在你的清单中任何 Fedora 主机上运行；你应该看到这三个任务要么全部执行，要么跳过——这取决于你清单的构成和内容，它可能看起来像这样：
- en: '![Figure 4.5 – A playbook demonstrating the use of blocks in conditional task
    execution](img/B20846_04_005.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 展示在条件任务执行中使用块的示例](img/B20846_04_005.jpg)'
- en: Figure 4.5 – A playbook demonstrating the use of blocks in conditional task
    execution
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 展示剧本中使用块来条件执行任务的示例
- en: This is very simple-to-construct but very powerful in terms of the effect it
    has on your ability to control the flow over large sets of tasks.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单易行，但在控制大量任务流程方面非常强大。
- en: This time, let’s build a different example to demonstrate how blocks can help
    Ansible to handle error conditions gracefully. So far, you should have seen that
    if your playbooks encounter any errors, they are likely to stop executing at the
    point of failure. This is, in some situations, far from ideal, and you might want
    to perform some kind of recovery action in this event rather than simply halting
    the playbook.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，让我们构建一个不同的示例来演示块如何帮助Ansible优雅地处理错误条件。到目前为止，您应该已经看到，如果您的剧本遇到任何错误，它们可能会在失败点停止执行。在某些情况下，这远非理想，您可能希望在此事件中执行某种恢复操作，而不只是简单地停止剧本。
- en: 'Let’s create a new playbook, this time with the following contents:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的剧本，这次内容如下：
- en: '[PRE64]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Note that in the preceding play, we now have additional sections to `block`
    – as well as the tasks in `block` itself, we have two new parts labeled `rescue`
    and `always`. The flow of execution is as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的剧本中，我们现在有额外的`block`部分 – 除了`block`本身的任务外，我们还有两个标记为`rescue`和`always`的新部分。执行流程如下：
- en: All tasks in the `block` section are executed normally, in the sequence in which
    they are listed.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有`block`部分的任务按列出的顺序正常执行。
- en: 'If a task in the `block` results in an error, no further tasks in the `block`
    are run:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`block`中的任务导致错误，则不会继续运行`block`中的其他任务：
- en: Tasks in the `rescue` section start to run in the order they are listed
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rescue`部分的任务按列出的顺序开始运行'
- en: Tasks in the `rescue` section do not run if no errors result from the `block`
    tasks
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`block`任务未导致错误，则不会运行`rescue`部分的任务
- en: If an error results from a task being run in the `rescue` section, no further
    `rescue` tasks are executed, and execution moves on to the `always` section.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在`rescue`部分运行任务时出错，则不会执行更多的`rescue`任务，并且执行将转移到`always`部分。
- en: Tasks in the `always` section are always run, regardless of any errors in either
    the `block` or `rescue` sections. They even run when no errors are encountered.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`always`部分的任务始终运行，无论`block`或`rescue`部分是否存在任何错误。即使遇到没有错误的情况，它们也会运行。'
- en: 'Test your playbook code by running the following command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的剧本代码，运行以下命令：
- en: '[PRE65]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'With this flow of execution in mind, you should see output similar to the following
    when you execute this playbook, noting that we have deliberately created two error
    conditions to demonstrate the flow:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种执行流程，请在执行此剧本时看到类似以下输出的内容，注意我们已故意创建了两个错误条件来演示流程：
- en: '![Figure 4.6 – Demonstrating the use of blocks in error handling in playbooks](img/B20846_04_006.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 演示剧本中错误处理中使用块的情况](img/B20846_04_006.jpg)'
- en: Figure 4.6 – Demonstrating the use of blocks in error handling in playbooks
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 演示剧本中错误处理中使用块的情况
- en: 'Ansible has two special variables, which contain information you might find
    useful in the `rescue` block to perform your recovery actions:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible有两个特殊变量，它们包含在`rescue`块中可能对执行恢复操作有用的信息：
- en: '`ansible_failed_task`: This is a dictionary containing details of the task
    from `block` that failed, causing us to enter the `rescue` section. You can explore
    this by displaying its contents using `ansible.builtin.debug`, so, for example,
    the name of the failing task can be obtained from `ansible_failed_task.name`.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_failed_task`：这是一个字典，包含导致我们进入`rescue`部分的`block`失败的任务的详细信息。您可以通过使用`ansible.builtin.debug`来显示其内容，例如，可以从`ansible_failed_task.name`获取失败任务的名称。'
- en: '`ansible_failed_result`: This is the result of the failed task and behaves
    the same as if you had added the `register` keyword to the failing task. This
    saves you from having to add `register` to every single task in the block if it
    fails.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_failed_result`：这是失败任务的结果，并且与如果将`register`关键字添加到失败任务中相同。如果失败，则无需在每个块中的任务中添加`register`，这将节省您的时间。'
- en: As your playbooks get more complex and error handling gets more and more important
    (or, indeed, conditional logic becomes more vital), blocks will become an important
    part of your arsenal to write robust playbooks. Let’s proceed in the next section
    to explore execution strategies to gain further control of your playbook runs.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的 playbook 变得越来越复杂，错误处理变得越来越重要（或者说条件逻辑变得更为关键），`block` 将成为编写健壮 playbook 的重要工具。接下来的章节我们将继续探讨执行策略，以便更好地控制你的
    playbook 运行。
- en: Configuring play execution via strategies
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过策略配置 play 执行
- en: As your playbooks become increasingly complex, it becomes more and more important
    that you have robust ways to debug any issues that might arise. For example, is
    there a way you can check the contents of a given variable (or variables) during
    execution without the need to insert `ansible.builtin.debug` statements throughout
    your playbook? Similarly, we have so far seen that Ansible will ensure that a
    particular task runs to completion on all inventory hosts that it applies to before
    moving on to the next task – is there a way to vary this?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的 playbook 变得越来越复杂，调试可能出现的问题变得越来越重要。例如，是否有办法在执行过程中检查给定变量（或多个变量）的内容，而不需要在整个
    playbook 中插入 `ansible.builtin.debug` 语句？类似地，到目前为止我们已经看到，Ansible 会确保在应用到所有库存主机后，特定任务在开始下一个任务之前完成——是否有办法改变这一点？
- en: When you get started with Ansible, the execution strategy that you see by default
    (and we have seen this so far in every playbook we have executed, even though
    we have not mentioned it by name) is known as `linear`. This does exactly what
    it describes – each task is executed in turn on all applicable hosts before the
    next task is started. However, there is another less commonly used strategy called
    `free`, which allows all tasks to be completed as fast as they can on each host,
    without waiting for other hosts.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用 Ansible 时，默认的执行策略（我们到目前为止在每个执行过的 playbook 中都看到了这个策略，尽管我们没有专门提到它）被称为 `linear`。它正如其名字所示——每个任务都会依次在所有适用的主机上执行，然后才开始下一个任务。然而，还有另一种不太常用的策略叫做
    `free`，它允许所有任务在每个主机上尽可能快速地完成，而无需等待其他主机。
- en: 'The most useful strategy when you start to work with Ansible, however, is going
    to be the `debug` strategy, and this enables Ansible to drop you straight into
    its integrated debug environment if an error should occur in the playbook. Let’s
    demonstrate this by creating a playbook that has a deliberate error in it. Note
    the `strategy: debug` and `debugger: on_failed` statements in the play definition:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，当你开始使用 Ansible 时，最有用的策略将是 `debug` 策略，它使得 Ansible 在 playbook 中发生错误时能够直接将你带入集成的调试环境。我们通过创建一个包含故意错误的
    playbook 来演示这一点。注意 play 定义中的 `strategy: debug` 和 `debugger: on_failed` 语句：'
- en: '[PRE66]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, if you execute this playbook, you should see that it starts to run, but
    then it drops you into the integrated debugger when it encounters the deliberate
    error it contains. The start of the output should be similar to the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你执行这个 playbook，你应该会看到它开始运行，但当遇到其中故意设置的错误时，它会进入集成调试器。输出的开始部分应该类似于以下内容：
- en: '[PRE67]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Note that the playbook starts executing but fails on the first task with an
    error, as the variable is undefined. However, rather than exiting back to the
    shell, it enters an interactive debugger. We’ve given a simple example of using
    the debugger in the preceding output, and if you’d like to learn how to use it
    more comprehensively, the Ansible documentation has full details of the available
    commands and how to use them: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.xhtml](https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.xhtml).'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，playbook 开始执行，但由于变量未定义，它在第一个任务上失败。然而，它并没有退出到 shell，而是进入了交互式调试器。我们在前面的输出中展示了如何使用调试器的简单示例，如果你想更全面地了解如何使用它，Ansible
    文档提供了完整的命令以及如何使用它们的细节：[https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.xhtml](https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.xhtml)。
- en: 'To take you through a very simple, practical debugging example, enter the `p
    task` command at the prompt – this will cause the Ansible debugger to print the
    name of the failing task, which is very useful if you are in the midst of a large
    playbook:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了带你了解一个非常简单的调试示例，在提示符下输入 `p task` 命令——这将导致 Ansible 调试器打印出失败任务的名称，如果你正在处理一个大的
    playbook，这将非常有用：
- en: '[PRE68]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we know where the play failed, so let’s dig a little deeper by issuing
    the `p task.args` command, which will show us the arguments that were passed to
    the module in the task:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道了剧本失败的原因，因此让我们通过执行`p task.args`命令深入挖掘一下，这将显示传递给模块的任务参数：
- en: '[PRE69]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'So, we can see that our module was passed the argument called `data`, with
    the argument value being a variable (denoted by the pairs of curly braces) called
    `mobile`. Hence, it might be logical to have a look at the variables available
    to the task to see whether this variable exists and, if so, whether the value
    is sensible (use the `p task_vars` command to do this):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以看到我们的模块传递了一个名为`data`的参数，参数值是一个变量（由成对的大括号表示），名为`mobile`。因此，查看任务中可用的变量，看看这个变量是否存在，并且如果存在，值是否合理，可能是合乎逻辑的（使用`p
    task_vars`命令来做这件事）：
- en: '[PRE70]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The preceding output is truncated, and you will find a great many variables
    associated with the task – this is because any gathered facts, and internal Ansible
    variables, are all available to the task. However, if you scroll through the list,
    you will be able to confirm that there is no variable called `mobile`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出被截断，你会发现任务中有很多与之相关的变量——这是因为任何收集到的事实和内部的 Ansible 变量都会对任务可用。然而，如果你滚动浏览列表，你将能确认没有名为`mobile`的变量。
- en: 'Hence, this should be enough information to fix your playbook. Enter `q` to
    quit the debugger:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些信息应该足够让你修复你的剧本。输入`q`退出调试器：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The Ansible debugger is an incredibly powerful tool, and you should learn to
    make effective use of it, especially as your playbook complexity grows. This concludes
    our practical look at the various aspects of playbook design – in the next section,
    we’ll take a look at the ways in which you can integrate Git source code management
    into your playbooks.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 调试器是一个非常强大的工具，尤其是当你的剧本复杂度增长时，你应该学会有效地使用它。这是我们对剧本设计各个方面的实际讲解的结束——在接下来的章节中，我们将看看如何将
    Git 源代码管理集成到你的剧本中。
- en: Using ansible-pull
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ansible-pull
- en: Of course, the ideal way to work with Ansible code is to store it in a version
    control repository. This is a valuable step that ensures all changes are tracked,
    and that everyone responsible for automation is working from the same code. However,
    it also presents an inefficiency – end users must remember to check out (or pull)
    the latest version of the code and then execute it, and while this isn’t difficult,
    manual tasks are both the enemy of efficiency and make it easy for errors to occur.
    Luckily, once again, Ansible supports us by providing tooling to ensure the most
    efficient approach can be achieved, and a special command called `ansible-pull`
    can be used to both retrieve the latest code from a Git repository and execute
    it, all using one command. This supports not only greater efficiency for end users
    (and reduces the chance of human error) but also enables automation jobs to be
    run unattended (for example, using a scheduler such as `cron`).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，与 Ansible 代码的理想工作方式是将其存储在版本控制仓库中。这是一个宝贵的步骤，确保所有更改都被跟踪，并且每个负责自动化的人都使用相同的代码。然而，这也带来了一种低效性——最终用户必须记得检出（或拉取）代码的最新版本，然后执行它，尽管这并不困难，但手动任务既是效率的敌人，也容易导致错误的发生。幸运的是，Ansible
    再次通过提供工具来确保能够实现最有效的方法来支持我们，一个名为`ansible-pull`的特殊命令可以用来从 Git 仓库中获取最新的代码并执行它，只需一个命令即可完成。这不仅提高了最终用户的效率（并减少了人为错误的机会），还使得自动化任务可以无人值守地运行（例如，使用像`cron`这样的调度程序）。
- en: An important thing to note, however, is that, while the `ansible` and `ansible-playbook`
    commands can both operate over an entire inventory and run the playbooks against
    one or more remote hosts, the `ansible-pull` command is only intended to run the
    playbooks it obtains from your source control system on `localhost`. Hence, if
    you want to use `ansible-pull` throughout your infrastructure, you must install
    it onto every host that needs it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，尽管`ansible`和`ansible-playbook`命令可以在整个库存上运行，并在一个或多个远程主机上执行剧本，但`ansible-pull`命令仅打算在`localhost`上运行它从源控制系统获取的剧本。因此，如果你想在整个基础设施中使用`ansible-pull`，你必须将其安装到每个需要它的主机上。
- en: Nonetheless, let’s see how this might work. We’ll simply run the command by
    hand to explore its application, but in reality, you would almost certainly install
    it in your `crontab` so that it runs on a regular basis, picking up any changes
    you make to your playbook in the version control system.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们看看这如何运作。我们将通过手动运行命令来探索其应用，但实际上，你几乎肯定会将其安装在 `crontab` 中，这样它就能定期运行，拾取你在版本控制系统中对
    playbook 所做的任何更改。
- en: As stated, `ansible-pull` is only intended to run the playbook on the local
    system, so an inventory file is somewhat redundant – instead, we’ll use a little-used
    inventory specification whereby you can simply specify the inventory hosts directory
    as a comma-separated list on the command line. If you only have one host, you
    simply specify its name followed by a comma.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ansible-pull` 仅用于在本地系统上运行 playbook，因此清单文件有些多余 —— 相反，我们将使用一个很少用到的清单指定方法，你可以在命令行上简单地指定清单主机目录作为以逗号分隔的列表。如果只有一个主机，只需指定其名称并加上逗号。
- en: 'Let’s use a simple playbook from GitHub that sets the message of the day based
    on variable content. To do this, we will run the following command (which we’ll
    break down in a minute):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 GitHub 上的一个简单的 playbook，根据变量内容设置每日消息。为了做到这一点，我们将运行以下命令（稍后我们将逐步分析）：
- en: '[PRE72]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This command breaks down as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的拆解如下：
- en: '`-d /tmp/ansible-set-motd`: This sets the working directory that will contain
    the checkout of the code from GitHub. Ensure this is writeable by the user account
    running the `ansible-pull` command.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d /tmp/ansible-set-motd`：这设置了包含从 GitHub 上检出的代码的工作目录。确保该目录对运行 `ansible-pull`
    命令的用户账户可写。'
- en: '`-i ${HOSTNAME},`: This runs only on the current host, specified by its hostname
    from the appropriate shell variable.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i ${HOSTNAME},`：这只在当前主机上运行，由其主机名和相应的 shell 变量指定。'
- en: '`-U` [https://github.com/jamesfreeman959/ansible-set-motd.git](https://github.com/jamesfreeman959/ansible-set-motd.git):
    We use this URL to obtain the playbooks.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-U` [https://github.com/jamesfreeman959/ansible-set-motd.git](https://github.com/jamesfreeman959/ansible-set-motd.git)：我们使用这个
    URL 来获取 playbooks。'
- en: '`site.yml`: This is the name of the playbook to run from the Git repository
    specified earlier.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`site.yml`：这是从之前指定的 Git 仓库中运行的 playbook 的名称。'
- en: '`-e "ag_motd_content=''MOTD generated by ansible-pull''"`: This sets the appropriate
    Ansible variable to generate the MOTD content.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e "ag_motd_content=''MOTD 由 ansible-pull 生成''"`：这设置了适当的 Ansible 变量来生成 MOTD
    内容。'
- en: '`>> /tmp/ansible-pull.log 2>&1`: This redirects the output of the command to
    a log file if we need to analyze it later – this is especially useful if running
    the command in a cron job where the output would never be printed to the user’s
    terminal.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>> /tmp/ansible-pull.log 2>&1`：这将命令的输出重定向到日志文件，以便我们以后分析 —— 如果在 cron 作业中运行命令，这尤其有用，因为输出不会打印到用户的终端。'
- en: 'You can test this with the following command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令进行测试：
- en: '[PRE73]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You should see some output similar to the following (note that log redirection
    has been removed to make it easier to see the output):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似于以下的输出（注意，日志重定向已被去除，以便更容易查看输出）：
- en: '![Figure 4.7 – Demonstrating the use of ansible-pull](img/B20846_04_007.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 演示 ansible-pull 的使用](img/B20846_04_007.jpg)'
- en: Figure 4.7 – Demonstrating the use of ansible-pull
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 演示 ansible-pull 的使用
- en: This command can be a very powerful part of your overall Ansible solution, especially
    as it means you don’t have to worry too much about running all of your playbooks
    centrally, or ensuring that they are all up to date every time you run them. The
    ability to schedule this in `cron` is especially powerful in a large infrastructure
    where, ideally, automation means things should take care of themselves.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令可以成为你整体 Ansible 解决方案中的一个非常强大的部分，特别是因为它意味着你不需要太担心集中运行所有 playbooks，或者确保它们在每次运行时都保持最新。将其安排在
    `cron` 中的能力在大规模基础设施中尤其强大，理想情况下，自动化意味着一切应该自行解决。
- en: This concludes our practical look at playbooks and how to author your own code
    – with a little research into Ansible modules, you should now have enough to write
    your own robust playbooks with ease.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对 playbooks 的实际操作示范，以及如何编写自己的代码 —— 通过对 Ansible 模块进行一些研究，你现在应该能够轻松编写自己的强大
    playbooks。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Playbooks are the lifeblood of Ansible automation, providing a robust framework
    within which to define logical collections of tasks and handle error conditions
    cleanly and robustly. The addition of roles into this mix is valuable in terms
    of not only organizing your code but also in terms of supporting code reuse as
    your automation requirements grow. Ansible playbooks provide a truly complete
    automation solution for your technology needs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks是Ansible自动化的核心，提供了一个强大的框架，用于定义逻辑任务集合，并干净、稳健地处理错误情况。在此框架中加入角色，既有助于组织代码，又能在自动化需求增长时支持代码重用。Ansible的playbook为您的技术需求提供了一个真正完整的自动化解决方案。
- en: In this chapter, you learned about the playbook framework and how to start building
    your own playbooks. You then learned how to organize your code into roles and
    design your code to effectively and efficiently support reuse. We then explored
    some of the more advanced playbook writing topics, such as working with conditional
    logic, blocks, and loops. Finally, we looked at playbook execution strategies,
    especially with a view to being able to debug our playbooks effectively, and we
    wrapped up with a look at how we can run Ansible playbooks on a local machine
    directly from GitHub.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了playbook框架以及如何开始构建自己的playbook。接着，您学习了如何将代码组织成角色，并设计代码以有效和高效地支持重用。然后，我们探讨了一些更高级的playbook编写主题，如条件逻辑、块和循环的使用。最后，我们回顾了playbook执行策略，特别是如何有效调试我们的playbook，并总结了如何直接从GitHub运行Ansible
    playbook。
- en: In the next chapter, we will learn how to consume and create our very own modules,
    providing you with the skills you need to expand the capabilities of Ansible to
    suit your own bespoke environments and contribute to the community.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用和创建我们自己的模块，为您提供扩展Ansible功能的技能，以适应您定制的环境并为社区做出贡献。
- en: Questions
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do you restart the Apache web server in the `frontends` host group via an
    ad hoc command?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何通过临时命令在`frontends`主机组中重启Apache web服务器？
- en: '`ansible frontends -i hosts -a "``name=httpd state=restarted"`'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible frontends -i hosts -a "``name=httpd state=restarted"`'
- en: '`ansible frontends -i hosts -b ansible.builtin.service -a "``name=httpd state=restarted"`'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible frontends -i hosts -b ansible.builtin.service -a "``name=httpd state=restarted"`'
- en: '`ansible frontends -i hosts -b -m ansible.builtin.service -a "``name=httpd
    state=restarted"`'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible frontends -i hosts -b -m ansible.builtin.service -a "``name=httpd
    state=restarted"`'
- en: '`ansible frontends -i hosts -b -m ansible.builtin.server -a "``name=httpd state=restarted"`'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible frontends -i hosts -b -m ansible.builtin.server -a "``name=httpd state=restarted"`'
- en: '`ansible frontends -i hosts -m restart -``a "name=httpd"`'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible frontends -i hosts -m restart -``a "name=httpd"`'
- en: 'Blocks allow you to logically make a group of tasks or perform error handling:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块允许您将任务逻辑上分组或执行错误处理：
- en: 'True'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: 'Default strategies are implemented via the relevant modules in the playbook:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认策略通过playbook中的相关模块实现：
- en: 'True'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Further reading
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '`ansible-galaxy` and its documentation can be found here: [https://galaxy.ansible.com/docs/](https://galaxy.ansible.com/docs/).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-galaxy`及其文档可以在此找到：[https://galaxy.ansible.com/docs/](https://galaxy.ansible.com/docs/)。'
- en: Part 2:Expanding the Capabilities of Ansible
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：扩展Ansible的功能
- en: In this section, we will cover the important concepts of Ansible plugins and
    modules. We will cover both their effective use and how to expand Ansible’s capabilities
    by writing your own plugins, modules, and collections. We’ll even look at the
    requirements for submitting your modules and plugins back to the official Ansible
    project. We’ll also look at coding best practices, as well as some advanced Ansible
    techniques that allow you to safely automate your infrastructure even when you
    are working with a clustered environment.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖Ansible插件和模块的重要概念。我们将讨论它们的有效使用，以及如何通过编写自己的插件、模块和集合来扩展Ansible的功能。我们甚至会看看将模块和插件提交到官方Ansible项目的要求。我们还将探讨编程最佳实践，以及一些高级Ansible技巧，帮助您在处理集群环境时安全地自动化基础设施。
- en: 'This section contains the following chapters:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 5*](B20846_05.xhtml#_idTextAnchor279), *Creating and Consuming* *Modules*'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B20846_05.xhtml#_idTextAnchor279)，*创建和使用* *模块*'
- en: '[*Chapter 6*](B20846_06.xhtml#_idTextAnchor318), *Creating and Consuming* *Collections*'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B20846_06.xhtml#_idTextAnchor318)，*创建和使用* *集合*'
- en: '[*Chapter 7*](B20846_07.xhtml#_idTextAnchor343), *Creating and Consuming* *Plugins*'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B20846_07.xhtml#_idTextAnchor343)，*创建和使用* *插件*'
- en: '[*Chapter 8*](B20846_08.xhtml#_idTextAnchor347), *Coding Best Practices*'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B20846_08.xhtml#_idTextAnchor347)，*编码最佳实践*'
- en: '[*Chapter 9*](B20846_09.xhtml#_idTextAnchor378), *Advanced Ansible Topics*'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B20846_09.xhtml#_idTextAnchor378)，*高级Ansible主题*'
