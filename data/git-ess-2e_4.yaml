- en: Git Fundamentals - Niche Concepts, Configurations, and Commands
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 基础知识 - 特殊概念、配置和命令
- en: This chapter is a collection of short but useful tricks to make our Git experience
    more comfortable. In the first three chapters, we learned all the concepts we
    need to take the first steps into versioning systems using the Git tool; now it's
    time to go a little bit in depth to discover some other powerful weapons in the
    Git arsenal, and how to use them (without shooting yourself in the foot, preferably).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一些简短但实用的技巧集合，旨在让我们的 Git 使用体验更加舒适。在前面的三章中，我们学习了使用 Git 工具进行版本控制的基本概念；现在是时候深入了解
    Git 中的一些强大武器以及如何使用它们（最好是避免自毁）。
- en: Dissecting Git configuration
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 Git 配置
- en: 'In the first part of this chapter, you will learn how to enhance our Git configuration
    to better fit your needs and speed up the daily work: it''s time to become familiar
    with configuration internals.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分，你将学习如何增强 Git 配置，使其更好地满足你的需求并加速日常工作：是时候熟悉配置的内部原理了。
- en: Configuration architecture
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置架构
- en: Configuration options are stored in plain text files. The `git config` command
    is just a convenient tool to edit these files without the hassle of remembering
    where they are stored and opening them in a text editor.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 配置选项存储在纯文本文件中。`git config` 命令只是一个方便的工具，用于编辑这些文件，无需记住它们存储的位置并打开文本编辑器。
- en: Configuration levels
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置级别
- en: 'In Git, we have *three configuration levels*:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 中，我们有*三个配置级别*：
- en: System
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统
- en: Global (user-wide)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局（用户范围）
- en: Repository
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库级别
- en: There are different configuration files for every different configuration level.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个不同的配置级别都有不同的配置文件。
- en: You can basically set every parameter at every level, according to your needs.
    If you set the same parameters at different levels, the lowest-level parameter
    hides the top-level ones; so, for example, if you set `user.name` at the global
    level, it will hide the one eventually set up at the system level, and if you
    set it at the repository level, it will hide the one specified at the global level
    and the one eventually set up at the system level.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你可以根据需要在每个级别设置所有参数。如果在不同级别设置相同的参数，最低级别的参数会覆盖上级的参数；例如，如果在全局级别设置了 `user.name`，它会覆盖系统级别设置的同一项，如果在仓库级别设置，它会覆盖全局级别和系统级别的设置。
- en: 'The following figure will help you to better understand these levels:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下图将帮助你更好地理解这些级别：
- en: '![](img/d7680d0a-e844-4de0-8210-f85631aea0b5.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7680d0a-e844-4de0-8210-f85631aea0b5.png)'
- en: System level
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统级别
- en: The system level contains **system-wide configurations**; if you edit the configuration
    at this level, *every user and every user's repository will be affected*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 系统级别包含**系统范围的配置**；如果你在此级别编辑配置，*所有用户和每个用户的仓库都会受到影响*。
- en: 'This configuration is stored in the `gitconfig` file usually located in:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置通常存储在 `gitconfig` 文件中，位置如下：
- en: 'Windows: `C:\Program Files\Git\etc\gitconfig`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `C:\Program Files\Git\etc\gitconfig`'
- en: 'Linux: `/etc/gitconfig`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux: `/etc/gitconfig`'
- en: 'macOS: `/usr/local/git/etc/gitconfig`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS: `/usr/local/git/etc/gitconfig`'
- en: To edit parameters at this level, you have to use the `--system` option; please
    note that it requires administrative privileges (for example, root permission
    on Linux and macOS).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此级别编辑参数，必须使用 `--system` 选项；请注意，它需要管理员权限（例如，在 Linux 和 macOS 上需要 root 权限）。
- en: Anyway, as a rule of thumb, *editing the configuration at system level is discouraged*,
    in favor of per user configuration modification.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，作为一个经验法则，*不建议在系统级别编辑配置*，建议修改每个用户的配置。
- en: Global level
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局级别
- en: The global level contains **user-wide configurations**; if you edit the configuration
    at this level, *every user's repository will be affected*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 全局级别包含**用户范围的配置**；如果你在此级别编辑配置，*每个用户的仓库都会受到影响*。
- en: 'This configuration is stored in the `.gitconfig` file usually located in:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置通常存储在 `.gitconfig` 文件中，位置如下：
- en: 'Windows: `C:\Users\<UserName>\.gitconfig`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `C:\Users\<UserName>\.gitconfig`'
- en: 'Linux: `~/.gitconfig`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux: `~/.gitconfig`'
- en: 'macOS: `~/.gitconfig`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS: `~/.gitconfig`'
- en: To edit parameters at this level, you have to use the `--global` option.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此级别编辑参数，必须使用 `--global` 选项。
- en: Repository level
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库级别
- en: The repository level contains **repository only configurations**; if you edit
    the configuration at this level, *only the repository in use will be affected*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库级别包含**仅限仓库的配置**；如果你在此级别编辑配置，*只有正在使用的仓库会受到影响*。
- en: 'This configuration is stored in the `config` file located in the `.git` repository
    subfolder:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置存储在 `.git` 仓库子文件夹中的 `config` 文件里：
- en: 'Windows: `C:\<MyRepoFolder>\.git\config`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `C:\<MyRepoFolder>\.git\config`'
- en: 'Linux: `~/<MyRepoFolder>/.git/config`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux: `~/<MyRepoFolder>/.git/config`'
- en: 'macOS: `~/<MyRepoFolder>/.git/config`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS: `~/<MyRepoFolder>/.git/config`'
- en: To edit parameters at this level, you can use the `--local` option or simply
    avoid using any option, as this is the default one.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此级别编辑参数，可以使用 `--local` 选项，或者直接避免使用任何选项，因为这是默认选项。
- en: Listing configurations
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置列表
- en: 'To get a list of all the configurations currently in use, you can run the `git
    config --list` command; if you are inside a repository, it will show all the configurations,
    from repository to system level. To filter the list, append optionally `--system`,
    `--global` or `--local` options to obtain only the desired level configurations:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前使用的所有配置列表，可以运行 `git config --list` 命令；如果你在一个仓库内，它将显示所有配置，从仓库级别到系统级别。为了过滤列表，可以选择性地附加
    `--system`、`--global` 或 `--local` 选项，只显示所需级别的配置：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Editing configuration files manually
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动编辑配置文件
- en: Even if it is generally discouraged, you can modify Git configurations directly
    by editing the files. Git configuration files are quite easy to understand, so
    when you look on the internet for a particular configuration you want to set,
    it is not unusual to find just the right corresponding text lines; the only little
    foresight in such cases is to back up files before editing them, just in case
    you mess with them. In the following paragraphs, we will try to make some changes
    in this manner.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使通常不推荐这么做，你也可以通过直接编辑文件来修改 Git 配置。Git 配置文件非常容易理解，所以当你在网上寻找想要设置的特定配置时，通常会找到完全对应的文本行；在这种情况下，唯一的小心之处是，在编辑之前备份文件，以防万一弄乱了它们。在接下来的段落中，我们将尝试以这种方式进行一些更改。
- en: Setting up some other environment configurations
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置其他环境配置
- en: Using Git can be a painful experience if you are not able to place it conveniently
    inside your work environment. Let's start to shape some rough edges using a bunch
    of custom configurations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能将 Git 方便地融入到你的工作环境中，使用 Git 可能是一个痛苦的经历。让我们开始使用一些自定义配置来修复一些粗糙的地方。
- en: Basic configurations
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本配置
- en: In previous chapters, we have seen that we can change a Git variable value using
    the `git config` with the `<variable.name> <value>` syntax. In this section, we
    will make use of the `config` command to vary some Git behaviors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经看到可以使用 `git config` 和 `<variable.name> <value>` 语法来更改 Git 变量的值。在本节中，我们将使用
    `config` 命令来修改一些 Git 行为。
- en: Typos autocorrection
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拼写错误自动修正
- en: 'So, let''s try to fix an annoying question about typing command: *typos*. I
    often find myself re-typing the same command two or more times; Git can help us
    with embedded *autocorrection*, but we first have to enable it. To enable it,
    you have to modify the `help.autocorrection` parameter, defining how many tenths
    of a second Git will wait before running the assumed command; so giving a `help.autocorrect
    10`, Git will wait for a second:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们尝试解决一个关于输入命令的恼人问题：*拼写错误*。我经常发现自己不得不重复输入相同的命令两次或更多次；Git 可以帮助我们实现内嵌的 *自动修正*，但我们首先需要启用它。要启用它，必须修改
    `help.autocorrection` 参数，定义 Git 在执行假定命令之前会等待多少十分之一秒；例如，设置 `help.autocorrect 10`，Git
    将等待一秒钟：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To abort the auto-correction, simply type *Ctrl*+*C*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要中止自动修正，只需按 *Ctrl*+*C*。
- en: 'Now that we know about configuration files, you can note that the parameters
    we set by the command line are in this form: `section.parameter_name`. You can
    see the section names within `[]` if you look in the configuration file; for example,
    in `C:\Users\<UserName>\.gitconfig`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了配置文件，你可以注意到我们通过命令行设置的参数是这种形式：`section.parameter_name`。如果你查看配置文件，可以在
    `[]` 中看到部分名称；例如，在 `C:\Users\<UserName>\.gitconfig` 中：
- en: '![](img/2c3bbdd3-ff34-48e6-9d10-366af70ee2cb.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c3bbdd3-ff34-48e6-9d10-366af70ee2cb.png)'
- en: Push default
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送默认行为
- en: We already talked about the `git push` command and its default behavior. To
    avoid annoying issues, it is good practice to set a more convenient default behavior
    for this command.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过 `git push` 命令及其默认行为。为了避免恼人的问题，最好为此命令设置一个更方便的默认行为。
- en: 'There are two ways we can do this. First one: set Git to ask us the name of
    the branch we want to push every time, so a simple `git push` will have no effect.
    To obtain this, set `push.default` to `nothing`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法可以做到这一点。第一种方法是：设置 Git 每次都询问我们要推送的分支名称，这样简单的 `git push` 将不起作用。为了实现这一点，将
    `push.default` 设置为 `nothing`：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, now Git pretends that you specify the target branch at every
    push.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，现在Git假装你在每次推送时都指定了目标分支。
- en: This is maybe too restrictive, but at least you can avoid common mistakes such
    as pushing some personal local branches to the remote, thus generating confusion
    in the team.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能太过严格，但至少你可以避免一些常见错误，例如将个人本地分支推送到远程，从而在团队中产生混乱。
- en: 'Another way to save yourself from this kind of mistake is to set the `push.default`
    parameter to `simple`, allowing Git to push only when there is a remote branch
    with the same name as the local one:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个避免此类错误的方法是将`push.default`参数设置为`simple`，这样只有在远程分支与本地分支同名时，Git才会进行推送：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will push the local tracked branch to the remote.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把本地跟踪分支推送到远程。
- en: Defining the default editor
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义默认编辑器
- en: 'Some people really don''t like `vim`, even only for writing commit messages;
    if you are one of them, there is good news: you can change it by setting the `core.default`
    config parameter:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人真的不喜欢`vim`，即便是仅用于编写提交信息；如果你是其中之一，好消息是：你可以通过设置`core.default`配置参数来更改它：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Obviously, you can set nearly all available text editors on the market. If you
    are a Windows user, remember that the full path of the editor has to be in the
    `PATH` environment variable; basically, if you can run your preferred editor by
    typing its executable name in a DOS shell, you can use it even in a Bash shell
    with Git.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可以设置市场上几乎所有可用的文本编辑器。如果你是Windows用户，记住编辑器的完整路径必须在`PATH`环境变量中；基本上，如果你能通过在DOS命令行中输入可执行文件的名称来运行你喜欢的编辑器，那么在Git的Bash命令行中也可以使用它。
- en: Other configurations
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他配置
- en: You can browse a wide list of other configuration variables at [git-scm.com/docs/git-config](http://git-scm.com/docs/git-config).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[git-scm.com/docs/git-config](http://git-scm.com/docs/git-config)浏览更多的配置变量列表。
- en: Git aliases
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 别名
- en: We already mentioned Git aliases and their purpose; in this section, I will
    suggest only a few more, to help make things easier.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过Git别名及其目的；在这一部分，我只会建议一些更多的别名，以帮助简化操作。
- en: Shortcuts to common commands
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用命令的快捷方式
- en: 'One thing you may find useful is to *shorten common commands* such as `git
    checkout` and so on; therefore, useful aliases can include the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个你可能会觉得有用的技巧是*简化常用命令*，例如`git checkout`等；因此，实用的别名可以包括以下内容：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another common practice is to shorten a command, adding one or more options
    you use all the time; for example, set a `git cm <commit message>` command shortcut
    to the alias `git commit -m <commit message>`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见做法是简化命令，添加一个或多个你经常使用的选项；例如，将`git cm <commit message>`命令快捷方式设置为`git commit
    -m <commit message>`：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating commands
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建命令
- en: Another common way to customize your Git experience is to *create commands*
    you think should exist.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的自定义Git体验的方法是*创建你认为应该存在的命令*。
- en: git unstage
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: git unstage
- en: 'The classic example is the `git unstage` alias:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 经典示例是`git unstage`别名：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this alias, you can remove a file from the index in a more meaningful
    way, compared to the equivalent `git reset HEAD -- <file>` syntax:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个别名，你可以比使用等效的`git reset HEAD -- <file>`语法更有意义地从索引中移除文件：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now behaves the same as:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的行为和下面这个相同：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: git undo
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: git undo
- en: 'Want a fast way to revert the last ongoing commit? Create a `git undo` alias:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 想要快速撤销上次正在进行的提交吗？创建一个`git undo`别名：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can obviously use `--hard` instead of `--soft`, or go with the default `--mixed`
    option.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可以使用`--hard`代替`--soft`，或者使用默认的`--mixed`选项。
- en: git last
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: git last
- en: 'A `git last` alias is useful to read about your last commit:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`git last`别名非常有用，可以查看你最后的提交：'
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: git difflast
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: git difflast
- en: 'With the `git difflast` alias, you can see a `diff` against your last commit:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`git difflast`别名，你可以查看与最后一次提交的`diff`：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Advanced aliases with external commands
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部命令的高级别名
- en: 'If you want the alias to run external shell commands, instead of a Git sub-command,
    you have to prefix the alias with a `!`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望别名运行外部 shell 命令，而不是 Git 子命令，必须在别名前加上`!`：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Suppose you are annoyed by the canonical `git add <file>` plus `git commit
    <file>` sequence of commands, and you want to do it in a single shot; you can
    call the `git` command twice in sequence by creating this alias:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你厌烦了经典的`git add <file>`加`git commit <file>`命令序列，而你希望将其合并成一条命令；你可以通过创建这个别名来连续调用两次`git`命令：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this alias you commit a file, adding it before if necessary.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个别名，你可以提交一个文件，必要时先将其添加。
- en: Have you noted that I set the `cm` alias again? If you set an already configured
    alias, the previous alias will be overwritten.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我再次设置了`cm`别名吗？如果你设置一个已经配置过的别名，之前的别名将会被覆盖。
- en: There are also aliases that define and use complex functions or scripts, but
    I'll leave it to the curiosity of the reader to explore these aliases. If you
    are looking for inspiration, take a look at this GitHub repository at [https://github.com/GitAlias/gitalias](https://github.com/GitAlias/gitalias).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些别名定义并使用复杂的功能或脚本，但我会把这些留给读者自己探索。如果你需要灵感，可以看看这个 GitHub 仓库：[https://github.com/GitAlias/gitalias](https://github.com/GitAlias/gitalias)。
- en: Removing an alias
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除别名
- en: 'Removing an alias is quite easy; you have to use the `--unset` option, specifying
    the alias to remove. For example, if you want to remove the `cm` alias, you have
    to run:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个别名非常简单；你只需要使用 `--unset` 选项，并指定要删除的别名。例如，如果你想删除 `cm` 别名，可以运行：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that you have to specify the configuration level with the appropriate option;
    in this case, we are removing the alias from the user (`--global`) level.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你必须使用适当的选项指定配置级别；在这种情况下，我们正在从用户（`--global`）级别删除别名。
- en: Aliasing the git command itself
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 别名化 Git 命令本身
- en: 'I''ve already said I''m a bad typist; if you are too, you can alias the git
    command itself (using the default `alias` command in Bash):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经说过我是个打字很慢的人；如果你也是的话，你可以给 Git 命令本身设置别名（使用 Bash 中的默认 `alias` 命令）：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this manner, you will save some other keyboard strokes. Note that this is
    not a Git alias, but a Bash shell alias.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你将节省一些键盘操作。请注意，这不是 Git 别名，而是 Bash shell 别名。
- en: Useful techniques
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的技巧
- en: In this section, we will improve our skills, learning some techniques that will
    come in handy in different situations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提高我们的技能，学习一些在不同情况下都很有用的技巧。
- en: Git stash - putting changes temporally aside
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git stash - 暂时搁置更改
- en: 'It sometimes happens that you need to switch branches for a moment, but some
    changes are in progress in the current branch. To put aside those changes for
    a while, we can use the `git stash` command: let''s give it a try in our `grocery`
    repository.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要暂时切换分支，但当前分支有一些正在进行的更改。为了将这些更改暂时搁置，我们可以使用 `git stash` 命令：让我们在 `grocery`
    仓库中尝试一下。
- en: 'Append a new fruit to the shopping list, then try to switch branch; Git won''t
    allow you to do so, because with the checkout you would lose your local (not yet
    committed) changes to the `shoppingList.txt` file. So, type the `git stash` command;
    your changes will be set apart and removed from your current branch, letting you
    switch to another one (`berries`, in this case):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 向购物清单添加一个新水果，然后尝试切换分支；Git 不允许这样做，因为在检出时你会丢失 `shoppingList.txt` 文件中尚未提交的本地更改。所以，输入
    `git stash` 命令；你的更改将被暂存并从当前分支中移除，允许你切换到另一个分支（在这个例子中是 `berries`）：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'How does `git stash` work? Actually, `git stash` is a fairly complex command.
    It basically saves from two up to three different commits:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`git stash` 是如何工作的？实际上，`git stash` 是一个相当复杂的命令。它基本上保存了两到三个不同的提交：'
- en: A new *WIP commit* containing the actual state of the working copy; it contains
    all the tracked files, and their modifications.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的 *WIP 提交*，包含工作副本的实际状态；它包含所有已追踪的文件及其修改。
- en: An *index commit*, as a parent of the WIP commit. This contains stuff added
    to the staging area.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *索引提交*，作为 WIP 提交的父提交。它包含已添加到暂存区的内容。
- en: An optional third commit, let's call it an *untracked files commit*, which contains
    untracked files (using the `--include-untracked` option) or untracked plus previously
    ignored files (using the `--all` option).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的第三个提交，称为 *未追踪文件提交*，它包含未追踪的文件（使用 `--include-untracked` 选项）或未追踪的文件加上之前被忽略的文件（使用
    `--all` 选项）。
- en: 'Let''s take a look at the actual situation in our repository using the `git
    log` command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `git log` 命令来查看我们仓库的实际情况：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, in this case there are only two commits. The *WIP commit*, `fedc4cf`,
    is the one with the message starting with *WIP on master*, where `master` is of
    course the branch where `HEAD` was at the time of the `git stash` command run.
    The *index commit*, `7312ff0`, is the one with the message starting with *index
    on master*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在这种情况下只有两个提交。*WIP 提交*，`fedc4cf`，是带有以 *WIP on master* 开头的消息的那个提交，其中 `master`
    当然是执行 `git stash` 命令时 `HEAD` 所在的分支。*索引提交*，`7312ff0`，是带有以 *index on master* 开头的消息的那个提交。
- en: 'The *WIP commit* contains the unstaged changes made to tracked files; as you
    can see, the *WIP commit* has two parents: one is the *index commit*, containing
    staged changes, the other is the last commit on the `master` branch, where `HEAD`
    was and where we run the `git stash` command.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*WIP 提交*包含对已跟踪文件所做的未暂存更改；如你所见，*WIP 提交*有两个父提交：一个是*索引提交*，包含已暂存的更改，另一个是`master`分支上的最后一个提交，也就是`HEAD`所在的位置，并且我们在此位置运行了`git
    stash`命令。'
- en: With all this shelved information, Git can then re-apply your work on top of
    the `master` branch when you finish your job on the `berries` branch; a stash
    can be applied wherever you want, and more than once if you like.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有这些被暂存的信息，Git 可以在你完成`berries`分支上的工作后，将你的工作重新应用到`master`分支上；一个 stash 可以在任何地方应用，甚至可以多次应用。
- en: Using the `git stash` command, we actually used the `git stash save` subcommand,
    the default option. The `save` subcommand saves changes to tracked files only,
    using a default set of messages for these *special commits* we see.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`git stash`命令时，实际上我们使用了默认选项`git stash save`子命令。`save`子命令仅保存对已跟踪文件的更改，使用的是这些*特殊提交*的默认消息。
- en: 'To retrieve a stash, the command is `git stash apply <stash>`; it applies changes
    within the two commits, eventually modifying your working copy and staging area.
    The stash will not be deleted after the apply; you can do it manually using the
    `git stash drop <stash>` subcommand. Another way implies the `git stash pop <stash>`
    subcommand: it applies the stash and then deletes it.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索一个 stash，使用命令`git stash apply <stash>`；它会应用这两个提交中的更改，最终修改你的工作副本和暂存区。应用后，stash不会被删除；你可以通过`git
    stash drop <stash>`手动删除。另一种方式是使用`git stash pop <stash>`子命令：它会应用 stash 后再删除它。
- en: While using these subcommands, you can refer to the various stashes you did
    in the past using different notations; the most common is `stash@{0}`, where `0`
    means *the last stash you did*. To retrieve the penultimate, you can use `stash@{1}`
    and so on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些子命令时，你可以通过不同的标记来引用过去的各种 stash；最常见的是`stash@{0}`，其中`0`表示*你最后一次创建的 stash*。要检索倒数第二个，可以使用`stash@{1}`，以此类推。
- en: 'To make a complete example, let''s drop the actual stash without applying it,
    and then do a new one following these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做一个完整的示例，让我们在不应用的情况下删除当前的 stash，然后按照以下步骤进行新的操作：
- en: Drop the last stash created using `git stash drop` (`git stash clear` drops
    all the stashes).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`git stash drop`删除最后一个创建的 stash（`git stash clear`会删除所有的 stash）。
- en: Append a new fruit to the shopping list (for example, a plum) and add it to
    the staging area.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向购物清单中添加一个新的水果（例如，一个李子）并将其添加到暂存区。
- en: Then add another one (for example, a pear) but avoid adding it to the staging
    area.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加另一个（例如，一个梨），但避免将其添加到暂存区。
- en: Now create a new untracked file (for example, `notes.txt`).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个新的未跟踪文件（例如，`notes.txt`）。
- en: Finally, create a new stash using `-u` (the `--include-untracked` option).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`-u`（`--include-untracked`选项）创建一个新的 stash。
- en: 'Here is the complete list of commands:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的命令列表：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'OK, let''s see what happened using the `git log` command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们通过`git log`命令来看看发生了什么：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, this time there is one more commit, the *untracked files* one:
    this commit contains the `notes.txt` file, and figures as an additional parent
    for the *WIP commit*.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这次有一个新的提交，即*未跟踪的文件*提交：这个提交包含了`notes.txt`文件，并且作为*WIP 提交*的额外父提交。
- en: Summarizing, you basically use the `git stash save` command (with the `-u` or
    `--all` option if needed) to shelve your modification and then `git stash apply`
    to retrieve them; I suggest using `git stash apply` and then `git stash drop`
    instead of `git pop` to have a chance to redo your stash application when needed,
    or when your stash is not as trivial as usual.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你基本上是使用`git stash save`命令（如果需要，使用`-u`或`--all`选项）来暂存你的修改，然后使用`git stash
    apply`来检索它们；我建议使用`git stash apply`后再使用`git stash drop`，而不是`git pop`，这样可以在需要时重新应用你的
    stash，或者当你的 stash 不像平常那样简单时。
- en: To take a look at all the options for this command, please refer to the `git
    stash --help` output.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此命令的所有选项，请参考`git stash --help`输出。
- en: Git commit amend - modify the last commit
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 提交修改 - 修改最后的提交
- en: 'This trick is for people that don''t double-check what they''re doing. If you
    have pressed the enter key too early, there''s a way to modify the last commit
    message or add that file you forgot, using the `git commit` command with the `--amend`
    option:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧适用于那些没有双重检查自己所做操作的人。如果你过早按下了回车键，有一种方法可以修改最后的提交消息或添加你忘记的文件，使用带有`--amend`选项的`git
    commit`命令：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Please note that with the `--amend` option, you are actually re-doing the commit,
    which will have a new hash; if you already pushed the previous commit, changing
    the last commit is not recommended - rather, it is deplorable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`--amend`选项时，你实际上是在重新提交一次，这将生成一个新的哈希值；如果你已经推送了之前的提交，更改最后一个提交并不推荐——实际上，这是不提倡的做法。
- en: 'If you amend an already pushed commit, then push the new one, you are basically
    discarding the latest commit on a branch, replacing it with the newly amended
    one: for those who will pull the branch, this can lead to some confusion, as they
    will see their local branch losing the last commit, replaced by a new one.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你修改了已经推送的提交并再次推送新的提交，实际上你是在丢弃分支上的最新提交，并用新提交替换它：对于那些将要拉取该分支的人来说，这可能会导致一些困惑，因为他们会看到自己的本地分支丢失了最后一个提交，并被一个新的提交所替代。
- en: Git blame - tracing changes in a file
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git blame - 追踪文件中的更改
- en: Working on source code in a team, it is not uncommon to have the need to look
    at the last modifications made to a particular file to better understand how it
    evolved over time. To achieve this result, we can use the `git blame <filename>`
    command.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队中进行源代码工作时，查看特定文件的最后修改记录以更好地理解其随时间演变的情况并不罕见。为此，我们可以使用`git blame <filename>`命令。
- en: 'Let''s try it inside the `Spoon-Knife` repository to see changes made to the
    `README.md` file during a specific time:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Spoon-Knife`仓库中尝试，查看在特定时间段内对`README.md`文件所做的更改：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the result reports all the affected lines of the `README.md`
    file; for every line, you can see the commit hash, the author, the date, and the
    row number of the text file lines.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结果报告了`README.md`文件中所有受影响的行；对于每一行，你都可以看到提交哈希值、作者、日期和文本文件行号。
- en: 'Suppose now you found that the modification you are looking for is the one
    made in the `d0dd1f61` commit; to see what happened there, type the `git show
    d0dd1f61` command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你现在发现你要查找的修改是发生在`d0dd1f61`提交中的；要查看其中发生了什么，可以输入`git show d0dd1f61`命令：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `git show` command is a multi-purpose command that can show to you one or
    more objects; in this case, we have used it to show the modification made in a
    particular commit using the `git show <commit-hash>` format.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`git show`命令是一个多功能命令，可以显示一个或多个对象；在这里，我们使用它来展示通过`git show <commit-hash>`格式显示某个特定提交所做的修改。'
- en: The `git blame` and `git show` commands have a quite long list of options; the
    purpose of this section is to only point the reader to the way they can trace
    changes on a file; you can inspect other possibilities using the ever-useful `git
    <command> --help` command.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`git blame`和`git show`命令有相当长的选项列表；本节的目的是引导读者找到追踪文件变更的方法；你可以通过随时使用`git <command>
    --help`命令来检查其他可能性。'
- en: 'The last tip I want to suggest is to use the Git GUI:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我想建议的最后一个小技巧是使用Git图形界面：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](img/3c4f9e4e-bdb1-4280-a6b9-c95c0f2d379b.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c4f9e4e-bdb1-4280-a6b9-c95c0f2d379b.png)'
- en: With the help of the GUI, things are even easier to understand.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有了图形界面的帮助，理解起来更加容易。
- en: Tricks
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小窍门
- en: In this section, I would like to suggest just a bunch of tips and tricks I have
    found useful in the past.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我想提出一些我过去发现有用的小技巧。
- en: Bare repositories
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 裸仓库
- en: 'Bare repositories are repositories that do not contain working copy files,
    but only the `.git` folder. A bare repository is essentially *for sharing*: if
    you use Git in a centralized way, pushing and pulling to a common remote (a local
    server, a GitHub repository, and so on), you will agree that the remote has no
    interest in checking out files you work on; the scope of that remote is only to
    be a central point of contact for the team, so having working copy files in it
    is only a waste of space as no one will edit them directly on the remote.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 裸仓库是指不包含工作副本文件，仅包含`.git`文件夹的仓库。裸仓库本质上是*用于共享*的：如果你以集中式方式使用Git，推送和拉取到一个公共远程仓库（如本地服务器、GitHub仓库等），你会发现远程仓库不需要查看你正在处理的文件；远程仓库的作用仅仅是作为团队的一个中心联络点，因此在其中拥有工作副本文件只会浪费空间，因为没有人会直接在远程修改这些文件。
- en: 'If you want to set up a bare repository, you only have to use the `--bare`
    option:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想设置一个裸仓库，只需要使用`--bare`选项：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you may have noticed, I called it `NewRepository.git`, using a `.git` extension;
    this is not mandatory, but is a common way to identify bare repositories. If you
    pay attention, you will note that even in GitHub every repository ends with a
    `.git` extension.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，我将其命名为`NewRepository.git`，并使用`.git`扩展名；这并不是强制性的，但它是识别裸仓库的常见方式。如果你留意的话，你会发现即使在GitHub上，每个仓库的名字也以`.git`结尾。
- en: Converting a regular repository to a bare one
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将常规仓库转换为裸仓库
- en: It can happen that you start working on a project in a local repository, and
    then you feel the need to move it to a centralized server to make it available
    for other people or from other locations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生您在本地仓库中开始工作，随后感到需要将其迁移到集中式服务器上，以便其他人或其他地方的人员也能使用。
- en: 'You can easily convert a regular repository to a bare one using the `git clone`
    command with the same `--bare` option:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地使用带有相同 `--bare` 选项的 `git clone` 命令将常规仓库转换为裸仓库：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this manner, you have a 1:1 copy of your repository in another folder, but
    in a bare version, ready to be pushed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，您可以在另一个文件夹中获得您仓库的 1:1 副本，但它是裸版本，准备好进行推送。
- en: Backup repositories
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份仓库
- en: 'If you need a backup, there are two commands you can use: one for archiving
    only files and one for backing up the entire bundle, including versioning information.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要备份，您可以使用两个命令：一个用于仅存档文件，另一个用于备份整个 bundle，包括版本信息。
- en: Archiving the repository
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存档仓库
- en: 'To archive the repository without including versioning information, you can
    use the `git archive` command; there are many output formats but the classic one
    is the `.zip` one:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要存档仓库而不包括版本信息，您可以使用 `git archive` 命令；有许多输出格式，但经典格式是 `.zip` 格式：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Please note that using this command is not the same as backing up folders in
    a filesystem; as you will have noticed, the `git archive` command can produce
    archives in a smarter way, including only files in a branch or even in a single
    commit; for example, by doing this you are archiving only the last commit:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用此命令并不等同于在文件系统中备份文件夹；正如您所注意到的，`git archive` 命令可以更智能地生成存档，仅包括某个分支中的文件，甚至是某次提交中的文件；例如，执行此操作时，您仅存档最后一次提交：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Archiving files in this way can be useful if you have to share your code with
    people that don't have Git installed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式存档文件在您需要与未安装 Git 的人共享代码时非常有用。
- en: Bundling the repository
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包仓库
- en: Another interesting command is the `git bundle` command. With `git bundle`,
    you can export a snapshot from your repository and then restore it wherever you
    want.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的命令是 `git bundle` 命令。使用 `git bundle`，您可以导出仓库的快照，然后将其恢复到任何您想要的地方。
- en: 'Suppose you want to clone your repository on another computer, and the network
    is down or absent; with this command, you can create a `repo.bundle` file of the
    `master` branch:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想在另一台计算机上克隆您的仓库，而网络中断或无法访问；使用此命令，您可以创建 `master` 分支的 `repo.bundle` 文件：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With this other command, we can restore the bundle in the other computer using
    the `git clone` command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，我们可以在另一台计算机上使用 `git clone` 命令恢复这个 bundle：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we enhanced our knowledge about Git and its wide set of commands.
    We discovered how configuration levels work, and how to set our preferences using
    Git by, for example, adding useful command aliases to the shell. Then we looked
    at how Git deals with stashes, providing the way to shelve then and reapply changes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们增强了对 Git 及其广泛命令集的理解。我们发现了配置层级的工作原理，以及如何通过 Git 设置我们的偏好，例如，向 shell 添加有用的命令别名。然后我们探讨了
    Git 如何处理缓存，提供了暂存和重新应用更改的方法。
- en: 'Furthermore, we added some other techniques to our skill set, learning some
    things we will use as soon as we start to use Git extensively. Some simple tricks
    provide a way to stimulate the curiosity of the reader: Git has a lot more commands
    to explore.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们向技能库中添加了一些其他技巧，学习了一些我们将很快在广泛使用 Git 时应用的内容。一些简单的技巧为激发读者好奇心提供了方式：Git 还有很多命令可以探索。
- en: In the next chapter, we will leave the console for a while, and talk about strategies
    to better organize our repositories. We will try to learn how to make significant
    commits, and we will get to know some of the adoptable flows to reconcile Git
    with our way of working.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将暂时离开控制台，讨论一些更好的仓库组织策略。我们将学习如何进行有意义的提交，并了解一些可采用的流程，将 Git 与我们的工作方式结合起来。
