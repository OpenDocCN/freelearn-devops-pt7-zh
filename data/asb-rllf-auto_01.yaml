- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Ansible Automation – Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 自动化 – 介绍
- en: Ansible is open source automation and orchestration software that can be used
    for automating most of your operations with IT infrastructure components including
    servers, storage, networks, and application platforms. Ansible is one of the most
    popular automation tools in the IT world now and has strong community support
    with more than 5,000 contributors around the world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一个开源的自动化和编排软件，可用于自动化大多数 IT 基础设施组件的操作，包括服务器、存储、网络和应用平台。Ansible 是目前 IT
    世界中最受欢迎的自动化工具之一，并且有强大的社区支持，全球有超过 5,000 名贡献者。
- en: 'In this chapter we are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节我们将涵盖以下主题：
- en: What is Ansible? Where should I use this automation tool?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Ansible？我应该在哪里使用这个自动化工具？
- en: Deploying Ansible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署 Ansible
- en: Configuring your managed nodes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置你的管理节点
- en: As of today, Ansible is only available on Linux/Unix platforms, but that doesn't
    mean you cannot use Ansible to automate other **operating systems** (**OSs**)
    or devices. It is possible to use Ansible to automate almost all components involved
    in the IT infrastructure, as there are thousands of supported modules available
    to support Ansible automation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，Ansible 仅在 Linux/Unix 平台上可用，但这并不意味着你不能使用 Ansible 来自动化其他**操作系统**（**OSs**）或设备。实际上，使用
    Ansible 可以自动化几乎所有与 IT 基础设施相关的组件，因为有成千上万个支持的模块可以支持 Ansible 自动化。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements to proceed with this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是继续本章节所需的技术要求：
- en: A basic understanding of the Linux OS and how to handle basic operations in
    Linux
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 Linux 操作系统有基本了解，并能够处理 Linux 中的基本操作
- en: One or more Linux machines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台或多台 Linux 机器
- en: The codes and snippets used in the chapter are tested in **Red Hat Enterprise
    Linux 8** (**RHEL8**). All the Ansible code, Ansible playbooks, commands, and
    snippets for this chapter can be found in the GitHub repository at [https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-01](https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-01).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节中使用的代码和代码片段在**Red Hat Enterprise Linux 8**（**RHEL8**）上进行了测试。本章节的所有 Ansible
    代码、Ansible playbooks、命令和代码片段可以在 GitHub 仓库中找到，网址为：[https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-01](https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-01)。
- en: Hello engineers!
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，工程师们！
- en: The primary role of a systems engineer is building and managing IT infrastructure
    for hosting applications and their data. In the olden days, the number of applications
    used was a lot less, hence the infrastructure size. As the applications and components
    grew, the IT infrastructure also grew, and systems engineers and system administrators
    started experiencing resource conjunction. In other ways, systems engineers are
    spending more time on building, maintaining, and supporting the infrastructure
    rather than spending time on improving the infrastructure designs and optimizing
    them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 系统工程师的主要职责是构建和管理用于托管应用程序及其数据的 IT 基础设施。过去，使用的应用程序数量较少，因此基础设施的规模也较小。随着应用程序和组件的增长，IT
    基础设施也在不断扩展，系统工程师和系统管理员开始遇到资源瓶颈。换句话说，系统工程师花更多时间在构建、维护和支持基础设施上，而不是花时间改进和优化基础设施设计。
- en: For the support team, 90% of the event tickets are simple fixes including disk
    space full, user account locked, volumes not mounted, and so on. But the support
    engineer still needs to manually log in to each and every server and fix the issues
    one by one.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持团队来说，90%的事件工单都是简单的修复，包括磁盘空间满、用户账户被锁定、卷未挂载等等。但支持工程师仍然需要手动登录每一台服务器，逐一解决这些问题。
- en: The task can be fixing a low disk space issue on servers, installing some packages,
    patching OSs, creating virtual machines, or resetting a user password; engineers
    are doing the same job repeatedly for multiple systems, and this led to the invention
    of automated operations. Initially, the solution for automation was custom scripts
    developed and maintained by individual engineers, but it was never a real solution
    for the enterprises as there was no collaboration, maintenance, or accountability
    for such custom automation scripts. If the developer leaves the organization,
    the script will become an orphan and the next engineer will create their own custom
    scripts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可能包括修复服务器上的磁盘空间不足问题、安装某些软件包、修补操作系统、创建虚拟机或重置用户密码；工程师在多个系统上重复执行相同的工作，这促使了自动化操作的发明。最初，自动化的解决方案是由个别工程师开发和维护的自定义脚本，但由于缺乏协作、维护或责任机制，这些自定义自动化脚本并没有成为企业的真正解决方案。如果开发人员离开公司，脚本就会变成孤儿，接下来的工程师将创建自己的自定义脚本。
- en: With the introduction of DevOps methodologies and practices, developers, systems
    engineers, operations teams, and other platform teams started working together,
    the boundaries between them became thinner, and a better accountable ecosystem
    evolved. Everyone started building and maintaining the applications and the underlying
    IT infrastructure, which, in turn, made the automation use case list bigger and
    more complex.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 DevOps 方法论和实践的引入，开发人员、系统工程师、运维团队和其他平台团队开始协作，彼此之间的界限变得越来越模糊，形成了一个更具责任感的生态系统。每个人开始构建和维护应用程序及其底层
    IT 基础设施，这反过来使得自动化的使用场景变得更加复杂和庞大。
- en: What is Ansible? Where should I use this tool?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Ansible？我应该在哪里使用这个工具？
- en: Ansible is an open source automation tool that was written and released by Michael
    DeHaan on February 20, 2012\. In 2013, **Ansible, Inc.** (originally **AnsibleWorks,
    Inc.**) was founded by Michael DeHaan, Timothy Gerla, and Saïd Ziouani, and their
    intention was to commercially support and sponsor Ansible. In 2015, Ansible was
    acquired by Red Hat, and Red Hat supports and promotes Ansible as per the expectations
    of the open source community.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一个开源自动化工具，由 Michael DeHaan 于 2012年2月20日编写并发布。2013年，**Ansible, Inc.**（最初名为**AnsibleWorks,
    Inc.**）由 Michael DeHaan、Timothy Gerla 和 Saïd Ziouani 创立，他们的目标是为 Ansible 提供商业支持和赞助。2015年，Ansible
    被 Red Hat 收购，Red Hat 按照开源社区的期望，支持并推广 Ansible。
- en: As of today, the Ansible control node is only available for Linux/Unix based
    platforms (most of the general-purpose OSs, such as Red Hat Enterprise Linux,
    CentOS, Fedora, Debian, or Ubuntu) and you cannot install it on Windows natively
    (it is possible to use Windows Subsystem for Linux or virtual machines for the
    same). This does not mean that you cannot use Ansible to automate your Windows
    operations. It is possible to use the Ansible control node on Linux and manage
    your Windows machines together, with other devices and platforms such as network
    devices, firewall devices, cloud platforms, and container platforms. There are
    more than 3,200 Ansible modules (as of today) available to use and, for Windows
    alone, there are more than 100 Ansible modules to automate Windows OS-based operations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，Ansible 控制节点仅适用于基于 Linux/Unix 的平台（如 Red Hat Enterprise Linux、CentOS、Fedora、Debian
    或 Ubuntu 等大多数通用操作系统），无法在 Windows 上原生安装（可以使用 Windows 子系统 for Linux 或虚拟机来实现）。这并不意味着你不能使用
    Ansible 来自动化 Windows 操作。你可以在 Linux 上使用 Ansible 控制节点，管理 Windows 机器以及其他设备和平台，如网络设备、防火墙设备、云平台和容器平台。截至目前，有超过
    3200 个 Ansible 模块可供使用，对于 Windows 操作系统，单独有超过 100 个 Ansible 模块来自动化 Windows 操作。
- en: Ansible-Supported Windows OSs
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 支持的 Windows 操作系统
- en: Ansible can manage desktop OSs including Windows 7, 8.1, and 10, and server
    OSs including Windows Server 2008, 2008 R2, 2012, 2012 R2, 2016, and 2019\. Refer
    to [https://docs.ansible.com/ansible/latest/user_guide/windows_setup.xhtml#host-requirements](https://docs.ansible.com/ansible/latest/user_guide/windows_setup.xhtml#host-requirements)
    for more details.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 可以管理包括 Windows 7、8.1 和 10 在内的桌面操作系统，以及包括 Windows Server 2008、2008 R2、2012、2012
    R2、2016 和 2019 在内的服务器操作系统。有关更多详细信息，请参考 [https://docs.ansible.com/ansible/latest/user_guide/windows_setup.xhtml#host-requirements](https://docs.ansible.com/ansible/latest/user_guide/windows_setup.xhtml#host-requirements)。
- en: The community version of Ansible is free to use like other open source software,
    but there is also a product offering from Red Hat based on Ansible called Red
    Hat **Ansible Automation Platform**, which is available with a paid subscription.
    Use either the community version of Ansible or the Red Hat-supported version with
    a subscription. Ansible Automation Platform is for enterprise use with functionalities
    such as **role-based access control** (**RBAC**), **graphical user interface**
    (**GUI**), **Application Programming Interface** (**API**), redundancy, and scalability.
    Consider these options when you expand your automation use cases with a bigger
    team with many engineers working on automation and when you need auditing, tracing,
    and other integrations. Read more about Ansible Automation Platform at [https://www.ansible.com/products/automation-platform](https://www.ansible.com/products/automation-platform).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 的社区版本像其他开源软件一样可以免费使用，但红帽也提供基于 Ansible 的产品——红帽 **Ansible 自动化平台**，该平台需要付费订阅。你可以使用社区版
    Ansible 或带有订阅的红帽支持版本。Ansible 自动化平台面向企业使用，提供如 **基于角色的访问控制**（**RBAC**）、**图形用户界面**（**GUI**）、**应用程序编程接口**（**API**）、冗余和可扩展性等功能。当你需要为更大的团队、多个工程师共同工作时，考虑这些选项，尤其是在你需要审计、追踪和其他集成时。详细了解
    Ansible 自动化平台，请访问 [https://www.ansible.com/products/automation-platform](https://www.ansible.com/products/automation-platform)。
- en: Red Hat Ansible Automation Platform
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 红帽 Ansible 自动化平台
- en: The enterprise automation product from Red Hat was known as **Ansible Tower**
    until the announcement of the Red Hat Ansible Automation Platform in September
    2019 ([https://www.ansible.com/blog/introducing-red-hat-ansible-automation-platform](https://www.ansible.com/blog/introducing-red-hat-ansible-automation-platform)).
    The components inside Ansible Automation Platform were renamed with more meaningful
    names, such as automation controller and execution environment. Read more about
    Ansible Automation Platform at [https://www.redhat.com/en/technologies/management/ansible](https://www.redhat.com/en/technologies/management/ansible).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 红帽的企业自动化产品在 2019 年 9 月之前被称为 **Ansible Tower**，直到宣布推出红帽 Ansible 自动化平台（[https://www.ansible.com/blog/introducing-red-hat-ansible-automation-platform](https://www.ansible.com/blog/introducing-red-hat-ansible-automation-platform)）。Ansible
    自动化平台中的组件被重新命名为更有意义的名称，如自动化控制器和执行环境。详细了解 Ansible 自动化平台，请访问 [https://www.redhat.com/en/technologies/management/ansible](https://www.redhat.com/en/technologies/management/ansible)。
- en: Ansible documentation is available at [https://docs.ansible.com](https://docs.ansible.com).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 文档可在 [https://docs.ansible.com](https://docs.ansible.com) 获取。
- en: Prerequisites
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前提条件
- en: 'We will write automation steps in a YAML file called an **Ansible playbook**.
    Ansible will parse the playbook file and execute the tasks on target machines:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个名为 **Ansible 剧本** 的 YAML 文件中编写自动化步骤。Ansible 将解析剧本文件并在目标机器上执行任务：
- en: You should know the basics of Linux; as I mentioned earlier, it is possible
    to install Ansible on a Linux or Unix machine only at the current time. That does
    not mean that you should be a Linux subject matter expert, but you need to be
    able to handle basic operations in Linux, such as file management and file editing.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该了解 Linux 基础知识；正如我之前提到的，目前只能在 Linux 或 Unix 机器上安装 Ansible。这并不意味着你需要成为 Linux
    专家，但你需要能够处理 Linux 中的基本操作，如文件管理和文件编辑。
- en: You need to understand the YAML syntax, which is easy, as YAML is one of the
    easiest human-readable file formats.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要理解 YAML 语法，这很简单，因为 YAML 是最容易阅读的文件格式之一。
- en: Ansible is based on the Python programming language, but you don't need to learn
    Python or any kind of programming language to develop Ansible automation playbooks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 基于 Python 编程语言，但你无需学习 Python 或任何编程语言即可开发 Ansible 自动化剧本。
- en: What is YAML?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 YAML？
- en: '**YAML Ain''t Markup Language** (**YAML**) is a human-readable language format
    used for most modern tools and software, including Ansible, Kubernetes, and OpenShift.
    YAML is often used as a file format for application data and configuration, for
    example.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAML 不是标记语言**（**YAML**）是一种人类可读的语言格式，广泛应用于现代工具和软件中，包括 Ansible、Kubernetes 和
    OpenShift。例如，YAML 常用作应用程序数据和配置的文件格式。'
- en: Ansible control node requirements
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 控制节点要求
- en: There are no specific hardware requirements for the Ansible control node machine.
    It is possible to use a machine with 512 MB memory and one **virtual central processing
    unit** (**vCPU**). Follow some standard **virtual machine** (**VM**) specifications,
    such as 4 GB or higher, as you may need more memory when you have more managed
    nodes and more tasks to run in parallel. For the disk, you may follow standard
    VM specifications, as Ansible is a small program and does not require much disk
    space. Use any Linux/Unix machine with Python 3.8 or newer installed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible控制节点机器没有特定的硬件要求。可以使用具有512 MB内存和一个**虚拟中央处理单元**（**vCPU**）的机器。遵循一些标准的**虚拟机**（**VM**）规范，例如4
    GB或更高，因为在管理更多节点和并行运行更多任务时，可能需要更多的内存。至于磁盘，你可以遵循标准的虚拟机规范，因为Ansible是一个小型程序，不需要太多的磁盘空间。使用任何安装了Python
    3.8或更新版本的Linux/Unix机器。
- en: Ansible Control Node Requirements
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible控制节点要求
- en: Find the Ansible control node requirements at https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#control-node-requirements.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#control-node-requirements查找Ansible控制节点要求。
- en: Ansible managed node requirements
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible管理节点要求
- en: The target nodes (managed nodes) should be installed with Python 2.6 or later
    (3.x is recommended) to execute the task. For Windows machines, you need to install
    PowerShell and .NET.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目标节点（管理节点）应该安装Python 2.6或更高版本（推荐使用3.x），以便执行任务。对于Windows机器，需要安装PowerShell和.NET。
- en: 'Ansible is also supported for the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible还支持以下内容：
- en: Network devices
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络设备
- en: VMware
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VMware
- en: Public clouds such as AWS, Azure, and GCP
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公有云如AWS、Azure和GCP
- en: Security devices
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全设备
- en: Python 2.x EOL
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.x结束生命周期
- en: Install Ansible on a machine with Python 2.x, but Python 2.x is already **end-of-life**
    (**EOL**) by January 1, 2020, and it is best practice to use the latest Python
    version. For more detailsabout Python 2 end of life, visit [https://www.python.org/doc/sunset-python-2/](https://www.python.org/doc/sunset-python-2/).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有Python 2.x的机器上安装Ansible，但Python 2.x已经在2020年1月1日**结束生命周期**（**EOL**），最好使用最新版本的Python。有关Python
    2结束生命周期的更多细节，请访问[https://www.python.org/doc/sunset-python-2/](https://www.python.org/doc/sunset-python-2/)。
- en: Ansible is agentless
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible是无代理的
- en: There are two types of machines involved in Ansible automation. The machine
    in which you install the Ansible program is known as the **Ansible control node**.
    The control node can be any machine, a dedicated server, or even your workstation,
    and it will have your Ansible playbook and other configurations. Then, the machines
    or devices that you want to automate are known as **managed hosts**. You will
    run the Ansible jobs and playbooks from the control node and the jobs will be
    executed on the target nodes or managed nodes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible自动化涉及两种类型的机器。安装Ansible程序的机器被称为**Ansible控制节点**。控制节点可以是任何机器，一台专用服务器，甚至是你的工作站，它会存放你的Ansible剧本和其他配置。然后，你想要自动化的机器或设备被称为**受管主机**。你将从控制节点运行Ansible任务和剧本，这些任务将在目标节点或受管节点上执行。
- en: 'The following diagram shows the basic components of Ansible:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了Ansible的基本组件：
- en: '![Figure 1.1 – Ansible and components ](img/B18383_01_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – Ansible及其组件](img/B18383_01_01.jpg)'
- en: Figure 1.1 – Ansible and components
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – Ansible及其组件
- en: Ansible is agentless and you do not need to install any kind of agents on the
    managed nodes. Ansible uses default connection methods to communicate with managed
    nodes, such as `ssh`, `WinRM`, `http`, or other appropriate protocols. During
    the onboarding, you need to configure the credentials for the managed nodes, such
    as an SSH credential, with SSH keys, or an SSL certificate for WinRM connection.
    This is a one-time setup, and it is possible to configure or change this anytime.
    It is possible to use the same or different credentials for different managed
    nodes, and configure this for individual nodes or a group of managed nodes. You
    will learn about managed nodes and inventory in the next sections of this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是无代理的，你不需要在管理节点上安装任何类型的代理。Ansible使用默认的连接方式与管理节点进行通信，例如`ssh`、`WinRM`、`http`或其他适当的协议。在上手过程中，你需要配置管理节点的凭证，例如使用SSH密钥的SSH凭证，或用于WinRM连接的SSL证书。这是一次性设置，之后可以随时配置或更改。你可以为不同的管理节点使用相同或不同的凭证，并为单个节点或一组管理节点配置凭证。在本章的后续章节中，你将了解受管节点和清单。
- en: Ansible architecture
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible架构
- en: 'The following diagram shows the Ansible internals and its components'' structure:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了Ansible内部结构及其组件的结构：
- en: '![Figure 1.2 – Ansible and components ](img/B18383_01_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – Ansible 和组件](img/B18383_01_02.jpg)'
- en: Figure 1.2 – Ansible and components
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – Ansible 和组件
- en: Ansible inventory
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 库存
- en: The Ansible inventory is a file or script that will provide the details about
    the managed nodes, including the hostname, connection methods, credential to use,
    and many other details. It is possible to pass the inventory to Ansible using
    static inventory files, dynamic inventory scripts, or using the **configuration
    management database** (**CMDB**). The CMDB is the same CMDB that can provide the
    managed nodes information. It is best practice to integrate CMDB with Ansible
    in an environment to avoid frequent updates on the static inventory files, but
    this is not a mandatory component.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 库存是一个文件或脚本，提供有关受管节点的详细信息，包括主机名、连接方式、使用的凭证以及其他许多细节。可以通过静态库存文件、动态库存脚本或使用**配置管理数据库**（**CMDB**）将库存传递给
    Ansible。CMDB 就是提供受管节点信息的 CMDB。最佳实践是在环境中将 CMDB 与 Ansible 集成，以避免频繁更新静态库存文件，但这不是强制性的组件。
- en: 'It is possible to add any number of managed nodes inside the inventory file,
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在库存文件中添加任意数量的受管节点，如下所示：
- en: '![Figure 1.3 – Ansible inventory with managed nodes ](img/B18383_01_03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 带有受管节点的 Ansible 库存](img/B18383_01_03.jpg)'
- en: Figure 1.3 – Ansible inventory with managed nodes
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 带有受管节点的 Ansible 库存
- en: It is best practice to separate the managed nodes information in multiple inventory
    files based on the criticality, server types, and environment. You will learn
    more about inventory best practices in [*Chapter 16*](B18383_16.xhtml#_idTextAnchor294),
    *Storing Remote Host Information – Inventory Best Practices*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是根据关键性、服务器类型和环境将受管节点信息分隔到多个库存文件中。你将在[*第 16 章*](B18383_16.xhtml#_idTextAnchor294)中学习更多关于库存最佳实践的内容，*存储远程主机信息
    – 库存最佳实践*。
- en: Dynamic inventory plugins will collect the details of managed nodes from your
    virtualization platforms such as VMware, OpenStack, AWS, Azure, and GCP, or from
    other container platforms such as Kubernetes. There are more than 40 dynamic inventory
    plugins available to use in the Ansible GitHub repository. Use them if needed
    or create your own dynamic inventory scripts if those are not suitable for your
    requirements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 动态库存插件将从你的虚拟化平台（如 VMware、OpenStack、AWS、Azure 和 GCP）或其他容器平台（如 Kubernetes）收集受管节点的详细信息。在
    Ansible GitHub 仓库中，提供了超过 40 个动态库存插件供使用。如果需要，可以使用它们，或者如果这些插件不适合你的需求，可以创建自己的动态库存脚本。
- en: Ansible Dynamic Inventory
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 动态库存
- en: For more details about the Ansible dynamic inventory, look it up at [https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml](https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml)
    and [https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory](https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 Ansible 动态库存的更多信息，请访问[https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml](https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml)
    和 [https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory](https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory)。
- en: Ansible plugins
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 插件
- en: Ansible plugins are small pieces of code that help to enable a flexible and
    expandable architecture. You have Ansible executable, and add plugins as needed
    for other features and capabilities like any other software. There are different
    types of plugins in Ansible such as `ssh`, and it is possible to use connection
    plugins called `docker` or `buildah` for connecting to containers. If you need
    to, install and use these plugins.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 插件是帮助启用灵活且可扩展架构的小段代码。你有 Ansible 可执行文件，并根据需要添加插件以支持其他功能和能力，像其他软件一样。Ansible
    中有不同类型的插件，如 `ssh`，并且可以使用名为 `docker` 或 `buildah` 的连接插件来连接容器。如果需要，安装并使用这些插件。
- en: Ansible Plugins
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 插件
- en: Read more about Ansible plugins at [https://docs.ansible.com/ansible/latest/plugins/plugins.xhtml](https://docs.ansible.com/ansible/latest/plugins/plugins.xhtml).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读更多关于 Ansible 插件的信息，请访问[https://docs.ansible.com/ansible/latest/plugins/plugins.xhtml](https://docs.ansible.com/ansible/latest/plugins/plugins.xhtml)。
- en: Ansible modules
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 模块
- en: An Ansible module is a piece of reusable and standalone script that can be used
    to achieve some specific tasks. Modules provide a defined interface with options
    to accept arguments and return information to Ansible in JSON format. When you
    execute a task using a module, the module script will be executed on the target
    machine using Python or using PowerShell for Windows machines.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 模块是一个可重用的独立脚本，可以用于实现某些特定任务。模块提供了一个定义好的接口，选项接受参数并以 JSON 格式将信息返回给 Ansible。当你使用模块执行任务时，模块脚本会在目标机器上使用
    Python 执行，或者在 Windows 机器上使用 PowerShell 执行。
- en: 'For example, the following Ansible content is using a `ping` module to verify
    the connectivity to the target machine and another task with the `yum` module
    for installing `httpd package` on a managed node using the `yum` package manager:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 Ansible 内容使用了一个 `ping` 模块来验证与目标机器的连通性，另一个任务使用 `yum` 模块来通过 `yum` 包管理器在受管节点上安装
    `httpd package`：
- en: '![Figure 1.4 – Ansible ping module and yum module ](img/B18383_01_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – Ansible ping 模块和 yum 模块](img/B18383_01_04.jpg)'
- en: Figure 1.4 – Ansible ping module and yum module
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – Ansible ping 模块和 yum 模块
- en: I said earlier that we can automate network devices and firewall devices using
    Ansible, but, we all know that we cannot install Python or PowerShell on those
    devices. Unlike most of the Ansible modules, network modules do not run on network
    devices. Instead, these modules will be executed from the Ansible control node
    itself and run the appropriate commands on target network devices to achieve the
    task. From the user's point of view, there is no difference in the execution of
    network modules as you still use them like any other modules. It is possible to
    manage the network devices like other Linux machines and Windows machines but
    with different connection methods, such as `network_cli`, `netconf`, and `httpapi`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，我们可以使用 Ansible 来自动化网络设备和防火墙设备，但我们都知道，不能在这些设备上安装 Python 或 PowerShell。与大多数
    Ansible 模块不同，网络模块并不直接在网络设备上运行。相反，这些模块会从 Ansible 控制节点本身执行，并在目标网络设备上运行适当的命令以完成任务。从用户的角度来看，网络模块的执行方式与其他模块没有区别，你仍然像使用其他模块一样使用它们。你可以像管理其他
    Linux 机器和 Windows 机器一样管理网络设备，只是使用不同的连接方式，例如`network_cli`、`netconf`和`httpapi`。
- en: 'Read: How Network Automation Is Different'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读：网络自动化有何不同
- en: Go to [https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.xhtml](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.xhtml)
    to learn more about network device automation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.xhtml](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.xhtml)了解更多关于网络设备自动化的信息。
- en: Ansible content collections
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 内容集合
- en: Before version 2.10, Ansible was a big package with all modules and libraries
    inside, but the community grew very fast and thousands of new modules were contributed
    to Ansible. Whenever there is a new module or new version of a module available
    from the community or vendors, then users need to wait for the next release of
    Ansible to get the updated module. To resolve this dependency, a new way of distribution
    has started in which Ansible modules are separated from the Ansible base and distributed
    as **Ansible content collections**, or simply **Ansible collections**. You have
    the choice of installing Ansible alone or installing the Ansible package including
    Ansible collections. If you need to manage some different set of nodes or systems
    (for example, managing the VMware private cloud or automating Fortigate firewall
    devices), then install the required Ansible collection and use it. This modularity
    allows you to install only the required modules and plugins rather than all available
    modules.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.10 版本之前，Ansible 是一个包含所有模块和库的大包，但社区发展非常迅速，成千上万的新模块被贡献到 Ansible 中。每当社区或供应商提供新的模块或模块的新版本时，用户需要等待下一个
    Ansible 版本的发布才能获取更新的模块。为了解决这个依赖问题，出现了一种新的分发方式，将 Ansible 模块从 Ansible 基础中分离出来，作为
    **Ansible 内容集合**，或简而言之，**Ansible 集合**来分发。你可以选择单独安装 Ansible，或者安装包含 Ansible 集合的
    Ansible 包。如果你需要管理一些不同的节点或系统（例如，管理 VMware 私有云或自动化 Fortigate 防火墙设备），那么安装所需的 Ansible
    集合并使用它。这种模块化使你可以只安装所需的模块和插件，而不是安装所有可用的模块。
- en: 'The following diagram shows the transition of the Ansible collection from old
    Ansible:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 Ansible 集合从旧版 Ansible 的过渡：
- en: '![Figure 1.5 – Ansible to Ansible core and Ansible collection transformation
    ](img/B18383_01_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – Ansible 到 Ansible 核心和 Ansible 集合转换](img/B18383_01_05.jpg)'
- en: Figure 1.5 – Ansible to Ansible core and Ansible collection transformation
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 从 Ansible 到 Ansible 核心和 Ansible 集合的转换
- en: 'Also, note some of the changes in the Ansible base and Ansible collection restructuring:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意一些 Ansible 基础和 Ansible 集合重构中的变化：
- en: 'Before version 2.9.x: The package included `ansible` and all the Ansible modules
    and other plugins.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在版本 2.9.x 之前：该包包含了 `ansible` 以及所有的 Ansible 模块和其他插件。
- en: 'From version 2.10++: Ansible was renamed to `ansible-base` and modules were
    moved to Ansible collections (vendors and communities).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从版本 2.10++ 开始：Ansible 被重命名为 `ansible-base`，并且模块被移到了 Ansible 集合（供应商和社区）。
- en: 'From version 2.11++: `ansible-base` was renamed to `ansible-core`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从版本 2.11++ 开始：`ansible-base` 被重命名为 `ansible-core`。
- en: When you install Ansible 3.x or Ansible 4.x, then you are installing the Ansible
    community package, which includes `ansible-core` and all the Ansible collections
    (vendor and community).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你安装 Ansible 3.x 或 Ansible 4.x 时，你安装的是 Ansible 社区包，其中包括 `ansible-core` 和所有的
    Ansible 集合（供应商和社区）。
- en: Restructuring the Ansible Project
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重构 Ansible 项目
- en: Read the blog post [ansible.com/blog/thoughts-on-restructuring-the-ansible-project](http://ansible.com/blog/thoughts-on-restructuring-the-ansible-project)
    and [ansible.com/blog/the-future-of-ansible-content-delivery](http://ansible.com/blog/the-future-of-ansible-content-delivery)
    to know more about Ansible collection transition.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读博客文章 [ansible.com/blog/thoughts-on-restructuring-the-ansible-project](http://ansible.com/blog/thoughts-on-restructuring-the-ansible-project)
    和 [ansible.com/blog/the-future-of-ansible-content-delivery](http://ansible.com/blog/the-future-of-ansible-content-delivery)
    以了解更多关于 Ansible 集合过渡的内容。
- en: Ansible playbook
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible playbook
- en: 'The Ansible playbook is a simple file written in YAML format with the instruction
    list of automation tasks. The following diagram explains the components, syntax,
    and structure of an Ansible playbook:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible playbook 是一个用 YAML 格式编写的简单文件，里面包含自动化任务的指令列表。以下图解展示了 Ansible playbook
    的组件、语法和结构：
- en: '![Figure 1.6 – Ansible playbook basic components ](img/B18383_01_06.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – Ansible playbook 基本组件](img/B18383_01_06.jpg)'
- en: Figure 1.6 – Ansible playbook basic components
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – Ansible playbook 基本组件
- en: Each task in the **play** runs a module to do some specific job on the target
    node. You can have multiple tasks in a play and multiple plays inside a single
    playbook, as shown in the diagram. The plays, tasks, and module arguments are
    identified by the indentation in YAML format. In this example, we have a playbook
    with two plays.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **play** 中的每个任务都会运行一个模块，在目标节点上执行某些特定的工作。一个 play 中可以有多个任务，一个 playbook 中可以有多个
    play，如图所示。play、任务和模块参数通过 YAML 格式中的缩进来区分。在此示例中，我们有一个包含两个 play 的 playbook。
- en: 'In the first play, `Enable Intranet Services`, we are running the tasks against
    `node1` – see the `hosts: node1` line.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '在第一个 play 中，`启用内网服务`，我们针对 `node1` 运行任务 —— 请查看 `hosts: node1` 这一行。'
- en: 'Under the tasks, see two tasks:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务下方，查看两个任务：
- en: The first task is using the `yum` module and installing the `httpd` package.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个任务是使用 `yum` 模块安装 `httpd` 包。
- en: The second task is using the `service` module to start the `httpd` service.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个任务是使用 `service` 模块启动 `httpd` 服务。
- en: 'Then, we have a second play, `Test intranet web server`, in the playbook, in
    which you have only one task:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 playbook 中有第二个 play，`测试内网 Web 服务器`，其中只有一个任务：
- en: Using the `uri` module to test the intranet web server
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `uri` 模块测试内网 Web 服务器
- en: Ansible will parse this playbook and execute the tasks one by one on the target
    nodes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 将解析此 playbook 并逐一在目标节点上执行任务。
- en: Ansible use cases
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 用例
- en: 'It is possible to build, manage, or maintain almost all components in IT infrastructure
    using Ansible:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ansible，几乎可以构建、管理或维护 IT 基础设施中的所有组件：
- en: Servers and storages
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和存储
- en: Network devices, firewalls, **software-defined networks** (**SDNs**), and load
    balancers
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络设备、防火墙、**软件定义网络**（**SDNs**）和负载均衡器
- en: Application components
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序组件
- en: Containers and container platforms
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器和容器平台
- en: Database applications
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库应用程序
- en: Public cloud and private cloud
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公有云和私有云
- en: 'You need to find the use cases from your day-to-day work and find the highest
    number of tasks you are repeating every day and consider those tasks as automation
    candidates. The following is a sample list of such use cases:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从日常工作中找到用例，并找出你每天重复执行的任务数量最多的任务，并将这些任务视为自动化候选任务。以下是此类用例的示例列表：
- en: OS patching
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统补丁
- en: Application and package deployment
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序和包部署
- en: Orchestration of application
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的编排
- en: Configuration management
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理
- en: Infrastructure provisioning
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施供应
- en: Continuous delivery
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续交付
- en: Security and compliance auditing and remediation
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性和合规性审计及整改
- en: Database provisioning and management
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库预配和管理
- en: In the following section, we will learn how to install and configure Ansible.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何安装和配置 Ansible。
- en: Installing Ansible
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Ansible
- en: There are multiple ways to install Ansible on your system, such as using the
    default package manager (`yum`, `apt`, `dnf`), using Python’s `pip`, or installing
    the source code itself. Depending on your environment and restrictions, follow
    any of the methods provided in the official documentation ([https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml)).
    If you are using the OS package manager, such as `dnf`, `yum`, or `apt`, then
    you need `sudo` privileges (or `root` access) to install Ansible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以在系统上安装 Ansible，例如使用默认的包管理器（`yum`、`apt`、`dnf`），使用 Python 的 `pip`，或安装源代码本身。根据你的环境和限制，按照官方文档中提供的任何方法进行安装（[https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml)）。如果你使用的是操作系统包管理器，如
    `dnf`、`yum` 或 `apt`，则需要 `sudo` 权限（或 `root` 访问权限）来安装 Ansible。
- en: Please note, you do not require `root` or `sudo` access on the Ansible control
    node for using Ansible. In the following snippet, `sudo` access is used for installing
    and updating packages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 Ansible 控制节点上使用 Ansible 时，不需要 `root` 或 `sudo` 权限。在以下代码片段中，`sudo` 权限用于安装和更新包。
- en: Verify dependencies
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证依赖关系
- en: 'As you learned that Ansible needs Python to work, you need to check the Python
    installation first:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Ansible 需要 Python 才能工作，因此你需要先检查 Python 是否已安装：
- en: '![Figure 1.7 – Checking installed Python packages and version ](img/B18383_01_07.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – 检查已安装的 Python 包和版本](img/B18383_01_07.jpg)'
- en: Figure 1.7 – Checking installed Python packages and version
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 检查已安装的 Python 包和版本
- en: If you have a supported Python version installed, then proceed with the Ansible
    installation as explained in the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了受支持的 Python 版本，则按下节所述继续安装 Ansible。
- en: Installing Ansible using the package manager
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用包管理器安装 Ansible
- en: 'Depending on the OS, you need to add and enable the appropriate repositories
    before installing Ansible. For example, if you are using **Red Hat Enterprise
    Linux** (**RHEL**), then you need to ensure the Red Hat subscriptions are in place
    and repositories are enabled to install Ansible:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 根据操作系统，你需要在安装 Ansible 之前添加并启用适当的仓库。例如，如果你使用 **Red Hat Enterprise Linux** (**RHEL**)，则需要确保已设置
    Red Hat 订阅，并启用仓库以安装 Ansible：
- en: '![Figure 1.8 – Installing Ansible package ](img/B18383_01_08.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 安装 Ansible 包](img/B18383_01_08.jpg)'
- en: Figure 1.8 – Installing Ansible package
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 安装 Ansible 包
- en: 'Verify an installed Ansible version with the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令验证已安装的 Ansible 版本：
- en: '![Figure 1.9 – Verifying Ansible installation ](img/B18383_01_09.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – 验证 Ansible 安装](img/B18383_01_09.jpg)'
- en: Figure 1.9 – Verifying Ansible installation
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 验证 Ansible 安装
- en: From this output, see the version of Ansible (*2.9.27*), the default configuration
    file used(config file = `/etc/ansible/ansible.cfg`), the module search path, the
    Python version in use, and other details.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从此输出中，可以看到 Ansible 的版本（*2.9.27*）、使用的默认配置文件（配置文件 = `/etc/ansible/ansible.cfg`）、模块搜索路径、正在使用的
    Python 版本和其他细节。
- en: The preceding Ansible version is coming from the default repository that you
    have configured on the OS. If you want to install the latest or different version
    of Ansible, then you need to follow different methods.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 Ansible 版本来自你在操作系统中配置的默认仓库。如果你想安装最新或不同版本的 Ansible，则需要按照不同的方法进行操作。
- en: Installing Ansible using Python pip
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python pip 安装 Ansible
- en: 'You need to install `pip` if it is not already available on the system and
    then install Ansible using Python pip as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统中没有安装 `pip`，则需要安装 `pip`，然后使用 Python pip 安装 Ansible，如下所示：
- en: '![Figure 1.10 – Installing Ansible using Python pip ](img/B18383_01_10.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10 – 使用 Python pip 安装 Ansible](img/B18383_01_10.jpg)'
- en: Figure 1.10 – Installing Ansible using Python pip
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 使用 Python pip 安装 Ansible
- en: Please note, when you execute `pip install ansible`, you are installing the
    Ansible package, which contains `ansible-core` and Ansible collections. I have
    already explained Ansible collections earlier in this chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你执行 `pip install ansible` 时，你正在安装包含 `ansible-core` 和 Ansible 集合的 Ansible
    包。我在本章前面已经解释过 Ansible 集合。
- en: Pip-Based Ansible Installation and Support
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Pip 的 Ansible 安装和支持
- en: It is best practice to follow the installation based on the OS package manager
    to get the appropriate support and updates automatically. Also, pip-based installations
    are hard to maintain and upgrade when there are newer versions of software available.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是根据操作系统的包管理器来进行安装，这样可以自动获得适当的支持和更新。此外，基于 pip 的安装方式在软件有新版本时维护和升级较为困难。
- en: 'If you want to install a specific version of `ansible`, `ansible-base`, or
    `ansible-core`, then use the version information as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想安装特定版本的 `ansible`、`ansible-base` 或 `ansible-core`，可以按照以下方式使用版本信息：
- en: '![Figure 1.11 – Installing specific version of Ansible using pip  ](img/B18383_01_11.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11 – 使用 pip 安装特定版本的 Ansible](img/B18383_01_11.jpg)'
- en: Figure 1.11 – Installing specific version of Ansible using pip
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 使用 pip 安装特定版本的 Ansible
- en: 'Let''s check the Ansible version now:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一下 Ansible 的版本：
- en: '![Figure 1.12 – Check Ansible version ](img/B18383_01_12.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12 – 检查 Ansible 版本](img/B18383_01_12.jpg)'
- en: Figure 1.12 – Check Ansible version
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 检查 Ansible 版本
- en: See the `DEPRECATION WARNING` message and ignore that in a development environment.
    But in the production environment, you need to make sure you are using the supported
    Python version for Ansible.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `DEPRECATION WARNING` 消息，并在开发环境中忽略该消息。但在生产环境中，你需要确保使用 Ansible 支持的 Python
    版本。
- en: Ansible Installation
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 安装
- en: Check the Ansible documentation for instructions for different OSs and methods
    at [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Ansible 文档，获取不同操作系统和方法的安装说明：[https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml)
- en: Deploying Ansible
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 Ansible
- en: 'Before you start with automation jobs, you need to configure Ansible for your
    environment using the `ansible.cfg` file. Ansible will look for a configuration
    file in four places in order, as listed in the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始自动化任务之前，你需要使用 `ansible.cfg` 文件为你的环境配置 Ansible。Ansible 会按以下顺序在四个地方查找配置文件：
- en: '`$ANSIBLE_CONFIG`: Configuration file path in an environment variable'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ANSIBLE_CONFIG`：环境变量中的配置文件路径'
- en: '`./ansible.cfg`: Configuration file in the current directory'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./ansible.cfg`：当前目录中的配置文件'
- en: '`~/.ansible.cfg`: Configuration file in the home directory'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/.ansible.cfg`：主目录中的配置文件'
- en: '`/etc/ansible/ansible.cfg`: Default configuration file'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/ansible/ansible.cfg`：默认配置文件'
- en: 'It is a best practice to keep the project-specific `ansible.cfg` file in the
    project directory:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是将项目特定的 `ansible.cfg` 文件保存在项目目录中：
- en: '![Figure 1.13 – Creating the ansible.cfg file  ](img/B18383_01_13.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.13 – 创建 ansible.cfg 文件](img/B18383_01_13.jpg)'
- en: Figure 1.13 – Creating the ansible.cfg file
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 – 创建 ansible.cfg 文件
- en: 'Add some basic configurations inside the `ansible.cfg` file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ansible.cfg` 文件中添加一些基本配置：
- en: '![Figure 1.14 – Content of the ansible.cfg file  ](img/B18383_01_14.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.14 – ansible.cfg 文件的内容](img/B18383_01_14.jpg)'
- en: Figure 1.14 – Content of the ansible.cfg file
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 – ansible.cfg 文件的内容
- en: It is not a best practice to keep `remote_user = devops` in `ansible.cfg`; instead,
    configure it inside the inventory for different hosts and host groups. You will
    learn about this later in this chapter, in the *Creating an Ansible inventory*
    section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ansible.cfg` 中保留 `remote_user = devops` 不是最佳实践；最好在清单文件中为不同的主机和主机组配置该项。你将在本章的*创建
    Ansible 清单*部分了解这一点。
- en: 'Now, check the Ansible version again to see the difference and see that Ansible
    is taking `/home/ansible/ansible-demo/ansible.cfg` as the configuration:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次检查 Ansible 版本，查看差异，并确认 Ansible 正在使用 `/home/ansible/ansible-demo/ansible.cfg`
    作为配置文件：
- en: '![Figure 1.15 – Checking which ansible.cfg is taken by Ansible  ](img/B18383_01_15.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.15 – 检查 Ansible 使用的是哪个 ansible.cfg 文件](img/B18383_01_15.jpg)'
- en: Figure 1.15 – Checking which ansible.cfg is taken by Ansible
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – 检查 Ansible 使用的是哪个 ansible.cfg 文件
- en: You have many other parameters to configure in `ansible.cfg` but not all of
    them are mandatory as if you have not specified parameters in your custom `ansible.cfg`
    file, then Ansible will load the default configurations as needed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ansible.cfg` 中，你有许多其他参数可以配置，但并非所有参数都是必需的。如果在自定义的 `ansible.cfg` 文件中没有指定某些参数，Ansible
    会根据需要加载默认配置。
- en: 'See another sample `ansible.cfg` file, which contains some of the important
    parameters, deciding the privilege escalation in Ansible. These parameters decide
    the `sudo` or `su` operation on the target nodes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 查看另一个示例`ansible.cfg`文件，它包含一些重要的参数，这些参数决定了Ansible中的权限提升。这些参数决定了目标节点上的`sudo`或`su`操作：
- en: '![Figure 1.16 – Another ansible.cfg sample with privilege escalation parameters
    ](img/B18383_01_16.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.16 – 另一个包含权限提升参数的ansible.cfg示例](img/B18383_01_16.jpg)'
- en: Figure 1.16 – Another ansible.cfg sample with privilege escalation parameters
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – 另一个包含权限提升参数的ansible.cfg示例
- en: 'In the preceding example, the following happens:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，发生了以下情况：
- en: Ansible will log in to the remote node as a `devops` user and without asking
    for a password (`ask_pass = false`).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible将以`devops`用户身份登录远程节点，且无需输入密码（`ask_pass = false`）。
- en: Ansible will automatically escalate privilege (`become = true`) to `root` (`become_user
    = root`) by using the `sudo` method (`become_method = sudo`) and it will also
    ask for a `sudo` password for the user. Turn this off with the `become_ask_pass
    = false` setting.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible将自动通过`sudo`方法将权限提升（`become = true`）至`root`（`become_user = root`），并且会要求输入`sudo`密码。可以通过设置`become_ask_pass
    = false`来关闭此功能。
- en: Configure different credentials for different nodes in the Ansible inventory.
    You will learn about that in a later section of this chapter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为Ansible库存中的不同节点配置不同的凭据。你将在本章后续部分学习这一点。
- en: Also note, in the preceding example I have not created any inventory files yet.
    I just mentioned the inventory filename there as `./hosts`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在前面的示例中，我还没有创建任何库存文件。我只是将库存文件名提到为`./hosts`。
- en: Creating an Ansible inventory
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Ansible库存
- en: 'Use any name for your inventory file, such as `hosts`, `inventory`, `myhosts`,
    or `production-servers`. Do not confuse this hosts file with the `/etc/hosts`
    file. When you have more and more managed nodes in inventory files, split the
    inventory into groups or into separate inventory files. For example, put production
    servers and devices in a file called `production-hosts`, and staging nodes into
    the `staging-hosts` file; there are no restrictions on this. Also note, if you
    are installing Ansible using the `yum` or `apt` utilities, then there will be
    a default inventory file called `/etc/ansible/hosts` with sample inventory content.
    Refer to that file to start with, but it is best practice to create your project-specific
    inventory file inside your project directory itself. It is possible to create
    inventory files in the `ini` or `yaml` formats as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为你的库存文件使用任何名称，例如`hosts`、`inventory`、`myhosts`或`production-servers`。不要将这个hosts文件与`/etc/hosts`文件混淆。当你的库存文件中有越来越多的管理节点时，可以将库存文件分为不同的组或分成多个库存文件。例如，将生产服务器和设备放入一个名为`production-hosts`的文件中，将预发布节点放入`staging-hosts`文件中；对此没有任何限制。还要注意，如果你通过`yum`或`apt`工具安装Ansible，则会有一个默认的库存文件，路径为`/etc/ansible/hosts`，其中包含示例库存内容。可以参考该文件开始使用，但最佳做法是在你的项目目录中创建一个项目特定的库存文件。你可以按照以下格式创建`ini`或`yaml`格式的库存文件：
- en: '![Figure 1.17 – Creating inventory file inside project directory  ](img/B18383_01_17.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.17 – 在项目目录中创建库存文件](img/B18383_01_17.jpg)'
- en: Figure 1.17 – Creating inventory file inside project directory
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17 – 在项目目录中创建库存文件
- en: 'Add content inside the file as follows and save the file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式在文件中添加内容并保存：
- en: '![Figure 1.18 – Sample inventory file  ](img/B18383_01_18.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.18 – 示例库存文件](img/B18383_01_18.jpg)'
- en: Figure 1.18 – Sample inventory file
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18 – 示例库存文件
- en: 'You do not need to add `localhost` as the `localhost` entry is implicit in
    Ansible. That means we can still call the `localhost` node and Ansible will create
    an implicit entry. In the preceding demonstration, I have added this to show an
    entry as a sample. Since `localhost` is the local machine, you will not be using
    an SSH connection and it is possible tell Ansible the connection type for localhost
    as `local`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你无需添加`localhost`，因为`localhost`条目在Ansible中是隐式的。这意味着我们仍然可以调用`localhost`节点，Ansible会自动创建隐式条目。在前面的示范中，我添加了这个条目作为示例。由于`localhost`是本地机器，你将不会使用SSH连接，而且可以告诉Ansible将localhost的连接类型设置为`local`：
- en: '[PRE0]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is not easy to remember the nodes with IP addresses or nodes with long hostnames.
    In Ansible, use any name for your hosts, and mention the actual name or IP address
    using the `ansible_host` parameter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 记住IP地址或长主机名的节点并不容易。在Ansible中，可以为主机使用任何名称，并通过`ansible_host`参数指定实际的名称或IP地址。
- en: 'Update your inventory with the correct entry name now. Please note, this is
    optional, but it is a best practice to use human-readable names rather than IP
    addresses and long **Fully Qualified Domain Names** (**FQDNs**):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请更新你的清单，使用正确的条目名称。请注意，这是可选的，但最佳实践是使用可读名称，而非IP地址和长**完全限定域名**（**FQDNs**）：
- en: '![Figure 1.19 – Ansible inventory with human-readable names and ansible_host
    ](img/B18383_01_19.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.19 – 具有可读名称和ansible_host的Ansible清单](img/B18383_01_19.jpg)'
- en: Figure 1.19 – Ansible inventory with human-readable names and ansible_host
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19 – 具有可读名称和ansible_host的Ansible清单
- en: The default `ansible_connection` is `ssh` and you do not need to mention that
    in the inventory. If you are using any other connection types, then you need to
    mention them, such as `local`, `winrm`, or `paramiko`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`ansible_connection`是`ssh`，你无需在清单中提及该项。如果你使用其他连接类型，则需要指定它们，例如`local`、`winrm`或`paramiko`。
- en: Add any number of nodes here with multiple host groups (as the `dev` host group
    in the preceding example).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在此添加任意数量的节点，并使用多个主机组（如前面示例中的`dev`主机组）。
- en: 'Now, test your inventory to make sure Ansible is able to read and understand
    your inventory and hosts. Please note that you are not connecting to the hosts
    from Ansible using this command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试你的清单，确保Ansible能够读取和理解你的清单和主机。请注意，你并没有通过此命令连接到主机：
- en: '![Figure 1.20 – List inventory hosts  ](img/B18383_01_20.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.20 – 列出清单主机](img/B18383_01_20.jpg)'
- en: Figure 1.20 – List inventory hosts
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20 – 列出清单主机
- en: 'Create another inventory file with some dummy managed nodes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建另一个包含一些虚拟托管节点的清单文件：
- en: '![Figure 1.21 – Another Ansible inventory with more hosts and groups  ](img/B18383_01_21.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.21 – 另一个具有更多主机和组的Ansible清单](img/B18383_01_21.jpg)'
- en: Figure 1.21 – Another Ansible inventory with more hosts and groups
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.21 – 另一个具有更多主机和组的Ansible清单
- en: 'In the preceding inventory, see the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的清单中，请参见以下内容：
- en: 'You have four host groups: `myself`, `intranet`, `database`, and `everyone`.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有四个主机组：`myself`、`intranet`、`database`和`everyone`。
- en: '`everyone` is the parent of the `myself`, `intranet`, and `database` host groups.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`everyone`是`myself`、`intranet`和`database`主机组的父组。'
- en: 'You have two inventory files here now:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有两个清单文件：
- en: '![Figure 1.22 – Multiple inventory files in project directory  ](img/B18383_01_22.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.22 – 项目目录中的多个清单文件](img/B18383_01_22.jpg)'
- en: Figure 1.22 – Multiple inventory files in project directory
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.22 – 项目目录中的多个清单文件
- en: 'To use a different inventory file, you do not need to change the content of
    `ansible.cfg`; instead, use the `-i` switch to specify the inventory file dynamically.
    Ansible will take the mentioned inventory files instead of the one configured
    in the `ansible.cfg` file as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用不同的清单文件，你无需更改`ansible.cfg`的内容；相反，使用`-i`开关动态指定清单文件。Ansible将采用指定的清单文件，而不是`ansible.cfg`文件中配置的文件，示例如下：
- en: '![Figure 1.23 – List inventory hosts with different a inventory file ](img/B18383_01_23.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.23 – 使用不同的清单文件列出清单主机](img/B18383_01_23.jpg)'
- en: Figure 1.23 – List inventory hosts with different a inventory file
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.23 – 使用不同的清单文件列出清单主机
- en: 'Use the `--help` options to see all the available switches with the Ansible
    command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--help`选项查看Ansible命令的所有可用开关：
- en: '![Figure 1.24 – List inventory hosts with different a inventory file ](img/B18383_01_24.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.24 – 使用不同的清单文件列出清单主机](img/B18383_01_24.jpg)'
- en: Figure 1.24 – List inventory hosts with different a inventory file
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.24 – 使用不同的清单文件列出清单主机
- en: 'It is also possible to use patterns to filter the managed hosts with supported
    patterns. For example, let us display only managed nodes with `*techbeatly.com`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用模式来过滤托管主机，支持的模式有很多。例如，我们可以仅显示`*techbeatly.com`的托管节点：
- en: '![Figure 1.25 – Host selection using patterns ](img/B18383_01_25.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.25 – 使用模式选择主机](img/B18383_01_25.jpg)'
- en: Figure 1.25 – Host selection using patterns
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.25 – 使用模式选择主机
- en: Ansible host patterns
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 主机模式
- en: Look up more information about patterns, targeting hosts, and groups at [https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.xhtml](https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.xhtml).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.xhtml](https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.xhtml)查阅有关模式、目标主机和组的更多信息。
- en: Look up more information about the Ansible dynamic inventory at [https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml](https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml)
    and [https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory](https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于 Ansible 动态库存的信息，请访问 [https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml](https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml)
    和 [https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory](https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory)。
- en: In the next section, we will learn how to configure managed nodes and connections.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何配置管理节点和连接。
- en: Configuring your managed nodes
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置你的管理节点
- en: Use any supported authentication mechanisms to connect from the Ansible control
    node to managed node, such as SSH key-based authentication, username and password-based
    authentication, and SSL certificate authentication, for example.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何支持的认证机制从 Ansible 控制节点连接到管理节点，例如基于 SSH 密钥的认证、基于用户名和密码的认证以及 SSL 证书认证等。
- en: Setting up SSH key-based authentication
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置基于 SSH 密钥的认证
- en: It is possible to automate most of the following steps using Ansible ad hoc
    commands, but we will be using the manual approach to understand what backend
    configurations are needed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ansible 的临时命令可以自动化大多数以下步骤，但我们将使用手动方法，以便了解所需的后台配置。
- en: 'The steps to create a user (for example devops) and enable SSH key based access
    on node-1 are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户（例如 devops）并在 node-1 上启用 SSH 密钥认证的步骤如下：
- en: 'Create a dedicated user on the target node (e.g.: node01) as follows. (This
    is not mandatory, and it is possible to use any existing user accounts and configure
    that in Ansible.):'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标节点上创建一个专用用户（例如：node01），步骤如下。（这不是强制的，也可以使用任何现有用户帐户，并在 Ansible 中进行配置。）
- en: '![Figure 1.26 – Create new user and set password  ](img/B18383_01_26.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.26 – 创建新用户并设置密码](img/B18383_01_26.jpg)'
- en: Figure 1.26 – Create new user and set password
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.26 – 创建新用户并设置密码
- en: If you do not have `ansible_host` option, or add entries in `/etc/hosts` as
    local DNS resolution.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `ansible_host` 选项，或者在 `/etc/hosts` 中添加条目以进行本地 DNS 解析。
- en: 'Enable the `sudo` access for the new user because, for any kind of privileged
    operation on the target node, you will be required to have this access:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用新用户的 `sudo` 访问权限，因为在目标节点执行任何特权操作时，必须具有此访问权限：
- en: '![Figure 1.27 – Enabled privileged access for the new user  ](img/B18383_01_27.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.27 – 为新用户启用特权访问](img/B18383_01_27.jpg)'
- en: Figure 1.27 – Enabled privileged access for the new user
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.27 – 为新用户启用特权访问
- en: 'Create an `SSH` key pair on the **Ansible control** **node**. It is possible
    to create any supported type and size. Please note, if you have any existing key
    with the same name, please remember to use a different name or backup the original
    SSH key pairs:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Ansible 控制** **节点** 上创建 `SSH` 密钥对。可以创建任何支持的类型和大小。请注意，如果已有相同名称的密钥，请记得使用不同的名称或备份原始
    SSH 密钥对：
- en: '![Figure 1.28 – Generating SSH key pair on Ansible control node  ](img/B18383_01_28.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.28 – 在 Ansible 控制节点上生成 SSH 密钥对](img/B18383_01_28.jpg)'
- en: Figure 1.28 – Generating SSH key pair on Ansible control node
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.28 – 在 Ansible 控制节点上生成 SSH 密钥对
- en: 'Verify the SSH key permissions:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 SSH 密钥权限：
- en: '![Figure 1.29 – Verify SSH key permission  ](img/B18383_01_29.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.29 – 验证 SSH 密钥权限](img/B18383_01_29.jpg)'
- en: Figure 1.29 – Verify SSH key permission
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.29 – 验证 SSH 密钥权限
- en: 'Copy the SSH public key from the Ansible control node to managed nodes under
    the `devops` user using the `ssh-copy-id` command:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ssh-copy-id` 命令将 SSH 公钥从 Ansible 控制节点复制到 `devops` 用户下的管理节点：
- en: '![Figure 1.30 – Copy SSH public key to managed node  ](img/B18383_01_30.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.30 – 将 SSH 公钥复制到管理节点](img/B18383_01_30.jpg)'
- en: Figure 1.30 – Copy SSH public key to managed node
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.30 – 将 SSH 公钥复制到管理节点
- en: If you have issues with password authentication or copying, then manually copy
    the public key content from `/home/ansible/.ssh/id_rsa.pub` to the `/home/devops/.ssh./authorized_keys`
    file on the managed node.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到密码认证或复制问题，可以手动将 `/home/ansible/.ssh/id_rsa.pub` 中的公钥内容复制到管理节点的 `/home/devops/.ssh/authorized_keys`
    文件中。
- en: 'Verify the passwordless SSH access from the Ansible control node to the managed
    node:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证从 Ansible 控制节点到管理节点的无密码 SSH 访问：
- en: '![Figure 1.31 – Login to managed node without password ](img/B18383_01_31.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.31 – 无密码登录到管理节点](img/B18383_01_31.jpg)'
- en: Figure 1.31 – Login to managed node without password
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.31 – 无密码登录到管理节点
- en: How to Set Up SSH Key-Based Authentication
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如何设置基于SSH密钥的认证
- en: Check out the steps on how to set up SSH key-based authentication at [https://www.techbeatly.com/2018/06/how-to-setup-ssh-key-based-authentication.xhtml](https://www.techbeatly.com/2018/06/how-to-setup-ssh-key-based-authentication.xhtml).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 查看如何设置基于SSH密钥的认证步骤，详见[https://www.techbeatly.com/2018/06/how-to-setup-ssh-key-based-authentication.xhtml](https://www.techbeatly.com/2018/06/how-to-setup-ssh-key-based-authentication.xhtml)。
- en: In the next section, we will explore the option to use multiple credential for
    different managed nodes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨使用多个凭据来管理不同受管节点的选项。
- en: Multiple users and credentials
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个用户和凭据
- en: 'If you have different credentials for different managed nodes, then configure
    the remote username, SSH key to be used, and more in your inventory file. Let
    me show a sample for our `node01` managed node in our inventory:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有不同的凭据用于不同的受管节点，请在你的清单文件中配置远程用户名、要使用的SSH密钥等信息。让我为我们的`node01`受管节点展示一个示例：
- en: '![Figure 1.32 – Configuring SSH key information for managed nodes  ](img/B18383_01_32.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.32 – 配置受管节点的SSH密钥信息](img/B18383_01_32.jpg)'
- en: Figure 1.32 – Configuring SSH key information for managed nodes
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.32 – 配置受管节点的SSH密钥信息
- en: In the latter example, we have used a variable section for the `dev` host group
    and mentioned the SSH key and remote user details.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的示例中，我们为`dev`主机组使用了一个变量部分，并提到了SSH密钥和远程用户的详细信息。
- en: Ansible ad hoc commands
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible即时命令
- en: The `ansible` command can be used to execute single jobs on managed nodes without
    a playbook; this is called an `ping`) to the managed nodes, creating a user account,
    copying some files, or restarting a service, and execute these tasks without writing
    an Ansible playbook.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible`命令可用于在受管节点上执行单个任务而无需剧本；这被称为`ping`）到受管节点，创建一个用户帐户、复制一些文件或重启一个服务，并执行这些任务而不编写Ansible剧本。'
- en: 'For example, it is possible to use the `ping` module to test the connection
    from Ansible to the managed node, `node01`, using this user and SSH key pair:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用`ping`模块测试从Ansible到受管节点`node01`的连接，使用此用户和SSH密钥对：
- en: '![Figure 1.33 – Ansible ad hoc command using ping module  ](img/B18383_01_33.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.33 – 使用ping模块的Ansible即时命令](img/B18383_01_33.jpg)'
- en: Figure 1.33 – Ansible ad hoc command using ping module
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.33 – 使用ping模块的Ansible即时命令
- en: In the preceding snippet, as you have `localhost` also in the inventory (by
    implicit), the task will be executed on both localhost and node01 nodes when you
    mention `all`. The Ansible `ping` module is not just a regular network ping (ICMP);
    instead, it will log in to the managed node and return the result, `pong`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，由于你的`localhost`也包含在清单中（隐式地），当你提到`all`时，任务将在`localhost`和`node01`节点上执行。Ansible的`ping`模块不仅仅是一个常规的网络ping（ICMP）；它将登录到受管节点并返回结果`pong`。
- en: 'Execute another Ansible ad hoc command using the `shell` module to check what
    remote user Ansible is using for connection:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`shell`模块执行另一个Ansible即时命令，检查Ansible用于连接的远程用户：
- en: '![Figure 1.34 – Ansible ad hoc command using shell module  ](img/B18383_01_34.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.34 – 使用shell模块的Ansible即时命令](img/B18383_01_34.jpg)'
- en: Figure 1.34 – Ansible ad hoc command using shell module
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.34 – 使用shell模块的Ansible即时命令
- en: From the preceding output, see that `localhost` is executed with the default
    `ansible` user and the `dev` node with the `devops` user.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看到，`localhost`是以默认的`ansible`用户执行的，而`dev`节点是以`devops`用户执行的。
- en: 'Now, execute multiple commands using the `shell` module:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`shell`模块执行多个命令：
- en: '![Figure 1.35 – Multiple commands in shell module  ](img/B18383_01_35.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.35 – 在shell模块中执行多个命令](img/B18383_01_35.jpg)'
- en: Figure 1.35 – Multiple commands in shell module
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.35 – 在shell模块中执行多个命令
- en: Please note that the preceding example was used to demonstrate the `shell` module,
    and similar details can be collected using `ansible_facts` without such tasks.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例用于演示`shell`模块，类似的细节可以使用`ansible_facts`收集，而无需此类任务。
- en: '![Figure 1.36 – Ansible ad hoc command using setup module ](img/B18383_01_36.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.36 – 使用setup模块的Ansible即时命令](img/B18383_01_36.jpg)'
- en: Figure 1.36 – Ansible ad hoc command using setup module
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.36 – 使用setup模块的Ansible即时命令
- en: You will learn more about `ansible_facts` in [*Chapter 3*](B18383_03.xhtml#_idTextAnchor052),
    *Automating Your Daily Jobs*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[*第3章*](B18383_03.xhtml#_idTextAnchor052)，*自动化你的日常任务*中了解更多关于`ansible_facts`的内容。
- en: Installing a package using Ansible
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ansible安装软件包
- en: You need to ensure that you have package repositories (`yum` or `apt`) configured
    and enabled on the target machine.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保目标机器上配置并启用了软件包仓库（`yum`或`apt`）。
- en: 'Install the `vim` package on `node01`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `node01` 上安装 `vim` 包：
- en: '![Figure 1.37 – Ansible ad hoc command using dnf module ](img/B18383_01_37.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.37 – 使用 dnf 模块的 Ansible 临时命令](img/B18383_01_37.jpg)'
- en: Figure 1.37 – Ansible ad hoc command using dnf module
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.37 – 使用 dnf 模块的 Ansible 临时命令
- en: 'From the preceding output, see that you are using the `devops` user for connecting
    to managed nodes, which is a normal user. You do not need to add the `become`
    details in `ansible.cfg`; instead, pass this `become` switch while executing the
    `ansible` command, which is `-b`. (For Ansible playbooks, you can enable or disable
    the privilege escalation at the play level or tasks level):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出中可以看出，你正在使用 `devops` 用户连接到管理节点，这个用户是普通用户。你无需在 `ansible.cfg` 中添加 `become`
    相关设置；相反，在执行 `ansible` 命令时，传递此 `become` 开关，即 `-b`。 (对于 Ansible playbook，你可以在 play
    层级或任务层级启用或禁用特权提升)：
- en: '![Figure 1.38 – Installing package using dnf module and privileged mode  ](img/B18383_01_38.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.38 – 使用 dnf 模块和特权模式安装包](img/B18383_01_38.jpg)'
- en: Figure 1.38 – Installing package using dnf module and privileged mode
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.38 – 使用 dnf 模块和特权模式安装包
- en: The package installation is successful as per the output.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 根据输出，包的安装已成功。
- en: 'The preceding ad hoc execution can be written in a playbook as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的临时执行可以按如下方式写入 playbook：
- en: '![Figure 1.39 – Package installation using an Ansible playbook ](img/B18383_01_39.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.39 – 使用 Ansible playbook 安装包](img/B18383_01_39.jpg)'
- en: Figure 1.39 – Package installation using an Ansible playbook
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.39 – 使用 Ansible playbook 安装包
- en: You will learn more about writing playbooks in [*Chapter 2*](B18383_02.xhtml#_idTextAnchor043),
    *Starting with Simple Automation*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会在[*第 2 章*](B18383_02.xhtml#_idTextAnchor043)，*从简单的自动化开始*，学习更多关于编写 playbook
    的内容。
- en: 'Now, remove the same package using an Ansible ad hoc command; instead of `state=latest`,
    use `state=absent`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 Ansible 临时命令移除相同的包；将 `state=latest` 替换为 `state=absent`：
- en: '![Figure 1.40 – Removing package using Ansible ad hoc command  ](img/B18383_01_40.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.40 – 使用 Ansible 临时命令移除包](img/B18383_01_40.jpg)'
- en: Figure 1.40 – Removing package using Ansible ad hoc command
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.40 – 使用 Ansible 临时命令移除包
- en: We have now successfully installed and uninstalled a package using Ansible.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功使用 Ansible 安装和卸载了一个包。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, you have learned about the core concepts of Ansible, how Ansible
    works, and the key terminology, including Ansible inventory, playbooks, tasks,
    Ansible control node, managed nodes, and modules. You have also learned about
    basic Ansible installation, configuration, and deployment, and the importance
    of managed node configuration, SSH key credentials, and passwordless SSH.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经了解了 Ansible 的核心概念，Ansible 的工作原理以及关键术语，包括 Ansible 清单、playbook、任务、Ansible
    控制节点、管理节点和模块。你还学习了基本的 Ansible 安装、配置和部署，以及管理节点配置、SSH 密钥凭证和无密码 SSH 的重要性。
- en: In the next chapter, you will learn how to start with simple automation playbooks
    and execution. Then, you will learn how to find suitable Ansible modules for playbook
    development and remote node connection methods.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何从简单的自动化 playbook 和执行开始。接着，你将学习如何找到适合的 Ansible 模块用于 playbook 开发和远程节点连接方式。
- en: Further reading
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Ansible documentation*: https://docs.ansible.com/ansible/latest/index.xhtml'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ansible 文档*: https://docs.ansible.com/ansible/latest/index.xhtml'
- en: '*Ansible control node requirements*: https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#control-node-requirements'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ansible 控制节点要求*: https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#control-node-requirements'
- en: '*Ansible dynamic inventory*: https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml
    and https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ansible 动态清单*: https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.xhtml
    和 https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory'
- en: '*Ansible Automation Platform*: https://www.ansible.com/blog/introducing-red-hat-ansible-automation-platform'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ansible 自动化平台*: https://www.ansible.com/blog/introducing-red-hat-ansible-automation-platform'
- en: '*Installing Ansible*: https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安装 Ansible*: https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml'
- en: '*How network automation is different*: https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.xhtml'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网络自动化的不同之处*: https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.xhtml'
