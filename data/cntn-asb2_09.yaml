- en: Going Further with Ansible Container
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探索Ansible Container
- en: In the introductory chapters of this book, we learned how trends in the IT industry
    have fundamentally shifted and shaped the ways in which applications and services
    are designed and deployed. With the rise of consumption of high-CPU and bandwidth-intensive
    services, consumers are regularly demanding more features, have zero-tolerance
    to outages, and want more options to consume services and applications. In response
    to this shift, no longer can monolithic application deployments and static servers
    be the backbone of this aging infrastructure. Even configuration management and
    automation tools, as dynamic as they are, cannot keep up with the need for organizations
    to continually scale out existing infrastructure footprints across a variety of
    platforms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的引言章节中，我们了解了信息技术（IT）行业的趋势如何发生根本性的变化，并塑造了应用程序和服务的设计与部署方式。随着高CPU和带宽密集型服务的消费需求上升，消费者经常要求更多功能，容忍不了故障，并且希望有更多选项来消费服务和应用程序。为了应对这种变化，单体应用程序部署和静态服务器不再能作为这一老化基础设施的支柱。即便是配置管理和自动化工具，尽管它们非常动态，也无法满足组织在各种平台上不断扩展现有基础设施的需求。
- en: In response to this trend, containerization platforms such as Docker rose to
    the challenge to address the need deploy and manage applications consistently
    and reliably. Docker containers enable businesses and organizations to adopt a
    modular infrastructure footprint in which applications can be built entirely self-contained
    and guaranteed to run on any system that uses a compatible container runtime environment.
    This allows software developers and DevOps engineers to rapidly build microservice
    applications, similar in many respects to Lego bricks that can be stuck together
    to design large and complex software stacks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为应对这一趋势，像Docker这样的容器化平台迎接挑战，解决了需要一致且可靠地部署和管理应用程序的问题。Docker容器使得企业和组织能够采用模块化的基础设施，使得应用程序可以完全自包含地构建，并保证能够在任何使用兼容容器运行时环境的系统上运行。这使得软件开发人员和DevOps工程师能够快速构建微服务应用程序，类似于许多方面的乐高积木，可以将它们组合在一起设计出大型且复杂的软件堆栈。
- en: While microservice applications seem to be the answer to many problems plaguing
    the industry today, conventional methods of building and deploying microservice
    applications are proving to be less robust and give the operators of these services
    fewer options to truly build and configure container images that meet the needs
    of organizations. The Ansible Container project seeks to meet this need by filling
    the gap between traditional configuration management and the container build and
    deploy pipeline. As we have seen throughout this book, Ansible Container can be
    leveraged to not only use the power of Ansible to build truly customized container
    images, but also to manage the life cycle of containerized software from development
    all the way to production.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微服务应用程序似乎解决了许多当今行业中的问题，但构建和部署微服务应用程序的传统方法正证明不足以满足需求，并且使这些服务的运营人员在真正构建和配置满足组织需求的容器镜像时面临更少的选择。Ansible
    Container项目旨在填补传统配置管理与容器构建和部署流水线之间的空白。正如我们在本书中所看到的，Ansible Container不仅可以利用Ansible的强大功能来构建真正定制的容器镜像，还可以管理容器化软件的生命周期，从开发一直到生产。
- en: In this, the final chapter of this book, I want to provide the reader with resources
    they can use to move forward with building and deploying containerized projects
    using Ansible Container, far beyond the scope of this book. Although we have covered
    all of the functional aspects of using and working with Ansible Container, microservice
    architecture is a rapidly growing field that is constantly changing and growing
    with the open source communities that author them. This chapter aims to point
    the reader in helpful directions that can be used as a starting point from which
    to grow in your knowledge of containerized software, provide helpful hints and
    tips for managing containers at scale, and also use your newly-found knowledge
    to help grow the open source communities around these projects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章，我想为读者提供一些资源，帮助他们在使用Ansible Container构建和部署容器化项目时，走得更远，超越本书的范围。尽管我们已经涵盖了使用和操作Ansible
    Container的所有功能方面，微服务架构是一个快速发展的领域，它不断随着开源社区的变化和发展而变化。本章旨在为读者指引一些有用的方向，作为扩展容器化软件知识的起点，提供管理大规模容器的有用提示，并运用你新获得的知识，帮助推动围绕这些项目的开源社区的发展。
- en: 'In this final chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将涵盖以下主题：
- en: Tips for writing roles and container apps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写角色和容器应用的技巧
- en: Building powerful deployment playbooks with Ansible Container
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible Container 构建强大的部署 playbook
- en: Tips for troubleshooting application containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排除应用容器故障的技巧
- en: CICD deployments with Jenkins or Travis CI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jenkins 或 Travis CI 进行 CICD 部署
- en: Sharing roles and apps on GitHub and Ansible Galaxy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GitHub 和 Ansible Galaxy 上共享角色和应用
- en: Containerize everything
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化一切
- en: Tips for writing roles and container apps
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写角色和容器应用的技巧
- en: If you are new to Ansible and playbook syntax, it can be quite easy to get confused
    when writing playbooks for the first time. Although Ansible is inherently a very
    readable and non-programmer friendly language to approach, there are a few *gotchas*
    one should keep in mind when writing roles or container apps to maximize usability.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是第一次接触 Ansible 和 playbook 语法，在编写 playbook 时很容易感到困惑。尽管 Ansible 本身是一种非常易读且对非程序员友好的语言，但在编写角色或容器应用时，仍有一些*陷阱*需要记住，以便最大限度地提高可用性。
- en: Use full YAML syntax
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用完整的 YAML 语法
- en: A personal pet peeve of mine when working with Ansible code is when the author
    uses what I call the *condensed method* of writing a playbook. Essentially, functional
    Ansible code can be written so that module calls and attributes can be written
    on the same line, using an equals sign (`=`) to separate attributes and values,
    as seen in the following code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在使用 Ansible 代码时，一个个人的恼怒点是作者使用我所称之为*简化方法*来编写 playbook。实际上，功能性的 Ansible 代码可以通过将模块调用和属性写在同一行上，使用等号（`=`）来分隔属性和值，就像下面的代码所示。
- en: '**Condensed method sample code**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**简化方法示例代码**：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Proper YAML syntax sample code**:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**正确的 YAML 语法示例代码**：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the condensed method and proper YAML syntax are functionally
    the same, but they are visually different. Using proper YAML syntax defines module
    calls across multiple lines and requires the user to indent module attributes
    underneath the definition of the module call itself. This makes playbooks much
    easier to read at a glance, and a lot easier to debug when looking for errors.
    Using proper YAML syntax also ensures that your text editor can perform proper
    syntax highlighting of your code since it conforms to standard YAML conventions.
    Using the condensed method, however, one can write Ansible code more *quickly*,
    but at the cost of readability and usability for others who might use your playbooks
    in the future. Not only is it visually unappealing, but makes reading the code
    and understanding the functionality a difficult experience. A best practice is
    to get into the habit of writing Ansible playbooks and roles using full YAML syntax
    and indentation. Others who use your code and contribute to it will thank you.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，简化方法和正确的 YAML 语法在功能上是相同的，但它们在视觉上有所不同。使用正确的 YAML 语法会将模块调用分布在多行上，并要求用户将模块属性缩进到模块调用的定义下方。这使得
    playbook 更容易一眼看懂，也更容易在查找错误时进行调试。使用正确的 YAML 语法还能确保你的文本编辑器可以对代码进行正确的语法高亮显示，因为它符合标准的
    YAML 规范。然而，使用简化方法虽然可以*更快速*地编写 Ansible 代码，但却牺牲了可读性和可用性，尤其是对于未来可能使用你 playbook 的其他人而言。这不仅在视觉上不吸引人，而且使得阅读代码和理解功能变得困难。最佳实践是养成使用完整的
    YAML 语法和缩进来编写 Ansible playbook 和角色的习惯。其他使用你代码并为其贡献的人会感谢你。
- en: Use Ansible modules
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 模块
- en: When first starting writing Ansible playbooks and roles, it is quite tempting
    to use the `shell` or `command` modules for almost every task. If one has a firm
    understanding of BASH and the suite of GNU/Linux tools and utilities that come
    natively with most Linux-based operating systems, it is logical to want to build
    playbooks using the shell or command modules. The problem with this approach is
    that it ignores the family of over a thousand unique Ansible modules that ship
    out of the box with Ansible.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚开始编写 Ansible playbook 和角色时，人们很容易对几乎所有任务都使用 `shell` 或 `command` 模块。如果你对 BASH
    以及大多数 Linux 操作系统中原生提供的 GNU/Linux 工具和实用程序有扎实的理解，那么使用 shell 或 command 模块来构建 playbook
    是合乎逻辑的。但这种方法的问题在于，它忽视了 Ansible 自带的超过千个独特模块。
- en: While `shell` and `command` do have their place under some circumstances, you
    should look first to see if there is an Ansible module that can programmatically
    do what you are trying to accomplish. The benefit of using an Ansible module,
    instead of running commands directly on the shell, is that Ansible modules have
    the ability to evaluate idempotency and take action only if the target is not
    in the desired state. While it is possible to use the command-line modules idempotently,
    it is far more difficult. Furthermore, Ansible modules have the unique ability
    to store and retrieve metadata about tasks in memory. For example, you could add
    the register line in a task definition to store the task metadata to a variable
    named `task_output`. Later in the playbook, you could check if that task performed
    a change on the system by checking if `task_output.changed == true` and take action
    accordingly. Similarly, this same logic can be used to check the return codes
    of tasks, search for metadata, or take actions if tasks have failed. Using modules
    gives you the freedom to leverage Ansible to work exactly the way you want it
    to.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`shell`和`command`在某些情况下确实有其作用，但你应该首先检查是否有 Ansible 模块可以编程地完成你想要实现的目标。使用 Ansible
    模块而不是直接在 shell 上运行命令的好处在于，Ansible 模块具有评估幂等性的能力，并且只有在目标不处于所需状态时才会采取行动。虽然使用命令行模块也能实现幂等性，但这要难得多。此外，Ansible
    模块具有独特的能力，可以在内存中存储和检索任务的元数据。例如，你可以在任务定义中添加 `register` 行，将任务元数据存储到名为 `task_output`
    的变量中。在 playbook 中，你可以通过检查 `task_output.changed == true` 来查看该任务是否对系统进行了更改，并据此采取相应的行动。同样，这一逻辑也可以用于检查任务的返回代码、搜索元数据或在任务失败时采取行动。使用模块使你能够自由地利用
    Ansible 按照你想要的方式工作。
- en: Build powerful deployment playbooks with Ansible Core
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible Core 构建强大的部署 playbook
- en: As we have looked at throughout this chapter, Ansible Core is essentially the
    engine that works behind the scenes during the execution of a deployment. We looked
    at extracting these playbooks from the `ansible-deployment` directory and running
    them manually, passing in the corresponding tags to manually execute the run,
    stop, restart, and destroy functionality. However, these playbooks are generally
    limited and quite basic in form and function. Don't think for a moment that for
    deploying projects you are only limited to running the `ansible-container deploy`
    command, or executing the deployment playbooks manually. If you look at the deployment
    playbooks that are automatically generated, you will notice that they make calls
    to the `docker_service` module, which is a module featured in Ansible Core. Using
    a similar methodology, you can write your own playbooks to build completely custom
    deployments outside the scope of Ansible Container.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中所看到的，Ansible Core 本质上是在部署执行过程中后台工作的引擎。我们查看了如何从 `ansible-deployment`
    目录中提取这些 playbook 并手动运行它们，传入相应的标签手动执行运行、停止、重启和销毁功能。然而，这些 playbook 一般都是有限的，形式和功能都很基础。不要以为在部署项目时，你只能局限于运行
    `ansible-container deploy` 命令，或者手动执行部署 playbook。如果你查看自动生成的部署 playbook，你会注意到它们调用了
    `docker_service` 模块，这是 Ansible Core 中的一个模块。使用类似的方法，你可以编写自己的 playbook 来构建完全自定义的部署，超出
    Ansible Container 的范围。
- en: 'An excellent use case for this scenario might be that you have other services
    that are dependent on the status of the containerized project you built with Ansible
    Container. These services could be monitoring services, a database cluster, or
    even an external infrastructure API that you want your containers to pull data
    from during the launch process. Using a separate Ansible Core playbook, you could
    completely orchestrate the process of launching your containers and interacting
    with the dependent services. Here is an example code snippet, to help give you
    some inspiration. Notice we are defining the project name as a variable that we
    are also passing into the REST API call to register the service:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的使用案例可能是你有其他服务，这些服务依赖于你使用 Ansible Container 构建的容器化项目的状态。这些服务可以是监控服务、数据库集群，甚至是你希望在启动过程中让容器拉取数据的外部基础设施
    API。通过使用单独的 Ansible Core playbook，你可以完全控制启动容器并与依赖服务交互的过程。这里有一个示例代码片段，帮助你获得一些灵感。请注意，我们将项目名称定义为一个变量，并将其传递到
    REST API 调用中，以注册服务：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, using Ansible Core playbooks to deploy containerized infrastructure
    can be an immensely powerful tool. When Ansible Core playbook modules to abstract
    your deployments, you are only limited by your imagination.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 Ansible Core playbooks 部署容器化基础设施是一个非常强大的工具。当使用 Ansible Core playbook
    模块来抽象化你的部署时，你的想象力将是唯一的限制。
- en: Troubleshooting application containers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除应用容器
- en: 'Inevitably during the course of building containerized services and applications,
    you will encounter the need to troubleshoot misbehaving containers. Sometimes,
    containers fail to start due to a misconfigured `container start` command or entry
    point. Other times, the container itself starts to throw errors that need to be
    debugged or diagnosed. Most of the time, these issues can be looked at by examining
    the container logs or viewing the container runtime details in OpenShift, Docker,
    or Kubenetes. Following is a list of commands for the respective containerized
    runtime environment I have found the most helpful over the years:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建容器化服务和应用程序的过程中，您不可避免地会遇到需要排查异常容器的情况。有时，容器由于配置错误的 `container start` 命令或入口点而无法启动。其他时候，容器本身会开始抛出错误，需进行调试或诊断。大多数情况下，可以通过查看容器日志或在
    OpenShift、Docker 或 Kubernetes 中查看容器运行时详细信息来排查这些问题。以下是我多年来在不同容器化运行时环境中找到的最有帮助的命令列表：
- en: '**Docker**:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：'
- en: '`docker logs`: Use the `docker logs` command to view the standard out logs
    for any stopped, running, or exited container. Oftentimes, when containers have
    stopped, the last message they logged to standard out will confirm the cause of
    the container stop. Docker logs are also useful for debugging errors as they happen
    in the container in real-time. The full syntax for this command is `docker logs
    [container name or ID]`.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker logs`：使用 `docker logs` 命令查看任何已停止、正在运行或退出的容器的标准输出日志。通常情况下，当容器停止时，它们最后一条记录的标准输出消息会确认容器停止的原因。Docker
    日志也有助于实时调试容器中的错误。此命令的完整语法是 `docker logs [容器名称或 ID]`。'
- en: '`docker inspect`: This can be used to view the all attributes and configuration
    details for almost any Docker resource, such as containers, networks, or storage
    volumes, in JSON format. `inspect` is useful for understanding how Docker itself
    sees the respective resource and whether it is picking up certain configuration
    parameters. The full syntax for inspect is `docker inspect [docker resource name
    or ID]`.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker inspect`：此命令可用于查看几乎所有 Docker 资源的所有属性和配置细节，如容器、网络或存储卷，以 JSON 格式显示。`inspect`
    命令对于理解 Docker 如何查看相应的资源以及它是否获取了某些配置参数非常有用。`inspect` 的完整语法是 `docker inspect [docker
    资源名称或 ID]`。'
- en: '**Kubernetes**:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes**：'
- en: '`kubectl logs`: `kubectl logs` is used to view the logs of a pod running in
    Kubernetes. Often, the `kubectl logs` output will be similar to the `docker logs`
    output, if Kubernetes is using Docker as the underlying container runtime environment.
    However, using Kubernetes to natively relay the log output allows the user to
    retrieve the logs using native Kubernetes abstractions, which may give an indication
    where the issue rests. It is also helpful to view the container runtime logs in
    conjunction with the Kubernetes logs. The full syntax for `kubectl logs` is `kubectl
    logs [full pod name] --namespace [namespace name]`.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl logs`：`kubectl logs` 用于查看 Kubernetes 中运行的 Pod 的日志。如果 Kubernetes 使用
    Docker 作为底层容器运行时环境，则 `kubectl logs` 输出通常与 `docker logs` 输出类似。然而，使用 Kubernetes
    原生转发日志输出可以让用户通过 Kubernetes 原生抽象检索日志，这可能有助于指示问题所在。结合查看容器运行时日志和 Kubernetes 日志也是非常有帮助的。`kubectl
    logs` 的完整语法是 `kubectl logs [完整 Pod 名称] --namespace [命名空间名称]`。'
- en: '`kubectl describe`: `describe` is useful for viewing verbose output and configuration
    parameters for almost any Kubernetes resource. It can be used on cluster nodes,
    pods, namespaces, replica sets, and services, to name a few. Using `describe`,
    one can view resource labels, event messages, and other configuration options.
    The major benefit of `kubectl describe` is being able to describe almost any cluster
    resource to troubleshoot issues, whether it is a cluster node or a misbehaving
    pod. The full syntax for describe is `kubectl describe [resource type] [resource
    name] --namespace [namespace name if applicable]`.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl describe`：`describe` 用于查看几乎任何 Kubernetes 资源的详细输出和配置参数。可以在集群节点、Pod、命名空间、副本集和服务等资源上使用。使用
    `describe`，可以查看资源标签、事件消息以及其他配置选项。`kubectl describe` 的主要好处是能够描述几乎任何集群资源，帮助排查问题，无论是集群节点还是行为异常的
    Pod。`describe` 的完整语法是 `kubectl describe [资源类型] [资源名称] --namespace [命名空间名称（如适用）]`。'
- en: '**OpenShift**:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenShift**:'
- en: '`oc logs`: `oc logs` is quite similar to `kubectl logs` and `docker logs` in
    that it allows the user to view the logs specific to a specific running or restarting
    pod. Similar to Kubernetes, it is often quite helpful to compare the `oc logs`
    output with the output of `docker logs` to try and pinpoint the source of the
    issue. The full syntax for `oc logs` is `oc logs [pod or resource name]`.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oc logs`：`oc logs` 与 `kubectl logs` 和 `docker logs` 非常相似，它允许用户查看特定运行或重启中的
    Pod 的日志。与 Kubernetes 类似，比较 `oc logs` 的输出和 `docker logs` 的输出通常非常有助于定位问题的根源。`oc
    logs` 的完整语法是 `oc logs [pod 或资源名称]`。'
- en: '`oc debug`: `debug` is used to create an exact copy of the troublesome pod
    or deployment to examine without interrupting the running service. Using `debug`,
    you can pass commands into the copied pod that can be used for debugging purposes,
    such as opening a shell or dumping environment variables. The full syntax for
    debug is `oc debug [pod, deployment, or resource name] -- [command to execute]`.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oc debug`：`debug` 用于创建问题 Pod 或部署的精确副本，以便在不干扰运行服务的情况下进行检查。使用 `debug`，可以向复制的
    Pod 中传入命令，进行调试操作，如打开 shell 或转储环境变量。`debug` 的完整语法是 `oc debug [pod、deployment 或资源名称]
    -- [要执行的命令]`。'
- en: Create a build pipeline using Jenkins or TravisCI
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jenkins 或 TravisCI 创建构建流水线
- en: In recent years, the idea of **continuous integration continuous deployment**
    (**CICD**) has taken the software development community by storm. Rich projects
    such as Jenkins, TeamCity, and TravisCI have given developers automated frameworks
    from which code changes can automatically be built, tested, and upon passing,
    deployed across the infrastructure. Leveraging CICD tools, developers using rapid
    software development methodologies such as Agile can deploy software faster and
    more reliably than ever before.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，**持续集成持续部署**（**CICD**）的概念已经在软件开发社区掀起了热潮。像 Jenkins、TeamCity 和 TravisCI 这样的丰富项目为开发人员提供了自动化框架，代码更改可以自动构建、测试，并在通过后部署到基础设施上。通过使用
    CICD 工具，采用敏捷等快速软件开发方法的开发人员可以比以往更快、更可靠地部署软件。
- en: Most CICD tools and workflows function by defining jobs that have specific triggers
    they are listening for. These triggers could be code check-ins in a Git repository,
    users manually kicking off builds, or automated processes that call the CICD API
    directly. These jobs perform very specific and automated functions such as building
    code, running tests against the newly built code, and even handling the deployment
    of code changes. The CICD jobs even have the capability of sending notifications
    to chatrooms or email if a build, testing, or deploy step fails. Some are even
    sophisticated enough to notify the user who checked in the code if that particular
    change is breaking the build. The major benefit of CICD rests in the automation
    it provides to software developers to ensure these jobs are performed reliably,
    consistently, and regularly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 CICD 工具和工作流通过定义具有特定触发条件的任务来运行。这些触发条件可以是 Git 仓库中的代码提交、用户手动启动构建，或是直接调用 CICD
    API 的自动化过程。这些任务执行非常具体和自动化的功能，如构建代码、对新构建的代码进行测试，甚至处理代码变更的部署。CICD 任务甚至可以在构建、测试或部署步骤失败时向聊天室或电子邮件发送通知。有些甚至足够智能，能够通知提交代码的用户，如果某个特定的变更导致了构建失败。CICD
    的主要好处在于它为软件开发人员提供的自动化，确保这些任务能够可靠、一致和定期地执行。
- en: 'Imagine for a moment what a huge benefit CICD tools could provide to Ansible
    Container projects:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，CICD 工具为 Ansible 容器项目带来的巨大好处：
- en: '`ansible-container build` automatically executed upon checking code into a
    certain Git repository branch'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检查代码到某个 Git 仓库分支时自动执行 `ansible-container build`
- en: '`ansible-container run` executed on the CICD host to bring up the containers
    locally and fire off smoke tests to ensure the containers are running as expected'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 CICD 主机上执行 `ansible-container run`，以在本地启动容器并触发烟雾测试，以确保容器按预期运行
- en: If the build and testing steps pass, `ansible-container push` could be executed
    on the images, which tags them with a specific build number and pushes them to
    a container image registry such as Docker Hub
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果构建和测试步骤通过，可以在镜像上执行 `ansible-container push`，它会用特定的构建号标记这些镜像，并将它们推送到容器镜像注册中心，如
    Docker Hub
- en: Automatically kicking off `ansible-container deploy` and `ansible-container
    run` to deploy projects into specific environments (even production!)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动触发 `ansible-container deploy` 和 `ansible-container run`，将项目部署到特定环境（甚至是生产环境！）
- en: 'Using automated CICD tools, you can take steps towards moving your infrastructure
    further towards a fully automatic build and deploy pipeline that does not involve
    human intervention at all. If you are curious to see what CICD tools can do for
    you and your workflow, I would suggest that you sign up for a free Travis CI account
    at [https://travisci.org](https://travisci.org). If you are interested in a fully
    free and open source solution to deploy in your own infrastructure, I would recommend
    Jenkins: [https://jenkins.io](https://jenkins.io).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动化的 CICD 工具，你可以朝着完全自动化的构建和部署流水线迈进，这个过程完全不需要人工干预。如果你对 CICD 工具如何帮助你和你的工作流程感到好奇，我建议你注册一个免费的
    Travis CI 账户：[https://travisci.org](https://travisci.org)。如果你对一个完全免费的开源解决方案，用于在自己的基础设施中部署，我推荐
    Jenkins：[https://jenkins.io](https://jenkins.io)。
- en: 'Additionally, you can look at the Travis CI build pipelines that build some
    of the Ansible Container projects we worked through throughout this book. For
    example, you can find the `django-gulp-nginx` project here: [https://travis-ci.org/ansible/django-gulp-nginx](https://travis-ci.org/ansible/django-gulp-nginx).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以查看 Travis CI 构建流水线，这些流水线构建了我们在本书中涉及的一些 Ansible 容器项目。例如，你可以在这里找到 `django-gulp-nginx`
    项目：[https://travis-ci.org/ansible/django-gulp-nginx](https://travis-ci.org/ansible/django-gulp-nginx)。
- en: Share roles and apps on GitHub and Ansible Galaxy
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 GitHub 和 Ansible Galaxy 上共享角色和应用程序
- en: 'Ansible Galaxy is an absolutely fantastic resource to leverage to reuse some
    of the best playbooks and roles developed by the community. As we have seen throughout
    the book, Ansible Galaxy hosts hundreds of Ansible Core roles, container roles,
    and container apps. These projects are developed and shared with the community
    due to the friendly and altruistic nature of the stellar and incredibly smart
    people who make up the vast Ansible ecosystem. Sharing Ansible roles on Galaxy,
    however, is not just reserved for a select few Ansible veterans. Anyone can sign
    up for an account on [https://galaxy.ansible.com](https://galaxy.ansible.com)
    and share a project already hosted in a GitHub repository. In my experience working
    with the Ansible community, if you develop a super-cool role or app that solves
    a problem, it is almost guaranteed there are others out there struggling with
    the same problem. By contributing your code to Ansible Galaxy, you are not only
    helping others, you are also opening the door to allow others to help you as well.
    Oftentimes, others will contribute to your code directly or by leaving feedback
    for ideas and suggestions for how things can be improved or fixed. Newer and better
    versions of your code can be contributed from community members and reused to
    help make your life even easier. That''s one of the most powerful things I love
    so much about open source software: we can achieve as a community what is oftentimes
    very difficult to achieve on our own.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Galaxy 是一个绝对棒的资源，可以用来复用社区开发的最佳 playbooks 和角色。如我们在本书中所见，Ansible Galaxy
    主持了数百个 Ansible 核心角色、容器角色和容器应用。这些项目是由社区开发并分享的，得益于组成庞大 Ansible 生态系统的那些杰出且聪明的人的友好与无私的精神。然而，分享
    Ansible 角色到 Galaxy 并不仅仅是为了一些 Ansible 老手准备的。任何人都可以在 [https://galaxy.ansible.com](https://galaxy.ansible.com)
    注册一个账户，并分享已经托管在 GitHub 仓库中的项目。在我与 Ansible 社区合作的经验中，如果你开发了一个非常酷的角色或应用，能够解决某个问题，几乎可以保证会有其他人也在为解决相同的问题而挣扎。通过将你的代码贡献到
    Ansible Galaxy，你不仅是在帮助他人，还在为他人帮助你打开大门。很多时候，别人会直接为你的代码贡献，或通过留下反馈，提出改进或修复的意见和建议。新的、更好的版本也可以由社区成员贡献，并被重新使用，从而让你的生活更加轻松。这正是我如此喜爱开源软件的原因之一：我们作为一个社区，可以实现那些通常很难单独完成的目标。
- en: 'At the very least, you should check your code into a GitHub repository to share
    your projects and make your code accessible to other users in the future. GitHub
    repositories are also useful for using version control on your projects and tracking
    changes. To use GitHub, sign up for an account at  [https://github.com](https://github.com):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，你应该将代码提交到 GitHub 仓库中，以便分享你的项目，并让其他用户在未来能够访问到你的代码。GitHub 仓库也有助于你对项目进行版本控制和跟踪变更。要使用
    GitHub，可以在 [https://github.com](https://github.com) 注册一个账户：
- en: '![](img/9083d652-35c8-415a-a02a-7437ba91f72e.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9083d652-35c8-415a-a02a-7437ba91f72e.png)'
- en: 'Figure 1: github.com homepage'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：github.com 首页
- en: 'From the [https://github.com/](https://github.com/) homepage, you can sign
    up for a free account by supplying a username, password, and valid email address.
    Once your account has been created and you have signed in for the first time,
    you can create a GitHub repository by clicking on the `+` (plus sign) dropdown
    in the upper-right corner of the screen and selecting New Repository. This will
    direct you to a form from which you can provide the details about the new project
    you wish to create:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://github.com/](https://github.com/) 首页，你可以通过提供用户名、密码和有效的电子邮件地址来注册一个免费账户。创建账户并首次登录后，你可以通过点击屏幕右上角的
    `+`（加号）下拉菜单，选择“新建仓库”来创建一个 GitHub 仓库。这将引导你进入一个表单页面，在这里你可以提供有关新项目的详细信息：
- en: '![](img/251d5b84-10e9-4d66-8a3e-7e9b2396a255.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/251d5b84-10e9-4d66-8a3e-7e9b2396a255.png)'
- en: 'Figure 2: Creating a new GitHub Repository'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：创建一个新的 GitHub 仓库
- en: 'Once the new GitHub repository has been created, you can clone the repo using
    the SSH or HTTPS link and start contributing code. Each GitHub repository has
    a unique public URL that can be used to share the link to the GitHub repository.
    This link is required to share your code on Ansible Galaxy:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新的 GitHub 仓库创建完成，你可以使用 SSH 或 HTTPS 链接克隆该仓库并开始贡献代码。每个 GitHub 仓库都有一个唯一的公共 URL，可以用来分享该仓库的链接。这个链接是将你的代码分享至
    Ansible Galaxy 所必需的：
- en: '![](img/6ef6b7de-23bc-44a4-a66d-80671ba47ed5.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ef6b7de-23bc-44a4-a66d-80671ba47ed5.png)'
- en: 'Figure 3: Cloning an empty Git repository'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：克隆一个空的 Git 仓库
- en: 'The following example demonstrates a sample Git workflow: cloning the repository,
    creating initial files, and committing them into the repository.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了一个典型的 Git 工作流程：克隆存储库，创建初始文件，并将它们提交到存储库中。
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For more information about Ansible Galaxy and sharing roles or apps online,
    please read the Ansible Galaxy documentation located at [https://galaxy.ansible.com/intro](https://galaxy.ansible.com/intro).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Ansible Galaxy 和在线共享角色或应用程序的更多信息，请阅读位于 [https://galaxy.ansible.com/intro](https://galaxy.ansible.com/intro)
    的 Ansible Galaxy 文档。
- en: Containerize everything!
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化一切！
- en: Progressing on your journey to a fully modular containerized infrastructure
    is an exciting one. I'm sure as you have worked your way through the examples
    contained within this book, you have undoubtedly caught container fever. Hopefully,
    you have seen how powerful containers can be, especially when run within container
    orchestration solutions such as Kubernetes and OpenShift. My last word of advice
    to you before our journey concludes is to keep it up! Now that you have a full
    understanding of the entire Ansible Container workflow, keep building projects
    and containerize as much as you possibly can. If the last few years have proven
    anything in the world of DevOps and infrastructure, it is that containers are
    the future of software as we know it. As more and more businesses and organizations
    adopt containerized solutions, the demand for qualified developers who have a
    firm understanding of building and deploying containers continues to grow.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在您迈向完全模块化的容器化基础设施的旅程中，这是一个令人兴奋的过程。我相信，当您逐步学习本书中包含的示例时，无疑会感染上容器热情。希望您已经看到了容器的强大之处，特别是在诸如
    Kubernetes 和 OpenShift 等容器编排解决方案中运行时。在我们的旅程结束之前，我给您的最后建议是坚持下去！现在您已经完全理解了整个 Ansible
    容器工作流程，请继续构建项目并尽可能容器化。在过去几年中，如果 DevOps 和基础设施领域有什么可以证明的，那就是容器是我们所知软件的未来。随着越来越多的企业和组织采用容器化解决方案，对具有构建和部署容器的坚实理解的合格开发人员的需求也在不断增长。
- en: 'It is my personal rule of thumb that I try to containerize everything, as often
    and as much as possible. Having reusable Docker containers for the applications
    I am working on gives me the ability to quickly build, destroy, deploy, and redeploy
    entire projects completely on my laptop at a moments notice. Using Ansible Container
    allows me, as a DevOps engineer, to build containers that speak the same language
    that my infrastructure speaks: Ansible. Using Ansible, I no longer have to mentally
    shift gears when working on infrastructure automation and building containerized
    projects. I can just as quickly develop containers as I can any other Ansible
    project I''m working on. This has given me tremendous drive and motivation to
    adapt my previously written Ansible roles to build and deploy Ansible containers
    that can run in any containerized environment, regardless of the platform or operating
    system. Subsequently, this also makes me think about current projects I am working
    on and how I can best adapt my automation strategy to fit into a containerized
    context.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人的经验法则是尽可能频繁地和尽可能多地进行容器化。为我正在开发的应用程序创建可重用的 Docker 容器使我能够在需要的时候快速构建、销毁、部署和重新部署整个项目。使用
    Ansible Container 允许我作为一名 DevOps 工程师构建能够与我的基础设施说同一种语言的容器：Ansible。使用 Ansible，当我在进行基础设施自动化和构建容器化项目时，我不再需要在脑海中切换模式。我能够像开发任何其他
    Ansible 项目一样快速开发容器。这让我非常有动力和动力，以适应以前编写的 Ansible 角色来构建和部署可以在任何容器化环境中运行的 Ansible
    容器。随后，这也让我思考我目前正在进行的项目以及如何最好地调整我的自动化策略以适应容器化环境。
- en: Looking at projects out there, such as CoreOS's Container Linux ([https://coreos.com/why/](https://coreos.com/why/))
    and other fully containerized operating system platforms, it is apparent that
    everything, even entire operating systems, will eventually be containerized. Go
    ahead. Start now! By containerizing everything you are working on, you will make
    your work more efficient, repeatable, and locally testable. Not only that, but
    you are ensuring your platforms, applications, and infrastructure is future-proof.
    Even if your team isn't currently thinking about containers yet, you should be.
    The world of cloud infrastructure and containerization is moving so quickly that
    without embracing a truly modular software development methodology, you will surely
    be left in the dust.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 观察目前的一些项目，例如 CoreOS 的 Container Linux ([https://coreos.com/why/](https://coreos.com/why/))
    和其他完全容器化的操作系统平台，可以明显看出，所有的东西，甚至整个操作系统，最终都会容器化。现在就开始吧！通过容器化你正在处理的所有内容，你将使工作更加高效、可重复，并且可以在本地进行测试。不仅如此，你还在确保你的平台、应用程序和基础设施是面向未来的。即使你的团队目前还没有考虑容器化，你也应该考虑。云基础设施和容器化的世界发展迅速，如果不拥抱真正的模块化软件开发方法论，你肯定会被抛在后头。
- en: References
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '**Travis CI**: [https://travis-ci.org/](https://travis-ci.org/)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Travis CI**: [https://travis-ci.org/](https://travis-ci.org/)'
- en: '**Jenkins**: [https://jenkins.io/](https://jenkins.io/)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins**: [https://jenkins.io/](https://jenkins.io/)'
- en: '**Ansible Container Freenode IRC**: [http://docs.ansible.com/ansible-container/](http://docs.ansible.com/ansible-container/)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ansible Container Freenode IRC**: [http://docs.ansible.com/ansible-container/](http://docs.ansible.com/ansible-container/)'
- en: '**Container Linux**: [https://coreos.com/why/](https://coreos.com/why/)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Container Linux**: [https://coreos.com/why/](https://coreos.com/why/)'
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: When I first started working with Docker containers around two years ago, I
    thought at first that building and managing containers was quite a pain, given
    how quickly and efficiently I could write Ansible playbooks that would do exactly
    the same thing. Eventually, I got the hang of the Dockerfile syntax and started
    to finally see how much power there was in deploying applications inside containers.
    What finally convinced me how awesome containers are was when I built out an entire
    OpenStack cloud using the Kolla project ([https://docs.openstack.org/kolla/latest/](https://docs.openstack.org/kolla/latest/)).
    The Kolla project aims to deploy a full OpenStack cloud solution using Ansible
    Playbooks to deploy OpenStack services in Docker containers. Using Kolla, I could
    deploy an entire multi-node OpenStack cluster in approximately 30 minutes. Coming
    from a background of having previously automated various OpenStack components,
    using Chef and Ansible, I was completely amazed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我大约两年前开始使用 Docker 容器时，最初我认为构建和管理容器是一项非常麻烦的工作，因为我可以通过编写 Ansible playbooks 快速高效地完成相同的事情。最终，我掌握了
    Dockerfile 语法，并开始真正理解将应用程序部署到容器中有多么强大。最终让我彻底信服容器的强大，是当我使用 Kolla 项目构建了一个完整的 OpenStack
    云时 ([https://docs.openstack.org/kolla/latest/](https://docs.openstack.org/kolla/latest/))。Kolla
    项目旨在通过使用 Ansible Playbooks 在 Docker 容器中部署 OpenStack 服务，从而部署一个完整的 OpenStack 云解决方案。使用
    Kolla，我可以在大约 30 分钟内部署一个完整的多节点 OpenStack 集群。作为曾经使用 Chef 和 Ansible 自动化各种 OpenStack
    组件的背景下，我完全惊讶于这个速度和简便性。
- en: Around a year ago, I started following the Ansible Container project as a supplement
    to the Docker, OpenStack, and Kubernetes work I was engaged in at the time. At
    the time, I saw Ansible Container as the missing piece of the puzzle that would
    allow me to use Ansible as a full end-to-end development and deployment solution
    to my container work. It has been an absolutely amazing journey so far. With the
    support of the community, I have used Ansible Container both personally and professionally
    to automate and deploy a multitude of projects over the last year or so. I have
    been absolutely amazed with how much more flexibility Ansible Container gives
    me as a DevOps engineer compared to building standard Dockerfiles.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大约一年前，我开始关注 Ansible Container 项目，作为我当时从事 Docker、OpenStack 和 Kubernetes 工作的补充。当时，我认为
    Ansible Container 是我所需的拼图缺失部分，它可以让我将 Ansible 作为一个完整的端到端开发和部署解决方案来处理我的容器工作。到目前为止，这一旅程绝对令人惊叹。在社区的支持下，我在过去一年多的时间里，个人和职业上都使用
    Ansible Container 自动化和部署了许多项目。作为一名 DevOps 工程师，Ansible Container 给我的灵活性远远超过了构建标准
    Dockerfiles，让我惊叹不已。
- en: 'It is my hope that you will finish reading this book with a sense of enthusiasm
    to move forward with your work and career no matter what segment or industry you
    work in. The thing that never ceases to amaze me with open source software is
    the sheer number of diverse people in various industries that adopt these technologies.
    I hope that, as you progress with Ansible Container, you will keep an eye on the
    future and an ear to the ground. As more and more people adopt these technologies,
    amazingly smart people will keep contributing features to make these platforms
    even better. Thank you for taking the time to read this book. I wish to also thank
    the amazing people who write Ansible Container: Chris Houseknecht (`@chouseknecht`)
    and Joshua Ginsberg (`@j00bar`), who have supported me on many of these examples,
    fixing bugs, and providing fantastic support for a project they are quite obviously
    passionate about.  If this book has been helpful to you, please drop me a line
    on Twitter or Freenode IRC: `@aric49`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能带着热情完成这本书的阅读，无论你从事哪个行业或领域，都能继续推动你的工作和职业发展。开源软件让我惊叹不已的一点是，来自各个行业、各种背景的人都在积极采用这些技术。我希望，当你在使用
    Ansible Container 逐步深入时，能时刻关注未来并保持敏锐的洞察力。随着越来越多的人采纳这些技术，越来越聪明的人会继续为这些平台贡献新功能，使它们变得更加完善。感谢你抽出时间阅读本书。同时，我也要感谢那些撰写
    Ansible Container 的了不起的团队成员：Chris Houseknecht（`@chouseknecht`）和 Joshua Ginsberg（`@j00bar`），他们在很多示例中给予了我极大的支持，修复了bug，并为这个显然充满激情的项目提供了出色的支持。如果本书对你有帮助，请在
    Twitter 或 Freenode IRC 上给我留言：`@aric49`。
