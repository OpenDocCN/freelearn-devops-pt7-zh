- en: Chapter 3. Separating Code and Data – Variables, Facts, and Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章：分离代码与数据 - 变量、事实和模板
- en: In the previous chapter, we looked at how to write a role to provide modularity
    and abstraction. While doing so, we created the configuration file and copied
    the file over to the destination host using Ansible's copy module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何编写角色以提供模块化和抽象。在此过程中，我们创建了配置文件，并使用 Ansible 的复制模块将文件复制到目标主机。
- en: 'In this chapter, we will cover the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下概念：
- en: How do you separate data from code?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将数据与代码分开？
- en: What are Jinja2 templates? How are these created?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Jinja2 模板？如何创建这些模板？
- en: What are variables? How and where are they used?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是变量？它们如何以及在哪里使用？
- en: What are system facts? How are they discovered?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是系统事实？它们是如何被发现的？
- en: What are the different types of variables?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量有哪些不同类型？
- en: What is a variable merge order? What are its precedence rules?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是变量合并顺序？它的优先级规则是什么？
- en: Static content explosion
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态内容爆炸
- en: 'Let''s imagine that we are managing a cluster of hundreds of web servers spanning
    across multiple data centers. Since we have the `server_name` parameter hardcoded
    in to the `config` file, we will have to create one file per server. This also
    means that we will manage hundreds of static files, which will quickly get out
    of control. Our infrastructure is dynamic, and managing change is one of the most
    common aspects of a DevOps engineer''s routine tasks. If tomorrow, our company
    policy states that we should run web servers on the port 8080 instead of the port
    80, only in a production environment, imagine the headache you''d get having to
    change all these files individually. Wouldn''t it be better to have a single file
    that takes dynamic inputs, which are specific to the host it''s running on? This
    is exactly what templates are for and, as depicted in the following diagram, a
    single template could replace a multitude of static files:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们管理着一个横跨多个数据中心的几百台 Web 服务器的集群。由于我们将 `server_name` 参数硬编码到 `config` 文件中，我们需要为每个服务器创建一个文件。这也意味着我们将管理数百个静态文件，这些文件会迅速失控。我们的基础设施是动态的，管理变化是
    DevOps 工程师日常工作中最常见的任务之一。如果明天公司政策规定我们应该将 Web 服务器的端口从 80 改为 8080，只在生产环境中执行，想象一下你得单独修改所有这些文件时会有多麻烦。是不是更好拥有一个接受特定主机动态输入的单一文件？这正是模板的用途，正如下图所示，一个模板可以替代多个静态文件：
- en: '![Static content explosion](img/B03800_03_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![静态内容爆炸](img/B03800_03_01.jpg)'
- en: Before we define what a template is, let's begin by understanding how to separate
    code from data and how this would help us solve the problem of static content
    explosion.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义模板是什么之前，让我们先理解如何将代码与数据分开，以及这如何帮助我们解决静态内容爆炸的问题。
- en: Separating code and data
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离代码和数据
- en: 'The real magic of infrastructure as code tools, such as Ansible, lies in its
    ability to separate data and code. In our example, the `default.conf` file is
    a configuration file that is specific to an Nginx web server. The configuration
    parameters, such as ports, users, paths, and so on, remain generic and constant
    at all times, no matter who installs and configures them. What is not constant
    are the values those parameters take. That''s what is specific to our organization.
    So, for this, we would decide the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即代码工具（如 Ansible）的真正魔力在于它能够将数据和代码分开。在我们的示例中，`default.conf` 文件是特定于 Nginx Web
    服务器的配置文件。配置参数（如端口、用户、路径等）始终保持通用且不变，无论由谁安装和配置。变化的是这些参数所取的值。这就是特定于我们组织的部分。所以，对于这个问题，我们需要决定以下内容：
- en: Which port should Nginx run on?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nginx 应该运行在哪个端口？
- en: Which user should own the web server process?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个用户应该拥有 Web 服务器进程？
- en: Where should the log files go?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件应该放在哪里？
- en: How many worker processes should be run?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该运行多少个工作进程？
- en: Our organization-specific policies may also require us to pass different values
    to these parameters based on the environment or geography the hosts run in.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组织政策可能还要求我们根据主机运行的环境或地理位置，向这些参数传递不同的值。
- en: 'Ansible splits these in to two parts:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 将这些分为两部分：
- en: The code that is generic
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用代码
- en: The data that is specific to an organization
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于组织的数据
- en: This has two advantages; one advantage is that it solves our problem of static
    data explosion. Now that we have separated the code and data, we can create `config`
    files flexibly and dynamically. The second advantage, you may realize, is now
    that the code and data are split, there is nothing in the code that is specific
    to a particular organization. This makes it easy to share the site with the world
    for anyone who finds it useful. That's exactly what you would find on Ansible-Galaxy
    or even on GitHub, fueling the growth of tools, such as Ansible. Instead of reinventing
    the wheel, you can download the code that someone else has written, customize
    it, fill in the data specific to the code, and get the work done.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个优点；第一个优点是它解决了我们静态数据爆炸的问题。现在我们已经分离了代码和数据，可以灵活且动态地创建 `config` 文件。第二个优点，你可能意识到的是，由于代码和数据已分离，代码中没有任何内容是特定于某个组织的。这使得将网站分享给世界上任何有需要的人变得容易。这正是你在
    Ansible-Galaxy 或 GitHub 上看到的情况，推动了像 Ansible 这样的工具的增长。你可以下载别人编写的代码，进行自定义，填入与代码相关的数据，然后完成工作，而不是重新发明轮子。
- en: 'Now, how is this code separate from the data? The answer is that Ansible has
    two primitives:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这段代码是如何与数据分离的呢？答案是 Ansible 有两个基本原语：
- en: Jinja templates (code)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja 模板（代码）
- en: The variables (data)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量（数据）
- en: 'The following diagram explains how the resulting file is generated from templates
    and variables:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下图解释了如何从模板和变量生成最终文件：
- en: '![Separating code and data](img/B03800_03_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![分离代码与数据](img/B03800_03_02.jpg)'
- en: Templates provide placeholders in place of parameter values, which are then
    defined in variables. Variables can then be fed in from various places, including
    roles, playbooks, inventories, and even from the command line when you launch
    Ansible. Let's now understand templates and variables in detail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 模板为参数值提供占位符，随后这些值在变量中定义。变量可以从不同地方提供，包括角色、剧本、清单，甚至在启动 Ansible 时通过命令行传递。现在让我们详细了解模板和变量。
- en: Jinja2 templates
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja2 模板
- en: What is **Jinja** all about? **Jinja2** is a very popular and powerful Python-based
    template engine. Since Ansible is written in Python, it becomes the default choice
    for most users, just like other Python-based configuration management systems,
    such as **Fabric** and **SaltStack**. The name Jinja originated from the Japanese
    word for temple, which is similar in phonetics to the word template.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jinja** 是做什么的？**Jinja2** 是一个非常流行且强大的基于 Python 的模板引擎。由于 Ansible 是用 Python
    编写的，因此它成为大多数用户的默认选择，就像其他基于 Python 的配置管理系统，如 **Fabric** 和 **SaltStack** 一样。Jinja
    这个名字源自日语中的“寺庙”一词，发音与“模板”相似。'
- en: 'Some of the important features of Jinja2 are:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2 的一些重要特性包括：
- en: It is fast and compiled just in time with the Python byte code
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它运行速度快，并且是与 Python 字节码即时编译的。
- en: It has an optional sandboxed environment
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个可选的沙盒环境
- en: It is easy to debug
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它易于调试
- en: It supports template inheritance
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持模板继承
- en: The template formation
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板的形成
- en: 'Templates look very similar to normal text-based files except for the occasional
    variables or code that surrounds the special tags. These get evaluated and are
    mostly replaced by values at runtime, creating a text file, which is then copied
    to the destination host. The following are the two types of tags that Jinja2 templates
    accept:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模板看起来与普通的基于文本的文件非常相似，除了偶尔出现的变量或代码，这些代码被特殊标签包围。它们在运行时被评估，并大部分被值替换，从而生成文本文件，并将其复制到目标主机上。以下是
    Jinja2 模板接受的两种标签类型：
- en: '`{{ }}` embeds variables inside a template and prints its value in the resulting
    file. This is the most common use of a template.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{ }}` 将变量嵌入模板中，并在生成的文件中打印其值。这是模板最常见的用法。'
- en: 'For example:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`{% %}` embeds statements of code inside a template, for example, for a loop,
    it embeds the if-else statements, which are evaluated at runtime but are not printed.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% %}` 将代码语句嵌入模板中，例如，对于循环，它嵌入 if-else 语句，这些语句在运行时被评估，但不会被打印出来。'
- en: Facts and variables
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事实和变量
- en: Now that we have looked at the code that Jinja2 templates provide, let's understand
    where this data comes from, which is then embedded in the template at runtime.
    Data can come from either facts or variables. When it comes to a Jinja2 template,
    the same rules apply to the usage of facts and variables. Facts are a type of
    variable; the differentiating factor here is the origin of the two. Facts are
    automatically available and discovered at runtime, and variables are user-defined.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Jinja2 模板提供的代码，让我们理解一下这些数据的来源，这些数据会在运行时嵌入到模板中。数据可以来自事实或变量。在 Jinja2
    模板中，事实和变量的使用遵循相同的规则。事实是一种变量；它们的区别在于来源。事实在运行时自动可用并被发现，而变量是用户定义的。
- en: Automatic variables – facts
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动变量 – 事实
- en: 'A lot of data in our systems is automatically discovered and made available
    to Ansible by the managed hosts during the handshake process. This data is very
    useful and tells us everything about that system, such as:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们系统中的很多数据在握手过程中的托管主机会自动发现并提供给 Ansible。这些数据非常有用，告诉我们有关系统的所有信息，例如：
- en: The hostname, network interface, and IP address
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机名、网络接口和 IP 地址
- en: The system architecture
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统架构
- en: The operating system
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统
- en: The disk drives
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬盘驱动器
- en: The processor used and amount of memory
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的处理器和内存量
- en: Whether it is a VM; if yes, is it a virtualization/cloud provider?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个虚拟机吗？如果是，是否是虚拟化/云提供商？
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Facts are collected at the very beginning of an Ansible run. Remember the line
    in the output that says **GATHERING FACTS *********? That's exactly when this
    happens.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 事实会在 Ansible 执行的最开始阶段收集。记住输出中有一行说 **GATHERING FACTS *********？那正是发生的时刻。
- en: 'You can find facts about any system by running the following command followed
    by a shortened output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来查找任何系统的事实，并获得简化的输出：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding output is in Ansible''s own format and uses its core setup module.
    Akin to the setup module, there is another module by the name `facter`, which
    discovers and displays facts in the format discovered with Puppet, another configuration
    management system. The following is an example of how to use the `facter` module
    to discover facts for the same host:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出是 Ansible 自有格式，使用的是其核心的 setup 模块。与 setup 模块类似，还有一个名为 `facter` 的模块，它会发现并展示在
    Puppet（一种配置管理系统）中发现的事实。以下是如何使用 `facter` 模块发现同一主机事实的示例：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While using the `facter` module, a point that you need to note is that this
    module is not a core module and comes as part of extra modules. Extras modules
    are a subset of the Ansible module, which is used less frequently and is less
    popular in comparison with the core modules. Moreover, to use the `facter` module,
    you require the "`facter`" and "`ruby-json`" packages preinstalled on the target
    host.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `facter` 模块时，你需要注意的一点是，这个模块不是核心模块，它是作为额外模块的一部分提供的。额外模块是 Ansible 模块的一个子集，使用频率较低，相比于核心模块也不那么流行。此外，要使用
    `facter` 模块，你需要在目标主机上预安装 "`facter`" 和 "`ruby-json`" 包。
- en: User-defined variables
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户定义的变量
- en: 'We looked at facts, which are automatically available, and the amount of data
    that is discovered is overwhelming. However, it does not provide us with every
    attribute of our infrastructure that we need. For example, Ansible can not discover:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了自动可用的事实，所发现的数据量是庞大的。然而，这并不提供我们基础设施的每个属性。例如，Ansible 无法发现：
- en: Which port we want our web server to listen to
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望 Web 服务器监听的端口
- en: Which user should own a process
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个用户应该拥有一个进程
- en: Which system the users need to create, with which authorization rules
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要创建哪些系统，并定义哪些授权规则
- en: All this data is external to a system profile and is to be provided by us, the
    users. It's user-defined for sure, but how and where should we define it? That's
    what we are going to look at next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据都是外部于系统配置文件的，必须由我们用户提供。这些数据是用户定义的，没错，但我们应该如何以及在哪里定义它们呢？接下来我们将探讨这个问题。
- en: Where to define a variable
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在哪里定义变量
- en: Where a variable can be defined from is a complex phenomenon, as Ansible offers
    abundant choices in this regard. This also offers a lot of flexibility to users
    to configure portions of their infrastructures divergently. For example, all Linux
    hosts in a production environment should use local package repositories or web
    servers in staging and should run on the port 8080\. All this without changing
    the code, and driven by data alone is done, by variables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以定义的地方是一个复杂的现象，因为 Ansible 在这方面提供了丰富的选择。这也为用户提供了很大的灵活性，使他们能够以不同的方式配置基础设施的各个部分。例如，生产环境中的所有
    Linux 主机应该使用本地包仓库或在暂存环境中的 Web 服务器，并应运行在 8080 端口上。所有这些都可以在不更改代码的情况下，仅通过数据驱动，变量来完成。
- en: 'The following are the places from where Ansible accepts variables:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Ansible 接受变量的地方：
- en: The `default` directory inside a role
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色中的`default`目录
- en: Inventory variables
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清单变量
- en: The `host_vars` and `group_vars` parameters defined in separate directories
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单独的目录中定义的`host_vars`和`group_vars`参数
- en: The `host/group vars` parameter defined in an inventory file
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在清单文件中定义的`host/group vars`参数
- en: Variables in playbooks and role parameters
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playbooks 中的变量和角色参数
- en: The `vars` directory inside a role and variables defined inside a play
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色中的`vars`目录和在 play 中定义的变量
- en: Extra variables provided with the `-e` option at runtime
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时通过`-e`选项提供的额外变量
- en: How to define a variable
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何定义一个变量
- en: After looking at where to define the variable from, we will start looking at
    how to define it at various places.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 看过变量可以从哪里定义之后，我们将开始研究如何在不同地方定义它。
- en: 'Here are some simple rules you can use to form a valid Ansible variable:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些简单的规则，你可以用来创建有效的 Ansible 变量：
- en: A variable should always start with a letter
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量应始终以字母开头
- en: 'It can contain:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以包含：
- en: Letters
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母
- en: Numbers
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: Underscores
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下划线
- en: 'Let''s take a look at the following table:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下表格：
- en: '| Valid variable | Invalid variable |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 有效变量 | 无效变量 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `app_port` | `app-port` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `app_port` | `app-port` |'
- en: '| `userid_5` | `5userid` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `userid_5` | `5userid` |'
- en: '| `logdir` | `log.dir` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `logdir` | `log.dir` |'
- en: We looked at the precedence rules and now we know that there are multiple places
    where you can define variables. Irrespective of the precedence levels, all use
    the same syntax to define a variable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了优先级规则，现在知道可以在多个地方定义变量。无论优先级如何，定义变量的语法都是相同的。
- en: 'To define a simple variable in a key-value pair format, use, `var: value`,
    for example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '要以键值对格式定义简单变量，请使用`var: value`，例如：'
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A dictionary or hash can be defined as Nginx:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义为 Nginx 的字典或哈希：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'An array could be defined as:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以定义为：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Templating the Nginx configurations
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板化 Nginx 配置
- en: 'You have learnt a lot about facts, variables, and templates. Now, lets transform
    our Nginx role to be data driven. We will start templating the `default.conf`
    file for Nginx that we created earlier. The approach toward converting a file
    into a template would be as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到了很多关于事实、变量和模板的知识。现在，让我们将我们的 Nginx 角色转换为数据驱动。我们将开始模板化之前创建的 Nginx 的`default.conf`文件。将文件转换为模板的方法如下：
- en: 'Create the directories required to hold templates and default variables inside
    a role:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色中创建用于存放模板和默认变量的目录：
- en: '[PRE6]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Always start with the actual configuration file, our end result of this process,
    to know all of the parameters it would take. Then, work backwards. For example,
    the configuration for the `default.conf` file on our system is as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 始终从实际的配置文件开始，这个文件是该过程的最终结果，了解它所需的所有参数。然后倒推。例如，系统中`default.conf`文件的配置如下：
- en: '[PRE7]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Identify the configuration parameters that you would like to generate dynamically,
    remove the values for those parameters, note them down separately, and replace
    them with template variables:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定你希望动态生成的配置参数，移除这些参数的值，将它们单独记录下来，并用模板变量替换：
- en: '[PRE8]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the values for any of the configuration parameters are supposed to be sourced
    from facts, typically system parameters or topology information, such as the hostname,
    IP address, and so on, then find out the relevant facts with the help of the following
    command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果某些配置参数的值应该来自事实（通常是系统参数或拓扑信息，如主机名、IP 地址等），则可以通过以下命令来查找相关事实：
- en: 'For example:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE9]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To find out the hostname of the system:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查找系统的主机名：
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the discovered fact inside the template instead of a user-defined variable.
    For example:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中使用发现的事实，而不是用户定义的变量。例如：
- en: '[PRE11]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Save the resulting file inside the template''s directory, ideally with the
    `.j2` extension. For example, for `roles/nginx/templates/default.conf.j2`, the
    resulting file becomes:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的文件保存在模板目录中，最好使用 `.j2` 扩展名。例如，对于 `roles/nginx/templates/default.conf.j2`，生成的文件变为：
- en: '[PRE12]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create `roles/nginx/defaults/main.yml` and store the sane defaults as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `roles/nginx/defaults/main.yml` 并存储如下的合理默认值：
- en: '[PRE13]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once the template has been created, change the task in the `configure.yml` file
    to use the template instead of the copy module:![Templating the Nginx configurations](img/B03800_03_04.jpg)
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦模板创建完成，修改 `configure.yml` 文件中的任务，使用模板而不是复制模块：![模板化 Nginx 配置](img/B03800_03_04.jpg)
- en: 'Finally, it''s time to remove the static file we used earlier with the copy
    module:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是时候删除之前使用复制模块的静态文件了：
- en: '[PRE14]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then it''s time to run the Ansible playbook:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后是运行 Ansible playbook 的时候：
- en: '[PRE15]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下截图：
- en: '![Templating the Nginx configurations](img/B03800_03_05.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![模板化 Nginx 配置](img/B03800_03_05.jpg)'
- en: 'Let''s analyze what happened during this run:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这次运行发生了什么：
- en: We changed the configuration task to use the template instead of the copy module,
    which is reflected in the screenshot when a task shows its changed status
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将配置任务更改为使用模板而不是复制模块，这一点在任务显示其更改状态时在截图中得到了体现
- en: Since the task has been updated, a notification gets triggered, which calls
    the handler to restart the service
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于任务已更新，触发了通知，这会调用处理程序重新启动服务
- en: 'Our code tree for the Nginx role looks like the following after we make this
    change:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行此更改后，Nginx 角色的代码树如下所示：
- en: '![Templating the Nginx configurations](img/B03800_03_06.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![模板化 Nginx 配置](img/B03800_03_06.jpg)'
- en: Adding another layer – the MySQL role
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加另一个层级——MySQL 角色
- en: So far, we have been focusing on the single tier of our infrastructure, that
    is, the web server layer. Writing code for just one tier is not a lot of fun.
    Being a cool DevOps team, we will create a multi-tier infrastructure with database,
    web server, and then, a load balancer. We will start creating the MySQL role next,
    apply everything that we have learnt so far, and extend that knowledge with a
    few new concepts.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于我们基础设施的单层，即 Web 服务器层。只编写一个层的代码其实并不好玩。作为一个酷炫的 DevOps 团队，我们将创建一个多层架构，包括数据库、Web
    服务器和负载均衡器。接下来，我们将开始创建 MySQL 角色，应用到目前为止学到的所有内容，并通过几个新概念扩展我们的知识。
- en: 'Here is our specification for the MySQL role:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们 MySQL 角色的规范：
- en: It should install the MySQL server package
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该安装 MySQL 服务器软件包
- en: It should configure '`my.cnf`', which is the main configuration for the MySQL
    server
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该配置 `my.cnf`，这是 MySQL 服务器的主要配置文件
- en: It should start the MySQL server daemon
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该启动 MySQL 服务器守护进程
- en: It should support Ubuntu 12.04 as well as CentOS/RedHat Enterprise 6.x
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该支持 Ubuntu 12.04 以及 CentOS/RedHat Enterprise 6.x
- en: Creating the scaffolding for the roles with Ansible-Galaxy
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ansible-Galaxy 创建角色框架
- en: So far, we have been doing all the hard work to understand and create the directory
    structure required by the roles. However, to make our lives easier, Ansible ships
    with a tool called **Ansible-Galaxy**, which should help us initialize a role
    by creating the scaffolding automatically and could help us follow the best practices.
    Ansible-Galaxy actually does more than that. It's a utility to connect to the
    repository of the freely available Ansible roles hosted at [http://galaxy.ansible.com](http://galaxy.ansible.com).
    This is similar to the way we use **CPAN** or **RubyGems**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在做所有的繁重工作，理解并创建角色所需的目录结构。然而，为了让我们的生活更轻松，Ansible 附带了一个名为 **Ansible-Galaxy**
    的工具，它应该能够帮助我们通过自动创建框架来初始化一个角色，并帮助我们遵循最佳实践。Ansible-Galaxy 实际上做的不止这些。它是一个实用工具，用于连接到
    [http://galaxy.ansible.com](http://galaxy.ansible.com) 上托管的自由可用 Ansible 角色的仓库。这类似于我们使用
    **CPAN** 或 **RubyGems** 的方式。
- en: 'Let''s start by initializing the MySQL role with Ansible-Galaxy using the following
    command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用以下命令通过 Ansible-Galaxy 初始化 MySQL 角色：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, the following is the analysis of the preceding command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面命令的分析：
- en: '`init`: This is the subcommand given to Ansible-Galaxy to create the scaffolding'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`：这是传递给 Ansible-Galaxy 用来创建框架的子命令'
- en: '`--init-path` or `-p`: These provide the path to the roles directory, under
    which the directory structure is created'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--init-path` 或 `-p`：这些参数提供角色目录的路径，在该路径下会创建目录结构'
- en: '`mysql`: This is the name of the role'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mysql`：这是角色的名称'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下截图：
- en: '![Creating the scaffolding for the roles with Ansible-Galaxy](img/B03800_03_07.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Ansible-Galaxy 创建角色框架](img/B03800_03_07.jpg)'
- en: The preceding diagram shows the directory layout created after you initialize
    the role with Ansible-Galaxy, which creates an empty role with a structure suitable
    for upload on to Galaxy. It also initializes the necessary components, including
    tasks, handlers, vars, and meta files with placeholders.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了通过 Ansible-Galaxy 初始化角色后创建的目录结构，它创建了一个空角色，结构适合上传到 Galaxy。它还初始化了必要的组件，包括任务、处理程序、变量和带占位符的
    meta 文件。
- en: Adding metadata to the role
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向角色添加元数据
- en: 'We used the `meta` file earlier to specify the dependency on another role.
    In addition to specifying the dependencies, meta files can specify much more data
    for the roles, such as:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用过 `meta` 文件来指定对其他角色的依赖关系。除了指定依赖关系外，meta 文件还可以为角色指定更多的数据，例如：
- en: The author and company information
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者和公司信息
- en: The supported OS and platforms
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的操作系统和平台
- en: A brief description of what a role does
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色功能的简要描述
- en: The Ansible versions supported
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的 Ansible 版本
- en: The category of software that this role attempts to automate
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该角色尝试自动化的软件类别
- en: The licensing information
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可信息
- en: 'Let''s update all this data by editing `roles/meta/main.yml`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编辑 `roles/meta/main.yml` 来更新所有这些数据：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding snippet, we added metadata to the role, such as the author
    and company details, a brief description of what a role does, its compatibility
    with Ansible versions, the supported platforms, the category the role belongs
    to, and so on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们为角色添加了元数据，例如作者和公司信息、角色功能的简要描述、与 Ansible 版本的兼容性、支持的平台、角色所属的类别等。
- en: Using variables in tasks and handlers
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在任务和处理程序中使用变量
- en: 'You have learnt how to use variables in templates. That''s not all the code
    there is used to define the variables. In addition to templates, we can also use
    variables inside tasks, plays, and so on. This time around, we have also committed
    to provide a multiplatform role, supporting Ubuntu and RedHat both. Unlike **Chef**
    and **Puppet**, Ansible uses OS-specific modules (for example, `apt` and `yum`)
    and not platform-independent resources (package). We will have to create OS-specific
    task files and call them selectively based on the OS they are going to run on.
    Here''s how we do so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何在模板中使用变量。这并不是所有定义变量的代码。除了模板，我们还可以在任务、plays 等中使用变量。这一次，我们承诺提供一个多平台角色，支持
    Ubuntu 和 RedHat。与 **Chef** 和 **Puppet** 不同，Ansible 使用特定于操作系统的模块（例如 `apt` 和 `yum`），而不是平台无关的资源（如包）。我们将必须创建特定于操作系统的任务文件，并根据它们运行的操作系统选择性地调用它们。以下是我们如何操作：
- en: 'We will find a fact that will determine the OS platform/family. We have a couple
    of options here:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将找到一个事实来确定操作系统平台/家族。我们在这里有几个选择：
- en: '`ansible_distribution`'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_distribution`'
- en: '`ansible_os_family`'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_os_family`'
- en: RedHat, CentOS, and Amazon Linux are all based on `rpm` and have similar behavior.
    The same goes for Ubuntu and Debian operating systems, which are part of the same
    platform family. Hence, we choose to use the `ansible_os_family` fact, which will
    give us wider support.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RedHat、CentOS 和 Amazon Linux 都基于 `rpm`，具有类似的行为。Ubuntu 和 Debian 操作系统也是相同平台家族的一部分。因此，我们选择使用
    `ansible_os_family` 事实，它能提供更广泛的支持。
- en: 'We will define variables from two places in the roles:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在角色中从两个地方定义变量：
- en: From the default `vars` file with the sane defaults for Debian.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自默认的 `vars` 文件，包含 Debian 的合理默认值。
- en: From the variables specific to `os_family` if not Debian.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自特定于 `os_family` 的变量（如果不是 Debian）。
- en: We will also create OS-specific task files, since we may need to call different
    modules (`apt` versus `yum`) and additional tasks that are specific to that OS.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将创建特定于操作系统的任务文件，因为我们可能需要调用不同的模块（例如 `apt` 与 `yum`）以及与该操作系统相关的附加任务。
- en: For handlers and tasks, we will use variables to provide OS-specific names (for
    example, MySQL versus mysqld, for service).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于处理程序和任务，我们将使用变量来提供特定于操作系统的名称（例如，MySQL 与 mysqld，用于服务）。
- en: Finally, we will create the `main.yml` file, which will selectively include
    host-specific vars as well as task files by checking the value of this fact.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将创建 `main.yml` 文件，通过检查该事实的值来选择性地包含主机特定的变量和任务文件。
- en: Creating variables
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建变量
- en: 'We will begin with the creation of variables. Let''s set up the sane defaults
    for Debian/Ubuntu inside the `/mysql/defaults/main.yml` file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建变量开始。在 `/mysql/defaults/main.yml` 文件中为 Debian/Ubuntu 设置合理的默认值：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then it will run on RedHat/CentOS machines, however, we will need to override
    a few of these variables to configure the RedHat-specific parameters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将在RedHat/CentOS机器上运行，但是我们需要覆盖一些变量以配置特定于RedHat的参数。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the filename should match the exact name (RedHat) that is returned
    by the `ansible_os_family` fact with the correct case.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件名应该与`ansible_os_family`事实返回的确切名称（RedHat）匹配，大小写要正确。
- en: 'We will create and edit the `roles/mysql/vars/RedHat.yml` file, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建并编辑`roles/mysql/vars/RedHat.yml`文件，如下所示：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we will create the `group_vars` fact with one variable to override
    our default settings. You have learnt that you can specify variables in the `inventory`
    files, the `group_vars` and the `host_vars` facts. We will start using the `group_vars`
    fact for now. You could either create these in your inventory file or create a
    separate directory for it with the name `group_vars`. We are going to take the
    second approach, which is recommended:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建`group_vars`事实，并使用一个变量来覆盖我们的默认设置。您已经了解到可以在`inventory`文件、`group_vars`和`host_vars`事实中指定变量。我们现在将开始使用`group_vars`事实。您可以在您的清单文件中创建这些，也可以创建一个名为`group_vars`的单独目录来进行管理。我们将采用后一种方法，这是推荐的做法：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Edit the `group_vars`/`all` file and add the following line:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`group_vars`/`all`文件，并添加以下行：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating tasks
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建任务
- en: 'It''s now time to create tasks. Following the best practices, we will split
    tasks into multiple files and use include statements, just like we did for Nginx.
    Let''s start by creating the default `main.yml` file inside `roles/mysql/tasks`,
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是创建任务的时候了。按照最佳实践，我们将任务分割成多个文件，并使用包含语句，就像我们为Nginx所做的那样。让我们首先在`roles/mysql/tasks`目录内创建默认的`main.yml`文件，如下所示：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We saw the `include` statements earlier. What''s new here is the `include_vars`
    fact and the use of the `ansible_os_family` fact. If you notice:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到了`include`语句。这里新的是`include_vars`事实和使用`ansible_os_family`事实。如果你注意到：
- en: We are using the `ansible_os_family` fact here with the `include_vars` fact
    to determine whether to include OS-specific variables when the OS family is not
    Debian. Why not for the Debian system? That's because we are already specifying
    Debian-specific configurations in the `default` file. The `include_vars` fact
    works well with the preceding conditionals.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这里使用了`ansible_os_family`事实和`include_vars`事实，以确定在不是Debian系统的情况下是否包含特定于操作系统的变量。为什么不适用于Debian系统？因为我们已经在`default`文件中指定了特定于Debian的配置。`include_vars`事实在前述条件下运行良好。
- en: We are also calling OS-specific installation scripts using the `when` condition.
    We have included two scripts for now to support the Debian and RedHat families.
    However, later on, we could just extend the scripts by adding more `install_<os_family>.yml`
    scripts to support additional platforms.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还使用`when`条件调用特定于操作系统的安装脚本。目前我们包含了两个脚本，支持Debian和RedHat系列。但是，以后我们可以通过添加更多的`install_<os_family>.yml`脚本来支持其他平台。
- en: 'Now, let''s create the install tasks for Debian and RedHat:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为Debian和RedHat创建安装任务：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then edit the file, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下步骤编辑文件：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After running the preceding command, edit the file as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述命令后，按照以下步骤编辑文件：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding example, we used the `apt` and `yum` modules, respectively,
    for Debian- and RedHat-based systems. Following the best practices, we will write
    a data-driven role by providing the package name using a variable `mysql_pkg`.
    This variable is set based on the platform it runs on. Let''s take a look at the
    following steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们分别使用了`apt`和`yum`模块来支持Debian和RedHat基于系统。按照最佳实践，我们将通过使用变量`mysql_pkg`来写入数据驱动角色，根据运行的平台设置包名称。让我们看看以下步骤：
- en: 'The next step is to create a task to configure MySQL. Since we know that every
    configuration file should be a template, we will create one for the `my.cnf` file,
    the default configuration file for the MySQL server:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个任务来配置MySQL。因为我们知道每个配置文件应该是一个模板，所以我们将为MySQL服务器的默认配置文件`my.cnf`创建一个模板：
- en: '[PRE26]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then edit the file, as follows:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后按照以下步骤编辑文件：
- en: '[PRE27]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We created a template with the `.j2` extension since it's a Jinja2 template.
    It's not a must, but a recommended practice.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个带有`.j2`扩展名的模板，因为它是一个Jinja2模板。虽然这不是必须的，但是是一种推荐的做法。
- en: All configuration parameters come from variables in the `{{var}}` format. This
    is a recommended practice for managing a configuration file. We could let the
    attribute precedence decide where the values comes from.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有配置参数都来自 `{{var}}` 格式的变量。这是管理配置文件的推荐做法。我们可以让属性优先级决定值的来源。
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's good practice to add a notice to every file being managed by Ansible. This
    will avoid possible manual updates or ad hoc changes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个被 Ansible 管理的文件中添加注释是一个好习惯。这可以避免可能的手动更新或临时更改。
- en: 'We will write a task that will manage this template, and copy over the resulting
    file to the desired path on the host:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个任务来管理这个模板，并将生成的文件复制到主机上的目标路径：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have a common configuration file template; however, the path to copy this
    varies from platform to platform, also based on the flavor of MySQL that you plan
    to use. Here, we are using a MySQL distribution that comes with the Ubuntu and
    CentOS repositories by default, and we will set the `mysql_cnfpath` path from
    the role variables, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个通用的配置文件模板；然而，复制到的路径因平台而异，也取决于你打算使用的 MySQL 版本。在这里，我们使用的是默认包含在 Ubuntu 和 CentOS
    仓库中的 MySQL 发行版，我们将从角色变量中设置 `mysql_cnfpath` 路径，具体如下：
- en: 'On Ubuntu/Debian, use the command: `mysql_cnfpath = /etc/mysql/my.cnf`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ubuntu/Debian 上，使用命令：`mysql_cnfpath = /etc/mysql/my.cnf`
- en: 'On RedHat/CentOS, use the command: `mysql_cnfpath = /etc/my.cnf`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 RedHat/CentOS 上，使用命令：`mysql_cnfpath = /etc/my.cnf`
- en: Also, we are sending the notification to the MySQL service restart handler.
    This will make sure that if there are any changes to the configuration file, the
    service will automatically be restarted.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们将通知 MySQL 服务重启处理程序。这将确保如果配置文件有任何更改，服务会自动重启。
- en: 'To manage a service, we will create a service task and handler:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理一个服务，我们将创建一个服务任务和处理程序：
- en: 'The task:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 任务：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then edit the file, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按如下方式编辑文件：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The handler:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After running the preceding commands, edit the file as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后，按如下方式编辑文件：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the task and handler are similar to the Nginx service, so nothing much
    needs to be described. The only change is that we are using the `mysql_service`
    variable to decide the service name to start, or restart, the service.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，任务和处理程序类似于 Nginx 服务，因此不需要过多描述。唯一的变化是我们使用 `mysql_service` 变量来决定启动或重启的服务名称。
- en: Using variables in playbooks
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 playbook 中使用变量
- en: Variables can also be specified in playbooks. The preferred method of doing
    so would be to pass them as role parameters, an example of which is shown as follows.
    This is typically useful when you have defaults in the role and you'd like to
    override some configuration parameters specific to your setup. That way, roles
    are still generic and sharable, and do not contain organization-specific data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以在 playbook 中指定。推荐的做法是将它们作为角色参数传递，以下是一个示例。这通常在角色中有默认值时很有用，如果你想覆盖一些特定于你配置的参数。这样，角色仍然是通用的和可共享的，并且不会包含特定于组织的数据。
- en: 'We are going to create a playbook to manage our databases and then we will
    include it in the site-wide playbook, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 playbook 来管理我们的数据库，然后将其包含在全局的 playbook 中，示例如下：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then edit the file, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按如下方式编辑文件：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we assume that the host''s inventory contains a host group by the name
    `db`. In our example, we have two `db` servers, one running on Ubuntu, the other
    running on CentOS. This is added as:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们假设主机的清单包含一个名为 `db` 的主机组。在我们的示例中，我们有两个 `db` 服务器，一个运行在 Ubuntu 上，另一个运行在 CentOS
    上。可以这样添加：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding playbook, we used a parameterized role, which overrides one
    variable, that is, `mysql_bind`. The value is set from a multilevel fact.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 playbook 中，我们使用了一个带参数的角色，覆盖了一个变量，即 `mysql_bind`。这个值是从多级事实中设置的。
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下截图：
- en: '![Using variables in playbooks](img/B03800_03_08.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![在 playbook 中使用变量](img/B03800_03_08.jpg)'
- en: A multilevel fact can also be specified as `ansible_eth1["ipv4"]["address"]`
    and both the formats are valid. Parameterized roles are also useful when we want
    to create multiple instances of the role, for example, virtual hosts and WordPress
    instances running on different ports.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 多级事实也可以指定为 `ansible_eth1["ipv4"]["address"]`，这两种格式都是有效的。当我们想创建角色的多个实例时，带参数的角色也很有用，例如，在不同端口上运行的虚拟主机和
    WordPress 实例。
- en: 'Let''s now include this playbook in the top-level `site.yml` file using the
    `include` statement:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `include` 语句将这个 playbook 包含在顶级的 `site.yml` 文件中：
- en: 'Edit the `site.yml` file as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`site.yml`文件如下：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Applying a MySQL role to the DB servers
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将MySQL角色应用于DB服务器
- en: 'We are all set to configure our database servers. Let''s go ahead and apply
    the newly created role to all the `db` servers we have in the inventory:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好配置数据库服务器。让我们继续将新创建的角色应用到清单中的所有`db`服务器：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following image contains the snippet of the output which is only relevant
    to the database play:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片包含了与数据库play相关的输出片段：
- en: '![Applying a MySQL role to the DB servers](img/B03800_03_09.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![将MySQL角色应用于DB服务器](img/B03800_03_09.jpg)'
- en: We have explained the Ansible run in the previous chapters, when we created
    our first playbook as well as when we applied the Nginx role. The only new concept
    here is the `include_var` part. Ansible will check our condition based on the
    `ansible_os_family` fact and call variables specific to the OS. In our case, we
    have one Ubuntu and CentOS host each, and both of them call for the `RedHat.yml`
    file when it runs on the CentOS host alone.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中已经解释了Ansible的运行过程，尤其是在创建第一个playbook和应用Nginx角色时。这里唯一的新概念是`include_var`部分。Ansible将根据`ansible_os_family`事实检查我们的条件，并调用特定于操作系统的变量。在我们的案例中，我们有一个Ubuntu主机和一个CentOS主机，并且当仅在CentOS主机上运行时，它们都会调用`RedHat.yml`文件。
- en: What will be really interesting here is to find out what happened to our configuration
    files on each platform and which variables took precedence.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真正有趣的是，找出每个平台上我们的配置文件发生了什么变化，以及哪些变量的优先级更高。
- en: Variable precedence
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量优先级
- en: We specified variable defaults, used them in inventory files, and defined the
    same variable from different places (for example, defaults, vars, and inventory).
    Let's now analyze the output of the templates to understand what happened with
    all those variables.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了变量的默认值，将它们用于清单文件，并从不同的位置定义了相同的变量（例如，defaults、vars和inventory）。现在，让我们分析模板的输出，了解这些变量到底发生了什么。
- en: 'The following is the figure showing the `my.cnf` file on Ubuntu:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示Ubuntu上`my.cnf`文件的图示：
- en: '![Variable precedence](img/B03800_03_11.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![变量优先级](img/B03800_03_11.jpg)'
- en: 'The following is the analysis of the screenshot:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对截图的分析：
- en: The file has a notice in the comments section. This can deter admins from making
    manual changes to the file.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的评论部分有一个通知。这可以防止管理员手动修改文件。
- en: Most of the variables come from the defaults in a role. This is because Debian
    is our default family of operating systems and we already have sane defaults set
    for it. Similarly, for other operating system platforms, we are setting variable
    defaults from the `vars` directory in a role.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数变量来自角色中的默认值。这是因为Debian是我们的操作系统默认系列，我们已经为其设置了合理的默认值。类似地，对于其他操作系统平台，我们也从角色的`vars`目录中设置变量默认值。
- en: Even though the `bind_address` parameter is specified in the defaults and `group_vars`,
    it takes a value from the playbook's role parameter, which has a higher precedence
    over the other two levels.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在默认值和`group_vars`中已指定`bind_address`参数，它也会从playbook的角色参数中获取值，该值的优先级高于其他两个级别。
- en: 'The following diagram explains what happens when there are variables defined
    at various levels. All of them are merged at runtime. If the same variables are
    defined in more than one place, the precedence rules apply:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表解释了在多个级别定义变量时会发生什么情况。所有这些都会在运行时合并。如果在多个位置定义了相同的变量，则适用优先级规则：
- en: '![Variable precedence](img/B03800_03_10.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![变量优先级](img/B03800_03_10.jpg)'
- en: 'To understand the precedence rules, let''s look at what happened on our CentOS
    host. The following is the `my.cnf` file created on CentOS:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解优先级规则，让我们看看在CentOS主机上发生了什么。以下是CentOS上创建的`my.cnf`文件：
- en: '![Variable precedence](img/B03800_03_12.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![变量优先级](img/B03800_03_12.jpg)'
- en: 'As seen in the preceding figure, in the case of CentOS, we see some interesting
    results:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，在CentOS的情况下，我们看到了一些有趣的结果：
- en: The values for **user**, **pid**, **datadir**, and **port** come from the defaults.
    We have looked at the merge order. If the variables are not identical, they are
    merged to create the final configuration.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**user**、**pid**、**datadir**和**port**的值来自默认值。我们已经看过合并顺序。如果变量不完全相同，它们将被合并以创建最终配置。'
- en: The value for a socket comes from vars as that's the only place it has been
    defined. Nevertheless, we want this socket to be constant for the RedHat-based
    system, hence, we specified it in the vars directory of the role.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字的值来自vars，因为这是唯一定义它的地方。不过，我们希望这个套接字在基于RedHat的系统中保持常量，因此我们将其指定在角色的vars目录中。
- en: 'The `bind_address` parameter comes from the vars directory again. This is interesting
    as we have the `mysql_bind` variable defined at the following locations:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind_address`参数再次来自vars目录。这一点很有趣，因为我们在以下位置定义了`mysql_bind`变量：'
- en: '`Default` in a role'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色中的`Default`
- en: '`group_vars`'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group_vars`'
- en: '`playbook`'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbook`'
- en: '`vars` in a role'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色中的`vars`
- en: 'The following figure depicts the precedence rules when we define the same variable
    more than once:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了当我们多次定义相同变量时的优先级规则：
- en: '![Variable precedence](img/B03800_03_03.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![变量优先级](img/B03800_03_03.jpg)'
- en: Since our role defines the `bind_address` parameter in the `vars` directory,
    it takes precedence over the rest.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的角色在`vars`目录中定义了`bind_address`参数，它优先于其他所有参数。
- en: There is a way to override a role parameter using extra variables or the `-e`
    switch while running Ansible. This is the supreme level of precedence for a variable
    that Ansible manages.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以在运行Ansible时使用额外的变量或`-e`选项来覆盖角色参数。这是Ansible管理的变量的最高优先级。
- en: 'For example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding launch command, we used the `-e` switch, which will override
    all the other variable levels and make sure that the MySQL server is bound to
    `127.0.0.1`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的启动命令中，我们使用了`-e`选项，它将覆盖其他所有变量级别，并确保MySQL服务器绑定到`127.0.0.1`。
- en: The best practices for variable usage
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量使用的最佳实践
- en: 'Overwhelming, eh? Do not worry. We will give you the recommendations on the
    best practices while using variables:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让人有些不知所措，对吧？别担心，我们将给你一些关于使用变量的最佳实践建议：
- en: Start with defaults in a role. This has the lowest precedence of all. This is
    also a good place to provide the sane defaults of your application, which can
    be later overridden from various places.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从角色中的默认值开始。这是所有优先级中最低的。这也是提供应用程序合理默认值的好地方，这些默认值之后可以从不同的地方被覆盖。
- en: Group variables are very useful. A lot of the time we will do region-specific
    or environment-specific configurations. We would also apply certain roles to a
    certain group of servers, for example, for all web servers in Asia, we apply the
    Nginx role. There is also a default group by the name "`all`", which will contain
    all the hosts for all groups. It's a good practice to put the variables common
    for all groups in "`all`" (`group_vars/all`), which can then be overridden by
    more specific groups.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组变量非常有用。我们很多时候会做区域特定或环境特定的配置。我们还会将某些角色应用于特定组的服务器，例如，对于亚洲的所有Web服务器，我们应用Nginx角色。还有一个名为"`all`"的默认组，它将包含所有组的所有主机。将所有组共享的变量放在"`all`"（`group_vars/all`）中是一个好习惯，之后可以被更具体的组覆盖。
- en: If there are host-specific exceptions, use `hosts_vars`, for example, `host_vars/specialhost.example.org`.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有主机特定的例外情况，请使用`hosts_vars`，例如`host_vars/specialhost.example.org`。
- en: 'If you would like to separate variables in different files, create directories
    named after the hosts and put the variable files inside it. All files inside those
    directories will be evaluated:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你希望将变量分开存放在不同的文件中，可以创建以主机名命名的目录，并将变量文件放入其中。该目录下的所有文件都会被评估：
- en: '`group_vars/asia/web`'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group_vars/asia/web`'
- en: '`host_vars/specialhost/nginx`'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host_vars/specialhost/nginx`'
- en: '`host_vars/specialhost/mysql`'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host_vars/specialhost/mysql`'
- en: If you would like to keep your roles generic and sharable, use defaults in the
    roles and then specify organization-specific variables from playbooks. These can
    be specified as role parameters.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你希望保持角色的通用性并且能够共享，请在角色中使用默认值，然后从playbook中指定特定于组织的变量。这些可以作为角色参数来指定。
- en: If you would like role variables to always take precedence over inventory variables
    and playbooks, specify them in the `vars` directory inside a role. This is useful
    for providing role constants for specific platforms.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你希望角色变量始终优先于清单变量和playbooks中的变量，可以将它们指定在角色的`vars`目录中。这对于为特定平台提供角色常量很有用。
- en: Finally, if you would like to override any of the preceding variables and provide
    some data during runtime, provide an extra variable with Ansible commands using
    the `-e` option.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果你希望在运行时覆盖上述任何变量并提供一些数据，可以在使用Ansible命令时通过`-e`选项提供额外的变量。
- en: 'By now, our tree for the MySQL role and DB playbook should look like the following
    figure:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的MySQL角色和数据库playbook的目录结构应该像下面的图示一样：
- en: '![The best practices for variable usage](img/B03800_03_13.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![变量使用最佳实践](img/B03800_03_13.jpg)'
- en: Review questions
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: 'Do you think you''ve understood the chapter well enough? Try answering the
    following questions to test your understanding:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为你已经足够理解本章内容了吗？尝试回答以下问题以测试你的理解：
- en: How are Jinja2 templates different from static files?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jinja2 模板与静态文件有什么不同？
- en: What are facts? How are they discovered?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是事实（facts）？它们是如何被发现的？
- en: What is the difference between `{{ }}` and `{% %}` in the context of Jinja2
    templates?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jinja2 模板中，`{{ }}` 和 `{% %}` 有什么区别？
- en: Can you use a variable anywhere apart from templates? If yes, where?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了模板外，你还可以在其他地方使用变量吗？如果可以，在哪里？
- en: If you define a variable `foo` in the `vars` directory in a role and the same
    variable in the `hosts_var` file, which of these will take precedence?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在角色的 `vars` 目录中定义了变量 `foo`，并且在 `hosts_var` 文件中也定义了相同的变量，那么这两个变量中哪个会优先使用？
- en: How do you write Ansible roles that are supported on multiple platforms?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何编写支持多个平台的 Ansible 角色？
- en: Where can you specify the author and licensing information in a role?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在角色的哪里指定作者和许可信息？
- en: How do you provide variables while launching an Ansible-playbook command?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在启动 Ansible-playbook 命令时提供变量？
- en: Which command would you use to create a directory structure required by the
    roles automatically?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个命令来自动创建角色所需的目录结构？
- en: How do you override a variable specified in the `vars` directory of a role?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何覆盖角色 `vars` 目录中指定的变量？
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started this chapter by learning about why and how to separate data from
    code using Ansible variables, facts, and Jinja2 templates. You learnt how to create
    data-driven roles by providing variables and facts in templates, tasks, handlers,
    and playbooks. Additionally, we created a new role for the database tier, which
    supports both the Debian and RedHat families of operating systems. You learnt
    what system facts are and how they are discovered and used. You learnt how variables
    can be specified from more than one place, how they are merged, and the precedence
    rules. Finally, you learnt about the best practices for using variables.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的开始，我们学习了为什么以及如何使用 Ansible 变量、事实和 Jinja2 模板将数据与代码分离。你学会了通过在模板、任务、处理器和 playbook
    中提供变量和事实来创建数据驱动的角色。此外，我们为数据库层创建了一个新角色，该角色支持 Debian 和 RedHat 两大操作系统家族。你学会了系统事实是什么，以及它们是如何被发现和使用的。你了解了变量可以从多个地方指定，它们是如何合并的以及优先级规则。最后，你了解了使用变量的最佳实践。
- en: In the next chapter, we will work with custom commands and scripts, understand
    what registered variables are, and deploy a sample WordPress application using
    all this information.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习如何使用自定义命令和脚本，了解什么是注册变量，并使用这些信息部署一个示例 WordPress 应用。
