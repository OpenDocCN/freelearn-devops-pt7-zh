- en: Tips and Tricks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示与技巧
- en: 'his chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将介绍以下内容：
- en: Using git stash
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 git stash
- en: Saving and applying stashes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和应用存储的更改
- en: Debugging with git bisect
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 git bisect 进行调试
- en: Using the blame command
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 blame 命令
- en: Coloring the UI in the prompt
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提示符中为 UI 着色
- en: Autocompletion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动补全
- en: Bash prompt with status information
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有状态信息的 Bash 提示符
- en: More aliases
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多别名
- en: Interactive add
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式添加
- en: Interactive add with Git gui
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Git gui 进行交互式添加
- en: Ignoring files
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略文件
- en: Showing and cleaning ignored files
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示和清理被忽略的文件
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, you will find some tips and tricks that can be useful in everyday
    Git work; from stashing away your changes when you get interrupted while doing
    an important task, to efficient bug hunting with `bisect` and `blame`, to finding
    color and status information in your prompt. We'll also look at aliases, how you
    can create clean commits by selecting which lines should be included in the commit
    and, finally, how you can ignore files.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你会发现一些在日常 Git 工作中非常有用的提示和技巧；从在重要任务被打断时存储更改，到通过 `bisect` 和 `blame` 高效调试，再到在提示符中查看颜色和状态信息。我们还将了解别名，如何选择要包含在提交中的行，从而创建干净的提交，最后，我们将介绍如何忽略文件。
- en: Using git stash
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 git stash
- en: In this example, we'll explore the `git stash` command and learn how we can
    use it to quickly `stash` away uncommitted changes and retrieve them again. This
    can be useful when you are interrupted while doing an urgent task and you are
    not yet ready to commit the work you currently have in your working directory.
    With the `git stash` command, you can save the state of your current working directory
    with/without a staging area and restore the working tree to a clean state.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探索 `git stash` 命令，并学习如何使用它快速将未提交的更改存储起来，并在需要时重新获取。这在你被紧急任务打断时很有用，而此时你还不准备提交当前工作目录中的工作。使用
    `git stash` 命令，你可以保存当前工作目录（有或没有暂存区）的状态，并将工作树恢复到干净的状态。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this example, we''ll use the `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks` repository.
    We''ll use the `master` branch, but before we are ready to try the `stash` command,
    we need to create some changes in the working directory and the staging area,
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用 `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks` 仓库。我们将使用
    `master` 分支，但在尝试 `stash` 命令之前，我们需要在工作目录和暂存区中创建一些更改，方法如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Make some changes to `foo` and add them to the staging area, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `foo` 进行一些更改并将它们添加到暂存区，方法如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Make some changes to `bar` and create a new file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `bar` 进行一些更改并创建一个新文件：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see that we have one file added to the staging area, `foo`, one modified
    file, `bar`, and an untracked file in the work area as well, `new_file`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有一个文件被添加到暂存区，`foo`，一个文件被修改，`bar`，以及一个未跟踪的文件在工作区中，`new_file`。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'With the preceding state of our repository, we can stash away the changes so
    that we can work on something else. The basic command will put away changes from
    the staging area and changes made to tracked files. It leaves untracked files
    in the working directory:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们仓库的前述状态下，我们可以将更改存储起来，以便去处理其他事务。基本命令会将暂存区的更改和对已跟踪文件的更改存储起来。它会将未跟踪的文件留在工作目录中：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now work on something else and create and commit those changes. We''ll
    change the first line of the `foo` file and create a commit with this change:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以处理其他事务，创建并提交这些更改。我们将更改 `foo` 文件的第一行，并创建一个包含此更改的提交：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can see the current work we have stashed away with the `git stash list`
    command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `git stash list` 命令查看当前存储的更改：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get the changes we stashed away back, we can pop them from the `stash` stack,
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取我们之前存储的更改，可以从 `stash` 栈中弹出它们，方法如下：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, the stashed changes are available again in the working repository and the
    `stash` entry has been deleted. Note that the changes are applied only to the
    working directory, although one of the files was staged when we created the `stash`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，存储的更改可以在工作仓库中再次使用，并且 `stash` 条目已被删除。请注意，这些更改仅应用于工作目录，尽管在我们创建 `stash` 时其中一个文件已被暂存。
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We have created two commits: one for the index and one for the work area. In
    `gitk`, we can see the commits that `stash` creates to put the changes away (`gitk
    stash`), as shown in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已创建了两个提交：一个是索引提交，一个是工作区提交。在 `gitk` 中，我们可以看到 `stash` 创建的提交，以将更改存储起来（`gitk stash`），如下图所示：
- en: '![](img/7406e649-8999-4398-bac9-ed3f94ad2f21.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7406e649-8999-4398-bac9-ed3f94ad2f21.png)'
- en: 'We can also see the state of the branches after we created the commit (`gitk
    --reflog`), as shown in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查看我们创建提交后的分支状态（`gitk --reflog`），如下图所示：
- en: '![](img/9daab906-9007-41b7-9006-3bb61e821a8d.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9daab906-9007-41b7-9006-3bb61e821a8d.png)'
- en: Git actually creates two commits under the `refs/stash` namespace. One commit
    contains the contents of the staging area. This commit is called `index on master`.
    The other commit is the work in progress in the working directory, `WIP on master`.
    When Git puts away changes by creating commits, it can use its normal resolution
    methods to apply the stashed changes back to the working directory. This means
    that if a conflict arises when applying the stash, you need it to be solved in
    the usual way.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Git实际上会在`refs/stash`命名空间下创建两个提交。一个提交包含暂存区的内容，这个提交被称为`index on master`。另一个提交是工作目录中的进行中的工作，`WIP
    on master`。当Git通过创建提交来暂存更改时，它可以使用正常的解析方法将暂存的更改应用回工作目录。这意味着如果在应用stash时出现冲突，你需要以常规方式解决冲突。
- en: There's more...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'In the preceding example, we saw only the very basic usage of the `stash` command,
    putting away changes to untracked files and changes added to the staging area.
    It is also possible to include untracked files in the `stash` command. This can
    be done with the `--include-untracked` option. We can add `foo` to the staging
    area; firstly, to have the same state as when we created the `stash` earlier and
    then to create a `stash` that includes untracked files:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们只看到了`stash`命令的基本用法，保存了对未追踪文件和添加到暂存区的更改。也可以在`stash`命令中包含未追踪的文件。可以通过`--include-untracked`选项来实现。我们可以将`foo`添加到暂存区；首先，使它与我们之前创建`stash`时的状态相同，然后创建一个包含未追踪文件的`stash`：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we can see that `new_file` has disappeared from the working directory.
    It''s included in the stash, and we can check this with Gitk. It will show up
    as another commit of untracked files:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到`new_file`已从工作目录中消失。它已包含在stash中，我们可以通过Gitk来检查这一点。它会显示为另一个未追踪文件的提交：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Gitk shows the stash with its untracked files:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Gitk显示包含未追踪文件的stash：
- en: '![](img/67d05fc8-ab3b-45f1-a62c-3e33ff4c3bf0.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67d05fc8-ab3b-45f1-a62c-3e33ff4c3bf0.png)'
- en: 'We can also make sure that the changes we added to the staging area are added
    back to the staging area after we apply the `stash`, so we end up with the exact
    same state as before we stashed our changes away:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以确保，在应用`stash`后，暂存区中添加的更改会重新添加回暂存区，这样我们就能恢复到暂存更改前的完全相同状态：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It''s also possible to put away only the changes in the working directory,
    while keeping the changes in the staging area. We can do this either for only
    the tracked files or by stashing away untracked files ( `--include-untracked`),
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以只保存工作目录中的更改，同时保留暂存区中的更改。我们可以仅为已追踪的文件执行此操作，或通过暂存未追踪文件（`--include-untracked`）来实现，方法如下：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Saving and applying stashes
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和应用暂存
- en: When stashing away work, we can easily have more than one state stashed away
    at a time. However, the default names for stashed away changes aren't always helpful.
    In this example, we'll see how we can save stashes and name them so that it is
    easy to identify them again when listing the content of the stash. We'll also
    learn how to apply a stash without deleting it from the stash list.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存工作时，我们可以轻松地将多个状态暂存。但是，默认的暂存名称并不总是很有帮助。在这个示例中，我们将看到如何保存stash并为其命名，以便在列出stash内容时容易识别。我们还将学习如何应用stash，而不将其从stash列表中删除。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'We''ll use the same repository as in the previous example, continuing from
    the state we left it in:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与前面示例相同的仓库，继续从我们离开时的状态：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To save the current state to a stash with a description we can remember at
    a later point in time, use the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要将当前状态保存到一个带有描述的暂存区，以便我们在稍后的时间能够记住，可以使用以下命令：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our `stash` list now looks like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`stash`列表现在如下所示：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can change `bar` and create a new `stash`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更改`bar`并创建一个新的`stash`：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can apply the stashes back to the working tree (and staging area with the
    `--index option`) without deleting them from the `stash` list:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将stash应用回工作树（并通过`--index`选项应用到暂存区），而不将其从`stash`列表中删除：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The stashes are still in the `stash` list, and they can be applied in any order
    and referred to with the `stash@{stash-no}` syntax. The `--quiet` option suppresses
    the status output after the stashes have been applied.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 存储仍然保留在`stash`列表中，可以按任何顺序应用，并通过`stash@{stash-no}`语法进行引用。`--quiet`选项在应用存储后会抑制状态输出。
- en: There's more...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'For stashes applied with `git stash apply`, the `stash` needs to be deleted
    with `git stash drop`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用`git stash apply`应用的存储，`stash`需要通过`git stash drop`删除：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Keeping the stashes in the `stash` list by using `stash apply` and explicitly
    deleting them with `git stash drop` has some advantages over just using `stash
    pop`. When using the `pop` option, the stashes in the list are automatically deleted
    if they can be successfully applied. But if it fails and triggers the conflict
    resolution mode, the stash applied is not dropped from the list and continues
    to exist on the `stash` stack. This might later lead to accidentally using the
    wrong `stash` because it was thought to have been removed. By consistently using
    `git stash apply` and `git stash drop`, you can avoid this scenario.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`stash apply`将存储保持在`stash`列表中，并通过`git stash drop`明确删除它们，相比直接使用`stash pop`有一些优势。当使用`pop`选项时，如果存储能够成功应用，它会自动从列表中删除。但是如果应用失败并进入冲突解决模式，应用的存储不会从列表中删除，而是仍然保留在`stash`堆栈中。这样可能会导致后续错误地使用未被删除的存储，因为它被误认为已被移除。通过始终使用`git
    stash apply`和`git stash drop`，你可以避免这种情况。
- en: 'The `git stash` command can also be used to apply debug information to an application.
    Let''s pretend you have been bug hunting and have added a lot of debug statements
    to your code in order to track down a bug. Instead of deleting all those debug
    statements, you can save them as a Git `stash`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`git stash`命令也可以用来将调试信息应用到一个应用程序中。假设你正在进行 bug 寻找，并且在代码中添加了很多调试语句以追踪 bug。与其删除所有这些调试语句，不如将它们保存为
    Git 的`stash`：'
- en: '`$ git stash save "Debug info stash"`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ git stash save "调试信息存储"`'
- en: Then, if you need debug statements later, you can just apply the stash and you'll
    be ready to debug.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果以后需要调试语句，你只需应用存储，你就可以准备好进行调试了。
- en: Debugging with git bisect
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 git bisect 进行调试
- en: The `git bisect` command is an excellent tool to find which commit caused a
    bug in the repository. The tool is particularly useful if you are looking at a
    long list of commits that may contain the bug. The `bisect` command performs a
    binary search through the commit history to find the commit that introduced the
    bug as fast as possible. The binary search method, or bisection method, as it
    is also called, is a search method where an algorithm finds the position of a
    key in a sorted array. In each step of the algorithm, the key is compared to the
    middle value of the array and if they match, the position is returned. Otherwise,
    the algorithm repeats its search in the subarray to the right or left of the middle
    value, depending on whether the middle value was greater or less than the key.
    In the Git context, the list of commits in the history makes up for the array
    of values to be tested, and the key can be a test if the code can be compiled
    successfully at the given commit. The binary search algorithm has a performance
    of *O(log n)*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`git bisect`命令是一个极好的工具，用于找出哪个提交导致了仓库中的 bug。这个工具特别有用，尤其是在你查看包含 bug 的长提交列表时。`bisect`命令通过执行二分查找来查找引入
    bug 的提交，从而尽可能快速地找到这个提交。二分查找法，也叫做折半查找法，是一种搜索方法，算法通过比较给定的关键字与已排序数组的中间值来定位该关键字。在每一步中，如果它们匹配，则返回该位置。否则，算法会根据中间值是否大于或小于关键字，选择继续在中间值左侧或右侧的子数组中查找。在
    Git 上下文中，提交历史中的提交列表相当于要测试的数组，而关键字则是测试某个提交时代码是否能成功编译。二分查找算法的时间复杂度为 *O(log n)*。'
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll use the same repository as seen in the last example, but from a clean
    state:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与上一个示例中相同的仓库，但从一个干净的状态开始：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `bug_hunting` branch contains 23 commits, since it branched off from the
    `master` branch. We know that the tip of the `bug_hunting` branch contains the
    bug and that it was introduced in a commit, since it branched off from `master`.
    The bug was introduced in the following commit:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`bug_hunting`分支自`master`分支分出后包含了23次提交。我们知道`bug_hunting`分支的最新提交包含了这个 bug，并且它是在某个提交中引入的，因为它是从`master`分支分出的。这个
    bug 是在以下提交中引入的：'
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The bug is clearly visible in the `map.txt` file, in the middle of Australia.
    The following snippet of the file shows the bug:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`map.txt`文件中，位于澳大利亚中部的地方清楚地显示了这个 bug。以下是文件中的片段，展示了这个 bug：
- en: '![](img/c0523183-60dc-4d83-b8af-a6f02eb395b3.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0523183-60dc-4d83-b8af-a6f02eb395b3.png)'
- en: Now, all we need is some way to reproduce/detect the bug so that we can test
    the different commits. This could, for example, simply be to compile the code,
    run tests, and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要某种方式来重现/检测这个错误，以便我们能够测试不同的提交。例如，可以是编译代码、运行测试等。
- en: 'For this example, we''ll create a test script to check for bugs in the code
    (a simple `grep` for `oo` should do it in this example; see for yourself if you
    can find the bug in the `map.txt` file):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个测试脚本来检查代码中的错误（在这个示例中，简单的`grep`命令查找`oo`应该可以；你可以自己试试看，是否能在`map.txt`文件中找到错误）：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It's better to create this test script outside the repository to prevent interactions
    between checkouts, compilation, and so on in the repository.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在仓库外创建这个测试脚本，以防止在仓库中的检出、编译等操作之间的相互作用。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To begin bisecting, we simply type the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始二分查找，我们只需输入以下命令：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To mark the current commit (`HEAD -> bug_hunting`) as bad, we type the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要将当前提交（`HEAD -> bug_hunting`）标记为坏，我们输入以下命令：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We also want to mark the last known good commit (`master`) as good:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想将最后一个已知的好提交（`master`）标记为好：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This time, something happened. Git did a checkout of `9d2cd13`, which it wants
    us to test and mark as either good or bad. It also tells us there are 11 revisions
    to test after this, and it can be done in approximately four steps. This is how
    the bisecting algorithm works: every time a commit is marked as good or bad, Git
    will `checkout` the one between the commit that has just been marked and the current
    commit of opposite value. In this way, Git quickly narrows down the number of
    commits to check. It also knows that there are approximately four steps, and this
    makes sense since, with 11 revisions left, the maximum number of tries is *log[2](11)
    = 3.46* before the faulty commit is found.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，发生了点事情。Git 检出了`9d2cd13`，它希望我们测试并将其标记为好或坏。它还告诉我们，在此之后还有 11 个修订需要测试，大约需要四个步骤才能完成。这就是二分查找算法的工作原理：每次标记一个提交为好或坏时，Git
    会`checkout`介于刚标记的提交和当前提交之间的那个相反值的提交。通过这种方式，Git 会快速缩小需要检查的提交数量。它还知道大约需要四步，这很合理，因为剩下
    11 个修订，最多需要 *log[2](11 = 3.46* 步才能找到错误的提交。
- en: 'We can test with the `test.sh` script we created previously, and based on the
    return value, mark the commit as good or bad:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用之前创建的`test.sh`脚本进行测试，并根据返回值将提交标记为好或坏：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The test marks the commit as good and Git checks out the next commit to be
    marked, until we hit the commit that introduces the bug:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将提交标记为好，然后 Git 会检查下一个需要标记的提交，直到我们找到引入错误的提交：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After four steps, Git has identified the `83c22a3` commit as the first bad
    commit. We can end the `bisect` session and take a closer look at the commit:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 四步之后，Git 已经确认`83c22a3`提交是第一个坏提交。我们可以结束`bisect`会话并仔细查看该提交：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Clearly, a bug was introduced with this commit.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这个提交引入了错误。
- en: 'The following annotated screenshot shows the steps taken by the `bisect` session:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下注释截图展示了`bisect`会话中所采取的步骤：
- en: '![](img/5e06b301-474f-479b-a48f-628a01617960.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e06b301-474f-479b-a48f-628a01617960.png)'
- en: Note that the bisection algorithm actually hits the faulty commit in the third
    step, but it needs to look further to make sure that the commit isn't just a child
    commit of the faulty commit, and is in fact the commit that introduced the bug.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，二分查找算法实际上在第三步就找到了错误的提交，但它需要进一步检查，以确保这个提交不仅仅是错误提交的子提交，确实是引入错误的提交。
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Instead of running all the bisecting steps manually, it''s possible to do it
    automatically by passing Git a script, makefile, or test to run on each commit.
    The script needs to exit with a **zero-status** to mark a commit as good and a
    **non-zero** status to mark it as bad. We can use the `test.sh` script we created
    at the beginning of this chapter for this. First, we set up the good and bad commits:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要手动执行所有二分查找步骤，可以通过将一个脚本、makefile 或测试传递给 Git 来自动执行这些步骤。脚本需要在每次提交时退出时返回**零状态**来标记提交为好提交，返回**非零状态**来标记提交为坏提交。我们可以使用在本章开头创建的`test.sh`脚本来实现这一点。首先，我们设置好好提交和坏提交：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we tell Git to run the `test.sh` script and automatically mark the commits:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们告诉 Git 运行`test.sh`脚本，并自动标记提交：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Git found the same commit and we can now exit the bisecting session:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Git 找到了相同的提交，我们现在可以退出二分查找会话：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using the blame command
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`blame`命令
- en: The `bisect` command is good when you don't know where in your code there is
    a bug, but you can test for it and thereby find the commit that introduced it.
    If you already know where in the code the bug is but want to find the commit that
    introduced it, you can use `git blame`. The `blame` command will annotate every
    line in the file with the commit that most recently touched that line, making
    it easy to find the commit ID and then the full context of the commit.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`bisect`命令在你不知道代码中哪个地方有 bug，但可以测试它并因此找到引入 bug 的提交时非常有用。如果你已经知道 bug 出现在代码的哪个地方，但想找到引入
    bug 的提交，你可以使用`git blame`。`blame`命令会在文件中的每一行旁边标注最近修改该行的提交，帮助你轻松找到提交 ID，并查看提交的完整上下文。'
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll use the same repository and branch as in the bisect example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与 bisect 示例中相同的仓库和分支：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We know that the bug is in `map.txt` on lines 37-39\. To annotate each line
    in the file with the commit ID and author, we''ll run `git blame` on the file.
    We can further limit the search to specific lines with the `-L <from>,<to>` option,
    as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 bug 出现在`map.txt`的第 37 到第 39 行。为了标注文件中每一行的提交 ID 和作者，我们将对该文件运行`git blame`。我们还可以使用`-L
    <from>,<to>`选项将搜索限制在特定行，如下图所示：
- en: '![](img/6a9c27d8-3809-483d-86c7-3458e6067a63.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a9c27d8-3809-483d-86c7-3458e6067a63.png)'
- en: From the output, it can clearly be seen that the commit with the ID `83c22a39`
    by `HAL 9000` introduced the bug.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以清楚地看到，由`HAL 9000`提交的 ID 为`83c22a39`的提交引入了这个 bug。
- en: There's more...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `blame` command can be used even if the file has been refactored and the
    code has been moved around. With the `-M` option, the `blame` command can detect
    lines that have been moved within the file, and with the `-C` option, Git can
    detect lines that were moved or copied from other files in the same commit. If
    the `-C` option is used three times `-CCC`, the `blame` command will find lines
    that were copied from other files in any commit.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使文件已经重构且代码已被移动，`blame`命令仍然可以使用。通过`-M`选项，`blame`命令可以检测文件中已被移动的行；而使用`-C`选项，Git可以检测在同一提交中从其他文件移动或复制过来的行。如果使用`-C`选项三次`-CCC`，`blame`命令将能够找到在任何提交中从其他文件复制的行。
- en: Coloring the UI in the prompt
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在提示符中为 UI 着色
- en: By default, Git has no colors when displaying information in the terminal. However,
    displaying colors is a feature of Git that is only a configuration away.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Git 在终端中显示信息时没有颜色。然而，显示颜色是 Git 的一项功能，只需配置一下即可启用。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll use the `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks`
    repository:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks`仓库：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we''ll edit and add `foo`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编辑并添加`foo`：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Change `foo` some more, but don''t add it to the staging area:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 继续更改`foo`，但不要将其添加到暂存区：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a new file called `test`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`test`的新文件：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `git status` command will show us the status:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`git status`命令将显示我们的状态：'
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can set the `color.ui` configuration to `auto` or `true` to get color in
    the UI when required:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`color.ui`配置设置为`auto`或`true`，这样在需要时，UI 会显示颜色：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `color.ui` configuration works with a long range of Git commands, `diff`,
    `log`, and `branch` included. The following is an example of `git log` when setting
    `color.ui` to `true`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`color.ui`配置适用于广泛的 Git 命令，包括`diff`、`log`和`branch`。以下是将`color.ui`设置为`true`时的`git
    log`示例：'
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Autocompletion
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动补全
- en: Git comes with built-in support for the autocompletion of Git commands for the
    `bash` and `zsh` shells. If you use either of these shells, you can enable the
    autocompletion feature and let the `<tab>` option help you complete commands.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Git 内置支持`bash`和`zsh` Shell 的 Git 命令自动补全功能。如果你使用这两种 Shell 中的任何一种，你可以启用自动补全功能，并使用`<tab>`选项来帮助你完成命令。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Generally, the autocompletion feature is distributed with the Git installation,
    but it is not enabled by default on all platforms or distributions. To enable
    it, we need to find the `git-completion.bash` file distributed/installed with
    the Git installation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，自动补全功能会随 Git 安装包一起分发，但在某些平台或发行版上并未默认启用。要启用该功能，我们需要找到与 Git 安装一起分发/安装的`git-completion.bash`文件。
- en: Linux
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: For Linux users, the location may vary depending on the distribution. Generally,
    the file can be found at `/etc/bash_completion.d/git-completion.bash`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 用户，位置可能会根据发行版的不同而有所不同。通常，该文件可以在`/etc/bash_completion.d/git-completion.bash`找到。
- en: Mac
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mac
- en: For Mac users, it can generally be found at `/Library/Developer/CommandLineTools/usr/share/git-core/git-completion.bash`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Mac 用户，通常可以在 `/Library/Developer/CommandLineTools/usr/share/git-core/git-completion.bash`
    找到。
- en: If you installed Git from Homebrew, it can be found at `/usr/local/Cellar/git/2.15.0/etc/bash_completion.d/git-completion.bash`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是通过 Homebrew 安装的 Git，它可以在 `/usr/local/Cellar/git/2.15.0/etc/bash_completion.d/git-completion.bash`
    找到。
- en: Windows
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: With the **Msysgit** installation on Windows, the completion functions are already
    enabled in the Git Bash shell it bundles.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Msysgit** 在 Windows 上安装时，Git Bash Shell 已经启用了补全功能。
- en: If you can't find the file on your system, you can obtain the latest version
    from [https://github.com/git/git/blob/master/contrib/completion/git-completion.bash](https://github.com/git/git/blob/master/contrib/completion/git-completion.bash)
    and install it in your home directory.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在系统中找不到该文件，可以从 [https://github.com/git/git/blob/master/contrib/completion/git-completion.bash](https://github.com/git/git/blob/master/contrib/completion/git-completion.bash)
    获取最新版本，并将其安装到你的主目录中。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To enable the completion feature, you need to run the `source` command on the
    completion file, which you can do by adding the following lines to your `.bashrc`
    or `.zshrc` file, depending on your shell and the location of the Git completion
    file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用补全功能，需要对补全文件运行 `source` 命令，你可以通过将以下几行添加到 `.bashrc` 或 `.zshrc` 文件来实现，具体取决于你的
    Shell 和 Git 补全文件的位置：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Now you are ready to try this. Switch to an existing Git repository, for example,
    `cookbook-tips-tricks`, and type the following commands:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好尝试这个了。切换到一个现有的 Git 仓库，例如 `cookbook-tips-tricks`，然后输入以下命令：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can add another `c<tab>` and the command will autocomplete to `checkout`.
    But the autocompletion feature doesn't only complete commands; it can also help
    you complete branch names, and so on. This means that you can continue with the
    checkout and write `mas<tab>`. You should be able to see the output completed
    to the `master` branch, unless you are in a repository where there are several
    branches starting with `mas`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以再输入一次 `c<tab>`，命令会自动补全为 `checkout`。但是补全功能不仅仅补全命令，它也能帮助你补全分支名等等。这意味着你可以继续执行
    checkout 并输入 `mas<tab>`。你应该能看到输出自动补全为 `master` 分支，除非你在一个有多个以 `mas` 开头的分支的仓库中。
- en: There's more...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The completion feature also works with options. This is quite useful if you
    can''t remember the exact option but you may remember some of it, for example,
    when using `git branch`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 补全功能也适用于选项。这在你记不清确切选项，但记得一些内容时非常有用，例如在使用 `git branch` 时：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Bash prompt with status information
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有状态信息的 Bash 提示符
- en: Another cool feature Git provides is having the prompt display status information
    if the current working directory is a Git repository.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Git 提供的另一个酷炫功能是，如果当前工作目录是一个 Git 仓库，提示符会显示状态信息。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For the status information prompt to work, we also need to source another file, `git-prompt.sh`,
    which is usually distributed with the Git installation and located in the same
    directory as the completion file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使状态信息提示符正常工作，我们还需要加载另一个文件，`git-prompt.sh`，该文件通常与 Git 安装一起分发，并位于与完成文件相同的目录中。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In your `.bashrc` or `.zshrc` file, add the following code snippet, again depending
    on your shell and the location of the `git-prompt.sh` file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `.bashrc` 或 `.zshrc` 文件中，添加以下代码片段，具体取决于你的 Shell 和 `git-prompt.sh` 文件的位置：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To make use of the Command Prompt, we must change the `PS1` variable; usually
    this is set to something like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用命令提示符，我们必须修改 `PS1` 变量；通常它设置为类似以下内容：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding command shows the current user, an `@` sign, the hostname, the
    current working directory relative to the user''s home directory, and finally,
    the `$` character:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会显示当前用户、一个 `@` 符号、主机名、相对于用户主目录的当前工作目录，最后是 `$` 字符：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can change this to add a branch name after the working directory by adding
    `$(__git_ps1 " (%s)")` to the `PS1` variable:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `$(__git_ps1 " (%s)")` 添加到 `PS1` 变量中，来修改它，使其在工作目录后面添加分支名：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Our prompt will now look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的提示符看起来是这样的：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is also possible to show the state of the working tree, the index, and so
    on. We can enable these features by exporting some environment variables in the
    `.bashrc` file that `git-prompt.sh` picks up.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以显示工作树、索引等的状态。我们可以通过在 `.bashrc` 文件中导出一些环境变量来启用这些功能，`git-prompt.sh` 会自动获取这些变量。
- en: 'The following environment variables can be set:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置以下环境变量：
- en: '| **Variable** | **Value** | **Effect** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **值** | **效果** |'
- en: '| `GIT_PS1_SHOWDIRTYSTATE` | Nonempty | Shows `*` for unstaged changes and
    `+` for staged changes. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `GIT_PS1_SHOWDIRTYSTATE` | 非空 | 显示 `*` 代表未暂存的更改，显示 `+` 代表已暂存的更改。 |'
- en: '| `GIT_PS1_SHOWSTASHSTATE` | Nonempty | Shows the `$` character if something
    is stashed. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `GIT_PS1_SHOWSTASHSTATE` | 非空 | 如果有暂存内容，则显示`$`字符。 |'
- en: '| `GIT_PS1_SHOWUNTRACKEDFILES` | Nonempty | Shows the `%` character if there
    are untracked files in the repository. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `GIT_PS1_SHOWUNTRACKEDFILES` | 非空 | 如果仓库中有未跟踪的文件，则显示 `%` 字符。 |'
- en: '| `GIT_PS1_SHOWUPSTREAM` | autoverbosenamelegacyGitsvn | Auto shows whether
    you are behind (`<`) or ahead (`>`) of the upstream branch. A `<>` value is displayed
    if the branch is diverged and `=` if it is up to date. Verbose shows the number
    of commits behind/ahead. Name shows the upstream name. Legacy is verbose for old
    versions of Git. Git compares `HEAD` to `@{upstream}`. SVN compares `HEAD` to
    `svn upstream`. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `GIT_PS1_SHOWUPSTREAM` | autoverbosenamelegacyGitsvn | 自动显示是否落后于（`<`）或领先于（`>`）上游分支。如果分支已经分歧，将显示
    `<>`，如果是最新的，则显示 `=`。Verbose 显示落后/领先的提交数量。Name 显示上游的名称。Legacy 是旧版本 Git 的详细信息。Git
    比较 `HEAD` 和 `@{upstream}`。SVN 比较 `HEAD` 和 `svn upstream`。 |'
- en: '| `GIT_PS1_DESCRIBE_STYLE` | containsbranchdescribedefault | Displays extra
    information when on a detached `HEAD`. Contains is relative to a newer annotated
    tag (`v1.6.3.2~35`). Branch is relative to a newer tag or branch (`master~4`).
    Describe is relative to an older annotated tag (`v1.6.3.1-13-gdd42c2f`). Default
    is the tag that matches exactly. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `GIT_PS1_DESCRIBE_STYLE` | containsbranchdescribedefault | 当处于分离的 `HEAD`
    状态时，显示额外的信息。Contains 表示相对于更新的注释标签（`v1.6.3.2~35`）。Branch 表示相对于更新的标签或分支（`master~4`）。Describe
    表示相对于较旧的注释标签（`v1.6.3.1-13-gdd42c2f`）。Default 是完全匹配的标签。 |'
- en: 'Let''s try to set some of the variables in the `~/.bashrc` file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在 `~/.bashrc` 文件中设置一些变量：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s see the `~/.bashrc` file in action:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `~/.bashrc` 文件的实际应用：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When using the `__git_ps1` option, Git will also display information when merging,
    rebasing, bisecting, and so on. This is very useful and a lot of `git status`
    commands suddenly become unnecessary, as you have the information right there
    in the prompt.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `__git_ps1` 选项时，Git 还会在合并、变基、二分搜索等操作时显示信息。这非常有用，很多 `git status` 命令突然变得不再必要，因为您可以直接在提示符中看到这些信息。
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'What is a terminal without some colors these days? The `git-prompt.sh` script
    also supports this. All we need to do is set the `GIT_PS1_SHOWCOLORHINTS` variable
    to a nonempty value and, instead of using `PS1`, we need to use `PROMPT_COMMAND`.
    Let''s change `~/.bashrc`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的终端没有一些颜色怎么行？`git-prompt.sh` 脚本也支持这个功能。我们需要做的就是将 `GIT_PS1_SHOWCOLORHINTS`
    变量设置为非空值，并且不再使用 `PS1`，而是使用 `PROMPT_COMMAND`。让我们修改 `~/.bashrc`：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we redo the same scenario as the previous one, we get the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新执行与之前相同的场景，结果如下：
- en: '![](img/cae11322-952c-4fc9-a382-1d4686e8155a.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cae11322-952c-4fc9-a382-1d4686e8155a.png)'
- en: See also
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: If you are using `zsh` or just want to try something new with many features,
    such as completion, Git support, and so on, you should take a look at the `oh-my-zsh`
    framework, available for `zsh` at: [https://github.com/robbyrussell/oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 `zsh`，或者想尝试一些具有许多功能的新东西，比如自动补全、Git 支持等，您应该看看 `oh-my-zsh` 框架，可以在 `zsh`
    上使用，网址：[https://github.com/robbyrussell/oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)。
- en: More aliases
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多别名
- en: In [Chapter 2](dfad614d-7bef-4396-824c-7bdfcbd22802.xhtml), *Configuration*,
    we saw how we can create aliases and looked at a few examples of them. In this
    section, we will look at some more examples of useful aliases.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](dfad614d-7bef-4396-824c-7bdfcbd22802.xhtml)《配置》中，我们看到了如何创建别名，并且查看了一些例子。在本节中，我们将查看更多有用的别名示例。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'We will have to clone the `cookbook-tips-tricks` repository and check out the
    `aliases` branch:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将克隆 `cookbook-tips-tricks` 仓库并检出 `aliases` 分支：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Here, we'll see some examples of aliases, with a short description of each of
    them and an example of how to use them. The aliases are just made for the local
    repository; use `--global` to make them available for all the repositories.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到一些别名的示例，每个别名都附带简短的描述和使用示例。这些别名仅适用于本地仓库；使用 `--global` 可以将它们应用于所有仓库。
- en: 'Let''s begin with an alias to show the current branch only:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从一个别名开始，它只显示当前分支：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To show a compact graph history view with colors, the following alias will
    save you many keystrokes:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示带有颜色的紧凑型图形历史视图，以下别名将为您节省许多按键：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following screenshot shows you a typical output, where commits are colored
    red, committers are colored blue, and so on:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个典型的输出，其中提交记录以红色显示，提交者以蓝色显示，等等：
- en: '![](img/18966b27-700f-41ae-8672-01228039f358.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18966b27-700f-41ae-8672-01228039f358.png)'
- en: 'When resolving a conflicted merge, it can be useful to get a list of the conflicted/unmerged
    files:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决冲突合并时，获取冲突/未合并文件的列表是很有用的：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can see the previous alias in action by merging the `origin/conflict` branch:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过合并`origin/conflict`分支来看到之前别名的实际效果：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'First, check the output of `git status`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查`git status`的输出：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We see the unmerged path mentioned in the output. Let''s use the `unmerged`
    alias to get a simple list of unmerged files:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在输出中看到了未合并的路径。让我们使用`unmerged`别名来获取一个简单的未合并文件列表：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can abort the merge as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以按如下方式中止合并：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'During a work day, you will type `git status` many times. Adding a shorthand
    status can be helpful:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工作日中，你会多次输入`git status`。添加一个简短的状态命令会非常有帮助：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'An even shorter status with branch and file information can be defined as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 甚至可以定义一个更短的状态命令，显示分支和文件信息：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To try it out, first modify `foo` and create an untracked `test` file:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要尝试它，首先修改`foo`并创建一个未跟踪的`test`文件：
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, try your new `s` alias:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，试试你新的`s`别名：
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Often, you''ll just want to show the latest commit with some stats:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，你只想显示最新的提交及一些统计信息：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'But sometimes, you need a bit more context. The following alias is the same 
    as the previous but for the five latest commits (the output is not shown):'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但有时，你可能需要更多的上下文。以下别名与之前的相同，但会显示五个最新提交的情况（输出未显示）：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A commit listing with statistics on the changed files in color can be displayed
    using the following alias:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下别名可以显示更改文件的统计信息和颜色化的提交列表：
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As the next screenshot shows, committers are colored blue, their age in green,
    and so on:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如下一张截图所示，提交者用蓝色显示，他们的提交时间用绿色显示，等等：
- en: '![](img/feb33e0e-c000-4819-8d9e-f0bf8d3ea163.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/feb33e0e-c000-4819-8d9e-f0bf8d3ea163.png)'
- en: 'If you work in many repositories, remember that the `upstream/tracking` branch
    can be difficult. The following alias is shorthand for showing this:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在多个仓库中工作，记住`upstream/tracking`分支可能会让你感到困惑。以下别名是显示该分支的简写：
- en: '[PRE63]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can show the details of ID/SHA-1 (commit, tag, tree, blob) with the `details`
    alias. Not that you save many keystrokes, but `details` is easier to remember:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用`details`别名查看ID/SHA-1（提交、标签、树、blob）的详细信息。虽然你节省了很多按键，但`details`更容易记住：
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A repository will grow, and the directory tree will become large. You can show
    the number of `cd-ups` and, `../`, needed to go to the repository root using the
    following alias, which can be useful in shell scripts:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仓库会不断增长，目录树也会变得庞大。你可以使用以下别名显示到达仓库根目录所需的`cd-ups`和`../`的数量，这在 shell 脚本中非常有用：
- en: '[PRE65]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The path of the repository on the filesystem can easily be viewed with the
    following alias:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用以下别名轻松查看文件系统中仓库的路径：
- en: '[PRE66]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we need to abandon whatever changes we have in the index, working tree,
    and also possibly the commits, and reset the working tree to a known state (commit
    ID) but we don''t want to touch the untracked files, all we need is a `ref` to
    a state of the repository to be restored, for example, `HEAD`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们需要放弃索引、工作区中的所有更改，并且可能还需要放弃提交记录，然后将工作区重置为已知状态（提交ID），但我们不想触及未跟踪的文件，我们只需要一个仓库状态的`ref`，例如`HEAD`：
- en: '[PRE67]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Interactive add
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式添加
- en: The exposed staging area Git offers sometimes leads to confusion, especially
    when adding a file, changing it a bit, and then adding the file again to be able
    to commit the changes made after the first add. While it can seem a bit cumbersome
    to add the file after every little change, it is also a big advantage that you
    can stage and unstage changes. With the `git add` command, it's even possible
    to only add some changes to a file in the staging area. This comes in handy, especially
    if you make a lot of changes to a file and, for example, want to split the changes
    into bug fixes, refactoring, and features. This example will show how you can
    easily do this.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Git 提供的暴露暂存区有时会导致困惑，尤其是在添加一个文件、稍微更改它，然后再添加该文件以便提交第一次添加后的更改时。尽管每次进行小改动后添加文件看起来有点麻烦，但你可以暂存和取消暂存更改，这是一个很大的优势。使用`git
    add`命令，你甚至可以仅将文件的部分更改添加到暂存区。这在你对文件做了很多修改时尤其方便，例如，你可能希望将更改拆分成修复bug、重构和功能开发等部分。这个例子将展示你如何轻松做到这一点。
- en: Getting ready
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Again, we''ll use the `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks`
    repository. Clone it and check out the interactive branch:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将使用`Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks` 仓库。克隆它并查看交互式分支：
- en: '[PRE68]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we need some changes to be added; we do this by resetting the latest
    commit:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加一些更改；我们通过重置最新的提交来做到这一点：
- en: '[PRE69]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now we have a modified file. To start the interactive add, we can either run
    the `git add -i` or `git add -p` filename. The `-i` option brings up an interface
    where all the different files in the modified state can be added interactively
    one at a time. The `add -p/--patch` option is simpler and just gives you the option
    to add parts of the file specified:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个已修改的文件。要开始交互式添加，我们可以运行`git add -i`或`git add -p`文件名。`-i`选项会显示一个界面，可以逐个交互式地添加处于修改状态的不同文件。`add
    -p/--patch`选项更简单，直接让你选择要添加的文件的部分内容：
- en: '[PRE70]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Git asks you whether you want to stage the previous change (the hunk), but
    also shows quite a lot of options, which can be expanded a little bit if you type
    `?`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Git 会询问你是否想要暂存之前的更改（hunk），同时还会显示很多选项，如果你输入`?`，这些选项可以展开一些：
- en: '[PRE71]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'There are a lot of options, but with the help text, they are quite self-explanatory.
    Let''s add the current hunk, `y`, and look at the next one:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多选项，但借助帮助文本，它们非常易于理解。让我们添加当前的 hunk，按`y`，然后查看下一个：
- en: '[PRE72]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Whoa! It looks like there is a debug line there that we should not add. Let''s
    split the hunk, `s`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！看起来那里有一行调试代码，我们不应该添加它。让我们拆分这个 hunk，按`s`：
- en: '[PRE73]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We don''t want the output to be staged, use `n`, but we''ll stage the next
    hunk and all the hunks later, in the `a` file:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望将输出暂存，使用`n`，但我们会暂存接下来的 hunk 和稍后的所有 hunk，在`a`文件中：
- en: '[PRE74]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s see the current status and the difference between the working directory
    and staging area:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看当前状态以及工作目录和暂存区之间的差异：
- en: '[PRE75]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Perfect! We got all the changes staged except the debug line, so the result
    can be committed:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！我们已经暂存了所有更改，除了调试行，因此结果可以提交：
- en: '[PRE76]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: There's more...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'As mentioned earlier, it''s also possible to use `git add -i` to interactively
    add files. If we do this after resetting our branch, we will get the following
    menu:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们也可以使用`git add -i`来交互式地添加文件。如果我们在重置分支后执行此操作，我们将得到以下菜单：
- en: '[PRE77]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The eight options pretty much do what they say. We can choose the patch option
    to get into the patch menu, as we saw previously, but first we have to choose
    which files to add patches for:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这八个选项几乎都能做它们所说的事。我们可以选择补丁选项进入补丁菜单，正如我们之前看到的那样，但首先我们必须选择要添加补丁的文件：
- en: '[PRE78]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Once we have chosen the files, we want to add patches so they get a `*` character
    in the menu. To begin patching, just click on `<return>`. When you're done, you'll
    return to the menu and can quit, review, revert, and so on.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了要添加补丁的文件，它们会在菜单中显示`*`符号。开始打补丁时，只需点击`<return>`。完成后，你将返回菜单，可以退出、审查、恢复等。
- en: Interactive add with Git gui
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Git gui 的交互式添加
- en: 'The interactive features of `git add` are really powerful for creating clean
    commits that only contain a single logical change, even though it was coded as
    a mix of feature adding and bug fixing. The downside of the interactive `git add`
    feature is that it is hard to get an overview of all the changes that exist in
    the file when only being showed one hunk at a time. To get a better overview of
    the changes and still be able to only add selected hunks (and even single lines),
    we can use `git gui`. Git GUI is normally distributed with the Git installation
    (MsysGit on Windows) and can be launched from the command line: `git gui`. If
    your distribution doesn''t have Git GUI available, you can probably install it
    from the package manager called `git-gui`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`git add`的交互式功能非常强大，可以创建仅包含单个逻辑更改的干净提交，即使这些更改最初是作为功能添加和错误修复的混合体编写的。交互式`git
    add`功能的缺点是，每次只显示一个 hunk，难以全面了解文件中所有的更改。为了更好地了解更改内容，并且仍然能够仅添加选定的 hunks（甚至单行），我们可以使用`git
    gui`。Git GUI 通常随 Git 安装包一起提供（Windows 上为 MsysGit），可以通过命令行启动：`git gui`。如果你的发行版没有提供
    Git GUI，你可能可以通过包管理器安装它，名为`git-gui`。'
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在准备中
- en: 'We''ll use the same repository as in the last example and reset it to the same
    state so that we can perform the same adds with Git GUI:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与上一个示例相同的仓库，并将其重置为相同的状态，这样我们就可以使用 Git GUI 执行相同的添加操作：
- en: '[PRE79]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Load Git GUI in the `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks`
    repository. Here, you can see the unstaged changes (files) at the top-left and
    the staged changes (files) underneath. The main window will display the unstaged
    changes in the current marked file. You can right-click on a hunk and see a context
    menu with options for staging and so on. The first hunk shown by Git GUI is much
    larger than what we saw before with `git add -p`. Choose Show Less Context to
    split the hunk, as shown in the following screenshot:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks` 仓库中加载 Git GUI。这里，你可以看到左上方是未暂存的更改（文件），下方是已暂存的更改（文件）。主窗口将显示当前标记文件中的未暂存更改。你可以右键点击某个块，看到一个上下文菜单，其中包含暂存等选项。Git
    GUI 显示的第一个块比我们之前用 `git add -p` 看到的要大。选择“显示更少上下文”以拆分该块，如下图所示：
- en: '![](img/55c0e5df-e123-4224-aaa7-63201d610cb7.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55c0e5df-e123-4224-aaa7-63201d610cb7.png)'
- en: 'Now, we get a smaller hunk like before, as shown in the following screenshot:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们像之前一样获得一个较小的块，如下图所示：
- en: '![](img/9e6d22e8-3fd6-4ea9-af5f-a53ecb20cee0.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e6d22e8-3fd6-4ea9-af5f-a53ecb20cee0.png)'
- en: 'For the first hunk, we just choose to add Stage Hunk For Commit, and the next
    hunk moves to the top of the screen, as shown in the next screenshot:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个块，我们选择添加“为提交暂存块”，接下来的块会移到屏幕顶部，如下图所示：
- en: '![](img/96088c69-0258-4cc8-9e54-478d70566145.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96088c69-0258-4cc8-9e54-478d70566145.png)'
- en: 'Here, we can select the lines we want to add, instead of performing another
    split, and stage those lines: Stage Lines For Commit. We can add the rest of the
    hunks except the one with the debug line. Now, we are ready to create a commit
    and we can do so from the Git GUI. We can just write the commit message in the
    field at the bottom of the screen and hit Commit, as shown in the next screenshot:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以选择要添加的行，而不是执行另一次拆分，并暂存这些行：为提交暂存行。我们可以添加除包含调试行的块外的其他所有块。现在，我们准备好创建一个提交了，可以通过
    Git GUI 完成。我们只需要在屏幕底部的字段中写入提交信息，然后点击提交，如下图所示：
- en: '![](img/d0d83a40-b60e-41ab-b619-bdda1bde49f2.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0d83a40-b60e-41ab-b619-bdda1bde49f2.png)'
- en: Ignoring files
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略文件
- en: For every repository, there are usually certain types of files you don't want
    tracked in the repository. The files can be configuration files, build output,
    or just backup files created by the editor when editing the file. To avoid these
    files showing up in the untracked files section of the `git status` output, it's
    possible to add them to a file called `.gitignore`. Entries in this file that
    match files in the working directory will not be considered by `git status`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个仓库，通常有一些类型的文件你不希望被跟踪。这些文件可能是配置文件、构建输出文件，或者是编辑器在编辑文件时生成的备份文件。为了避免这些文件出现在
    `git status` 输出中的未跟踪文件部分，可以将它们添加到名为 `.gitignore` 的文件中。这个文件中与工作目录中文件匹配的条目将不会被 `git
    status` 考虑。
- en: Getting ready
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Clone the `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks` repository
    and check out the `ignore` branch:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆 `Git-Version-Control-Cookbook-Second-Edition_tips_and_tricks` 仓库并检出 `ignore`
    分支：
- en: '[PRE80]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How to do it...
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we''ll create some files and directories:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一些文件和目录：
- en: '[PRE81]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let''s see the output of `git status`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们查看 `git status` 的输出：
- en: '[PRE82]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Only the `test.txt` file showed up in the output. This is because the rest
    of the files are ignored by Git. We can check the content of `.gitignore` to see
    how this happened:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有 `test.txt` 文件出现在输出中。这是因为其余的文件都被 Git 忽略了。我们可以检查 `.gitignore` 的内容，看看是如何发生的：
- en: '[PRE83]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This means that `*.bak`, `*.class`, `*.config`, and everything in the `bin`
    directory are being ignored by Git.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `*.bak`、`*.class`、`*.config` 以及 `bin` 目录中的所有内容都被 Git 忽略。
- en: 'If we try to add files in a path ignored by Git, for example `bin`, it will
    complain:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试在 Git 忽略的路径中添加文件，例如 `bin`，它会报错：
- en: '[PRE84]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'But, it also gives us the option to use `-f` if we really want to add it, which
    is `-f`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它也给了我们使用 `-f` 的选项，如果我们真的想要添加它，那就是 `-f`：
- en: '[PRE85]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'If we ignore the `foo` file, which is already tracked, and modify it, it still
    shows up in the status, since tracked files are not ignored:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们忽略了已经被跟踪的 `foo` 文件，并对其进行了修改，它仍然会出现在状态中，因为已跟踪的文件不会被忽略：
- en: '[PRE86]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let''s add and commit `foo`, `.gitignore`, and the contents of the current
    staging area:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以添加并提交 `foo`、`.gitignore` 以及当前暂存区的内容：
- en: '[PRE87]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: There's more...
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It''s also possible to ignore files of a repository without the `.gitignore`
    files. You can put your ignored files in a global ignore file, for example `~/.gitignore_global`, and
    globally configure Git to also consider entries in this file to be ignored:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在没有`.gitignore`文件的情况下忽略仓库中的文件。你可以将被忽略的文件放在一个全局忽略文件中，例如`~/.gitignore_global`，并全局配置Git，使其也考虑该文件中的条目作为被忽略的文件：
- en: '[PRE88]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You can also do it per repository in the `.git/info/exclude` file. If you use
    either of these options, you won''t be able to easily share the ignored file;
    they can''t be added to the repository as they are stored outside it. Sharing `.gitignore`
    files is much easier; you just add and commit them to Git. But, let''s see how
    the other options work:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`.git/info/exclude`文件中为每个仓库配置忽略文件。如果使用这些选项之一，你将无法轻松共享被忽略的文件；因为它们存储在仓库外部，无法被添加到仓库中。共享`.gitignore`文件则要简单得多；你只需将它们添加并提交到Git。但让我们看看其他选项是如何工作的：
- en: '[PRE89]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We can see that the `.test` file didn't show up in the `status` output and that
    the ignored files exist in the working directory.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`.test`文件没有出现在`status`输出中，并且被忽略的文件依然存在于工作目录中。
- en: See also
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: A wide range of files are commonly ignored, for example, to avoid accidentally
    adding text editor backup files, `*.swp`, `*~.`, and `*.bak` are commonly ignored.
    If you are working on a Java project, you might add `*.class`, `*.jar`, and `*.war`
    to your `.gitignore` and `*.o`, `*.elf`, and `*.lib` if you are working on a C
    project. GitHub has a repository dedicated to collect Git ignore files for different
    programming languages and editors/IDEs. You can find it at: [https://github.com/github/gitignore](https://github.com/github/gitignore).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会忽略许多文件，例如，为了避免意外添加文本编辑器的备份文件，`*.swp`、`*~.`和`*.bak`文件通常会被忽略。如果你在做Java项目，可能会将`*.class`、`*.jar`和`*.war`添加到`.gitignore`文件中；如果你在做C语言项目，可能会添加`*.o`、`*.elf`和`*.lib`。GitHub有一个专门的仓库，用于收集不同编程语言和编辑器/IDE的Git忽略文件。你可以在[https://github.com/github/gitignore](https://github.com/github/gitignore)找到它。
- en: Showing and cleaning ignored files
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示和清理被忽略的文件
- en: Ignoring files is useful for filtering noise from the output of `git status`.
    But sometimes, it's necessary to check which files are ignored. This example will
    show you how to do that.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略文件对于过滤`git status`输出中的噪声非常有用。但有时，需要检查哪些文件被忽略了。这个例子将展示如何做到这一点。
- en: Getting ready
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll continue in the repository from the last example.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一个例子中的仓库继续操作。
- en: How to do it...
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'To show the files we have ignored, we can use the `clean` command. Normally,
    the `clean` command will remove the untracked files from the working directory,
    but it is possible to run this in dry-run mode, `-n`, which just shows what would
    happen:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示我们忽略的文件，可以使用`clean`命令。通常，`clean`命令会从工作目录中移除未跟踪的文件，但也可以在干运行模式`-n`下执行，它仅显示将会发生的情况：
- en: '[PRE90]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The options used in the preceding command specify the following:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令中使用的选项指定了以下内容：
- en: '`-n`, `--dry-run`: Only lists what will be removed'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n`，`--dry-run`：仅列出将被移除的文件'
- en: '`-X`: Removes only the files ignored by Git'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-X`：仅移除Git忽略的文件'
- en: '`-d`: Removes the untracked directories in addition to the untracked files'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：除了未跟踪的文件，还会移除未跟踪的目录'
- en: 'The ignored files can also be listed with the `ls-files` command:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 被忽略的文件也可以通过`ls-files`命令列出：
- en: '[PRE91]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Where the `-o` option, `--others`, shows the untracked files, the `-i` option, `--ignored`,
    shows only the ignored files, and `--exclude-standard` uses the standard exclusion
    files `.git/info/exclude` and `.gitignore` in each directory, and the user's global
    exclusion file.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`-o`选项，`--others`，显示未跟踪的文件；`-i`选项，`--ignored`，仅显示被忽略的文件；`--exclude-standard`使用标准的排除文件`.git/info/exclude`和`.gitignore`（每个目录中）以及用户的全局排除文件。
- en: There's more...
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we need to remove the ignored files, we can of course use `git clean` to
    do this; instead of the dry-run option, we pass the force option, `-f`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要移除被忽略的文件，当然可以使用`git clean`来执行此操作；与干运行选项不同，我们传递强制选项`-f`：
- en: '[PRE92]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: To remove all the untracked files and not just the ignored files, use `git clean
    -xfd`. The lowercase `x` means we don't use the ignore rules, we just remove everything
    that is not tracked by Git.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除所有未跟踪的文件，而不仅仅是被忽略的文件，可以使用`git clean -xfd`。小写的`x`表示我们不使用忽略规则，而是直接移除所有没有被Git跟踪的文件。
