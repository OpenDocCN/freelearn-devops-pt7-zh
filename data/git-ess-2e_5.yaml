- en: Obtaining the Most - Good Commits and Workflows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取最大效益 - 良好的提交和工作流程
- en: Now that we have acquired some familiarity with Git and versioning systems,
    it's time to look at the whole thing from a much higher perspective, to become
    aware of common patterns and procedures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Git 和版本控制系统有了一些了解，是时候从更高的视角来看待整个问题，意识到常见的模式和流程。
- en: In this chapter, we will walk through some of the most common ways to organize
    and build meaningful commits and repositories, obtaining not only a well-organized
    code stack, but even a meaningful source of information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些最常见的组织和构建有意义的提交和代码库的方式，从而获得一个井井有条的代码栈，甚至是一个有意义的信息源。
- en: The art of committing
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交的艺术
- en: 'While working with Git, committing seems the easiest part of the job: you add
    files, write a short comment, and then you''re done. But it is just for its simplicity
    that often, especially at the very beginning of your experience, you acquire the
    bad habit of doing terrible commits: too late, too big, too short, or simply equipped
    with bad messages.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Git 时，提交似乎是工作中最简单的部分：你添加文件，写一个简短的评论，然后就完成了。但正因为它简单，尤其是在刚开始使用时，你往往会养成做出糟糕提交的坏习惯：提交得太晚、太大、太短，或者仅仅是带有糟糕的消息。
- en: Now we will take some time to identify possible issues, like unmeaning or too
    large commits, drawing attention to tips and hints to get rid of those bad habits.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将花一些时间来识别可能的问题，比如没有意义的或过大的提交，并提出一些建议和提示，帮助大家摆脱这些坏习惯。
- en: Building the right commit
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建正确的提交
- en: One of the harder skills to acquire while programming in general is to **split
    the work into small and meaningful tasks**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程过程中，一项更难掌握的技能是**将工作分解为小而有意义的任务**。
- en: 'Too often, I have experienced this scenario: you start to fix a small issue
    in a file; then you see another piece of code that can be easily improved, even
    if it''s not related to what you are working on now - you can''t resist, and you
    fix it. At the end, and after some time, you find yourself with a ton of **concurrent**
    files and **changes** to commit.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常遇到这样的情况：你开始修复文件中的一个小问题；然后你看到另一段代码，可以轻松改进，尽管它与当前的工作无关——你忍不住，还是去修复了。最后，经过一段时间，你发现自己有一大堆**并发**文件和**更改**等待提交。
- en: 'At this point, *things get worse*, because usually *programmers are lazy people*,
    so they don''t write all the important things to describe changes in the commit
    message. In commit messages, you start to write sentences like "*Some fixes to
    this and that*", "*Removed old stuff*", "*Tweaks*" and so on, without anything
    that helps other programmers to understand what you have done:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到此时，*情况变得更糟*，因为通常*程序员是懒惰的人*，所以他们不会在提交信息中写下所有重要的内容来描述所做的更改。在提交信息中，你开始写诸如“*对这个和那个的一些修复*”，“*移除旧的东西*”，“*微调*”之类的句子，但这些并没有帮助其他程序员理解你做了什么：
- en: '![](img/50475693-9b9d-4707-95e2-1c09c796c2a2.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50475693-9b9d-4707-95e2-1c09c796c2a2.png)'
- en: Courtesy of http://xkcd.com/1296/
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由 http://xkcd.com/1296/ 提供
- en: At the end, you realize *your repository is only a dump*, where you empty your
    index only now and then. I have seen some people committing only at the end of
    the day (and not every day), only to keep a backup of the data or because someone
    else needed the changes reflected on their computer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你会意识到*你的代码库只不过是一个垃圾堆*，你偶尔才会清理一次索引。我见过一些人只在一天结束时提交（而且不是每天都提交），只是为了备份数据，或者因为其他人需要在他们的计算机上反映这些更改。
- en: Another side effect is that the resulting *repository history becomes useless*
    for anything other than retrieving the contents at a given point in time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个副作用是，结果的*代码库历史变得毫无意义*，除了在某个时间点检索内容外，几乎没有其他用途。
- en: The following tips can help you turn your VCS from a backup system into *a valuable
    tool for communication and documentation*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下提示可以帮助你将版本控制系统（VCS）从一个备份系统转变为*一个有价值的沟通和文档工具*。
- en: Making only one change per commit
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每次提交只进行一次更改
- en: 'After the routine morning coffee, you open your editor and then you start to
    work on a bug: `BUG42`. Working around fixing the bug in the code, you realize
    that fixing `BUG79` will require tweaking just a single line of code, so you fix
    it, but you not only change that awful class name, but also add a good-looking
    label to the form and make a few more changes. *The damage is done now*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在例行的早晨咖啡后，你打开编辑器，开始处理一个 bug：`BUG42`。在修复代码中的 bug 时，你意识到修复 `BUG79` 只需要修改一行代码，于是你进行修复，但你不仅修改了那个糟糕的类名，还给表单添加了一个漂亮的标签，并做了一些其他更改。*现在损失已经造成了*。
- en: How can you now wrap up all that work in a *meaningful commit*? Maybe in the
    meantime you went home for lunch, talked to your boss about another project, and
    even you can't remember exactly all the little things you did.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你怎么将所有这些工作总结成一个*有意义的提交*呢？也许你在这段时间回家吃午饭，跟老板讨论了另一个项目，甚至你自己都不记得所有做过的细小事情了。
- en: 'In this scenario, there is only one way to **limit the damage**: *split files
    to commit in more than one commit*. Sometimes this helps to reduce the pain, but
    it is only a *palliative*: too often you modify the same file for *different reasons*,
    so doing that is quite difficult, if not impossible.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有一种方法可以**限制损害**：*将文件拆分成多个提交*。有时这样做有助于减轻痛苦，但这只是一个*权宜之计*：你太频繁地因为*不同的原因*修改同一个文件，所以这样做是相当困难的，甚至是不可能的。
- en: The only way to solve this problem completely is to **only make one change per
    commit**. It seems easy, I know, but is quite difficult to acquire this ability.
    There are no tools for it; no one but you can help, as it requires **discipline**,
    *the most lacking virtue in creative people* (like programmers).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的唯一方法是**每次提交时只做一次修改**。这看起来简单，我知道，但要掌握这项能力却相当困难。没有工具能做到；除了你自己，没有人能帮忙，因为这需要**自律**，*这是创意工作者（比如程序员）最缺乏的美德*。
- en: There are some tips to pursue this aim; let's have a look at them together.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些技巧可以帮助你实现这个目标；让我们一起看看它们。
- en: Splitting up features and tasks
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分功能和任务
- en: As said before, breaking up things to do is a fine art. If you know and adopt
    some **Agile Movement** techniques, you have probably faced these problems already,
    so you have an advantage; otherwise you will need to make a little more effort,
    but it isn't anything you can't achieve.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，将事情分解是一个精细的艺术。如果你知道并采用了一些**敏捷方法**技巧，你可能已经遇到过这些问题，因此你占有优势；否则你将需要付出更多努力，但这不是你无法达成的。
- en: 'Consider you have been assigned to add the Remember Me check in the login page
    of a web application, like the following one:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被指派在一个web应用的登录页上添加“记住我”选项框，像下面这样：
- en: '![](img/af4909e1-428d-43b8-815d-65279b2b290a.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af4909e1-428d-43b8-815d-65279b2b290a.png)'
- en: 'This feature is quite small, but implies changes at different levels. To accomplish
    this, you''ll have to:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能很小，但在不同层面上会涉及到改动。为了实现这一点，你必须：
- en: Modify the UI to add the check control.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改UI以添加检查控制。
- en: Pass the *is checked* information through different layers.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*已检查*的信息通过不同的层级传递。
- en: Store this information somewhere.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些信息存储到某个地方。
- en: Retrieve this information when needed.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在需要时获取这些信息。
- en: Invalidate (set it to false) following some kind of policy (after 15 days, after
    10 logins, and so on).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据某些政策使其失效（例如：15天后，或登录10次后，等等）。
- en: 'Do you think you can do all these things in a shot? Yes? You are wrong! Even
    if you estimate a couple of hours for an ordinary task, remember that Murphy''s
    Law applies: you will receive four calls, your boss will look for you for three
    different meetings and your computer will go up in flames.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为你能在一次尝试中完成所有这些事情吗？是吗？你错了！即使你为一项普通任务估计几个小时，也要记住墨菲定律：你会接到四个电话，你的老板会找你参加三个不同的会议，而你的电脑会起火。
- en: 'This is one of the first things to learn: **break up every piece of work into
    small tasks**. No matter if you use time-boxing techniques like the *Pomodoro
    Technique* or not, small things are easier to handle. I''m not talking about splitting
    hairs, but try to organize your tasks into things you can do in a defined amount
    of time, hopefully a bunch of half-hours, not days.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要学习的第一件事之一：**将每一项工作分解成小任务**。无论你是否使用时间盒技术，比如*番茄工作法*，小任务更容易处理。我不是说要斤斤计较，但尽量将任务组织成可以在规定时间内完成的事情，最好是几段半小时，而不是几天。
- en: For more information on the Pomodoro Technique you can visit [https://cirillocompany.de/pages/pomodoro-technique](https://cirillocompany.de/pages/pomodoro-technique)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于番茄工作法的信息，可以访问[https://cirillocompany.de/pages/pomodoro-technique](https://cirillocompany.de/pages/pomodoro-technique)
- en: or Wikipedia [https://en.wikipedia.org/wiki/Pomodoro_Technique](https://en.wikipedia.org/wiki/Pomodoro_Technique)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或者维基百科[https://en.wikipedia.org/wiki/Pomodoro_Technique](https://en.wikipedia.org/wiki/Pomodoro_Technique)
- en: 'So, *take paper and a pen and write down all the tasks*, as we did before with
    the login page example. Do you think now you can do all those things in a small
    amount of time? Maybe yes, maybe not: some tasks are bigger than others. That''s
    okay, this is not a scientific method, *it''s a matter of experience*; can you
    split a task, creating two other meaningful tasks? Do it.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，*拿起纸和笔，写下所有任务*，就像我们之前在登录页面的例子中做的那样。你现在觉得自己能在很短的时间内完成所有这些任务吗？也许能，也许不能：有些任务比其他任务要大。这没关系，这不是一种科学方法，*这取决于经验*；你能将一个任务拆分成两个有意义的任务吗？做吧。
- en: Can you? No problem, *don't try to split tasks if they lose meaning*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做到吗？没问题，*不要尝试拆分任务，如果这样会失去它们的意义*。
- en: 'Make a little notebook, like the one in the following picture - it will become
    one of your most precious tools:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 做一个小本子，像下面图片中的那样——它会成为你最宝贵的工具之一：
- en: '![](img/b995efc5-b09e-48be-a21d-469d020de539.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b995efc5-b09e-48be-a21d-469d020de539.png)'
- en: Writing commit messages before starting to code
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写提交信息再开始编码
- en: Now you have a list of tasks to do; pick the first and... Start to code? No!
    Take another piece of paper and **describe every task's step with a sentence**;
    magically you will realize that every sentence can be the message of a single
    commit, where you describe features you deleted, added, or changed in your software.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一份任务清单，选择第一个任务并... 开始编码？不！再拿一张纸，**用一句话描述每个任务的步骤**；你会发现每一句话都可以成为一个提交信息，描述你在软件中删除、添加或更改的功能。
- en: This kind of prior preparation helps you in *defining modifications to implement*
    (letting *better software design* emerge), *focusing on what matters,* and *lowering
    the stress* to think about the versioning part of the work during the coding session.
    While you are facing a programming problem, your brain floods with little implementation
    details related to the code you are working on, so the fewer distractions, the
    better.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种事先的准备帮助你*定义要实现的修改*（让*更好的软件设计*自然产生），*专注于重要事项*，并且*减轻压力*，让你在编码过程中不再过多考虑版本管理的部分。当你面对编程问题时，你的大脑会充斥着与正在编写代码相关的小细节，因此，分散注意力的事情越少越好。
- en: 'This is one of the best versioning related hints I ever received: if you have
    just quarter of an hour of spare time, I recommend reading the *Preemptive commit
    comments* blog post at [https://arialdomartini.wordpress.com/2012/09/03/pre-emptive-commit-comments/](https://arialdomartini.wordpress.com/2012/09/03/pre-emptive-commit-comments/)
    by *Arialdo Martini*, which is where I learnt this trick.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我收到的与版本管理相关的最佳建议之一：如果你有十五分钟的空闲时间，我建议你阅读*预先提交评论*的博客文章，链接在[https://arialdomartini.wordpress.com/2012/09/03/pre-emptive-commit-comments/](https://arialdomartini.wordpress.com/2012/09/03/pre-emptive-commit-comments/)，它是我学到这个技巧的地方，作者是*Arialdo
    Martini*。
- en: Including the whole change in one commit
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有更改放在一个提交中
- en: Making more than one change per commit is a bad thing, but even splitting a
    single change into more than one commit is considered harmful. As you may already
    know, in some trained teams you do not simply push your code to production; first
    you have to pass *code quality reviews*, where someone else tries to understand
    what you did to decide if your code is good or not (that is why there are *pull
    requests*, indeed). You can be the best developer in the world, but if the person
    at the other end can't get a sense of your commits, your work will probably be
    refused.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每次提交做多于一个更改是坏事，但即使将单个更改拆分成多个提交也会被认为是有害的。正如你可能已经知道的，在一些训练有素的团队中，你不能简单地将代码推送到生产环境；首先你必须通过*代码质量审查*，其中其他人会尝试理解你所做的工作，以决定你的代码好不好（这就是为什么会有*拉取请求*的原因）。你可能是世界上最好的开发人员，但如果对方无法理解你的提交，你的工作很可能会被拒绝。
- en: 'To avoid these unpleasant situations, you have to follow a simple rule: **don''t
    do partial commits**. If time''s up, if you have to go to that damn meeting (programmers
    hate meetings) or whatever, remember that you can save your work at any moment
    without committing, using the `git stash` command. If you want to close the commit,
    because you want to push it to the remote branch for backup purposes, remember
    that *Git is not a backup tool*: backup your stash on another disk, put it in
    the cloud, or simply end your work before leaving, but don''t do commits like
    they are episodes of a TV series.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要避免这些不愉快的情况，你必须遵循一个简单的规则：**不要进行部分提交**。如果时间不够，如果你必须参加那该死的会议（程序员讨厌开会）或其他任何事情，请记住你可以随时保存你的工作而不提交，使用`git
    stash`命令。如果你想关闭提交，因为你想把它推送到远程分支进行备份，请记住*Git不是备份工具*：在另一个磁盘上备份你的stash，把它放在云上，或者在离开之前结束你的工作，但不要像看电视剧集一样提交。
- en: 'One more time, Git is a software tool like any other, and even it can fail:
    don''t think that by using Git or other versioning systems you don''t need backup
    strategies - backup local and remote repositories just the same as you backup
    all the other important things.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 再说一遍，Git就像任何其他软件工具一样，甚至它也可能失败：不要认为使用Git或其他版本控制系统就不需要备份策略 - 本地和远程仓库的备份同样重要，就像你备份其他重要事物一样。
- en: Describing the change, not what have you done
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述变更，而不是你做了什么
- en: Too often I read (and more often I wrote) commit messages like "*Removed this*",
    "*Changed that*", "*Added that one*" and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常读到（而且更经常写到）像“*移除这个*”、“*修改那个*”、“*添加那个*”之类的提交信息。
- en: 'Imagine you are going to work on the common "*lost password*" feature on your
    website; you''ll probably find a message like this adequate: "*Added the lost
    password retrieval link to the login page*". This kind of commit message does
    not describe what modifications the feature brings to you, but what you did (and
    not everything you did). Try to answer sincerely: reading a repository history,
    do you want to read what every developer did? Or maybe it''s better to read the
    feature implemented in every single commit?'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你要在你的网站上共同工作的“*丢失密码*”功能；你可能会觉得这样的消息足够了：“*在登录页面添加了丢失密码找回链接*”。这种提交消息不描述功能给你带来了什么修改，而是你做了什么（并非你做的一切）。试着真诚地回答：阅读仓库历史时，你想要读到每个开发者做了什么吗？或者读到每个提交中实现的功能会更好？
- en: 'Try to make the effort, and **start writing sentences where the change itself
    is the subject**, not what you did to implement it. *Use the imperative present
    tense* (for example, *fix*, *add*, or *implement*), describing the change in a
    small subject sentence, and then add some details (when needed) in other lines
    of text; "*Implement the password retrieval mechanism*" is a good commit message
    subject; if you find it useful then you can add some other information to get
    a well-formed message, like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 努力去做，**开始编写以变更本身为主题的句子**，不要描述你是如何实现它的。使用祈使现在时态（例如*修复*、*添加*或*实现*），在一个简短的主题句中描述变更，然后在需要时添加一些细节（如果需要的话），例如：“*实现密码找回机制*”是一个良好的提交信息主题；如果你觉得有用，那么可以添加一些其他信息来使其形成一个完整的消息，就像这样：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Have you ever written a *changelog* for software by hand? I did, and it''s
    one of the most boring things to do. If you don''t like writing changelogs, like
    me, think of the repository history as your changelog: if you take the right care
    of your commit messages, you will get a beautiful changelog for free!'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有手动编写过软件的*更新日志*？我有过，那是最无聊的事情之一。如果你不喜欢写更新日志，就像我一样，把代码库历史看作是你的更新日志：只要你注意提交信息，你就会免费得到一个漂亮的更新日志！
- en: In the next paragraph, I will cover some other useful hints about good commit
    messages.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的段落中，我将介绍一些关于良好提交信息的其他有用提示。
- en: Don't be afraid to commit
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要害怕提交
- en: 'Fear is one of the most powerful of emotions; it can drive a person to do the
    craziest things on Earth. One of the most common reactions to fear is the **breakdown**:
    *you don''t know what to do, so you end up doing nothing*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 恐惧是最强烈的情感之一；它可以驱使一个人做地球上最疯狂的事情。对恐惧的最常见反应之一是**崩溃**：*你不知道该怎么做，最终什么也不做*。
- en: 'This is a common reaction even when you begin to use a new tool like Git, where
    gaining confidence can be difficult; because of the fear of making a mistake,
    you don''t commit until you are obligated. **This is the real mistake: being scared**.
    In Git, you don''t have to be scared; maybe the solution is not obvious, and maybe
    you have to dig on the internet to find the right way, but you can get away with
    small or no consequences, ever (well, unless you are a hard user of the `--hard`
    option).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的反应，特别是当你开始使用像Git这样的新工具时，建立信心可能很困难；因为害怕犯错，你通常不会提交，直到被迫提交。**这才是真正的错误：害怕**。在Git中，你不必害怕；也许解决方案并不显而易见，也许你得上网查找正确的做法，但你可以承受的小代价几乎没有（除非你是`--hard`选项的重度用户）。
- en: 'On the contrary, you have to make the effort to **commit often**, as soon as
    possible. The more frequently you commit, the smaller your commits; the smaller
    your commits, the easier it is to read and understand the changelog, and the easier
    it is to cherry-pick commits, and do code reviews. To help myself get used to
    committing this way, I followed this simple trick: write the commit message in
    Visual Studio before starting to write any code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你需要努力**频繁提交**，尽可能早提交。你提交的越频繁，提交的内容就越小；提交越小，变更日志就越容易阅读和理解，挑选提交也变得更加容易，代码审查也更轻松。为了帮助自己习惯这种提交方式，我采用了这个简单的小技巧：在开始写任何代码之前，先在Visual
    Studio中写下提交信息：
- en: '![](img/f6d93f81-a85c-4a64-8b10-7a339797c513.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6d93f81-a85c-4a64-8b10-7a339797c513.png)'
- en: Try to do the same in your IDE or directly in the Bash shell, it helps a lot.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在你的IDE或者直接在Bash终端中做到这一点，这会有很大帮助。
- en: Isolating meaningless commits
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离无意义的提交
- en: The golden rule is to avoid them, but sometimes you need to commit *something
    that is not a real implementation*, but only a clean-up, like old comments deletion,
    formatting rearrangement, and so on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金法则是避免这种情况，但有时候你确实需要提交*不是真正实现的内容*，而只是一些清理工作，比如删除旧的注释、调整格式等等。
- en: In these cases, it is better to isolate these kind of code changes in separated
    commits. By doing this you prevent another team member from running towards you
    with a knife in his hand, frothing at the mouth. Don't commit meaningless changes,
    mixing them up with real ones, otherwise other developers (and you, after a couple
    of weeks) will not understand them while diffing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，最好将这些代码变更隔离在单独的提交中。这样做可以防止其他团队成员带着刀冲向你，嘴里冒着泡沫。不要将无意义的更改与真正的更改混合在一起提交，否则其他开发者（以及几周后的你）在查看差异时将无法理解它们。
- en: The perfect commit message
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完美的提交信息
- en: 'Let me be honest: the perfect message does not exist. If you work alone, you
    probably find the best way for you, but when in a team there are different minds
    and different sensibilities, so what is good for me might not be as good for somebody
    else.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我坦白地说：完美的提交信息是不存在的。如果你独自工作，你可能会找到最适合自己的方式，但在团队中有不同的思维方式和敏感度，所以对我来说合适的，可能对别人来说并不一定是最好的。
- en: In this case you have to sit down around a table and make a retrospective, trying
    to end up with a shared standard; it may not be the one you prefer, but at least
    it's a way to find a common path.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要坐下来一起开会进行回顾，尽量达成一个共享的标准；这个标准可能不是你最喜欢的，但至少这是找到共同路径的方式。
- en: Rules for a good commit message really depend on the way you and your team work
    day by day, but some common hints can be applied by everyone; here they are.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的提交信息的规则确实取决于你和你的团队的日常工作方式，但有一些常见的提示是每个人都可以应用的；它们如下。
- en: Writing a meaningful subject
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写一个有意义的主题
- en: 'The subject of a commit is the most important part: its role is to make clear
    what the commit contains. Avoid technical details of other things - a common developer
    can understand opening the code, and focus on the big picture: remember that every
    commit is a sentence on the repository history. So, wear the hat of the changelog
    reader and try to write the most convenient sentence for him, not for you: use
    present tense, and write a 50 chars max sentence.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 提交的主题是最重要的部分：它的作用是清楚地表明提交包含了什么内容。避免涉及其他技术细节——普通开发者可以通过打开代码来理解，应该专注于大局：记住，每个提交都是仓库历史中的一句话。所以，戴上变更日志阅读者的帽子，尝试写出最便于他理解的句子，而不是为你自己写：使用现在时态，写一个最多50个字符的句子。
- en: 'A good subject is one like this: "*Add the newsletter signup in homepage*".'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的主题是这样的：“*在主页中添加新闻通讯注册功能*”。
- en: 'As you can see, I used the *imperative past tense* and, more importantly, *I
    didn''t say what I had done, but what the feature does*: it adds a newsletter
    signup box to my website.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我使用了*祈使过去式*，更重要的是，*我没有说我做了什么，而是说功能做了什么*：它在我的网站上添加了一个新闻通讯订阅框。
- en: 'The 50-char rule is due to the way you use Git from the shell or GUI tools;
    if you start to write long sentences, reviewing logs and so on can become a nightmare.
    So, don''t try to be the *Stephen King* of commit messages: avoid adjectives and
    get straight to the point, you can then go more in-depth in the additional details
    lines.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 50字符规则源于你通过命令行或图形界面工具使用Git的方式；如果你开始写长句子，查看日志等操作可能会变成一场噩梦。所以，不要试图成为提交信息的*斯蒂芬·金*：避免使用形容词，直接进入主题，之后可以在附加的详细行中更深入地描述。
- en: 'One more thing: start with capital letters, and do not end sentences with periods
    - they are useless, and even dangerous.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事：开始时使用大写字母，并且不要以句号结束句子——它们是多余的，甚至是危险的。
- en: Adding bulleted details lines when needed
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据需要添加项目符号细节行
- en: 'Often you can say all that you want in 50 chars; in that case, use details
    lines. In this situation, the common rule is to *leave a blank line after the
    subject*, use a dash and go no longer than 72 chars:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以在50个字符内表达你想说的所有内容；在这种情况下，使用详细的行。常见的规则是*主题后留空一行*，使用破折号，并且不要超过72个字符：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In these lines go a little bit in depth, but not too much; try to describe the
    original problem (if you fixed it) or the original need, why this functionality
    has been implemented (what problem has been solved) and any possible limitations
    or known issues.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行中稍微深入一点，但不要过多；尽量描述原始问题（如果你解决了它）或原始需求，为什么实现了这个功能（解决了什么问题）以及可能的限制或已知问题。
- en: Tying other useful information
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联其他有用的信息
- en: 'If you use issue and project tracking systems, write down the issue number,
    bug id''s, or anything else helpful:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用问题和项目追踪系统，请写下问题编号、bug ID或任何其他有用的信息：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Special messages for releases
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布的特别信息
- en: Another useful thing is to write *special format* commit messages for releases,
    so it will be easier to find them. I usually decorate subjects with some special
    characters, but nothing more; for highlighting a particular commit, like a release
    one, there is the `git tag` command, remember?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件有用的事是，为发布写*特殊格式*的提交信息，这样会更容易找到它们。我通常会用一些特殊字符来装饰主题，但除此之外没有更多；为了突出某个特别的提交，比如发布版本，可以使用`git
    tag`命令，记得吗？
- en: Conclusions
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: At the end, my suggestion is to try to compose your personal commit message
    standard, following previous hints and looking at message strategies adopted by
    great projects and teams around the web, but especially by doing it. Your standard
    will change for sure, as you evolve as a software developer and Git user, so start
    as soon as possible and let the time help you find the perfect way to write a
    commit message.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我的建议是，尝试制定你个人的提交信息标准，遵循之前的提示，并参考网络上优秀项目和团队所采用的信息策略，尤其是通过实际操作来发现它。你的标准一定会随着你作为软件开发者和Git用户的成长而变化，因此尽早开始，并让时间帮助你找到写出完美提交信息的方法。
- en: 'At least, don''t imitate this link: [http://www.commitlogsfromlastnight.com](http://www.commitlogsfromlastnight.com).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，不要模仿这个链接：[http://www.commitlogsfromlastnight.com](http://www.commitlogsfromlastnight.com)。
- en: Adopting a workflow - a wise act
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用工作流——明智之举
- en: Now that we learnt how to perform good commits, it's time to fly higher and
    think of **workflows**. Git is a tool for versioning, but as with other powerful
    tools like knives, you can cut tasty sashimi or get hurt.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经学习了如何进行良好的提交，是时候更进一步，考虑一下**工作流**了。Git是一个版本控制工具，但就像其他强大的工具（比如刀具）一样，你可以用它切出美味的生鱼片，也可能会受伤。
- en: The thing that separates a great repository from a junkyard is the way you manage
    releases, the way you react when there is a bug to fix in particular version of
    your software, and the way you act when you have to make users able to beta-test
    incoming features.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 区分一个优秀代码库与垃圾堆的，是你如何管理发布、如何在某个特定版本的程序中修复bug以及当你需要让用户测试即将发布的功能时，你的反应方式。
- en: These kinds of actions belong to ordinary administration for a modern software
    project, but too often I see teams out of breath because of the poor versioning
    workflows.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作属于现代软件项目的日常管理，但我常常看到团队因为糟糕的版本控制工作流而疲于应付。
- en: In this second part of the chapter, we will take a quick look at some of the
    most used workflows together with the Git versioning system.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们将快速浏览一些最常用的工作流和Git版本控制系统。
- en: Centralized workflows
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中化工作流
- en: As we used to do in other VCS like Subversion or so, even in Git it is not uncommon
    to adopt a *centralized way of working*. If you work in a team, it is often necessary
    to share repositories with others, so a *common point of contact* becomes indispensable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在其他版本控制系统（如Subversion）中常做的那样，即便是在Git中，采用*集中式工作方式*也是很常见的。如果你在团队中工作，通常需要与他人共享仓库，因此一个*共同的联络点*变得不可或缺。
- en: We can assume that if you are not alone in your office, you will adopt one of
    the variations of this workflow. As we know, we can configure to get all the computers
    of our co-workers as remote, in a sort of *peer-to-peer* configuration, but you
    usually don't do this, because it quickly becomes too difficult to keep every
    branch in every remote in sync.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设，如果你在办公室里不是一个人，你将采用这种工作流的某种变体。正如我们所知，我们可以配置使同事们的所有电脑成为远程仓库的一部分，形成某种*点对点*的配置，但通常你不会这么做，因为这会很快变得太复杂，难以保持每个分支在每个远程仓库中的同步。
- en: 'The scenario is represented in the following picture:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这一场景在下图中展示：
- en: '![](img/7029acee-f6e4-45e3-b620-d69820f66a9e.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7029acee-f6e4-45e3-b620-d69820f66a9e.png)'
- en: How they work
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它们如何运作
- en: 'In this scenario, you usually follow these simple steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种场景中，你通常会遵循以下简单步骤：
- en: Someone initializes the remote repository (in a local Git server, on GitHub,
    BitBucket, or so on)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有人初始化了远程仓库（在本地Git服务器、GitHub、BitBucket等上）
- en: Other team members clone the original repository on their computer and start
    working
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他团队成员将原始仓库克隆到他们的电脑上并开始工作
- en: When the work is done, you push it to the remote to make it available to other
    colleagues
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作完成后，你将推送到远程仓库，使其他同事能够访问
- en: At this point, it is only a matter of internal rules and patterns.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，剩下的只是内部规则和模式的问题。
- en: Feature branch workflow
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性分支工作流
- en: At this point, you will probably choose at least a *feature branch* approach,
    where every single developer works on his branch. When the work is done, the feature
    branch is ready to be merged onto the master branch; you will probably have to
    merge back from the `master` before, because one of your other colleagues has
    merged a feature branch after you started your one, but after that you basically
    have finished.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，你可能至少会选择*特性分支*的方法，每个开发者都在自己的分支上工作。当工作完成后，特性分支准备好被合并到主分支；在此之前，你可能需要从`master`分支合并回来，因为你的另一位同事在你开始自己的分支后已经合并了一个特性分支，但之后基本就完成了。
- en: 'The following picture represents the branches evolution within the repository:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了仓库中分支的发展：
- en: '![](img/9b537cf9-9883-4150-a33c-db9160770c74.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b537cf9-9883-4150-a33c-db9160770c74.png)'
- en: Gitflow
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gitflow
- en: The **Gitflow** workflow comes from the mind of **Vincent Driessen**, a passionate
    software developer from the Netherlands; you can find his original blog post about
    it at [http://nvie.com/posts/a-successful-git-branching-model](http://nvie.com/posts/a-successful-git-branching-model).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gitflow**工作流源自**Vincent Driessen**的思想，他是来自荷兰的一个热情的软件开发者；你可以在[http://nvie.com/posts/a-successful-git-branching-model](http://nvie.com/posts/a-successful-git-branching-model)找到他关于该工作流的原始博客文章。'
- en: His workflow has gained success over the years, to the point that many other
    developers (including me!), teams, and companies are starting to use it. *Atlassian*,
    a well-known company that offers Git related services like *BitBucket*, integrates
    the Gitflow directly in their GUI tool, the nice *SourceTree*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作流多年来获得了成功，甚至许多其他开发者（包括我！）、团队和公司都开始使用它。*Atlassian*，一家知名公司，提供像*BitBucket*这样的Git相关服务，它们将Gitflow直接集成到他们的图形用户界面工具——漂亮的*SourceTree*中。
- en: 'Even the Gitflow work flow is a centralized one, and it is well described by
    the following image:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Gitflow工作流是一个集中式的，它也可以通过以下图片来很好地描述：
- en: '![](img/80773189-8611-42ac-8788-9edd27562f0e.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80773189-8611-42ac-8788-9edd27562f0e.png)'
- en: 'This workflow is based on the use of some **main branches**; what makes these
    branches special is nothing other than the significance we attribute to them:
    there are no *special branches* with *special characteristics* in Git, but we
    can certainly use them for different purposes.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作流基于使用一些**主分支**；这些分支之所以特别，完全是因为我们赋予它们的意义：在Git中并没有*特殊分支*和*特殊特性*，但我们当然可以将它们用于不同的目的。
- en: Master branch
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主分支
- en: In Gitflow the `master` branch represents the final stage; merging your work
    in it is equal to making a *new release* of your software. You usually don't start
    new branches from the `master`; you do it only if there are severe bugs you have
    to fix instantly, even if that bug has been found and fixed in another evolving
    branch. This way of operating is superfast when you need to react to a painful
    situation. Other than that, the `master` branch is where you tag your release.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gitflow 中，`master` 分支代表最终阶段；将你的工作合并到该分支就相当于发布一个 *新版本* 的软件。通常你不会从 `master`
    分支开始新的分支；只有在你必须立即修复严重 bug 时，才会这样做，即使这个 bug 已经在另一个正在开发的分支中被发现并修复。这种操作方式在需要快速反应时非常高效。除此之外，`master`
    分支就是你打标签发布版本的地方。
- en: Hotfixes branches
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热修复分支
- en: '**Hotfixes branches** are branches derived only from the `master`, as we said
    before; once you have fixed a bug, you merge the `hotfix` branch onto the `master`,
    to enable you to get a new release to ship. If the bug has not been resolved anywhere
    else in your repository, the strategy is to merge the `hotfix` branch into the
    `develop` branch. After that, you can delete the `hotfix` branch, as it has hit
    the mark.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**热修复分支** 是只从 `master` 分支派生的分支，正如前面所提到的；一旦你修复了一个 bug，你就会将 `hotfix` 分支合并到 `master`，这样你就可以发布新的版本。如果
    bug 在其他地方没有得到解决，那么策略是将 `hotfix` 分支合并到 `develop` 分支。之后，你可以删除 `hotfix` 分支，因为它已经达到了预期目标。'
- en: 'In Git, there is *a trick to grouping similar branches*: you have to name them
    using a common prefix followed by a slash `/`; for the hotfix branches, the author
    recommends the `hotfix/<branchName>` prefix (for example `hotfix/LoginBug` or `hotfix/#123`
    for those using bug tracking systems, where `#123` is the bug ID).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 中，有 *一种分组相似分支的技巧*：你需要使用一个共同的前缀并加上斜杠 `/` 来命名它们；对于热修复分支，作者建议使用 `hotfix/<branchName>`
    前缀（例如 `hotfix/LoginBug` 或 `hotfix/#123`，对于使用 bug 跟踪系统的用户，其中 `#123` 是 bug ID）。
- en: These branches are usually not pushed to remote; you push them only if you need
    the help of other team members.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分支通常不会推送到远程；只有在你需要其他团队成员的帮助时，才会推送。
- en: The develop branch
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发分支
- en: The `develop` branch is a sort of *staging* branch. When you start to implement
    a new feature, you have to create a new branch starting from `develop`; you will
    continue to work in that branch until you complete your task.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`develop` 分支是一种 *预发布* 分支。当你开始实现新功能时，必须从 `develop` 分支创建一个新的分支；直到任务完成，你会一直在这个分支上工作。'
- en: 'After the task completion, you can merge back to `develop` and delete your
    `feature` branch: as hotfix branches, these are only temporary branches.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成后，你可以将代码合并回 `develop` 分支并删除你的 `feature` 分支：像热修复分支一样，这些分支只是临时性的分支。
- en: 'Like the master one, the `develop` branch is a **long living branch**: you
    will never close nor delete it.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `master` 分支一样，`develop` 分支是一个 **长期存在的分支**：你永远不会关闭或删除它。
- en: This branch is pushed and shared to a remote Git repository.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分支会被推送并共享到远程 Git 仓库。
- en: The release branch
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布分支
- en: At some point, you need to wrap up the next release, including some of the features
    you implemented in the last few weeks. To prepare an incoming release you have
    to branch from `develop`, assigning the branch a name composed by the `release`
    prefix, followed by the numeric form of choice for your release (for example `release/1.0`).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，你需要准备下一个版本的发布，包含过去几周你实现的一些功能。为了准备即将到来的版本，你必须从 `develop` 分支创建一个新的分支，并为该分支命名，名称由
    `release` 前缀和你选择的版本数字（例如 `release/1.0`）组成。
- en: 'Pay attention: **at this stage, no new feature is allowed**! You can no longer
    merge `develop` onto the `release` branch; you can create new branches from that
    branch only for bug-fixing; the purpose of this intermediate branch is to give
    the software to beta testers, allowing them to try it and send you feedback and
    bug tickets.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：**在这个阶段，不允许添加新功能**！你不能再将 `develop` 合并到 `release` 分支；你只能从该分支创建新的分支来修复 bug；这个中间分支的目的是将软件交给
    beta 测试人员，允许他们进行试用并向你反馈问题和 bug。
- en: In case you have fixed some bug onto the `release` branch, the only thing to
    remember is to merge them into the `develop` branch, just to avoid the loss of
    the bug fix - the `release` branch will not be merged back to `develop`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 `release` 分支上修复了某个 bug，唯一需要记住的是将其合并到 `develop` 分支，以避免丢失 bug 修复——`release`
    分支不会被合并回 `develop`。
- en: 'You can keep this branch alive as long as you want, until you decide the software
    is both mature and tested sufficiently to go into production: at this point you
    merge the `release` branch onto the `master` branch, making a new release.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以让这个分支保持有效，直到你认为软件已经成熟并经过足够的测试，准备进入生产环境：此时你将`release`分支合并到`master`分支，创建一个新的发布。
- en: 'After the merge to the `master` you have a choice: keep the `release` branch
    open, if you need to keep different releases alive, otherwise you can delete it.
    Personally, I always delete the `release` branch (as Vincent suggests), because
    I generally do frequent, small, and incremental releases (so I rarely need to
    fix an already shipped release) and because, as you certainly remember, you can
    open a brand-new branch from a commit (a tagged one in this case) whenever you
    want so, at the most, I will open it from that point only when necessary.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 合并到`master`后，你有两个选择：如果你需要保持不同版本的发布，可以保持`release`分支开放，否则可以删除它。就我个人而言，我总是删除`release`分支（正如Vincent建议的那样），因为我通常会进行频繁的小规模增量发布（所以我很少需要修复已经发布的版本），而且，正如你一定记得的那样，你可以随时从一个提交（在这种情况下是一个标记的提交）打开一个全新的分支，因此，最多我也只是会在必要时从那个点重新打开它。
- en: This branch is pushed and shared to a common remote repository.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分支会推送并共享到一个公共的远程仓库。
- en: The feature branches
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性分支
- en: When you have to start the implementation of a new feature, you have to create
    a new branch from the `develop` branch. Feature branches start with the `feature/`
    prefix (for example `feature/NewAuthenitcation` or `feature/#987` if you use some
    features tracking software, as `#987` is the feature ID).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要开始实现一个新特性时，你需要从`develop`分支创建一个新分支。特性分支以`feature/`为前缀（例如`feature/NewAuthenitcation`或`feature/#987`，如果你使用某些功能追踪软件，`#987`就是特性ID）。
- en: 'You will work on the feature release until you finish your work; I suggest
    you *frequently merge back* from `develop`: in case of concurrent modifications
    to the same files, you will resolve conflicts faster if you will resolve them
    earlier; then it is easier to resolve one or two conflicts at a time, rather than
    dozens at the end of the feature work.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你会一直在特性发布上工作，直到完成你的任务；我建议你*经常从`develop`分支合并回来*：如果多个修改同时作用于同一文件，提前解决冲突能更快地解决问题；这样，一次解决一两个冲突比在特性工作结束时解决几十个冲突要容易得多。
- en: Once your work is done, you merge the feature onto `develop` and you are done;
    you can now delete the `feature` branch.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工作完成，你将特性分支合并到`develop`，工作就完成了；此时你可以删除`feature`分支。
- en: Feature branches are mainly private branches, but you can push them to the remote
    repository in case you have to collaborate on it with some other team mates.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 特性分支主要是私有分支，但如果需要与其他团队成员合作，你可以将它推送到远程仓库。
- en: Conclusion
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: I really recommend taking a look at this workflow, as I can assure you there
    were no situations I have failed to solve using solve using it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的推荐你看一下这个工作流，因为我可以向你保证，使用它时没有任何我无法解决的情况。
- en: You can find a deeper explanation, with Git commands ready to use, on **Vincent
    Driessen****'s** already cited blog. You can even use the *gitflow commands* Vincent
    made to customize his Git experience; check these out on his GitHub account at
    [https://github.com/nvie/gitflow](https://github.com/nvie/gitflow).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**Vincent Driessen**之前提到的博客上找到更深入的解释，里面有可以直接使用的Git命令。你甚至可以使用Vincent为定制Git体验而创建的*gitflow命令*；可以在他的GitHub账户上查看，地址是[https://github.com/nvie/gitflow](https://github.com/nvie/gitflow)。
- en: GitHub flow
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitHub flow
- en: The previously described *GitFlow* has tons of followers, but it's always a
    matter of taste; someone else found it too complex and rigid for their situation,
    and in fact there are other ways to manage software repositories that have gained
    consensus during the last few years.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前面描述的*GitFlow*有很多追随者，但这总是一个口味问题；也有人认为它对于他们的情况来说太复杂和死板，事实上，在过去几年中，也有其他管理软件仓库的方法获得了共识。
- en: One of these is the workflow used at GitHub for internal projects and repositories;
    this workflow takes the name of **GitHub flow** and it has been firstly described
    by the well-known **Scott Chacon**, former GitHubber and *ProGit* book author,
    on his blog at [http://scottchacon.com/2011/08/31/github-flow.html](http://scottchacon.com/2011/08/31/github-flow.html).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种工作流是GitHub用于内部项目和仓库的工作流；这个工作流被称为**GitHub flow**，最早由著名的**Scott Chacon**（前GitHub员工以及*ProGit*书籍作者）在他的博客中描述，网址是[http://scottchacon.com/2011/08/31/github-flow.html](http://scottchacon.com/2011/08/31/github-flow.html)。
- en: This workflow, compared to Gitflow, is better tailored for frequent releases,
    and when I say frequent, I mean very frequently, even twice a day. Obviously,
    this kind of flow works better on web projects, because to deploy you have to *only* put
    the new release on the production server; if you develop desktop solutions, you
    need a perfectly oiled update mechanism to do the same.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Gitflow 相比，这种工作流更适合频繁发布，当我说频繁时，我指的是非常频繁，甚至一天两次。显然，这种工作流在网页项目中效果更好，因为要部署，你*只需要*将新版本放到生产服务器上；如果你开发的是桌面解决方案，则需要一个完美运作的更新机制来做到这一点。
- en: GitHub software basically doesn't have releases, because they deploy to production
    regularly, even more than once a day. This is possible due to a robust *Continuous
    Delivery* structure, which is not so easy to obtain; it requires some effort.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 软件基本上没有发布版本，因为他们会定期将更新部署到生产环境，甚至一天多次。这是由于强大的*持续交付*结构，这并不容易实现；它需要一定的努力。
- en: The GitHub flow is based on these simple rules.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub flow 基于以下简单规则。
- en: Anything in the master branch is deployable
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`master` 分支中的任何内容都是可部署的'
- en: Similar to GitFlow, even here in GitHub flow, deploy is done from the `master`
    branch.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 GitFlow，在 GitHub flow 中，部署也是从 `master` 分支进行的。
- en: This is the only *main* branch in this flow; in Gitflow there are no `hotfix`,
    `develop,` or other particular branches. Bug fixes, new implementations and so
    on are constantly merged onto the `master` branch.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该工作流中唯一的*主*分支；在 Gitflow 中没有 `hotfix`、`develop` 或其他特殊分支。错误修复、新功能实现等都会不断地合并到
    `master` 分支。
- en: Other than this, code in the `master` branch is always in a *deployable* state;
    when you fix or add something new in a branch and then you merge it onto the `master`,
    you don't deploy automatically, but you can assume you changes will be up and
    running in a matter of hours.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，`master` 分支中的代码始终处于*可部署*状态；当你在某个分支上修复或添加新内容，然后将其合并到 `master` 上时，你不会自动进行部署，但你可以假设你的更改将在几个小时内上线并运行。
- en: 'Branching and merging constantly to the `master`, the production-ready branch,
    can be dangerous: you can easily introduce regressions or bugs, as no one other
    than you can check you have done a good job. This problem is avoided by a *social
    contract* commonly adopted by GitHub developers; in this contract, you promise
    to test your code before merging it to the `master`, assuring you that all automated
    tests have been successfully completed.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不断地将分支合并到 `master`，即生产就绪分支，可能会带来风险：你很容易引入回归问题或错误，因为除了你自己，没有其他人能够检查你是否做得好。这个问题通过
    GitHub 开发者常用的*社会契约*来避免；在这个契约中，你承诺在将代码合并到 `master` 之前进行测试，确保所有自动化测试都已成功完成。
- en: Creating descriptive branches off of master
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 `master` 分支创建描述性分支
- en: In GitFlow you always branch from the `master`, so it's easy to get a forest
    of branches to look at when you have to pull one. To better identify them, in
    GitHub flow you have to use descriptive names to get meaningful *topic branches*.
    Even here it is a matter of good manners; if you start to create branches named
    *stuff-to-do* you will probably fail in adopting this flow. Some examples are
    `new-user-creation, most-starred-repositories,` and so on (note the use of the
    **Kebab Case**, [http://wiki.c2.com/?KebabCase](http://wiki.c2.com/?KebabCase));
    using a common way to define topics, you will easily find branches you are interested
    in by looking for topics' keywords.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitFlow 中，你总是从 `master` 分支上创建分支，所以当你需要拉取某个分支时，很容易看到一片分支森林。为了更好地识别这些分支，在 GitHub
    flow 中，你需要使用描述性的名称来创建有意义的*主题分支*。这里也是一种良好的习惯；如果你开始创建名为 *stuff-to-do* 的分支，你很可能会在采用这种工作流时失败。一些示例包括
    `new-user-creation`、`most-starred-repositories` 等等（注意使用**Kebab Case**，[http://wiki.c2.com/?KebabCase](http://wiki.c2.com/?KebabCase)）；通过使用一种常见的方式来定义主题，你将更容易通过查找关键词找到感兴趣的分支。
- en: Pushing to named branches constantly
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不断推送到命名分支
- en: Another great difference when comparing GitHub flow to Gitflow is that in GitHub
    flow you push feature branches to the remote regularly, even if you are the only
    developer involved and interested. This is done for continuous integration and
    testing, or maybe also for backup purposes; regarding the backup part, even if
    I already exposed my opinion in merit, I can't say this is a bad thing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Gitflow 相比，GitHub flow 的另一个显著区别是，在 GitHub flow 中，即使你是唯一的开发者并且只对自己感兴趣，你也需要定期将功能分支推送到远程。这是为了持续集成和测试，或者可能也是为了备份；关于备份这一部分，尽管我已经在优点上表达了我的观点，但我不能说这是一件坏事。
- en: A thing I appreciate about Gitflow is that this habit of push every branch to
    the remote gives you the ability to see, with a simple `git fetch`, all the branches
    currently active, and so all the work in progress, even that of your team mates.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢 GitFlow 的一个方面是，每次将分支推送到远程仓库的习惯让你能够通过简单的`git fetch`看到所有当前活动的分支，从而了解所有的进行中的工作，包括你团队成员的工作。
- en: Opening a pull request at any time
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随时发起拉取请求
- en: 'In [Chapter 3](20e98db3-d248-436e-88d5-069be7808998.xhtml), *Git Fundamentals
    - Working Remotely,* we talked about GitHub and made a quick try with *Pull Requests*.
    We have seen that basically they are for *contributing*: you fork someone else''s
    repository, create a new branch, make some modifications and then ask for a pull
    request from the original author.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](20e98db3-d248-436e-88d5-069be7808998.xhtml)，*Git 基础 - 远程工作*中，我们讨论了 GitHub，并快速尝试了*拉取请求*。我们已经看到，基本上它们用于*贡献*：你
    fork 了别人的仓库，创建了一个新分支，进行了一些修改，然后向原作者发起拉取请求。
- en: In GitHub flow you use pull requests massively, even for asking another developer
    on your team to have a look at your work and help you, give you a hint, or review
    the work done. At this point you can start a discussion, using the GitHub pull
    request to chat and involving other people by putting in /CCing their username.
    In addition, the pull request feature lets you comment on even a single line of
    code in the diff view, making users involved able to discuss the work under revision.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub Flow 中，你大量使用拉取请求，即便是请求团队中的其他开发人员来查看你的工作并提供帮助、建议，或审查已完成的工作。在这个阶段，你可以开始讨论，使用
    GitHub 的拉取请求功能进行聊天，并通过 @提及 他们的用户名来让其他人参与。此外，拉取请求功能还允许你在差异视图中评论代码的单行内容，让相关用户能够讨论正在修改的工作。
- en: Merging only after pull request review
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅在拉取请求审查后合并
- en: You can understand now that the *pull requested branch stage* we have seen above
    becomes a sort of *review stage*, where other users can take a look at the code
    and even simply leave a positive comment, just a `+1` to let other users know
    that they are confident about the job, and that they approve its merge into master.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以理解，前面我们看到的*拉取请求分支阶段*变成了一个*审查阶段*，在这个阶段，其他用户可以查看代码，甚至仅仅留下一个积极的评论，像是一个`+1`，让其他人知道他们对这项工作有信心，并且批准将其合并到
    master 分支。
- en: After this step, when the CI server says the branch still passes all the automated
    tests, you are ready to merge the branch in `master`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤之后，当 CI 服务器表示该分支仍通过所有自动化测试时，你就准备好将该分支合并到 `master`。
- en: Deploying immediately after review
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查后立即部署
- en: At this stage, you merge your branch into `master` and the work is done. The
    deploy is not instantly fired, but at GitHub they have a very straight and robust
    deployment procedure, so they can do that easily. They deploy big branches with
    50 commits but even branches with a single commit and a single line of code change,
    because deployment is very quick and cheap for them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你将分支合并到`master`，工作就完成了。虽然部署不是立即触发的，但在 GitHub，他们有一个非常直接且强大的部署程序，因此他们可以轻松地完成部署。无论是包含
    50 次提交的大分支，还是只有一次提交和一行代码更改的小分支，他们都能很快且廉价地完成部署。
- en: This is the reason why they can afford such a simple branching strategy, where
    you put on `master` and then you deploy without the need for passing through `develop`
    or `release` stage branches like in GitFlow.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么他们能够承担如此简单的分支策略的原因，首先将代码放到`master`，然后部署，而无需像 GitFlow 中那样通过`develop`或`release`阶段的分支。
- en: Conclusions
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'I consider this flow very responsive and effective for web based projects,
    where basically you deploy to production without much regard for the versions
    of your software. Using only the `master` branch to derive and integrate branches
    is faster than light, but this strategy can be applied only if you have these
    prerequisites:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这种流程对于基于 web 的项目非常高效和灵活，基本上你可以在没有太多关注软件版本的情况下直接部署到生产环境。只使用`master`分支来派生和集成其他分支，比光速还快，但这种策略仅在具备以下前提条件时才可应用：
- en: A centralized remote ready to manage pull requests (as GitHub does)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个已准备好的集中式远程仓库来管理拉取请求（就像 GitHub 所做的那样）
- en: A good shared agreement about branch names and pull requests usage
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个良好的分支命名和拉取请求使用约定
- en: A very robust deploy system
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个非常强大的部署系统
- en: 'This is a big picture of this flow, graphically represented in the following
    image; for more details, I recommend visiting the GitHub related page at [https://guides.github.com/introduction/flow/index.html](https://guides.github.com/introduction/flow/index.html):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这一流程的宏观图，图形化地表示在下图中；欲了解更多详情，我建议访问与GitHub相关的页面，[https://guides.github.com/introduction/flow/index.html](https://guides.github.com/introduction/flow/index.html)：
- en: '![](img/a7c32beb-274c-427c-b1c7-1f76312b4207.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7c32beb-274c-427c-b1c7-1f76312b4207.png)'
- en: Trunk-based development
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于主干的开发
- en: 'These days, another strategy has regained a certain popularity among developers
    all around the world; its name says it all: *stop using branches*, use only the
    *master branch*!'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，另一种策略在全球开发者中重新获得了一定的关注；它的名字已经说明了一切：*停止使用分支*，仅使用*主分支*！
- en: 'In the picture below there''s the essence of this flow:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了这一流程的精髓：
- en: '![](img/6c32367b-6f99-4206-8add-3521d03c716a.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c32367b-6f99-4206-8add-3521d03c716a.png)'
- en: This trend aims to fight the so called *merge hell*; this happens when branches
    diverge for too long, so merging them is a pain. Similar to the GitHub flow, here
    there aren't long living branches, but even feature branches are discouraged.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这一趋势旨在解决所谓的*合并地狱*问题；当分支长时间分叉时，合并它们就变得非常痛苦。与GitHub流程类似，这里没有长时间存在的分支，甚至连功能分支也不推荐使用。
- en: Continuous Integration and Continuous Delivery are under the light here, and
    this way of working really enforces these good practices we already know thanks
    to the **eXtreme Programming** ([http://www.extremeprogramming.org/](http://www.extremeprogramming.org/))
    mindset and practices.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成和持续交付在这里得到了体现，这种工作方式确实加强了我们已经熟悉的好实践，这些实践得益于**极限编程**([http://www.extremeprogramming.org/](http://www.extremeprogramming.org/))的心态和实践。
- en: This movement is too wide and deep to be discussed here in a couple of sentences,
    but it's worth reading its principles, as it makes you reflect on the topics a
    developer faces during his day by day work. So please take a minute and read more
    about it at [trunkbaseddevelopment.com](http://trunkbaseddevelopment.com).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运动太广泛且深刻，无法在几句话中讨论，但值得阅读它的原则，因为它让你反思开发者在日常工作中所面对的话题。所以请花一点时间，阅读更多内容，[trunkbaseddevelopment.com](http://trunkbaseddevelopment.com)。
- en: Other workflows
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他工作流程
- en: Obviously, there are many other workflows; I will spend just a moment on the
    one that (fortunately!) convinced Linus Torvalds to realize the Git VCS.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，还有许多其他工作流程；我将花一点时间讲述这个（幸运的是！）说服Linus Torvalds意识到Git版本控制系统的工作流。
- en: Linux kernel workflow
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux内核工作流程
- en: The **Linux kernel** uses a workflow that refers to the traditional way **Linus
    Torvalds** has driven its evolution during these years, based on a *military like
    hierarchy*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux内核**使用的工作流程参考了**Linus Torvalds**在这些年中推动其演进的传统方式，基于*军事化的层级结构*。'
- en: Simple kernel developers work on their personal branches, rebasing the master
    branch on the reference repository, then push their branches to the *lieutenant
    developers *`master` branch. Lieutenants are developers that Linus assigned to
    particular topics and areas of the kernel because of their experience. When a
    lieutenant has his work done, he pushes it to the *benevolent dictator *`master`
    branch (Linus branch) and then if things are okay (it is not simple to cheat him),
    Linus pushes his master branch onto the *blessed repository*, the one the developers
    use to rebase from before starting their work.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的内核开发者在他们个人的分支上工作，基于参考库将主分支进行重置，然后将他们的分支推送到*中尉开发者*`master`分支。中尉是Linus根据他们的经验指派负责内核特定话题和领域的开发者。当中尉完成工作时，他会将代码推送到*仁慈独裁者*`master`分支（Linus分支），然后如果一切正常（他不容易被骗），Linus会将他的主分支推送到*祝福库*，这是开发者在开始工作前用来重置的库。
- en: This kind of workflow is not usual; Linus and the Linux kernel bandwagon crafted
    it as it exactly reflected the way they used to work on projects since the beginning,
    when developers used patches and email to forward their work to Linus Torvalds.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作流程并不常见；它是由Linus和Linux内核团队创造的，恰好反映了他们从一开始就采用的项目工作方式，当时开发者使用补丁和电子邮件将工作提交给Linus
    Torvalds。
- en: Having millions of lines of code to manage, and thousands of contributors, I
    find this hierarchy model to be a good compromise in terms of working scope, responsibility,
    and patches skimming.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 管理数百万行代码和成千上万的贡献者，我认为这种层级模型在工作范围、责任和补丁筛选方面是一个很好的折中方案。
- en: 'The following picture helps you better understand this flow:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片有助于你更好地理解这个流程：
- en: '![](img/c336cf95-489a-415a-9efb-e0b763a79950.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c336cf95-489a-415a-9efb-e0b763a79950.png)'
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we became aware of effective ways to use Git; I personally
    consider this chapter the most important for the *new Git user*, because it is
    only by applying some rules and discipline that you will obtain the most from
    this tool. So please pick up a good workflow (make your own, if necessary!), and
    pay attention to your commits: this is the only way to become a good versioning
    tool user, not only in Git.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了有效使用 Git 的方法；我个人认为本章对*新 Git 用户*来说最为重要，因为只有通过应用一些规则和纪律，你才能从这个工具中获得最大的收益。所以，请选择一个好的工作流程（如果需要，自己制定！），并注意你的提交：这才是成为一个优秀版本控制工具用户的唯一途径，不仅仅是在
    Git 中。
- en: In the next chapter, we will see some tips and tricks for using Git even if
    you have to deal with Subversion servers, and then we will take a quick look at
    migrating definitely from Subversion to Git.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到一些使用 Git 的技巧，即使你需要处理 Subversion 服务器，之后我们还将快速了解如何从 Subversion 完全迁移到
    Git。
