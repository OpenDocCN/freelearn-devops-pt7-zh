- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: The Ansible Commands
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 命令
- en: Before moving on to writing and executing more advanced playbooks, we will look
    at the rest of the built-in Ansible commands. Here, we will cover using the commands
    that make up Ansible. Toward the end of this chapter, we will install a third-party
    tool to visualize our host inventory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写和执行更复杂的 playbook 之前，我们将先了解 Ansible 的其他内建命令。在这里，我们将介绍构成 Ansible 的命令。在本章末，我们将安装一个第三方工具来可视化我们的主机清单。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涉及以下主题：
- en: Inbuilt commands
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内建命令
- en: Third-party commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方命令
- en: Inbuilt commands
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内建命令
- en: 'When we installed Ansible, several different commands were installed. These
    were as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们安装 Ansible 时，安装了几种不同的命令。它们如下所示：
- en: '`ansible`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible`'
- en: '`ansible-config`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-config`'
- en: '`ansible-console`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-console`'
- en: '`ansible-doc`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-doc`'
- en: '`ansible-galaxy`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-galaxy`'
- en: '`ansible-inventory`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-inventory`'
- en: '`ansible-playbook`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-playbook`'
- en: '`ansible-pull`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-pull`'
- en: '`ansible-vault`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-vault`'
- en: We already covered the `ansible-galaxy` command in [*Chapter 2*](B21620_02.xhtml#_idTextAnchor080),
    *Exploring Ansible Galaxy*. We will be looking at `ansible-playbook` throughout
    the remaining chapters of this book, so I will not go into any detail about that
    command in this chapter. Let’s start at the top of the list and a command we have
    already used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [*第 2 章*](B21620_02.xhtml#_idTextAnchor080)，*探索 Ansible Galaxy* 中介绍了 `ansible-galaxy`
    命令。在本书的剩余章节中，我们将继续深入探讨 `ansible-playbook`，因此本章将不再详细介绍该命令。让我们从列表的顶部开始，回顾一个我们已经使用过的命令。
- en: Ansible
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible
- en: Now, you would have thought that `ansible` would be the most common command
    we will use throughout this book, but it isn’t.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会认为 `ansible` 是我们在本书中最常用的命令，但事实并非如此。
- en: The `ansible` command is only ever used for executing ad hoc commands against
    a single host or collection of hosts. In [*Chapter 1*](B21620_01.xhtml#_idTextAnchor017),
    *Installing and Running Ansible*, we created a host inventory file that targeted
    a single local virtual machine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible` 命令仅用于对单个主机或一组主机执行临时命令。在 [*第 1 章*](B21620_01.xhtml#_idTextAnchor017)，*安装与运行
    Ansible* 中，我们创建了一个目标为单个本地虚拟机的主机清单文件。'
- en: 'For this part of the chapter, we’ll look at targeting four different hosts
    I have running in a cloud provider; my host’s file looks as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将查看我在云服务提供商上运行的四个不同主机；我的主机文件如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, I have four hosts – `ansible01` > `ansible04`. My first two
    hosts are in a group called `london` and my second two are in a group called `nyc`.
    I have then taken these two groups and created one containing them called `demohosts`,
    and I used this group to apply some basic configurations based on the hosts I
    have launched.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我有四个主机——`ansible01` > `ansible04`。前两个主机在名为 `london` 的组中，后两个主机在名为 `nyc`
    的组中。然后我将这两个组组合在一起，创建了一个名为 `demohosts` 的新组，并使用该组应用一些基于我启动的主机的基本配置。
- en: 'Using the `ping` module, I can check connectivity to the hosts by running the
    following commands. First, let’s check the two hosts in `london`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ping` 模块，我可以通过运行以下命令来检查与主机的连接性。首先，让我们检查 `london` 中的两个主机：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This returns the following results:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下结果：
- en: '![Figure 3.1 – Doing an Ansible ping targeting the london hosts](img/B21620_03_1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 执行 Ansible ping，目标为 london 主机](img/B21620_03_1.jpg)'
- en: Figure 3.1 – Doing an Ansible ping targeting the london hosts
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 执行 Ansible ping，目标为 london 主机
- en: 'Now, let’s run the same command, but this time targeting the `nyc` hosts:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行相同的命令，但这次是针对 `nyc` 主机：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This gives us the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: "![Figure 3.2\uFEFF – Doing an Ansible ping targeting the nyc hosts](img/B21620_03_2.jpg)"
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: "![图 3.2\uFEFF – 执行 Ansible ping，目标为 nyc 主机](img/B21620_03_2.jpg)"
- en: Figure 3.2 – Doing an Ansible ping targeting the nyc hosts
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 执行 Ansible ping，目标为 nyc 主机
- en: As you can see, all four of my hosts returned `pong`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我的四个主机都返回了 `pong`。
- en: 'I can also target all four hosts at once by adding `all` rather than a particular
    group of hosts:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以通过添加 `all` 而不是特定主机组，来一次性针对所有四个主机：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we can access our host through Ansible, we can target them and run
    some ad hoc commands; let’s start with something basic:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过 Ansible 访问我们的主机，可以对其进行操作并运行一些临时命令；让我们从一些基础命令开始：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command will connect to the `london` hosts and run the `ping -c 3 google.com`
    command; this will `ping` the [google.com](http://google.com) domain from the
    hosts and return the results:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将连接到 `london` 主机并运行 `ping -c 3 google.com` 命令；这将从主机对 [google.com](http://google.com)
    域进行 `ping` 并返回结果：
- en: '![Figure 3.3 – Running the ping command against google.com](img/B21620_03_3.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 对 google.com 执行 ping 命令](img/B21620_03_3.jpg)'
- en: Figure 3.3 – Running the ping command against google.com
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 对 google.com 执行 ping 命令
- en: 'We can also run a single module using the `ansible` command; we did this in
    [*Chapter 1*](B21620_01.xhtml#_idTextAnchor017), *Installing and Running Ansible*,
    using the `setup` module. However, a better example would be updating all the
    installed packages across all the hosts by running the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过 `ansible` 命令运行单个模块；我们在[*第 1 章*](B21620_01.xhtml#_idTextAnchor017)中曾经做过这种操作，*安装和运行
    Ansible*，使用的是 `setup` 模块。然而，一个更好的例子是通过运行以下命令来更新所有主机上的所有已安装软件包：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, we have taken the `ansible.builtin.apt` module, which we defined
    as follows in [*Chapter 1*](B21620_01.xhtml#_idTextAnchor017), *Installing and*
    *Running Ansible*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用的是 `ansible.builtin.apt` 模块，我们在[*第 1 章*](B21620_01.xhtml#_idTextAnchor017)中已经定义了该模块，*安装和运行
    Ansible*：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I’ve passed in the same options, but rather than use YAML, I have formatted
    it as a key and value, which is typical of what you would pass into any command
    on the command line:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我传入了相同的选项，但这次我没有使用 YAML，而是将其格式化为键值对，这通常是你在命令行中传递给任何命令的格式：
- en: '![Figure 3.4 – Using the ansible.builtin.apt module to update all the packages](img/B21620_03_4.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 使用 ansible.builtin.apt 模块更新所有软件包](img/B21620_03_4.jpg)'
- en: Figure 3.4 – Using the ansible.builtin.apt module to update all the packages
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 使用 ansible.builtin.apt 模块更新所有软件包
- en: As you can see, the output when running Ansible is quite verbose, and it provides
    feedback to tell us precisely what it did during the ad hoc execution.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，运行 Ansible 时的输出非常详细，并提供了反馈，准确地告诉我们在临时执行过程中做了什么。
- en: 'Let’s rerun the command against all our hosts, but this time just for a single
    package, say `ntp`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新对所有主机运行命令，但这次只针对一个软件包，比如 `ntp`：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running the command once will install the package on all four of our hosts:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一次命令将会在我们的四个主机上安装该软件包：
- en: '![Figure 3.5 – Using the ansible.builtin.apt module to install the ntp package](img/B21620_03_5.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 使用 ansible.builtin.apt 模块安装 ntp 软件包](img/B21620_03_5.jpg)'
- en: Figure 3.5 – Using the ansible.builtin.apt module to install the ntp package
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 使用 ansible.builtin.apt 模块安装 ntp 软件包
- en: 'Now, let’s rerun the command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新运行该命令：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running the command once will install the package on all four of our hosts
    and give us the following results:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一次命令将会在我们的四个主机上安装该软件包，并给出以下结果：
- en: '![Figure 3.6 – Rerunning the ansible.builtin.apt module to install the ntp
    package](img/B21620_03_6.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 重新运行 ansible.builtin.apt 模块安装 ntp 软件包](img/B21620_03_6.jpg)'
- en: Figure 3.6 – Rerunning the ansible.builtin.apt module to install the ntp package
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 重新运行 ansible.builtin.apt 模块安装 ntp 软件包
- en: As you can see, the hosts are returning a `SUCCESS` status and are showing no
    changes, which is what we would expect to see.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，主机返回了 `SUCCESS` 状态并且没有显示变化，这正是我们期望看到的。
- en: So, why would you want to do this, and what is the difference between the two
    commands we ran?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要这样做呢？我们运行的两个命令有什么区别？
- en: 'First, let’s take a look at two of the commands we initially ran once we confirmed
    our hosts were available using an Ansible `ping`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下在确认主机可用后，使用 Ansible `ping` 命令最初运行的两个命令：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While it appears that the first command isn’t running a module, it is. The default
    module for the `ansible` command is called `raw` and runs raw commands on each
    of the targeted hosts. The `-a` part of the command passes arguments to the module.
    The raw module happens to accept raw commands, which is precisely what we are
    doing with the second command.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来第一个命令并没有运行模块，但实际上它是运行了的。`ansible` 命令的默认模块叫做 `raw`，它会在每个目标主机上运行原始命令。命令中的
    `-a` 部分将参数传递给模块。`raw` 模块接受原始命令，这正是我们在第二个命令中所做的。
- en: As mentioned previously, you will have noticed that the syntax is slightly different
    when we pass commands to the `ansible` command and when using it as part of a
    YAML playbook. All we are doing here is passing the key-value pairs directly to
    the module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可能已经注意到，当我们将命令传递给 `ansible` 命令和将其作为 YAML 剧本的一部分使用时，语法略有不同。我们这里只是将键值对直接传递给模块。
- en: So, why would you want to use Ansible like this? Well, it’s excellent for running
    commands directly against non-Ansible managed hosts in an extremely controlled
    way.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要像这样使用 Ansible 呢？嗯，它非常适合以极其受控的方式直接在非 Ansible 管理的主机上运行命令。
- en: 'Ansible uses SSH to connect to the hosts, runs the command, and lets you know
    the results. Just be careful – it is easy to get overconfident and run something
    like the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 使用 SSH 连接到主机，执行命令并告知你结果。只需小心——很容易变得过于自信，执行一些像下面这样的命令：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the user Ansible is using to connect to the host has permission to execute
    the command, it will just run the command you give it. Running the previous command
    will reboot all the servers in the host inventory file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接主机的用户具有执行命令的权限，它将执行你提供的命令。运行上面的命令将重启主机清单文件中的所有服务器：
- en: '![Figure 3.7 – Rebooting all four of the hosts with a single command](img/B21620_03_7.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 使用单个命令重启所有四个主机](img/B21620_03_7.jpg)'
- en: Figure 3.7 – Rebooting all four of the hosts with a single command
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 使用单个命令重启所有四个主机
- en: 'All hosts have an `UNREACHABLE` status because the `reboot` command kicked
    our SSH session before the `SUCCESS` status could be returned. You can, however,
    see that each of the hosts has been rebooted by running the `uptime` command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主机的状态为 `UNREACHABLE`，因为 `reboot` 命令在返回 `SUCCESS` 状态之前终止了我们的 SSH 会话。不过，你可以通过运行
    `uptime` 命令看到每台主机已经重启：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following screenshot shows the output for the preceding command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面命令的输出：
- en: '![Figure 3.8 – Checking the uptime of the four hosts](img/B21620_03_8.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 检查四个主机的运行时间](img/B21620_03_8.jpg)'
- en: Figure 3.8 – Checking the uptime of the four hosts
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 检查四个主机的运行时间
- en: Important
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: As mentioned previously, plus speaking from experience (it’s a long story),
    please be extremely careful when using Ansible to manage hosts using ad hoc commands
    – it’s a powerful but dumb tool, and it will assume you know the consequences
    of running the commands against your hosts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，并根据经验（这是个长故事），在使用 Ansible 管理主机时，使用临时命令要格外小心——它是一个强大但愚笨的工具，它会假设你知道运行这些命令对主机的后果。
- en: That concludes our look at the `ansible` command; let’s move on to our next
    command, `ansible-config`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对 `ansible` 命令的介绍；接下来我们来看下一个命令，`ansible-config`。
- en: The ansible-config command
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ansible-config 命令
- en: 'The `ansible-config` command is used to manage Ansible configuration files.
    Ansible ships with sensible defaults, so there is little to configure outside
    of these. You can view the current configuration by running the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-config` 命令用于管理 Ansible 配置文件。Ansible 附带了合理的默认设置，因此在这些设置之外几乎无需进行配置。你可以通过运行以下命令来查看当前配置：'
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As shown from the following output, all the text in green is the default config,
    and any configuration in orange is a changed value:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下输出可以看到，所有绿色文本是默认配置，任何橙色的配置值是已更改的值：
- en: '![Figure 3.9 – Dumping our complete Ansible configuration to screen](img/B21620_03_9.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 将完整的 Ansible 配置输出到屏幕](img/B21620_03_9.jpg)'
- en: Figure 3.9 – Dumping our complete Ansible configuration to screen
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 将完整的 Ansible 配置输出到屏幕
- en: 'Running the following command will list details of every configuration option
    there is within Ansible, including what the option does, its current state, when
    it was introduced, the type, and much more:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将列出 Ansible 中每个配置选项的详细信息，包括该选项的作用、当前状态、引入时间、类型等：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following screenshot shows the output for the preceding command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面命令的输出：
- en: '![Figure 3.10 – Viewing details on an Ansible configuration option](img/B21620_03_10.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 查看 Ansible 配置选项的详细信息](img/B21620_03_10.jpg)'
- en: Figure 3.10 – Viewing details on an Ansible configuration option
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 查看 Ansible 配置选项的详细信息
- en: 'If you had a configuration file, say at `~/.ansible.cfg`, then you can load
    it using the `-c` or–`-config` flags:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个配置文件，比如在 `~/.ansible.cfg`，你可以使用 `-c` 或 `--config` 标志来加载它：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The previous command will give you an overview of the custom configuration file
    and display the Ansible default values not defined in your custom configuration
    file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将为你提供自定义配置文件的概览，并显示未在自定义配置文件中定义的 Ansible 默认值。
- en: The ansible-console command
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ansible-console 命令
- en: 'Ansible has a built-in console. It is not something I have used much in my
    day-to-day running of Ansible. To start the console, we need to run one of the
    following commands:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 内置了一个控制台。它不是我在日常使用 Ansible 时经常用到的工具。要启动控制台，我们需要运行以下其中一个命令：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first of the three commands targets all of the hosts, while the next two
    just target the named groups:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 三个命令中的第一个针对所有主机，而接下来的两个仅针对指定的组：
- en: '![Figure 3.11 – Establishing the console connection](img/B21620_03_11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 建立控制台连接](img/B21620_03_11.jpg)'
- en: Figure 3.11 – Establishing the console connection
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 建立控制台连接
- en: 'Once connected, you will see that I am connected to the `london` group of hosts,
    in which there are two hosts. From here, you can type a module name, such as `ping`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接成功，你将看到我已连接到 `london` 主机组，该组中有两台主机。在这里，你可以输入一个模块名称，例如 `ping`：
- en: '![Figure 3.12 – Running ping from Ansible](img/B21620_03_12.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 从 Ansible 运行 ping](img/B21620_03_12.jpg)'
- en: Figure 3.12 – Running ping from Ansible
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 从 Ansible 运行 ping
- en: 'Alternatively, you can use the `raw` module; for example, you can check the
    `uptime` command by typing `ansible.builtin.raw uptime`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以使用 `raw` 模块；例如，你可以通过输入 `ansible.builtin.raw uptime` 来检查 `uptime` 命令：
- en: '![Figure 3.13 – Using the raw module to run the uptime command](img/B21620_03_13.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 使用 raw 模块运行 uptime 命令](img/B21620_03_13.jpg)'
- en: Figure 3.13 – Using the raw module to run the uptime command
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 使用 raw 模块运行 uptime 命令
- en: 'You can also use the same syntax as we did when running the `ansible` command
    to pass key-value pairs – for example, running the following at the console prompt:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用与运行 `ansible` 命令时相同的语法来传递键值对——例如，在控制台提示符下运行以下命令：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It should give you something like the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该会给你类似以下的输出：
- en: '![Figure 3.14 – Checking that the ntp package is installed using the ansible.builtin.apt
    module](img/B21620_03_14.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – 使用 ansible.builtin.apt 模块检查是否安装了 ntp 包](img/B21620_03_14.jpg)'
- en: Figure 3.14 – Checking that the ntp package is installed using the ansible.builtin.apt
    module
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 使用 ansible.builtin.apt 模块检查是否安装了 ntp 包
- en: You may have noticed that the syntax of the command we are running this time
    is slightly different from when we ran the same module using the `ansible` command
    earlier in this chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这次我们运行的命令语法与我们在本章前面使用 `ansible` 命令运行同一个模块时略有不同。
- en: 'That command was as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 那个命令如下：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Whereas this time, we just ran the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 而这次，我们只运行了以下命令：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The reason for this is that when we called the module using the `ansible` command,
    we were working on the command line of our local machine, so we needed to pass
    in the module name using the `-m` flag and then define the attributes by using
    the `-a` flag. After, we had to pass in our key-value pairs within quotation marks
    so as not to break the flow of the command as spaces are used as a delimiter when
    it comes to the command line.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以如此，是因为当我们使用 `ansible` 命令调用模块时，我们是在本地机器的命令行上操作，因此需要通过 `-m` 标志传入模块名称，然后使用 `-a`
    标志定义属性。之后，我们必须将键值对放入引号中，以避免破坏命令流，因为命令行中空格作为分隔符。
- en: When we ran the Ansible console, we had effectively already run the `ansible
    -i hosts london` part of the command, left our local command line altogether,
    and were interacting with Ansible itself directly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 Ansible 控制台时，我们实际上已经执行了 `ansible -i hosts london` 命令的一部分，完全离开了本地命令行，直接与
    Ansible 进行交互。
- en: To leave the console, type `exit` to return to your regular command-line shell.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要离开控制台，输入 `exit` 以返回常规命令行 shell。
- en: As mentioned at the start of this section, the `ansible-console` command is
    something I do not use – mainly for the warning I gave when we looked at the `ansible`
    command at the start of this chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开始时所提到的，`ansible-console` 命令是我不常使用的——主要是因为我在本章开始时讨论 `ansible` 命令时给出的警告。
- en: When connecting to several hosts using the `ansible-console` command, you must
    be 100% confident that the commands you are typing are correct. For example, while
    I was only connected to two hosts, my `hosts` file could have contained 200 hosts.
    Now, imagine I typed the wrong command – executing it across 200 hosts at once
    could potentially do some unwanted things, such as rebooting them all simultaneously.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ansible-console` 命令连接多个主机时，你必须 100% 确信你输入的命令是正确的。例如，虽然我只连接了两台主机，但我的 `hosts`
    文件可能包含了 200 台主机。现在，假设我输入了错误的命令——如果它同时在 200 台主机上执行，可能会导致一些不想要的事情，比如同时重启所有主机。
- en: To quit the `ansible-console` session, simply type `exit` and hit *Enter*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出 `ansible-console` 会话，只需输入 `exit` 并按 *Enter* 键。
- en: As you have probably guessed, this happened to me. It wasn’t 200 hosts, but
    it could have easily been – *so please* *be careful.*
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经猜到的，这种情况发生在我身上。虽然不是 200 台主机，但也很可能是——*所以请* *小心。*
- en: The ansible-inventory command
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ansible-inventory 命令
- en: 'Using the `ansible-inventory` command provides you with details of your host
    inventory files. It can be helpful to understand how your hosts are grouped. For
    example, let’s say I run the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ansible-inventory`命令可以为你提供主机清单文件的详细信息。这对于理解你的主机是如何分组的非常有帮助。例如，假设我运行以下命令：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the same folder as the `hosts` inventory file that I have been using throughout
    this section, the following is returned:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在与我在本节中一直使用的`hosts`清单文件相同的文件夹中，返回以下内容：
- en: '![Figure 3.15 – Getting an overview of the inventory hosts file](img/B21620_03_15.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – 获取清单主机文件的概览](img/B21620_03_15.jpg)'
- en: Figure 3.15 – Getting an overview of the inventory hosts file
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 获取清单主机文件的概览
- en: As you can see, it displays the groups, starting with `all`, then the main host
    group (`demohosts`), then the child groups (`london` and `nyc`), and finally the
    hosts themselves (`ansible01` > `ansible04`).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它显示了从`all`开始的主机组，然后是主要的主机组（`demohosts`），接着是子组（`london`和`nyc`），最后是主机本身（`ansible01`
    > `ansible04`）。
- en: 'If you want to view the configuration for a single host, you can use this command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看单个主机的配置，可以使用此命令：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了前面命令的输出：
- en: '![Figure 3.16 – Viewing a single host](img/B21620_03_16.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16 – 查看单个主机](img/B21620_03_16.jpg)'
- en: Figure 3.16 – Viewing a single host
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – 查看单个主机
- en: 'You may have noticed that it displays the configuration information that the
    host inherited from the configuration we set for all the hosts in the `demohost`
    host group in the inventory file. You can view all the information on each of
    your hosts and groups by running the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，它显示了主机继承的配置，这些配置来自我们为清单文件中所有主机设置的`demohost`主机组。你可以通过运行以下命令来查看每个主机和主机组的所有信息：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command is helpful if you have a large or complicated host inventory file
    and want information on just a single host or if you have taken on a host inventory
    and want a better idea of how the inventory is structured. We will look at a third-party
    tool later in this chapter that gives more display options.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个大型或复杂的主机清单文件，并且只需要某一台主机的信息，或者你接手了一个主机清单并希望更好地了解清单的结构，那么这个命令会很有帮助。我们将在本章后面讨论一个第三方工具，它提供更多显示选项。
- en: What is ansible-pull?
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是ansible-pull？
- en: Like the `ansible-console` command, `ansible-pull` is not a command I use very
    often; I can count on one hand how often I have used it in the past several years.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 和`ansible-console`命令一样，`ansible-pull`不是我经常使用的命令；我可以用一只手来数出在过去几年中我使用它的次数。
- en: '`ansible-pull` is a command that allows a target machine to pull its configuration
    from a given source, such as a Git repository, and apply it locally. This reverses
    the typical Ansible push model, where a central control node pushes configuration
    to managed nodes.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-pull`是一个命令，允许目标机器从指定的源（例如Git仓库）拉取配置并应用于本地。这与典型的Ansible推送模型相反，后者是中央控制节点将配置推送到受管理节点。'
- en: 'The `ansible-pull` command works as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-pull`命令的工作方式如下：'
- en: The target machine, the one running `ansible-pull`, fetches a specified repository.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标机器（即运行`ansible-pull`的机器）获取指定的仓库。
- en: Once the repository has been fetched, the target machine looks for a playbook.
    By default, it looks for one called `localhost.yml`, but you can specify a different
    playbook file if you need to – please note that this is not included in the example
    files.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦仓库被拉取，目标机器会查找剧本。默认情况下，它会查找名为`localhost.yml`的剧本，但如果需要，你也可以指定其他剧本文件——请注意，这个文件不包括在示例文件中。
- en: The target machine then runs the playbook against itself.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标机器随后对自身运行该剧本。
- en: 'There are a few use cases for `ansible-pull`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-pull`有一些使用场景：'
- en: '`ansible-pull` allows nodes to self-configure by pulling their configurations'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-pull`允许节点通过拉取配置来进行自我配置。'
- en: '`ansible-pull` can be scheduled to run at specific intervals via a cron job,
    ensuring that hosts can self-update when they have connectivity'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-pull`可以通过定时任务安排在特定的时间间隔内运行，确保主机在有连接时能够自我更新。'
- en: '`ansible-pull` to pull down and apply configurations to their local development
    environments, ensuring consistency with production configurations'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-pull`用来拉取并应用配置到本地开发环境，确保与生产配置的一致性。'
- en: There are a few prerequisites to running `ansible-pull` – the most prominent
    being that the host running `ansible-pull` must have an active and valid Ansible
    installation and any other dependencies needed to execute the playbook.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `ansible-pull` 有一些前提条件，其中最重要的是运行 `ansible-pull` 的主机必须有一个有效且活动的 Ansible 安装，并且安装任何执行剧本所需的其他依赖项。
- en: In summary, `ansible-pull` provides a way to invert the traditional Ansible
    model, allowing hosts to pull their configurations as needed rather than having
    a central host push the configurations to them, as we did in [*Chapter 1*](B21620_01.xhtml#_idTextAnchor017),
    *Installing and Running Ansible*, and [*Chapter 2*](B21620_02.xhtml#_idTextAnchor080),
    *Exploring Ansible Galaxy*. For the remainder of this book, we will be taking
    the more traditional approach to Ansible deployments and pushing our configuration
    to our target hosts.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`ansible-pull` 提供了一种颠倒传统 Ansible 模型的方法，允许主机根据需要拉取配置，而不是像我们在[*第 1 章*](B21620_01.xhtml#_idTextAnchor017)《安装和运行
    Ansible》和[*第 2 章*](B21620_02.xhtml#_idTextAnchor080)《探索 Ansible Galaxy》中所做的那样，由中央主机将配置推送给它们。本书的其余部分，我们将采用更传统的
    Ansible 部署方式，将配置推送到目标主机。
- en: However, it is always good to know that if, for whatever reason, you are not
    able to take this approach, then you do have an alternative option in `ansible-pull`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，如果由于某种原因你无法采用这种方法，那么你确实有一个替代方案，那就是 `ansible-pull`。
- en: Using the ansible-vault command
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ansible-vault 命令
- en: 'In Ansible, it is possible to load variables from files or within a playbook
    itself; we will look at this in the next chapter in more detail. These files can
    contain sensitive information such as passwords and API keys. Here’s an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible 中，可以从文件或剧本本身加载变量；我们将在下一章更详细地介绍这个内容。这些文件可能包含敏感信息，如密码和 API 密钥。以下是一个示例：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, we have two sensitive bits of information visible as plaintext.
    This is OK while the file is on our local machine – well, just about OK. But what
    if we want to check the file into source control to share it with our colleagues?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们有两个敏感信息以明文形式显示。这在文件位于本地机器时是可以的——嗯，差不多可以。但是，如果我们想将文件提交到源代码管理系统并与同事共享呢？
- en: '*We shouldn’t store this information in plaintext, even if the repository*
    *is private.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*即使仓库* *是私有的，我们也不应将这些信息以明文形式存储。*'
- en: Ansible introduced Ansible Vault to help solve this very problem. Using the
    `ansible-vault` command, we can encrypt a file or just variables, and then when
    Ansible is executed, it can be decrypted in memory, and the content can be read
    as part of the execution.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 引入了 Ansible Vault 来帮助解决这个问题。通过使用 `ansible-vault` 命令，我们可以加密文件或仅加密变量，然后在
    Ansible 执行时，它可以在内存中解密，内容可以作为执行的一部分被读取。
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the rest of the chapter, I will set a Vault password of `password`, should
    you wish to run the `ansible-vault` command against the files in the `Chapter03/vault`
    folder.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余部分，我将设置 Vault 密码为 `password`，以便你在运行 `ansible-vault` 命令时可以针对 `Chapter03/vault`
    文件夹中的文件进行操作。
- en: 'To encrypt a file, we need to run the following command, providing a password
    that will be used to decrypt the file when prompted:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密一个文件，我们需要运行以下命令，并提供一个密码，该密码将在提示时用于解密文件：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following screenshot shows the output of the preceding command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前述命令的输出：
- en: '![Figure 3.17 – Using ansible-vault to encrypt an entire file](img/B21620_03_17.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17 – 使用 ansible-vault 加密整个文件](img/B21620_03_17.jpg)'
- en: Figure 3.17 – Using ansible-vault to encrypt an entire file
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – 使用 ansible-vault 加密整个文件
- en: 'As you can see from the output, you will be asked to confirm the password.
    Once encrypted, your file will look something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，你将被要求确认密码。加密后，你的文件看起来会像这样：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, the details are encoded using text. This ensures that our `secrets.yml`
    file will still work without problems when it’s checked into source control such
    as Git.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，细节是使用文本编码的。这确保了我们的 `secrets.yml` 文件在提交到源代码管理系统（如 Git）时仍然可以正常工作。
- en: 'You can view the content of a file by running the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来查看文件内容：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will ask you for the password and print the content of the file to the
    screen:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求你输入密码，并将文件内容打印到屏幕上：
- en: '![Figure 3.18 – Using ansible-vault to encrypt an entire file](img/B21620_03_18.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18 – 使用 ansible-vault 加密整个文件](img/B21620_03_18.jpg)'
- en: Figure 3.18 – Using ansible-vault to encrypt an entire file
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – 使用 ansible-vault 加密整个文件
- en: 'You can decrypt the file on disk by running the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来解密磁盘上的文件：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will restore the file to its unencrypted original state.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这将恢复文件到其未加密的原始状态。
- en: Important
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When using the `ansible-vault decrypt` command, please do not commit or check
    the decrypted file into your source control system!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ansible-vault decrypt` 命令时，请不要将解密后的文件提交或检查到你的源代码控制系统中！
- en: 'Since early in the release of Ansible 2, encrypting a single variable in a
    file is now possible. Let’s add some more variables to our file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Ansible 2 版本初期发布以来，现已可以加密文件中的单个变量。让我们将更多变量添加到文件中：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It would be good if we didn’t have to keep viewing or decrypting our file to
    check its variable name and overall content.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要不断查看或解密文件以检查其变量名和整体内容，那就太好了。
- en: 'Let’s encrypt the password content by running the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下命令来加密密码内容：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will encrypt the `mypassword` string and give it a variable name of `password`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加密字符串 `mypassword` 并给它一个变量名 `password`：
- en: '![Figure 3.19 – Using ansible-vault to encrypt a single string](img/B21620_03_19.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.19 – 使用 ansible-vault 加密单个字符串](img/B21620_03_19.jpg)'
- en: Figure 3.19 – Using ansible-vault to encrypt a single string
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19 – 使用 ansible-vault 加密单个字符串
- en: 'We can then copy and paste the output into our file and repeat this process
    for `secretapikey`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将输出复制并粘贴到我们的文件中，并对 `secretapikey` 重复此过程：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With that, we have generated two secret variables and replaced the unencrypted
    ones in our variables file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们生成了两个秘密变量，并用它们替换了变量文件中未加密的内容。
- en: Note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For ease of reading, I have truncated the output a little – the entire file
    can be found in the `Chapter03/vault` folder in this book’s GitHub repository.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，我对输出进行了简化 – 完整的文件可以在本书 GitHub 仓库中的 `Chapter03/vault` 文件夹找到。
- en: 'Our variables file should end up looking something like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的变量文件应该最终看起来像这样：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, that is much easier to read and is just as secure as encrypting
    the file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这样更容易阅读，且与加密文件同样安全。
- en: So far, so good, but how do you use Ansible Vault encrypted data in an Ansible
    playbook?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但如何在 Ansible playbook 中使用 Ansible Vault 加密的数据呢？
- en: 'Before we look at how to do this, let’s see what happens when you don’t tell
    the `ansible-playbook` command you are using Ansible Vault by running the following
    playbook. As you can see, it is loading in the `myvars.yml` file and then printing
    the contents of our variables to the screen using the `ansible.builtin.debug`
    module:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习如何做之前，让我们先看看当你没有告诉 `ansible-playbook` 命令你正在使用 Ansible Vault 时会发生什么。运行以下
    playbook，你会看到它加载了 `myvars.yml` 文件，并使用 `ansible.builtin.debug` 模块将变量内容打印到屏幕上：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can run the playbook using the following command; note that since it’s just
    running locally, we are not passing an inventory file. This is something it will
    give you a warning about:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行 playbook；请注意，由于它只是本地运行，因此我们不会传递库存文件。这是它会给你警告的地方：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This results in an error message being shown in the Terminal output:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致终端输出中显示错误消息：
- en: '![Figure 3.20 – Getting an error when running the ansible-playbook command](img/B21620_03_20.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.20 – 运行 `ansible-playbook` 命令时出现错误](img/B21620_03_20.jpg)'
- en: Figure 3.20 – Getting an error when running the ansible-playbook command
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – 运行 `ansible-playbook` 命令时出现错误
- en: As you can see, it’s complaining that it found Vault-encrypted data in one of
    the files, but we haven’t provided the secret to unlock it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它在抱怨它在其中一个文件中发现了 Vault 加密数据，但我们没有提供解锁它的秘密。
- en: The first way we can pass the Vault password during the `ansible-playbook` run
    is to put the password in a text file and have the `ansible-playbook` command
    read the file’s contents.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `ansible-playbook` 运行时将 Vault 密码放入文本文件中，并让 `ansible-playbook` 命令读取该文件的内容，来传递
    Vault 密码。
- en: 'As mentioned at the start of this section, I have been encoding my Vaults using
    a password of `password`. Let’s put that in a file and then use it to unlock our
    Vault:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开始时提到的，我一直在使用密码 `password` 对我的 Vault 进行编码。我们将密码放入文件中，然后用它来解锁我们的 Vault：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running the following command will read the content of `/tmp/vault-file` and
    decrypt the data:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将读取 `/tmp/vault-file` 的内容并解密数据：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see from the following playbook run, the output is now as we expect:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，以下是播放书执行后的结果，输出现在符合我们的预期：
- en: '![Figure 3.21 – Running ansible-playbook and passing the Vault password in
    via a file](img/B21620_03_21.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.21 – 运行 ansible-playbook 并通过文件传递 Vault 密码](img/B21620_03_21.jpg)'
- en: Figure 3.21 – Running ansible-playbook and passing the Vault password in via
    a file
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 – 运行 ansible-playbook 并通过文件传递 Vault 密码
- en: 'If you prefer to be prompted for the password, you can use the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢在提示时输入密码，可以使用以下命令：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following output shows the prompt:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了提示：
- en: '![Figure 3.22 – Running ansible-playbook and entering the password via a prompt](img/B21620_03_22.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.22 – 运行ansible-playbook并通过提示输入密码](img/B21620_03_22.jpg)'
- en: Figure 3.22 – Running ansible-playbook and entering the password via a prompt
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 – 运行ansible-playbook并通过提示输入密码
- en: You might be asking yourself, why are there two different options? When prompted,
    just running the command and entering the password might seem enough.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么有两个不同的选项？当提示时，直接运行命令并输入密码似乎就足够了。
- en: However, when it comes to using services such as the ones we will cover in [*Chapter
    15*](B21620_15.xhtml#_idTextAnchor641), *Using Ansible with GitHub Actions and
    Azure DevOps*, the commands need to run utterly unattended as there will not be
    an active terminal for you to enter the password.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用我们将在[*第15章*](B21620_15.xhtml#_idTextAnchor641)中介绍的服务时，*使用Ansible与GitHub
    Actions和Azure DevOps*，命令需要完全无人值守地运行，因为在运行时不会有活动终端让您输入密码。
- en: Another advantage that will be looked at in both [*Chapter 15*](B21620_15.xhtml#_idTextAnchor641),
    *Using Ansible with GitHub Actions and Azure DevOps*, and [*Chapter 16*](B21620_16.xhtml#_idTextAnchor716),
    *Introducing Ansible AWX and Red Hat Ansible Automation Platform*, is that by
    abstracting away the need for an end user to enter credentials at runtime, it
    is entirely possible for someone to run a pipeline and never need to know or have
    access to any of the secrets stored in your playbooks or the credentials to unlock
    them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在[*第15章*](B21620_15.xhtml#_idTextAnchor641)，*使用Ansible与GitHub Actions和Azure
    DevOps*，和[*第16章*](B21620_16.xhtml#_idTextAnchor716)，*介绍Ansible AWX和Red Hat Ansible自动化平台*中会看到的优点是，通过抽象化运行时输入凭据的需求，完全可以让某人运行一个管道，而不需要知道或访问任何存储在剧本中的机密或解锁它们的凭据。
- en: Third-party commands
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方命令
- en: Before we finish looking at the various Ansible commands, let’s look at a command
    that isn’t shipped as part of Ansible itself but is, in fact, a third-party open
    source project.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束查看各种Ansible命令之前，让我们来看一个命令，它不是Ansible本身的一部分，而是一个第三方开源项目。
- en: The ansible-inventory-grapher command
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ansible-inventory-grapher命令
- en: 'The `ansible-inventory-grapher` command, by Will Thames, uses the Graphviz
    library to visualize your host inventories. The first thing we need to do is install
    Graphviz. To install this on macOS using Homebrew, run the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-inventory-grapher`命令，由Will Thames编写，使用Graphviz库可视化您的主机清单。我们需要做的第一件事是安装Graphviz。要使用Homebrew在macOS上安装它，请运行以下命令：'
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To install Graphviz on Ubuntu, use the following command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Ubuntu上安装Graphviz，请使用以下命令：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once installed, you can install `ansible-inventory-grapher` using `pip`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您可以使用`pip`安装`ansible-inventory-grapher`：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have everything installed, we can generate the graph using the
    `hosts` file we used earlier in this chapter:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装好了所有内容，可以使用本章早些时候使用的`hosts`文件生成图表：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will generate something that looks like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成如下所示的内容：
- en: '![Figure 3.23 – Running ansible-inventory-grapher against our hosts file](img/B21620_03_23.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.23 – 对我们的主机文件运行ansible-inventory-grapher](img/B21620_03_23.jpg)'
- en: Figure 3.23 – Running ansible-inventory-grapher against our hosts file
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.23 – 对我们的主机文件运行ansible-inventory-grapher
- en: 'This is the raw output of the graph. As you can see, it is like and uses some
    of the same syntax as HTML. We can render this using the `dot` command, which
    ships as part of Graphviz. The `dot` command creates hierarchical drawings from
    graphs. To do this, run the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是图形的原始输出。如您所见，它类似并使用了与HTML相同的一些语法。我们可以使用`dot`命令来呈现它，`dot`命令作为Graphviz的一部分一起提供。`dot`命令从图形中创建层次结构图。要执行此操作，请运行以下命令：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will generate a PNG file called `hosts.png` that contains the visualization
    of the host inventory file you can see here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个名为`hosts.png`的PNG文件，其中包含您可以在此处看到的主机清单文件的可视化：
- en: '![Figure 3.24 – The output of passing our ansible-inventory-grapher output
    through Graphviz](img/B21620_03_24.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.24 – 通过Graphviz传递我们ansible-inventory-grapher输出的结果](img/B21620_03_24.jpg)'
- en: Figure 3.24 – The output of passing our ansible-inventory-grapher output through
    Graphviz
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.24 – 通过Graphviz传递我们ansible-inventory-grapher输出的结果
- en: As you can see, this is an excellent representation of the hosts being targeted
    by Ansible; it works great for inclusion in your documentation but also gives
    you an idea of how a complicated inventory file is structured.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是 Ansible 目标主机的一个很好的展示；它非常适合用在文档中，同时也能让你了解复杂的清单文件是如何结构化的。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we briefly looked at some of the supporting tools that ship
    as part of a standard Ansible installation and a useful third-party tool designed
    to work with Ansible.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了作为标准 Ansible 安装一部分的几个支持工具，以及一个旨在与 Ansible 配合使用的有用第三方工具。
- en: We will use these commands and the one we have purposely missed, `ansible-playbook`,
    in later chapters.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中使用这些命令，以及我们有意跳过的 `ansible-playbook`。
- en: In the next chapter, we will write a more complex playbook that installs a basic
    LAMP stack on our local virtual machine.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将编写一个更复杂的 playbook，安装一个基本的 LAMP 堆栈到本地虚拟机上。
- en: Further reading
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'You can find the documentation for each of the tools covered in this chapter
    at the following URLs:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下网址找到本章涉及的每个工具的文档：
- en: 'Ansible command-line tools overview: [https://docs.ansible.com/ansible/latest/command_guide/command_line_tools.html](https://docs.ansible.com/ansible/latest/command_guide/command_line_tools.html)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 命令行工具概览： [https://docs.ansible.com/ansible/latest/command_guide/command_line_tools.html](https://docs.ansible.com/ansible/latest/command_guide/command_line_tools.html)
- en: '`ansible`: [https://docs.ansible.com/ansible/latest/cli/ansible.html](https://docs.ansible.com/ansible/latest/cli/ansible.html)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible`: [https://docs.ansible.com/ansible/latest/cli/ansible.html](https://docs.ansible.com/ansible/latest/cli/ansible.html)'
- en: '`ansible-config`: [https://docs.ansible.com/ansible/latest/cli/ansible-config.html](https://docs.ansible.com/ansible/latest/cli/ansible-config.html
    )'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-config`: [https://docs.ansible.com/ansible/latest/cli/ansible-config.html](https://docs.ansible.com/ansible/latest/cli/ansible-config.html)'
- en: '`ansible-console`: [https://docs.ansible.com/ansible/latest/cli/ansible-console.html](https://docs.ansible.com/ansible/latest/cli/ansible-console.html)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-console`: [https://docs.ansible.com/ansible/latest/cli/ansible-console.html](https://docs.ansible.com/ansible/latest/cli/ansible-console.html)'
- en: '`ansible-doc`: [https://docs.ansible.com/ansible/latest/cli/ansible-doc.html](https://docs.ansible.com/ansible/latest/cli/ansible-doc.html)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-doc`: [https://docs.ansible.com/ansible/latest/cli/ansible-doc.html](https://docs.ansible.com/ansible/latest/cli/ansible-doc.html)'
- en: '`ansible-inventory`: [https://docs.ansible.com/ansible/latest/cli/ansible-inventory.html](https://docs.ansible.com/ansible/latest/cli/ansible-inventory.html)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-inventory`: [https://docs.ansible.com/ansible/latest/cli/ansible-inventory.html](https://docs.ansible.com/ansible/latest/cli/ansible-inventory.html)'
- en: '`ansible-playbook`: [https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html](https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-playbook`: [https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html](https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html)'
- en: '`ansible-pull`: [https://docs.ansible.com/ansible/latest/cli/ansible-pull.html](https://docs.ansible.com/ansible/latest/cli/ansible-pull.html)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-pull`: [https://docs.ansible.com/ansible/latest/cli/ansible-pull.html](https://docs.ansible.com/ansible/latest/cli/ansible-pull.html)'
- en: '`ansible-vault`: [https://docs.ansible.com/ansible/latest/cli/ansible-vault.html](https://docs.ansible.com/ansible/latest/cli/ansible-vault.html)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-vault`: [https://docs.ansible.com/ansible/latest/cli/ansible-vault.html](https://docs.ansible.com/ansible/latest/cli/ansible-vault.html)'
- en: '`ansible-inventory-grapher`: [https://github.com/willthames/ansible-inventory-grapher](https://github.com/willthames/ansible-inventory-grapher)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-inventory-grapher`: [https://github.com/willthames/ansible-inventory-grapher](https://github.com/willthames/ansible-inventory-grapher)'
- en: 'Part 2: Deploying Applications'
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 部分：部署应用程序
- en: Now that you understand Ansible’s basics, it’s time to put that knowledge into
    practice. In this part, we will focus on deploying applications using Ansible
    playbooks. From setting up a LAMP stack to deploying WordPress and targeting multiple
    distributions, you will gain hands-on experience automating application deployments.
    We will also explore how Ansible can manage Windows-based servers, expanding your
    automation capabilities.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了 Ansible 的基础知识，接下来是时候将这些知识付诸实践了。在这一部分，我们将重点讲解如何使用 Ansible playbook 部署应用程序。从设置
    LAMP 堆栈到部署 WordPress，再到针对多个发行版的操作，你将获得实际操作经验，自动化应用程序的部署。我们还将探索 Ansible 如何管理基于
    Windows 的服务器，扩展你的自动化能力。
- en: 'This part has the following chapters:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分包含以下章节：
- en: '[*Chapter 4*](B21620_04.xhtml#_idTextAnchor202), *Deploying a LAMP Stack*'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 4 章*](B21620_04.xhtml#_idTextAnchor202), *部署 LAMP 堆栈*'
- en: '[*Chapter 5*](B21620_05.xhtml#_idTextAnchor253), *Deploying WordPress*'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 5 章*](B21620_05.xhtml#_idTextAnchor253), *部署 WordPress*'
- en: '[*Chapter 6*](B21620_06.xhtml#_idTextAnchor291), *Targeting Multiple Distributions*'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 6 章*](B21620_06.xhtml#_idTextAnchor291), *目标多个发行版*'
- en: '[*Chapter 7*](B21620_07.xhtml#_idTextAnchor336), *Ansible Windows Modules*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21620_07.xhtml#_idTextAnchor336)，*Ansible Windows模块*'
