- en: '*Chapter 5*: Working with External Systems'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：与外部系统的交互'
- en: Applications rarely exist in isolation. They tend to specialize in doing one
    thing well, but to be truly useful, they need to co-exist with other applications
    within your organization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序很少是孤立存在的。它们通常专注于做一件事，但为了真正有用，它们需要与组织中的其他应用程序共同存在。
- en: This is especially true for Jira, and this can be seen in the Atlassian Marketplace
    where, among the large number of available apps, hundreds of them exist solely
    to integrate Jira with other applications and systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这尤其适用于 Jira，这一点可以在 Atlassian Marketplace 中看到，在大量可用应用程序中，数百个仅用于将 Jira 与其他应用程序和系统集成。
- en: Even with the number of integrations with various applications available as
    plugins to Jira, there will often be occasions where the integration you need
    is not catered for, or where an existing integration does not quite meet your
    specific requirements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有许多与各种应用程序的集成插件可供 Jira 使用，仍然会有一些情况，所需的集成未被涵盖，或者现有的集成无法完全满足你的特定需求。
- en: In recent years, many applications and systems have embraced JSON-based REST
    APIs to enable third-party systems to integrate with them, and automation rules
    in Jira provide us with the components necessary to take advantage of this.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，许多应用程序和系统都采用了基于 JSON 的 REST API，以便使第三方系统能够与它们集成，而 Jira 中的自动化规则为我们提供了利用这些
    API 所需的组件。
- en: In this chapter, we will learn how we can send requests to external systems
    using automation rules and how to work with the data that is returned from these
    requests. In addition, we will explore how we can use automation rules to set
    up incoming webhooks that can listen for requests from external systems to trigger
    a rule.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何通过自动化规则向外部系统发送请求，并如何处理从这些请求返回的数据。此外，我们还将探讨如何使用自动化规则设置传入的 Webhooks，以便监听来自外部系统的请求并触发规则。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to send requests to external systems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向外部系统发送请求
- en: Working with data returned from requests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理从请求中返回的数据
- en: How to receive requests using incoming webhooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用传入 Webhooks 接收请求
- en: Working with data in incoming webhooks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理传入 Webhooks 中的数据
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The requirements for this chapter are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求如下：
- en: '**Jira Cloud environment**: If you don''t already have access to Jira, you
    can create a free Jira Cloud account at [https://www.atlassian.com/software/jira/free](https://www.atlassian.com/software/jira/free)
    and ensure that you have both Jira Software and Jira Service Management selected.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jira Cloud 环境**：如果你还没有访问 Jira 的权限，可以在[https://www.atlassian.com/software/jira/free](https://www.atlassian.com/software/jira/free)创建一个免费的
    Jira Cloud 账户，并确保选择了 Jira Software 和 Jira Service Management。'
- en: '**Jira Server environment**: If you are using Jira Server (available from [https://www.atlassian.com/software/jira/download](https://www.atlassian.com/software/jira/download)),
    ensure you have licenses for both Jira Software and Jira Service Management. In
    addition, you will also need to ensure that you install the *Automation for Jira*
    app available from the Atlassian Marketplace.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jira Server 环境**：如果你使用 Jira Server（可以从[https://www.atlassian.com/software/jira/download](https://www.atlassian.com/software/jira/download)下载），确保你拥有
    Jira Software 和 Jira Service Management 的许可证。此外，你还需要确保安装来自 Atlassian Marketplace
    的*Automation for Jira*应用。'
- en: '**Confluence Cloud environment**: If you don''t already have access to Confluence,
    you can use the application switcher menu in your Jira Cloud instance to set up
    a Confluence site in your cloud account. If you don''t have a Jira Cloud account,
    you can set up a free Confluence Cloud account at [https://www.atlassian.com/software/confluence/free](https://www.atlassian.com/software/confluence/free).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Confluence Cloud 环境**：如果你还没有访问 Confluence 的权限，可以通过 Jira Cloud 实例中的应用切换菜单在你的云账户中设置
    Confluence 网站。如果你没有 Jira Cloud 账户，可以在[https://www.atlassian.com/software/confluence/free](https://www.atlassian.com/software/confluence/free)设置一个免费的
    Confluence Cloud 账户。'
- en: '**Confluence Server environment**: If you are using Jira Server, you can either
    download and install Confluence Server from [https://www.atlassian.com/software/confluence/download](https://www.atlassian.com/software/confluence/download)
    or you can create and use a Confluence Cloud account.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Confluence Server 环境**：如果你使用 Jira Server，可以从[https://www.atlassian.com/software/confluence/download](https://www.atlassian.com/software/confluence/download)下载并安装
    Confluence Server，或者你可以创建并使用 Confluence Cloud 账户。'
- en: In both instances, you will need to have at least **Project Administrator**
    access to a Service Management project and a Scrum Software project to be able
    to follow the examples in this chapter. For the examples in this chapter, we have
    used the *IT Service Management project template* to create the Service Management
    project and the *Scrum Software project template* to create the Software project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个实例中，你需要至少拥有**项目管理员**权限，才能按照本章的示例进行操作，权限要求分别是Service Management项目和Scrum Software项目。我们在本章示例中使用了*IT服务管理项目模板*来创建Service
    Management项目，并使用*Scrum软件项目模板*来创建软件项目。
- en: You can download the latest code samples for this chapter from this book's official
    GitHub repository at [https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira](https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira).
    The Code in Action videos for this chapter are available at [https://bit.ly/2LJAJvN](https://bit.ly/2LJAJvN).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从本书的官方GitHub仓库下载本章的最新代码示例，地址为[https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira](https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira)。本章的《代码实战》视频可以在[https://bit.ly/2LJAJvN](https://bit.ly/2LJAJvN)找到。
- en: How to send requests to external systems
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何向外部系统发送请求
- en: The ability to send requests to external systems from your automation rules
    opens up a whole new realm of extremely powerful possibilities. This functionality
    can be used to send notifications, or issue data or any custom data to any application
    or system that accepts web requests over HTTP or HTTPS. For example, you could
    use this functionality to kick off a build process in a build tool such as Bamboo
    or Jenkins, or to initiate a password change in a centralized user directory system
    if it supports this.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从自动化规则中向外部系统发送请求，打开了一个全新的极其强大的可能性领域。此功能可以用来发送通知，或将数据或任何自定义数据发送到任何接受通过HTTP或HTTPS进行网络请求的应用程序或系统。例如，你可以使用此功能触发在构建工具（如Bamboo或Jenkins）中的构建过程，或在支持此功能的集中式用户目录系统中发起密码更改。
- en: In this section, we will look at the **Send web request** component and how
    to use it in automation rules to send requests to external systems. We'll begin
    by taking a look at the various configuration options available in the action.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解**发送网络请求**组件，并如何在自动化规则中使用它来向外部系统发送请求。我们将从查看操作中可用的各种配置选项开始。
- en: 'In the following screenshot, we can see the configuration options for the **Send
    web request** action:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下方的截图中，我们可以看到**发送网络请求**操作的配置选项：
- en: '![Figure 5.1 – Configuring the Send web request action'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 配置发送网络请求操作'
- en: '](img/B16551_Figure_5.1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_5.1.jpg)'
- en: Figure 5.1 – Configuring the Send web request action
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 配置发送网络请求操作
- en: 'Let''s take a look at each field in the configuration screen and how we can
    make use of it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看配置屏幕中的每个字段，并了解我们如何使用它：
- en: '`urlEncode` to ensure the smart value is properly encoded. For example, you
    should insert the issue key in the field as `{{issue.key.urlEncode}}`.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`urlEncode`确保智能值正确编码。例如，你应该在字段中插入`{{issue.key.urlEncode}}`。
- en: The **Headers** field is where you add any HTTP request headers required by
    the external system you're going to connect to, such as an **Authorization** header,
    which allows you to submit credentials or authorization tokens to the remote system,
    or the **Content-Type** header, which informs the remote system of the nature
    of the data you will be sending. We'll be making use of both of these headers
    in our example when we publish release notes to Confluence.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Headers**字段是你添加外部系统所需的任何HTTP请求头的地方，例如**Authorization**头，允许你向远程系统提交凭证或授权令牌，或**Content-Type**头，它告知远程系统你将要发送的数据的性质。在我们的示例中，我们将在发布版本说明到Confluence时使用这两个头。'
- en: Tip
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: Header names are generally case-insensitive. However, you should always ensure
    that you use the case defined in the official specifications to avoid any unexpected
    results. Wikipedia maintains a handy list of the standard request headers, complete
    with examples of accepted input for each header, at [https://en.wikipedia.org/wiki/List_of_HTTP_header_fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields).
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请求头名称通常不区分大小写。然而，你应始终确保使用官方规范中定义的大小写，以避免任何意外结果。维基百科维护了一份标准请求头的便捷列表，包含每个头部的示例接受输入，网址为[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)。
- en: You can add as many HTTP request headers as you need by clicking on the **Add**
    link below the **Name** field. If you need to remove a header, you can do so by
    using the trash can icon to the right of the **Value** field.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过点击 **名称** 字段下方的 **添加** 链接，添加尽可能多的 HTTP 请求头。如果你需要删除一个头部，可以通过使用 **值** 字段右侧的垃圾桶图标来删除。
- en: 'The **HTTP method** field allows you to select the correct method required
    by the external resource to perform the selected operation. The **Send web request**
    action supports the following standard HTTP methods:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**HTTP 方法** 字段允许你选择外部资源执行所选操作所需的正确方法。**发送网络请求** 操作支持以下标准 HTTP 方法：'
- en: '**GET**: Generally used to retrieve a resource from the external system.'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**获取**: 通常用于从外部系统中检索资源。'
- en: '**POST**: Generally used to create a resource in the external system using
    the data located in the request body.'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**发布**: 通常用于使用请求体中的数据在外部系统中创建资源。'
- en: '**PUT**: Generally used to replace a resource or create it if it does not exist,
    with the resource data located in the request body.'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**替换**: 通常用于替换资源，或者在资源不存在时创建它，资源数据位于请求体中。'
- en: '**PATCH**: Generally used to update a resource, with the updated data located
    in the request body.'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**修补**: 通常用于更新资源，更新后的数据位于请求体中。'
- en: '**DELETE**: Generally used to delete a resource from the external system.'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**删除**: 通常用于从外部系统中删除资源。'
- en: '`Get issue` at the following link: [https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issues/#api-rest-api-3-issue-issueidorkey-get](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issues/#api-rest-api-3-issue-issueidorkey-get).'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下链接获取问题：[https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issues/#api-rest-api-3-issue-issueidorkey-get](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issues/#api-rest-api-3-issue-issueidorkey-get)。
- en: '**Custom data**: Selecting this option will cause the **Custom data** field
    (6) to be shown. This option is usually needed when using the **POST**, **PUT**,
    or **PATCH** methods and the external system is not expecting data in the Jira
    issue format.'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**自定义数据**: 选择此选项将显示 **自定义数据** 字段（6）。通常在使用 **发布**、**替换** 或 **修补** 方法时，如果外部系统不期望
    Jira 问题格式的数据，就需要此选项。'
- en: The `{{webhookResponse}}` smart value field. We will explore this in more detail
    in the next section, *Working with data returned from requests*.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{{webhookResponse}}` 智能值字段。我们将在下一节中详细探讨这一点，*处理来自请求的返回数据*。'
- en: '`{{issue.description.abbreviate(255).jsonEncode}}` to ensure that the content
    of the description field is properly encoded.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{{issue.description.abbreviate(255).jsonEncode}}` 以确保描述字段的内容得到正确编码。'
- en: Tip
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: Always make sure when sending custom data that you use the **Headers** field
    to specify the correct content type of your data to the external system with the
    *Content-Type* header name. For example, if you're sending JSON data, set *Content-Type*
    to *application/json*, or to *application/xml* for XML data.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 始终确保在发送自定义数据时，使用 **Headers** 字段指定正确的内容类型，并通过 *Content-Type* 头名称告知外部系统。例如，如果你发送的是
    JSON 数据，将 *Content-Type* 设置为 *application/json*，或者对于 XML 数据，设置为 *application/xml*。
- en: Once you've configured your web request with the correct URL, headers, method,
    and optional data, you should always test that the request generated, and response
    received, are what you're expecting.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你已经配置了正确的 URL、头部、方法和可选数据，你应该始终测试生成的请求和接收到的响应是否符合预期。
- en: You can do this by expanding the **Validate your webhook configuration** disclosure
    and clicking the **Validate** link. Supplying an optional issue key will ensure
    that any smart values are substituted during the validation process.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过展开 **验证你的 Webhook 配置** 并点击 **验证** 链接来完成此操作。提供一个可选的问题密钥将确保在验证过程中替换任何智能值。
- en: 'When you click the **Validate** link, a request with your configured options
    and data will be generated and sent to the external system and the response received
    will be captured and presented back to you, similar to the following screenshot:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你点击 **验证** 链接时，将会生成一个包含你配置的选项和数据的请求，并发送到外部系统，接收到的响应会被捕获并呈现给你，类似于以下截图：
- en: '![Figure 5.2 – Validating a web request configuration'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2 – 验证网络请求配置'
- en: '](img/B16551_Figure_5.2.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_5.2.jpg)'
- en: Figure 5.2 – Validating a web request configuration
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 验证网络请求配置
- en: As you can see, validating the request will return the response received from
    the external system, as well as the request that was generated and sent to the
    external system. Expanding the **Payload** disclosures will reveal the actual
    data received and sent by the web request, allowing you to ensure that the data
    in both directions is what you expected to see.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，验证请求将返回从外部系统接收到的响应，以及生成并发送到外部系统的请求。展开**负载**（Payload）部分将显示通过 Web 请求接收和发送的实际数据，让你确保双向数据符合预期。
- en: Now that we've learned about the various configuration options for sending a
    web request, let's look at using these in an automation rule.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了发送 Web 请求的各种配置选项，让我们看看如何在自动化规则中使用这些选项。
- en: Creating a rule to publish release notes to Confluence
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个规则，将发布说明发布到 Confluence
- en: In [*Chapter 4*](B16551_04_Final_ASB_ePub.xhtml#_idTextAnchor080), *Sending
    Automated Notifications*, we showed you how to create a rule to send an email
    notification to various stakeholders when a software version is released in Jira.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 4 章*](B16551_04_Final_ASB_ePub.xhtml#_idTextAnchor080)《发送自动化通知》中，我们向你展示了如何创建规则，在
    Jira 发布软件版本时向各个相关人员发送电子邮件通知。
- en: We are going to revisit that rule in this example. However, instead of sending
    an email notification when a version is released, we will instead publish a page
    to Confluence using the **Send web request** action.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本示例中重新审视该规则。然而，我们将不再在发布版本时发送电子邮件通知，而是通过**发送 Web 请求**操作将页面发布到 Confluence。
- en: For this example, we have created a new Confluence space and a Releases page.
    Individual release notes pages will be created as children of the Releases page.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个新的 Confluence 空间和一个发布页面。各个发布说明页面将作为“发布”页面的子页面创建。
- en: To make things easier, we'll create a **Release Notes Template** page in Confluence,
    complete with all the relevant smart values populated. Once we have our template,
    we need to copy the page using its storage format so we can include it in the
    **Send web request** body in our automation rule.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，我们将在 Confluence 中创建一个**发布说明模板**页面，页面中填充了所有相关的智能值。我们有了模板后，需要复制该页面的存储格式，以便将其包含在自动化规则中的**发送
    Web 请求**主体中。
- en: 'In the following screenshot, we can see the completed template and the option
    to view the storage format of the page:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们可以看到已完成的模板，并且可以查看页面的存储格式：
- en: '![Figure 5.3 – Getting the Release Notes Template page source'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3 – 获取发布说明模板页面源代码'
- en: '](img/B16551_Figure_5.3.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_5.3.jpg)'
- en: Figure 5.3 – Getting the Release Notes Template page source
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 获取发布说明模板页面源代码
- en: 'Copy all the code in the storage format view into a text editor, and then we''ll
    modify the `{{#lookupIssues}}` section as follows to ensure that the smart value
    substitutions work as expected:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将存储格式视图中的所有代码复制到文本编辑器中，然后我们将按如下方式修改`{{#lookupIssues}}`部分，以确保智能值替换按预期工作：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we will escape all the double quote characters in the code by prepending
    a backslash to them and then remove all the new lines so that the entire code
    is on a single line.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过在代码中的双引号前添加反斜杠来转义所有双引号字符，并删除所有换行符，这样整个代码就会在一行内。
- en: Tip
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We use the storage format when working with Confluence as this gives us access
    to the underlying HTML formatting of the page, including the XML used to define
    the various Confluence macros in the page, and allows us greater flexibility in
    making adjustments to the final content that will be displayed when the page is
    published.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与 Confluence 配合使用时，采用存储格式，这样我们可以访问页面的底层 HTML 格式，包括用于定义页面中各种 Confluence 宏的
    XML，并且能更灵活地调整发布页面时显示的最终内容。
- en: 'Finally, we need to ensure that you have a valid API token, which will be needed
    to authorize the web request later in the rule:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保你拥有一个有效的 API 令牌，该令牌将在规则中授权 Web 请求时使用：
- en: Navigate to [https://id.atlassian.com/manage-profile/security/api-tokens](https://id.atlassian.com/manage-profile/security/api-tokens)
    and click on **Create API token**.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://id.atlassian.com/manage-profile/security/api-tokens](https://id.atlassian.com/manage-profile/security/api-tokens)，点击**创建
    API 令牌**。
- en: Important note
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: You cannot use two-step authentication for the account that you use in an automation
    rule. Two-step verification is designed for human users who have access to a secondary
    device and is impossible to implement for an automated system.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不能在自动化规则中使用的账户启用双重身份验证。双重验证是为有访问辅助设备的人类用户设计的，无法在自动化系统中实现。
- en: Give your token a label, for example, `Automation Rules`, and click **Create**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给你的令牌起个标签，比如 `自动化规则`，然后点击 **创建**。
- en: Copy the token somewhere safe, as you will not be able to retrieve it once you
    close the pop-up window.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将令牌保存在安全的地方，因为关闭弹出窗口后你将无法检索它。
- en: We now need to encode our credentials for use in our automation rule. You can
    use an online tool such as the one at [https://www.base64encode.org](https://www.base64encode.org)
    to perform the encoding.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要对凭证进行编码，以便在自动化规则中使用。你可以使用像 [https://www.base64encode.org](https://www.base64encode.org)
    这样的在线工具进行编码。
- en: Enter your email address, followed immediately by a colon (:) and then your
    API token, click the **Encode** button, and then copy the resulting encoded value
    somewhere safe.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入你的电子邮件地址，紧跟其后输入冒号（:），然后输入你的 API 令牌，点击 **编码** 按钮，然后将生成的编码值保存在安全的地方。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: If you're using Confluence Server, you need only the username and password of
    a user who can create pages in the Confluence space. To encode the credentials,
    replace the email address in the preceding *step 4* with the username, and the
    API token with the user's password.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是 Confluence Server，你只需要一个可以在 Confluence 空间中创建页面的用户的用户名和密码。要对凭证进行编码，将前面的
    *第 4 步* 中的电子邮件地址替换为用户名，将 API 令牌替换为用户的密码。
- en: 'Now, let''s move on to building the automation rule:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始构建自动化规则：
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the **Project Settings** menu, and then click **Create
    rule**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Jira 软件项目中，导航到 **项目设置**，点击 **项目设置** 菜单中的 **自动化** 链接，然后点击 **创建规则**。
- en: Select the **Version released** trigger and click **Save**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **版本发布** 触发器，然后点击 **保存**。
- en: Next, select `fixVersion = "{{version.name}}"`
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择 `fixVersion = "{{version.name}}"`
- en: Then, select `https://<your_site>.atlassian.net/wiki/rest/api/content`
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择 `https://<your_site>.atlassian.net/wiki/rest/api/content`
- en: First `Content-Type`
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一步 `Content-Type`
- en: '`application/json`'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`application/json`'
- en: Second `Authorization`
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二步 `Authorization`
- en: '`Basic <your base64-encoded credentials>`'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Basic <你的 base64 编码凭证>`'
- en: '`POST`'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`POST`'
- en: '`Custom data`'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`自定义数据`'
- en: We need to retrieve the page ID of the Release Notes page as this will be the
    parent of our release pages. To do so, navigate to the Release Notes page in Confluence,
    and then click the `ancestors` item in the JSON.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要获取发布说明页面的页面 ID，因为它将作为我们发布页面的父页面。为此，导航到 Confluence 中的发布说明页面，然后点击 JSON 中的
    `ancestors` 项。
- en: You also need to ensure you use the correct Confluence space key. In our example,
    this is **MA**.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还需要确保使用正确的 Confluence 空间密钥。在我们的示例中，这是 **MA**。
- en: '[PRE1]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the JSON structure looks like the preceding code, copy the JSON into the
    **Custom data** field, after which your rule should look similar to the following
    screenshot:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 JSON 结构与上面的代码类似，将 JSON 复制到 **自定义数据** 字段中，之后你的规则应该类似以下截图：
- en: '![Figure 5.4 – Configuring the Send web request'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.4 – 配置发送 Web 请求'
- en: '](img/B16551_Figure_5.4.jpg)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_5.4.jpg)'
- en: Figure 5.4 – Configuring the Send web request
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.4 – 配置发送 Web 请求
- en: Finally, click `Publish release notes to Confluence`, and click **Turn it on**
    to save and enable the rule.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击 `发布发布说明到 Confluence`，然后点击 **开启** 以保存并启用该规则。
- en: 'When you release a version in your Jira Software project now, you should have
    a published page in Confluence under **Release Notes** that looks similar to the
    following screenshot:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你在 Jira 软件项目中发布版本时，你应该在 Confluence 中的 **发布说明** 下有一个类似以下截图的已发布页面：
- en: '![Figure 5.5 – The release notes published by the automation rule'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – 自动化规则发布的发布说明'
- en: '](img/B16551_Figure_5.5.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_5.5.jpg)'
- en: Figure 5.5 – The release notes published by the automation rule
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 自动化规则发布的发布说明
- en: We have now learned how to send a web request to an external system using automation
    rules. In the next section, we'll expand on this and see how we can incorporate
    the data returned from the external system in subsequent rule components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学习了如何使用自动化规则向外部系统发送 Web 请求。在下一节中，我们将扩展这一点，看看如何将从外部系统返回的数据纳入后续规则组件中。
- en: Working with data returned from requests
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用请求返回的数据
- en: Many systems you will integrate with not only accept data you send, but also
    respond with additional data depending on the request. With automation rules,
    we are able to retrieve the response from a request and utilize this data in subsequent
    conditions and actions in our rules. This ability gives our rules even greater
    flexibility and power as we can now make decisions and perform actions based on
    the specific content returned from the external system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统在集成时不仅会接收你发送的数据，还会根据请求返回额外的数据。通过自动化规则，我们能够获取请求的响应，并在后续的条件和操作中利用这些数据。这个功能让我们的规则更加灵活和强大，因为我们现在可以根据外部系统返回的具体内容来做决策和执行操作。
- en: When configuring the `{{webhookResponse}}`, with the response from the external
    system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置`{{webhookResponse}}`时，使用来自外部系统的响应。
- en: 'The `{{webhookResponse}}` smart value contains a number of fields that you
    can access in your subsequent rule components, and these are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{webhookResponse}}`智能值包含许多字段，你可以在后续的规则组件中访问这些字段，具体如下：'
- en: '`200` or `201` for successful requests, or in the range `300` to `599` for
    redirection and errors. You can find more about HTTP response codes at [https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes).'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功请求返回`200`或`201`，重定向和错误则在`300`到`599`范围内。你可以在[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)查找更多关于HTTP响应代码的信息。
- en: '`{{webhookResponse.headers.Content-Type}}` will retrieve the **Content-Type**
    header returned by the external system.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{webhookResponse.headers.Content-Type}}`将获取外部系统返回的**Content-Type**头信息。'
- en: '**{{webhookResponse.body}}**: The body field will contain the body of the response
    from the external system. If the external system response is a JSON object, you
    can access any of the fields using **dot notation**.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**{{webhookResponse.body}}**：body字段将包含外部系统返回的响应主体。如果外部系统的响应是JSON对象，你可以使用**点符号**访问任何字段。'
- en: '**{{webhookResponses}}**: If you have multiple **Send web request** actions
    in your rule, each response, if present, will be added to this list and you can
    use the smart value list functions that we covered in [*Chapter 3*](B16551_03_Final_ASB_ePub.xhtml#_idTextAnchor065),
    *Enhancing Rules with Smart Values*, to work with the list items.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**{{webhookResponses}}**：如果你的规则中有多个**发送Web请求**动作，每个响应（如果有）都会被添加到这个列表中，你可以使用我们在[*第3章*](B16551_03_Final_ASB_ePub.xhtml#_idTextAnchor065)《使用智能值增强规则》中讲解的智能值列表函数来处理列表项。'
- en: Let's now take a look at how we can incorporate the response from a web request
    into an automation rule.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下如何将来自Web请求的响应纳入自动化规则。
- en: Creating a rule to add incident managers as watchers
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个规则，将事件管理者添加为观察者
- en: In this example, we are going to add the members of the VIP group that we created
    in [*Chapter 1*](B16551_01_Final_ASB_ePub.xhtml#_idTextAnchor017), *Key Concepts
    of Automation*, as watchers to issues whose priority is set to **Highest** when
    the issue is either created or updated.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将在[*第1章*](B16551_01_Final_ASB_ePub.xhtml#_idTextAnchor017)，《自动化的关键概念》中，添加我们在VIP组中创建的成员作为观察者，给那些优先级设置为**最高**的、无论是已创建还是已更新的问题。
- en: As Jira itself has a powerful REST API, we can treat it as an external system
    in our automation rules and retrieve data for use in our rules that we wouldn't
    ordinarily have access to.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Jira本身具有强大的REST API，我们可以将其视为自动化规则中的外部系统，获取通常无法访问的数据，并将其用于我们的规则中。
- en: 'Let''s take a look at the rule:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下规则：
- en: In your Jira Service Management project, navigate to **Project settings**, click
    on the **Automation** link in the **Project Settings** menu, and then click **Create
    rule**.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Jira服务管理项目中，导航至**项目设置**，点击**项目设置**菜单中的**自动化**链接，然后点击**创建规则**。
- en: Select the `Issue Created` and `Issue Updated`. Then click **Save**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`问题创建`和`问题更新`，然后点击**保存**。
- en: Now select `Issue Type`
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择`问题类型`
- en: '`equals`'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`equals`'
- en: '`Incident`'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`事件`'
- en: Then select `Priority`
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后选择`优先级`
- en: '`equals`'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`equals`'
- en: '`Highest`'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`最高`'
- en: Next, select `https://<your_site.domain.com>/rest/api/3/group/member?groupname=VIP`
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择`https://<your_site.domain.com>/rest/api/3/group/member?groupname=VIP`
- en: '`Authorization`'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`授权`'
- en: '`Basic <your base64-encoded credentials>`'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`基本 <your base64-encoded credentials>`'
- en: '`GET`'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GET`'
- en: '`Empty`'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`空`'
- en: '**Wait for response**: Select the checkbox'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**等待响应**：选择复选框'
- en: 'The response from this API call returns a list of users in the **values** array
    that belong to the **groupname** we specified in the query parameter, similar
    to the following:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个API调用的响应会返回一个包含属于我们在查询参数中指定的**groupname**的用户列表，这个列表位于**values**数组中，类似于以下内容：
- en: '[PRE2]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can find more information about this API call at [https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-groups/#api-rest-api-3-group-member-get](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-groups/#api-rest-api-3-group-member-get).
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在 [https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-groups/#api-rest-api-3-group-member-get](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-groups/#api-rest-api-3-group-member-get)
    找到有关此 API 调用的更多信息。
- en: To complete the rule, select `{{webhookResponse.body.values.accountId}}`
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成规则，选择`{{webhookResponse.body.values.accountId}}`
- en: 'Your rule should look similar to the following screenshot:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的规则应类似于以下截图：
- en: '![Figure 5.6 – Using webhookResponse data in a rule'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.6 – 在规则中使用 webhookResponse 数据'
- en: '](img/B16551_Figure_5.6.jpg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_5.6.jpg)'
- en: Figure 5.6 – Using webhookResponse data in a rule
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.6 – 在规则中使用 webhookResponse 数据
- en: Finally, click `Add` `watchers` `to` `Highest` `priority` `incidents`, and then
    click **Turn it on** to save and enable the rule.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击`Add` `watchers` `to` `Highest` `priority` `incidents`，然后点击**Turn it on**以保存并启用规则。
- en: In this section, we have learned how to expose the response returned from an
    external system request and how we can use this data to create much more powerful
    automation rules.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何暴露外部系统请求返回的响应，并且我们可以如何利用这些数据创建更强大的自动化规则。
- en: In the next section, we will learn how we can listen for web requests from external
    systems and how these can be used to trigger our automation rules.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将学习如何监听来自外部系统的 web 请求，以及如何利用这些请求来触发我们的自动化规则。
- en: How to receive requests using incoming webhooks
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何通过传入的 webhook 接收请求
- en: In the previous two sections, we learned how to use automation rules to send
    notifications and data to external systems and how to work with the response data
    received from an external system.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两节中，我们学习了如何使用自动化规则向外部系统发送通知和数据，并且如何处理从外部系统接收到的响应数据。
- en: In addition to this, automation rules also allow us to receive notifications
    and data from external systems using the **Incoming webhook** trigger. This component
    will create a unique URL for each trigger that can then be called by an external
    system and will trigger the automation rule to run. These incoming webhooks can
    receive a list of issues on which to act as well as custom data in the form of
    JSON objects, which can be used in later rule components to make decisions using
    conditions or to create or update issues using the custom data provided.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，自动化规则还允许我们使用**Incoming webhook**触发器接收来自外部系统的通知和数据。该组件将为每个触发器创建一个唯一的 URL，外部系统可以调用该
    URL，并触发自动化规则的运行。这些传入的 webhook 可以接收待处理的 issue 列表以及以 JSON 对象形式提供的自定义数据，后者可用于后续规则组件中，通过条件作出决策，或使用提供的自定义数据创建或更新
    issues。
- en: 'The following screenshot shows the configuration options for the **Incoming
    webhook** trigger:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了**Incoming webhook**触发器的配置选项：
- en: '![Figure 5.7 – Configuring the Incoming webhook trigger'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – 配置传入的 webhook 触发器'
- en: '](img/B16551_Figure_5.7.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_5.7.jpg)'
- en: Figure 5.7 – Configuring the Incoming webhook trigger
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 配置传入的 webhook 触发器
- en: 'Let''s now take a look at how each of the configuration options works:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下每个配置选项的工作原理：
- en: The **Webhook URL** is the unique URL that will cause the rule to run when an
    external system sends an HTTP **POST** request to it.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Webhook URL** 是唯一的 URL，当外部系统向它发送 HTTP **POST** 请求时，将触发规则的运行。'
- en: This URL is generated automatically and requires no authentication to use. If
    the URL is compromised, you can use the **Regenerate** link to generate a new
    URL for the webhook and update any external systems that use it.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此 URL 是自动生成的，使用时无需认证。如果 URL 被泄露，您可以使用**Regenerate**链接生成一个新的 URL，并更新任何使用该 URL
    的外部系统。
- en: Important note
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Incoming webhooks only support the HTTP **POST** method. They will not respond
    to HTTP **GET** or any other method. In addition, you need to ensure that the
    external system that sends a request to the webhook sets the *Content-Type* request
    header to *application/json*.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 传入的 webhook 仅支持 HTTP **POST** 方法。它们不会响应 HTTP **GET** 或任何其他方法。此外，您需要确保发送请求到 webhook
    的外部系统将 *Content-Type* 请求头设置为 *application/json*。
- en: 'The `issue`, for example, `https://automation.atlassian.com/pro/hooks/<unique-webhook-token>?issue=MAPP-1`.
    To specify multiple issues, you should include either the issue key or the issue
    ID in an `"issues"` list in the JSON-formatted request body as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`issue`，例如，`https://automation.atlassian.com/pro/hooks/<unique-webhook-token>?issue=MAPP-1`。要指定多个
    issue，应在 JSON 格式的请求体中包含一个名为 `"issues"` 的列表，并在该列表中包含 issue 键或 issue ID，如下所示：'
- en: '[PRE3]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Issues provided by running the following JQL search** will display the **JQL**
    field (3), which allows you to input a JQL query to search for the relevant issues.'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**通过运行以下JQL查询提供的问题**将显示**JQL**字段（3），允许你输入JQL查询来搜索相关问题。'
- en: '**No issues from the webhook** means the webhook is not expecting to operate
    on any existing issue. You could use this option if you needed to create issues
    as a result of the webhook being called, for example.'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Webhook没有问题**意味着Webhook不期望操作任何现有问题。如果需要在Webhook调用时创建问题，可以使用此选项。'
- en: As mentioned in *step 2* above, the **JQL** field is displayed when you use
    the **Issues provided by running the following JQL search** option and allows
    you to define a JQL query to return the issues that will be updated as a result
    of calling the webhook. You can use smart values and functions in the query. However,
    doing so means you cannot validate the query using the **Validate query** link.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如上所述的*第2步*，当你使用**通过运行以下JQL查询提供的问题**选项时，会显示**JQL**字段，允许你定义一个JQL查询，以返回在调用Webhook时将被更新的问题。你可以在查询中使用智能值和函数。然而，使用这种方法时，你无法通过**验证查询**链接验证查询。
- en: Let's now look at how we can use an incoming webhook to trigger an automation
    rule that we've seen in order to configure incoming webhooks.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看如何使用传入Webhook触发我们所看到的自动化规则，以便配置传入Webhook。
- en: Creating a rule to resolve open issues using an automation webhook
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自动化Webhook创建解决开放问题的规则
- en: Many software projects have some form of automated build and deploy tool that
    automates the building, testing, and deployment of code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件项目都有某种形式的自动化构建和部署工具，用于自动化构建、测试和部署代码。
- en: In this example, we are going to assume that the developers will move their
    issues to the *Waiting for deploy* status once they have completed development.
    When our automated deployment starts, we want to automatically resolve all issues
    in the currently open sprint that are awaiting deployment by having our build
    and deploy tool an automation rule in Jira.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设开发人员在完成开发后，会将问题移动到*等待部署*状态。当我们的自动化部署开始时，我们希望通过让我们的构建和部署工具在Jira中创建一个自动化规则，自动解决当前开放冲刺中所有等待部署的问题。
- en: In our example Jira Software project, we are using the *Software Simplified*
    workflow, so we will edit the workflow from the **Project Settings** screen and
    add a new *Waiting for deploy* status and allow all statuses to transition to
    it. In addition, add the *Resolve issue* screen to the *Done* transition to allow
    comments to be added when resolving issues.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Jira软件项目中，我们使用的是*简化软件*工作流程，因此我们将从**项目设置**屏幕编辑工作流程，添加一个新的*等待部署*状态，并允许所有状态过渡到此状态。此外，添加*解决问题*屏幕到*完成*过渡，以便在解决问题时允许添加评论。
- en: 'Now that we''ve adjusted our workflow to take this new status into account,
    let''s create the automation rule:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经调整了工作流程以考虑到这个新状态，接下来让我们创建自动化规则：
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the project settings menu, and then click **Create rule**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Jira软件项目中，导航到**项目设置**，点击项目设置菜单中的**自动化**链接，然后点击**创建规则**。
- en: Select the `Issues provided by running the following JQL search`
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`通过运行以下JQL查询提供的问题`
- en: '`sprint in openSprints() AND status = "Waiting for deploy"`'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sprint in openSprints() AND status = "Waiting for deploy"`'
- en: Now, select `Done` in the **Destination status** field.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**目标状态**字段中选择`完成`。
- en: In addition, we want to add a comment to these issues to the effect that the
    issue was automatically resolved by the build system.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还希望向这些问题添加评论，表明问题是由构建系统自动解决的。
- en: 'To do this, expand the **More options** disclosure, add the following JSON
    in the **Additional fields** editor, and then click **Save**:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为此，展开**更多选项**面板，在**附加字段**编辑器中添加以下JSON，然后点击**保存**：
- en: '[PRE4]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Your rule should now look similar to the following screenshot:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的规则现在应该类似于下图所示：
- en: '![Figure 5.8 – Configuring a rule with an incoming webhook'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.8 – 配置带有传入Webhook的规则'
- en: '](img/B16551_Figure_5.8.jpg)'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_5.8.jpg)'
- en: Figure 5.8 – Configuring a rule with an incoming webhook
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.8 – 配置带有传入Webhook的规则
- en: Finally, name your rule `Release` `issues` `waiting` `for` `deploy` and click
    **Turn it on** to save and enable the rule.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将你的规则命名为`Release` `issues` `waiting` `for` `deploy`，并点击**开启**以保存并启用规则。
- en: In this section, we have learned how to create and use incoming webhooks to
    trigger automation rules. In the next section, we'll learn how we can also make
    use of data supplied by the external system to further enhance our automation
    rules.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们学习了如何创建和使用传入的webhook来触发自动化规则。在下一部分中，我们将学习如何利用外部系统提供的数据进一步增强我们的自动化规则。
- en: Working with data in incoming webhooks
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在传入webhook中处理数据
- en: Having the ability to trigger actions in Jira from external systems enables
    you to create really powerful integrations with automation rules.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 能够从外部系统触发Jira中的操作使您能够创建非常强大的自动化规则集成。
- en: As we saw in the previous section, you can act on specific issues by including
    them in the incoming request body. However, with the `{{webhookData}}` smart value,
    where you can access any of the JSON object fields using dot notation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一部分看到的，您可以通过将特定问题包括在传入请求体中来对其进行操作。但是，借助`{{webhookData}}`智能值，您可以使用点表示法访问任何JSON对象字段。
- en: This powerful functionality will enable you to integrate with any external system
    that can send web requests and allow you to extract valuable data for use in your
    issues. For example, you could potentially set up your monitoring tools to send
    notifications to an automation rule when an incident occurs and use the data it
    provides to create a new incident and set affected components based on which asset
    caused the incident.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个强大的功能将使您能够与任何可以发送web请求的外部系统进行集成，并提取有价值的数据以用于您的问题。例如，您可以设置监控工具，在事件发生时向自动化规则发送通知，并使用它提供的数据创建一个新事件，并根据哪个资产导致事件来设置受影响的组件。
- en: Let's now take a look at how we can configure an automation rule that makes
    use of custom data from an incoming web request.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何配置一个自动化规则，利用传入的web请求中的自定义数据。
- en: Creating a rule to raise new issues using an automation webhook
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个规则，通过自动化webhook来提升新的问题
- en: Being able to collect information about your deployed software when something
    goes wrong is invaluable for many developers and many software applications allow
    users to submit feedback when an error occurs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，能够收集关于已部署软件的信息对许多开发者来说是非常宝贵的，许多软件应用程序允许用户在发生错误时提交反馈。
- en: In this example, we are going to create an automation rule using an incoming
    webhook to receive a bug report and automatically create a bug in our Jira project
    to track it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个自动化规则，使用传入的webhook接收一个错误报告，并自动在我们的Jira项目中创建一个错误来跟踪它。
- en: 'We are going to expect a JSON object with the following structure to process
    this incoming information:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将期望处理一个具有以下结构的JSON对象来处理这些传入的信息：
- en: '[PRE5]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you were including this in a product, you could probably add more relevant
    data, such as stack traces to the JSON structure to make the bug report more contextual.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将其包括在产品中，您可能还可以向JSON结构中添加更多相关数据，如堆栈跟踪，以使错误报告更具上下文。
- en: 'Let''s now take a look at how to build this automation rule:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何构建这个自动化规则：
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the **Project Settings** menu, and then click **Create
    rule**.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Jira软件项目中，导航到**项目设置**，点击**项目设置**菜单中的**自动化**链接，然后点击**创建规则**。
- en: Select `No issues from the webhook` as we're going to be using this rule to
    create an issue. Then click **Save**.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`No issues from the webhook`，因为我们将使用此规则来创建一个问题。然后点击**保存**。
- en: Next, select `Same project`
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择`Same project`
- en: '`Bug`'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Bug`'
- en: '`{{webhookData.summary}}`'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{{webhookData.summary}}`'
- en: '`{{webhookData.bugDescription}}`'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{{webhookData.bugDescription}}`'
- en: We also want to capture the software version that was deployed when this bug
    was submitted, and we'd like to add some labels to the issue to make it easier
    to find bugs raised from the in-product feedback collector.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望捕获在提交此错误时部署的软件版本，并希望向问题添加一些标签，以便更容易地找到通过产品内反馈收集器提出的错误。
- en: 'To do this, expand the **More options** disclosure and then add the following
    JSON to the **Additional fields** editor:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为此，展开**更多选项**，然后将以下JSON添加到**附加字段**编辑器：
- en: '[PRE6]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Your rule should now look similar to the following screenshot:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在您的规则应该类似于以下屏幕截图：
- en: '![Figure 5.9 – Consuming incoming webhook data'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.9 – 消费传入的webhook数据'
- en: '](img/B16551_Figure_5.9.jpg)'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_5.9.jpg)'
- en: Figure 5.9 – Consuming incoming webhook data
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.9 – 消费传入的webhook数据
- en: Click on `In-product` `bug` `collector`, and then click **Turn it on** to save
    and enable the rule.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`In-product` `bug` `collector`，然后点击**开启**以保存并启用该规则。
- en: You have now learned how to consume request data from an external system in
    an incoming webhook.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了如何在传入的Web钩子中获取外部系统的请求数据。
- en: The ability to consume incoming data from external systems and use it to make
    decisions and effect changes to issues using automation rules gives you some extremely
    powerful options in terms of automating your projects in Jira.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 能够消费来自外部系统的传入数据，并利用这些数据做出决策，使用自动化规则对问题进行更改，给你提供了在Jira中自动化项目的一些强大选项。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned how you can integrate to external systems
    using automation rules by sending web requests and how you can include custom
    data in these requests using smart values and smart value functions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学会了如何通过发送Web请求将外部系统集成到自动化规则中，并且了解了如何使用智能值和智能值函数将自定义数据包含在这些请求中。
- en: We have also learned how to ensure we can receive a response from a request
    to an external system and how we can extract the data for use in subsequent rule
    components.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了如何确保我们能够接收到来自外部系统请求的响应，并且如何提取数据以便在后续的规则组件中使用。
- en: Next, we learned to set up an incoming webhook using automation rules to listen
    for requests coming from external systems and how to optionally process data sent
    in the request body and use this in subsequent rule components.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了如何使用自动化规则设置传入的Web钩子，监听来自外部系统的请求，并且如何可选地处理请求体中发送的数据，并在后续的规则组件中使用这些数据。
- en: As we have seen in this chapter, the ability to integrate with external systems
    using automation rules opens a world of possibilities to your Jira projects. For
    example, you could start a software build or deployment from your build tool when
    you release a version or complete a sprint in Jira Software. In Service Management,
    you could integrate with your user directory service to automatically provision
    new accounts based on service requests or reset passwords automatically, if supported.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中所看到的，通过使用自动化规则与外部系统集成的能力为你的Jira项目开辟了无限可能。例如，当你在Jira Software中发布版本或完成冲刺时，你可以通过构建工具启动软件构建或部署。在Service
    Management中，你可以集成用户目录服务，根据服务请求自动创建新账户或自动重置密码（如果支持的话）。
- en: In the next chapter, we will look at how we can use the skills learned in this
    and previous chapters to help build automations in your Service Management instances.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨如何运用本章以及前几章中学到的技能，在Service Management实例中帮助构建自动化。
