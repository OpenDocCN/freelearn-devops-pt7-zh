- en: Jinja in Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja在Ansible中的应用。
- en: JINJA was created in 2008 by Armin Ronacher and aims to replace similar template
    engines with a more modern and structured solution. Jinja was designed for Python
    (the programming language that Ansible was created with) and, coupled with Ansible,
    to provide a framework that integrates seamlessly with YAML. Ansible's YAML implementation
    and programmatic playbook solution incorporates this robust Jinja template engine.
    Like many other template solutions (Django, Smarty, and so on), Jinja was designed
    to provide structural support for reusable text with context specific alterations
    (environments, hosts, and so on) and comprehensive functionality that developers
    have come to rely on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JINJA由Armin Ronacher于2008年创建，旨在用更现代、结构化的解决方案替代类似的模板引擎。Jinja是为Python（Ansible所用的编程语言）设计的，并且与Ansible结合，提供了一个能够与YAML无缝集成的框架。Ansible的YAML实现和程序化的playbook解决方案整合了这个强大的Jinja模板引擎。像许多其他模板解决方案（Django、Smarty等）一样，Jinja旨在为可重用的文本提供结构支持，并根据具体环境（如环境、主机等）进行特定的修改，以及为开发人员提供他们所依赖的全面功能。
- en: For those who have experience with Smarty or Django-styled tempting solutions,
    Jinja will indeed be familiar. The design of the Jinja template solution aims
    to provide support for designers, developers, and operators alike by providing
    the ability to add conditional logic, iterative behaviors, and logic oriented
    solutions while adhering to Python best practices. This solution is particularly
    useful for playbook developers because it provides a highly adaptive programmatic
    flexibility that can be leveraged by organizations using environments that are
    similar in nature but have slight differences. Suffice to say, the initial learning
    curve of Jinja is low and the usefulness of the markup and logic is high.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有Smarty或Django风格模板经验的人来说，Jinja将非常熟悉。Jinja模板解决方案的设计旨在为设计师、开发人员和运维人员提供支持，能够添加条件逻辑、迭代行为和面向逻辑的解决方案，同时遵循Python的最佳实践。这个解决方案对playbook开发人员尤其有用，因为它提供了高度适应性的编程灵活性，能够在环境相似但有细微差别的组织中发挥作用。可以说，Jinja的学习曲线较低，而标记和逻辑的实用性却很高。
- en: 'In this chapter, we will learn how Ansible integrates with Jinja and how Jinja
    can be leveraged to provide advanced functionality within Ansible playbook''s.
    We will discover how Jinja came about, see how it can be leveraged to create comprehensive
    playbook implementations, learn how its syntax cohabitates with Ansible''s YAML
    playbook syntax, and see how Jinja complements Ansible''s playbook implementation.
    By the end of this chapter, we will have covered the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习Ansible如何与Jinja集成，以及如何利用Jinja在Ansible的playbook中提供高级功能。我们将了解Jinja的起源，学习如何利用它创建全面的playbook实现，了解它的语法如何与Ansible的YAML
    playbook语法共同存在，并看到Jinja如何补充Ansible的playbook实现。到本章结束时，我们将涵盖以下内容：
- en: Introduction to Jinja.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja简介。
- en: How is Jinja2 used by Ansible?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja2是如何被Ansible使用的？
- en: Jinja programming constructs.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja编程结构。
- en: Applying Jinja to Ansible playbooks.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Jinja应用于Ansible的playbooks。
- en: How to create loops and iterators in Jinja2.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Jinja2中创建循环和迭代器。
- en: How to make and use Jinja2 template files.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和使用Jinja2模板文件。
- en: How to use data structures with Jinja2.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Jinja2中使用数据结构。
- en: Let's begin, shall we?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，好吗？
- en: Introducing Jinja
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Jinja。
- en: Jinja is a templating engine that was developed in 2008 by Armin Ronacher in
    an effort to provide Python developers with a framework that would supply comprehensive
    Python-like syntax that could be used within strings and data documents. The solution
    was designed with similar solutions such as Smarty and Django in mind. Jinja executes
    its template translations in a sandbox (isolated from the rest of the program
    execution) so as to prevent the template engine from interfering with the normal
    operational execution of the Python program.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja是一个模板引擎，由Armin Ronacher于2008年开发，旨在为Python开发人员提供一个框架，该框架可以在字符串和数据文档中使用具有全面Python风格的语法。这个解决方案是考虑到类似的解决方案（如Smarty和Django）设计的。Jinja在沙盒中执行模板转换（与程序的其余部分隔离），以防止模板引擎干扰Python程序的正常操作。
- en: Jinja2 represents the second major version of the Jinja Python library. Jinja
    is leveraged to generate string-based documents based on one or more predefined
    templates (also made of strings). As of the writing of this book, Jinja is in
    use by numerous open source solutions that are actively developed with Python.
    Some notable examples of solutions that use Jinja include Salt, Flask, and Ansible.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2 代表 Jinja Python 库的第二个主要版本。Jinja 被用来基于一个或多个预定义模板（也由字符串组成）生成基于字符串的文档。截至本书编写时，Jinja
    被许多活跃开发的 Python 开源解决方案使用。一些使用 Jinja 的著名解决方案包括 Salt、Flask 和 Ansible。
- en: When coupled with Ansible and YAML, Jinja adds significant amounts of power
    to the Ansible playbook architecture. Jinja in this context provides Ansible playbook
    developers with the ability to add programming constructs (including variables,
    conditional logic, loops, and more) to a playbook and structure it in such a way
    where it can be leveraged as a complete programming solution for automation. Before
    we get ahead of ourselves and start looking at all the neat stuff that Jinja can
    do, let's first understand how it actually works.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 Ansible 和 YAML 配合使用时，Jinja 为 Ansible playbook 架构增添了强大的功能。在这个背景下，Jinja 为 Ansible
    playbook 开发者提供了将编程构造（包括变量、条件逻辑、循环等）添加到 playbook 中的能力，并将其结构化，使其能够作为一个完整的自动化编程解决方案。在我们深入探讨
    Jinja 能做的所有有趣功能之前，先让我们了解一下它是如何工作的。
- en: Jinja is a software solution designed to combine templates with a data model
    to produce result documents. The templates contain special markup tags and logic
    that are parsed and logically combined during the execution of the template-parsing
    process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja 是一种软件解决方案，旨在将模板与数据模型结合以生成结果文档。模板包含特殊的标记标签和逻辑，这些标签在模板解析过程中被解析并在执行时进行逻辑组合。
- en: 'To better explain the concept of a template engine, the following Python code
    shows a basic example of string manipulation using Jinja:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释模板引擎的概念，以下 Python 代码展示了一个使用 Jinja 的字符串处理基本示例：
- en: 'Basic Jinja Python implementation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 Jinja Python 实现：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'From the example we just saw, we can observe that this simple Python script
    does the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们刚才看到的例子中，我们可以观察到这个简单的 Python 脚本完成了以下任务：
- en: Imports the Jinja template engine library.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 Jinja 模板引擎库。
- en: Defines a simple string template, `['Hello {{ place }] ']`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个简单的字符串模板，`['Hello {{ place }] ']`。
- en: Renders the template and substitutes the `{{ place }}` tag with the word `World`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染模板，并将 `{{ place }}` 标签替换为单词 `World`。
- en: 'If you are planning on implementing Jinja directly within Python, the Python
    Jinja module must be installed within Python first. This can be performed fairly
    easily, and the instructions on how to do this are readily available at the following
    URL:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在 Python 中直接实现 Jinja，首先必须在 Python 中安装 Jinja 模块。这可以相对容易地完成，关于如何操作的说明可以在以下网址找到：
- en: '[http://jinja.pocoo.org/docs/2.9/intro/#installation](http://jinja.pocoo.org/docs/2.9/intro/#installation)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://jinja.pocoo.org/docs/2.9/intro/#installation](http://jinja.pocoo.org/docs/2.9/intro/#installation)'
- en: The output of the previous example is `Hello World`. From this example, we can
    observe that the Jinja template tag `{{ ... }}` is translated during the rendering
    process, whereas the rest of the string-based document is left intact.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个例子的输出是 `Hello World`。从这个例子中，我们可以观察到 Jinja 模板标签 `{{ ... }}` 在渲染过程中被翻译，而其余的基于字符串的文档保持不变。
- en: Now that we have a pretty good idea of the basic concepts surrounding Jinja,
    let's take a look at a more realistic example of Jinja in action by looking at
    a simple Ansible playbook that uses Jinja.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Jinja 的基本概念有了相当清晰的了解，接下来我们将通过查看一个使用 Jinja 的简单 Ansible playbook 来了解 Jinja
    在实际中的应用。
- en: 'The content of the `playbook.yml` is illustrated as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`playbook.yml` 的内容如下所示：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`motdexample.j2`: This is a Jinja2-generated **motd** file also known as **message
    of the day**. The following content tags will be replaced by the variable data
    we defined in our playbook (`my_var` and `my_var2`, respectively):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`motdexample.j2`：这是一个由 Jinja2 生成的 **motd** 文件，也叫做 **今日消息**。以下内容标签将被我们在 playbook
    中定义的变量数据替换（分别为 `my_var` 和 `my_var2`）：'
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Can you guess what this example will do when executed using Ansible with the
    assistance of the Jinja2 templating engine? Ansible in conjunction with Jinja
    will copy the motd file to the target hosts *and* replace the `{{}}` styled variables
    at the same time with the contents of `my_var` and `my_var2`. Let''s take a look
    at the output of the motd file on the target host:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到这个例子在使用 Ansible 和 Jinja2 模板引擎执行时会做什么吗？Ansible 与 Jinja 配合将把 motd 文件复制到目标主机，并同时替换
    `{{}}` 样式的变量，替换成 `my_var` 和 `my_var2` 的内容。让我们来看看目标主机上 motd 文件的输出：
- en: '`/etc/motd content`: This is a Jinja2-generated motd file. The following content
    tags will be replaced by the variable data we defined in our playbook (`my_var`
    and `my_var2`, respectively):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/motd 内容`：这是一个由 Jinja2 生成的 motd 文件。以下内容标签将被我们在 playbook 中定义的变量数据替换（分别为
    `my_var` 和 `my_var2`）：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the context of an Ansible playbook, Jinja allows us to add the `{...}` style
    tags within our playbook (or within a templated file as we just saw), and Ansible
    will tell the Jinja library to translate the tags and generate a new document
    prior to execution. This means we can add common programming constructs either
    directly to our playbooks or to templated files and make our automation significantly
    more intelligent. While this example may not seem all that useful, the Jinja implementation
    overall provides a significant enhancement when coupled with Ansible and YAML.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible playbook 的上下文中，Jinja 允许我们在 playbook 中（或像我们刚才看到的模板文件中）添加 `{...}` 样式的标签，Ansible
    会指示 Jinja 库在执行前翻译这些标签并生成一个新文档。这意味着我们可以将常见的编程构造直接添加到 playbook 或模板文件中，使我们的自动化变得更加智能。虽然这个例子看起来可能不是很有用，但总体来说，Jinja
    的实现与 Ansible 和 YAML 配合使用时提供了显著的增强。
- en: Consider this implementation for when it is necessary to generate, say, Apache
    configuration files or MySQL queries. We could although arduously generate each
    config manually, *or* we could template the content of these and have Ansible
    iterate. In the coming sections, we will take a deep dive into Jinja programming
    constructs and learn how to leverage Jinja effectively.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在需要生成 Apache 配置文件或 MySQL 查询时的实现。我们当然可以费力地手动生成每个配置，*或者*我们可以将这些内容模板化，并让 Ansible
    进行迭代。在接下来的章节中，我们将深入探讨 Jinja 编程构造，并学习如何有效地利用 Jinja。
- en: Jinja2 Programming Constructs
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja2 编程构造
- en: Jinja2 was incorporated into the Ansible architecture back in 2012 when Ansible
    0.5 was released. The implementation of Ansible at the time incorporated the concept
    of Jinja2 filters and supported basic Jinja2 syntax. As ansible evolved, so did
    its developer support for Jinja. By coupling YAML and Jinja2, Ansible was soon
    able to provide a comprehensive scripting-oriented solution for Ansible playbook
    developers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2 在 Ansible 架构中被引入是在 2012 年，当时 Ansible 0.5 发布。那时 Ansible 的实现已经包含了 Jinja2
    过滤器的概念，并支持基本的 Jinja2 语法。随着 Ansible 的发展，它对 Jinja 的开发支持也在不断增强。通过结合 YAML 和 Jinja2，Ansible
    很快能够为 playbook 开发者提供一个全面的脚本解决方案。
- en: 'By the time Ansible 1.0 was released, the Ansible playbook concept (including
    Jinja and YAML) had evolved enough to support a wide array of syntax implementations.
    As a result of the integration of YAML, Jinja and Ansible''s popularity skyrocketed.
    After the release of Ansible 1.0, playbooks could be authored to incorporate the
    following syntaxes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到 Ansible 1.0 发布时，Ansible playbook 的概念（包括 Jinja 和 YAML）已经发展到足以支持各种语法实现。由于集成了
    YAML，Jinja 和 Ansible 的流行度急剧上升。Ansible 1.0 发布后，playbook 可以编写以包含以下语法：
- en: 'Jinja tag syntax:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja 标签语法：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each of these tags serves a unique role within the Jinja universe, and it is
    important to understand each completely (so as not to mix them up). In the coming
    sections, we will learn about these special tags and learn how they can be leveraged
    to enhance our playbook logic. By the time we're done, we should have a solid
    understanding of how to wield Jinja implementations of expressions, control statements,
    and comments.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签在 Jinja 世界中各自承担着独特的角色，理解每个标签的作用非常重要（以免混淆）。在接下来的章节中，我们将学习这些特殊标签，并了解如何利用它们增强我们的
    playbook 逻辑。到我们完成时，应该能够深入理解如何使用 Jinja 表达式、控制语句和注释的实现。
- en: Expressions, filters, and variables
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式、过滤器和变量
- en: 'Jinja filters (also known as **variable expressions**) are very similar in
    nature to programming variables, although with a key difference. Filter expressions
    represent a data value item *or* the computed value of a data point in conjunction
    with another data source. Expressions are evaluated at runtime and can provide
    a level of flexibility for playbook and template developers. The syntax of Jinja2''s
    expression format is shown as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja 过滤器（也称为**变量表达式**）在性质上非常类似于编程中的变量，尽管有一个关键的不同点。过滤器表达式表示一个数据值项*或*与其他数据源结合的计算数据点的值。表达式在运行时被评估，并能为剧本和模板开发人员提供灵活性。Jinja2
    表达式格式的语法如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The source data for the `var` section can be from multiple different places.
    Within an Ansible playbook, there are presently four unique methods for sourcing
    variable values and content within the context of Jinja:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 部分的数据源可以来自多个不同的地方。在 Ansible 剧本中，目前有四种独特的方法可以在 Jinja 的上下文中获取变量值和内容：'
- en: Pass a YAML or JSON file with the `--var-file` option.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `--var-file` 选项传递一个 YAML 或 JSON 文件。
- en: Create environment variables.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建环境变量。
- en: Add a top-level defaults section to the playbook.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向剧本添加一个顶级默认值部分。
- en: Capture the value from `stdout`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获 `stdout` 中的值。
- en: As we can see from the example syntax we just looked at, Jinja expressions provide
    significant power that can be now wielded by Ansible playbook developers. Let's
    take a look at a more comprehensive playbook example using Ansible and Jinja2
    expressions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们刚才看到的示例语法所示，Jinja 表达式为 Ansible 剧本开发人员提供了强大的功能。让我们看看使用 Ansible 和 Jinja2 表达式的更全面的剧本示例。
- en: '`playbook.yml`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`playbook.yml`：'
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we run the playbook, Ansible''s output looks like the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行剧本时，Ansible 的输出如下所示：
- en: '**![](img/c0343c61-4d5b-4827-9276-2e83523e3f13.png)**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/c0343c61-4d5b-4827-9276-2e83523e3f13.png)**'
- en: 'Output (contents of `/etc/motd`):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（`/etc/motd` 的内容）：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we simply set the content of the MOTD file using a basic variable.
    Simple enough, right? But the real power of Jinja expressions comes when we realize
    we can source the variable data from multiple sources and perform operations on
    the variable inline and in real time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们仅使用一个基本变量设置 MOTD 文件的内容。很简单，对吧？但 Jinja 表达式的真正强大之处在于，我们可以从多个来源获取变量数据，并在运行时对变量进行操作。
- en: Jinja string concatenation and manipulation
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja 字符串连接与操作
- en: Jinja provides an excellent solution for manipulating strings and concatenating
    text (joining it with other text). For example, we might want to create a unique
    MOTD file by adding some additional information to the MOTD contents based on
    perhaps the hostname. This could be easily achieved via the following ansible
    playbook and Jinja syntax.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja 提供了一个优秀的解决方案，用于操作字符串和连接文本（将其与其他文本连接）。例如，我们可能想通过基于主机名等信息，将一些附加信息添加到 MOTD
    内容中，从而创建一个独特的 MOTD 文件。通过以下 Ansible 剧本和 Jinja 语法可以轻松实现这一目标。
- en: '`playbook.yml`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`playbook.yml`：'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we can see, the example shows how easy it is to concatenate string variables
    using Jinja. While the example we just looked at is useful, the expression implementation
    of Jinja is not limited to simple string concatenation. We can also manipulate
    strings using Jinja. For example, we might use any of the following solutions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，示例展示了如何轻松地使用 Jinja 连接字符串变量。虽然我们刚刚看到的示例很有用，但 Jinja 的表达式实现并不限于简单的字符串连接。我们还可以使用
    Jinja 操作字符串。例如，我们可能会使用以下任何一种解决方案：
- en: 'To use *regular expressions* within a Jinja variables:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jinja 变量中使用*正则表达式*：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To convert Jinja variables to *upper* and *lower* case:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Jinja 变量转换为*大写*和*小写*：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In addition to string manipulation, the Jinja implementation is *far* more powerful.
    We can also perform math operations using Jinja. Let's learn how.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符串处理，Jinja 的实现*更为*强大。我们还可以使用 Jinja 执行数学运算。让我们来看看如何操作。
- en: Basic arithmetic operations in Jinja
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja 中的基本算术操作
- en: 'In addition to basic string concatenation, we can also perform math and computational
    operations in Jinja. For example, we can add numerical values together using the
    following syntax:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的字符串连接，我们还可以在 Jinja 中执行数学和计算操作。例如，我们可以使用以下语法将数值相加：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The resulting output would have been calculated as *1+1 = 2*, thus resulting
    in *2* as the value of the `incremented_var` variable. In conjunction with basic
    addition, we can also perform multiplication, subtraction, division, and more.
    A complete list of the basic math operations available is provided next:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 计算结果将会是*1+1 = 2*，因此`incremented_var`变量的值将是*2*。除了基本的加法，我们还可以进行乘法、减法、除法等运算。接下来将提供一个可用的基础数学运算的完整列表：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From what we just saw, it is easy to see how Jinja can perform basic math operations.
    But it's not limited to just simple math.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们刚才看到的内容，容易理解Jinja是如何执行基本数学运算的。但它不仅限于简单的数学运算。
- en: Compound math equations and order of operations in Jinja
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja中的复合数学方程式和运算顺序
- en: 'Basic operations such as adding, subtracting, multiplying, and dividing can
    also be combined to create more robust calculated results. This is implemented
    via the `()` ordering of operations solution, which is common across many programming
    languages. It basically states that mathematical operations contained within the
    parentheses will be performed first with precedence of multiplication, division,
    addition, and then subtraction. Once the items inside a given set of parentheses
    are complete, the logic moves outward. An example of this is provided here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的运算如加法、减法、乘法和除法也可以组合在一起，创建更强大的计算结果。这是通过`()`运算顺序解决方案实现的，这在许多编程语言中都很常见。它基本上说明了括号内的数学运算会首先执行，并且优先级为乘法、除法、加法和减法。完成一对括号中的操作后，逻辑会向外展开。这里提供了一个示例：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Within the context of a Jinja expression, this math operation would look something
    like the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jinja表达式的上下文中，这个数学运算看起来大概像这样：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Filters available
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用的过滤器
- en: Jinja2 is not limited to strictly computational operations. It can be leveraged
    for any number of operational tasks. Ansible has kindly also provided a number
    of handy filters, which can be applied to our variable implementations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2不仅仅局限于计算操作。它可以用于执行各种操作任务。Ansible还提供了许多方便的过滤器，可以应用于我们的变量实现。
- en: 'The following is a table with a set of examples for the more popular operational
    tasks one might need to perform using Jinja filter expressions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个表格，列出了使用Jinja过滤表达式时可能需要执行的更常见的操作任务的示例：
- en: '| **Expression name** | **Example** | **Description of the expression** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **表达式名称** | **示例** | **表达式描述** |'
- en: '| `to_json` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `to_json` |'
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| Converts the variable data into JSON format and renders it. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 将变量数据转换为JSON格式并渲染。 |'
- en: '| `to_yaml` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `to_yaml` |'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| Converts the variable data into YAML format and renders it. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 将变量数据转换为YAML格式并渲染。 |'
- en: '| `mandatory` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `mandatory` |'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| Makes the variable declaration and setting mandatory for the playbook to
    execute properly. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 使变量声明和设置成为playbook正确执行的必要条件。 |'
- en: '| `default value` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `default value` |'
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| Sets a default value for the variable if it is not defined. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 如果变量未定义，则为该变量设置默认值。 |'
- en: '| `min&#124;max` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `min&#124;max` |'
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| Fetches the minimum or maximum value from an array. In this case, the values
    would be `2` or `4`, respectively. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 从数组中提取最小值或最大值。在这个例子中，值将分别为`2`或`4`。 |'
- en: '| `random` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `random` |'
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| Fetches a random item from a list, a random number, or seed value, respectively.
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 从列表中获取随机项、随机数或种子值，分别为此操作。 |'
- en: '| Shuffle |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 打乱 |'
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| Generates a new random list from an existing random list. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 从现有的随机列表生成一个新的随机列表。 |'
- en: '| Math log |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 数学对数 |'
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| Log algorithm math function and log numeric algorithm, respectively. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 日志算法数学函数和日志数值算法，分别为此操作。 |'
- en: '| Square root |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 平方根 |'
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| Square root math. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 平方根数学运算。 |'
- en: '| IPV filter |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| IPV过滤器 |'
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| Tests whether a string is a specific IPV version. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 测试字符串是否为特定的IPV版本。 |'
- en: '| Quote filter |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 引号过滤器 |'
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '| Wraps the expression evaluated in quotes. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 将计算出的表达式用引号括起来。 |'
- en: '| Concatenate lists |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 合并列表 |'
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| Joins list items into a single unified string. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 将列表项连接成一个统一的字符串。 |'
- en: '| Basename |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 基名 |'
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '| Linux path basename. Gets `foo.txt` out of `/etc/bar/foo.txt`, for example.
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| Linux路径基名。例如，从`/etc/bar/foo.txt`中提取`foo.txt`。 |'
- en: '| WIN basename |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| WIN基名 |'
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '| Same as basename but for MS Windows. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 与basename相同，但适用于MS Windows。 |'
- en: Now that we have a good understanding of how Ansible and Jinja leverage filters,
    let's move on to control structures.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Ansible和Jinja如何利用过滤器有了很好的理解，接下来我们来探讨控制结构。
- en: For a complete list of available filters and expressions, consult the official
    Ansible 2.0 documentation provided at [http://docs.ansible.com/ansible/playbooks_filters.html#filters-for-formatting-data](http://docs.ansible.com/ansible/playbooks_filters.html#filters-for-formatting-data).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可用过滤器和表达式的完整列表，请查阅官方的Ansible 2.0文档，网址为 [http://docs.ansible.com/ansible/playbooks_filters.html#filters-for-formatting-data](http://docs.ansible.com/ansible/playbooks_filters.html#filters-for-formatting-data)。
- en: Conditional logic (if-then-else)
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件逻辑（if-then-else）
- en: Control structures within any programming language provide a way of defining
    paths for an executing program to flow through based on a condition. In addition
    to conditional logic, control structures also provide us with a way of repeating
    like tasks without duplicating code. This is commonly known as **conditional logic
    and looping**, respectively. Jinja provides us with a set of operators that allow
    us to loop or conditionally execute code. In this section, we will discuss conditional
    logic specifically and learn how to leverage it within the context of Jinja.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言中的控制结构提供了一种定义程序根据条件执行路径的方式。除了条件逻辑外，控制结构还为我们提供了一种在不重复代码的情况下重复相似任务的方法。这通常被称为**条件逻辑和循环**。Jinja为我们提供了一组运算符，允许我们循环或条件性地执行代码。在本节中，我们将专门讨论条件逻辑，并学习如何在Jinja的上下文中利用它。
- en: 'A conditional statement provides the developer with a way of conditionalizing
    a sequence of events based on the evaluation of an expression. In most languages,
    this is accomplished through an `if...then`-styled solution. Take for example
    the following flowchart that illustrates the basic principles of conditional logic:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句为开发者提供了一种根据表达式的评估来有条件地执行一系列事件的方法。在大多数语言中，这是通过`if...then`式的解决方案实现的。举个例子，以下是展示条件逻辑基本原理的流程图：
- en: '![](img/6a6397c9-aeee-4272-84c7-dedb89bc4824.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a6397c9-aeee-4272-84c7-dedb89bc4824.png)'
- en: 'Conditional logic in code form might look something like the following (Python
    code):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的条件逻辑可能看起来像下面这样（Python代码）：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This Python code presents a simplistic example of conditional logic. It simply
    says that if `x` is equal to `0`, then execute the `print` statement telling the
    user so. Within Jinja, we can implement a very similar set of logical operators.
    The only real difference in context is that within Jinja, all control structures
    and conditionalizations are wrapped within `{% %}` tags. Let''s look at the same
    implementation using Jinja:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段Python代码展示了一个简单的条件逻辑示例。它简单地表示，如果`x`等于`0`，则执行`print`语句告诉用户这一点。在Jinja中，我们可以实现一个非常相似的逻辑运算符。唯一的实际区别是，在Jinja中，所有控制结构和条件语句都被包裹在`{%
    %}`标签内。让我们来看一下使用Jinja的相同实现：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we can see, the Jinja implementation also gives us the optional `else-if`
    statement. This provides us with additional capabilities when it comes to implementing
    conditional logic.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Jinja的实现也为我们提供了可选的`else-if`语句。这为我们在实现条件逻辑时提供了额外的功能。
- en: 'In Ansible, Jinja''s conditional logic can be used in many different ways.
    It can be used to wrap entire tasks with a conditional statement (only execute
    these tasks if a variable is set). This provides a huge amount of flexibility
    and power to playbook developers. Let''s look at a real-world example of implementing
    conditional logic within an Ansible playbook:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible中，Jinja的条件逻辑可以以多种不同的方式使用。它可以用来用条件语句包装整个任务（仅在设置了变量时才执行这些任务）。这为剧本开发者提供了极大的灵活性和强大功能。让我们看一个在Ansible剧本中实现条件逻辑的实际示例：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we run this playbook, we get the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个剧本时，我们会得到以下输出：
- en: '![](img/6e3b7ebe-88a8-40be-80c3-0aad9a1d33aa.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e3b7ebe-88a8-40be-80c3-0aad9a1d33aa.png)'
- en: 'Based on the conditional statements we defined within our playbook:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们在剧本中定义的条件语句：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can flip the `hello` variable to false and get the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`hello`变量设为false，然后得到以下输出：
- en: '![](img/c483724d-fb56-4ad0-bd37-b7e8faa379c4.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c483724d-fb56-4ad0-bd37-b7e8faa379c4.png)'
- en: It is important to note that Jinja syntax leveraged within an Ansible playbook
    will need to be inside of quotes and continue to adhere to YAML dictionary formatting
    standards. Jinja conditional syntax outside of the playbook (inside a Jinja template
    file) doesn't need to adhere to YAML standards.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在Ansible剧本中使用的Jinja语法需要放在引号内，并继续遵守YAML字典格式标准。而在剧本之外（例如Jinja模板文件内）的Jinja条件语法，则不需要遵守YAML标准。
- en: Conditional logic can be compounded to provide significantly more flexibility
    and power within Ansible playbooks. In the example we saw, the `{% ... %}` tags
    were placed within the vars section, but they don't necessarily need to be there.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 条件逻辑可以复合使用，以在 Ansible playbook 中提供更大的灵活性和功能。在我们看到的示例中，`{% ... %}` 标签被放置在 `vars`
    部分，但它们不一定非得在那里。
- en: 'Aside from placing conditionals within an Ansible playbook directly, we can
    leverage Jinja conditional logic within a Jinja template file. This is where Jinja''s
    true power can be felt. Let''s look at an example of a Jinja template file implemented
    with conditional logic:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接在 Ansible playbook 中放置条件语句外，我们还可以在 Jinja 模板文件中利用 Jinja 条件逻辑。这是 Jinja 真正强大之处的体现。让我们看一个实现了条件逻辑的
    Jinja 模板文件的示例：
- en: 'Ansible playbook:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ansible playbook:'
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`httpdconf.j2`:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpdconf.j2`：'
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: On running this example, Anisble will translate the Jinja template, transfer
    it over to the remote host, and place it in the `/etc/httpd/httpd.conf` directory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例时，Ansible 将翻译 Jinja 模板，将其传送到远程主机，并放置在 `/etc/httpd/httpd.conf` 目录中。
- en: Loops and iterators
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环和迭代器
- en: 'No programming language would be complete without the capability of reducing
    the amount of code implemented by iterating over repetitive tasks, and Jinja is
    no exception. Jinja offers multiple loop types within its syntax arsenal. Loops
    can come in many forms within a modern traditional programming language. For example,
    most modern programming languages support most of the following loop types:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 没有编程语言是完整的，如果没有通过迭代重复任务来减少代码量的能力，而 Jinja 也不例外。Jinja 在其语法工具库中提供了多种循环类型。现代传统编程语言中的循环形式多种多样。例如，大多数现代编程语言都支持以下大部分循环类型：
- en: '`For` loops'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`For` 循环'
- en: '`Foreach` loops'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Foreach` 循环'
- en: '`While` loops'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`While` 循环'
- en: '`Do...Until` loops'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Do...Until` 循环'
- en: In addition to these loop options, some programming languages support other
    OOP-oriented loop types. Within Ansible's implementation of Jinja, there is currently
    only support for the for loop. While the implementation of the types of loops
    is limited, there is the ability to perform counter-based iterations, list iterations,
    and compound loop conditionals. In this section, we will discuss loops within
    Jinja and learn how to implement them within our playbooks and our Jinja templates.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些循环选项外，一些编程语言还支持其他面向对象编程（OOP）类型的循环。在 Ansible 实现的 Jinja 中，目前只支持 `for` 循环。虽然循环类型的实现有限，但仍然可以执行基于计数器的迭代、列表迭代和复合循环条件。在这一部分中，我们将讨论
    Jinja 中的循环，并学习如何在我们的 playbook 和 Jinja 模板中实现它们。
- en: Simple counters
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单计数器
- en: 'Counter loops involve the repetitive increment or decrement of a variable until
    a condition is met. Counter loops can be really useful for code that would only
    need a minor integer change as part of its iteration loop sequence. To better
    understand the concept of a counter loop, let''s look at a flowchart illustration
    of a common programming loop that increments a counter:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器循环涉及对一个变量的重复递增或递减，直到满足某个条件。计数器循环对于仅需要在迭代循环序列中进行小幅整数变化的代码非常有用。为了更好地理解计数器循环的概念，我们来看一个常见编程循环的流程图示例，该循环递增一个计数器：
- en: '![](img/b79ab38b-622d-4080-ab92-98d21ffc7179.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b79ab38b-622d-4080-ab92-98d21ffc7179.png)'
- en: 'In this illustration, we basically repeat the increment task until the variable
    `X` is equal to the number `10`. Once the evaluation of `X` is equal to `10`,
    the iterator stops. The illustrated example of our loop could be represented in
    basic Python programming via the following syntax:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们基本上重复执行增量任务，直到变量 `X` 等于数字 `10`。一旦 `X` 的值等于 `10`，迭代器停止。我们示例中的循环可以通过以下基本
    Python 语法表示：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Loops don't always need to perform mathematical operations. They can also execute
    automation, iterate over a list, or do pretty much anything your imagination can
    dream up. This example of a loop simply increments a counter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 循环不一定总是执行数学运算。它们还可以执行自动化操作、迭代列表，或者完成几乎任何你想象得到的任务。这个循环示例仅仅是递增一个计数器。
- en: 'Now that we have understood the basic concept of a loop, let''s look at how
    we might implement the same type of loop within the context of Jinja and Ansible:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了循环的基本概念，让我们看看如何在 Jinja 和 Ansible 的上下文中实现同类型的循环：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Simple enough implementation, right? The next obvious question is *how would
    we go about implementing this same type of logic within a Jinja template file*?
    I''m glad you asked! Let''s take a look:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 实现起来很简单，对吧？接下来的问题是，*我们如何在 Jinja 模板文件中实现相同类型的逻辑*？很高兴你问了！让我们看看：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Simple enough also, right? Beyond counting values within a loop, we can also
    iterate other data items.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 也挺简单的，对吧？除了在循环中计数值，我们还可以遍历其他数据项。
- en: List iterators
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表迭代器
- en: 'List iterators in programming solutions offer the ability to take a list of
    items and perform a sequence of operations on them. For example, we might have
    a list of fruit, `[apples, oranges, grapes, pears]`, and want to iterate over
    this list. In traditional programming languages, we could use a `foreach` loop.
    The basic flow of a `foreach` loop might look something like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程解决方案中，列表迭代器提供了对一组项目执行一系列操作的能力。例如，我们可能有一个水果列表 `[apples, oranges, grapes, pears]`，并希望遍历这个列表。在传统的编程语言中，我们可以使用
    `foreach` 循环。`foreach` 循环的基本流程可能如下所示：
- en: '![](img/a0eaa273-a47d-4c51-926b-50b0c4fbc0ab.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0eaa273-a47d-4c51-926b-50b0c4fbc0ab.jpg)'
- en: 'This example simply iterates through each item in the list and executes a code
    block based on the new list item presented. This type of implementation of looping
    is very basic within most programming languages, and Jinja is no exception. Based
    on this flow, we can look at a Python example and map this to the following code
    fragment:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例简单地遍历列表中的每个项目，并根据呈现的新列表项执行代码块。这种类型的循环实现方式在大多数编程语言中都很基础，Jinja 也不例外。根据这个流程，我们可以查看一个
    Python 示例，并将其映射到以下代码片段：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In Jinja, the implementation of the list iterator has the following syntax:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jinja 中，列表迭代器的实现具有以下语法：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, let''s look at the translation of this loop sequence into Jinja:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看一下将这个循环序列转换为 Jinja 的实现：
- en: 'Hosts file:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机文件：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Playbook:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playbook：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Jinja template:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja 模板：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Thise example will autopopulate a file titled `configfile.conf` and upload it
    to the target hosts with the contents transformed using the Jinja `for` iterator.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将自动填充一个名为 `configfile.conf` 的文件，并将其上传到目标主机，内容使用 Jinja 的 `for` 迭代器进行转换。
- en: Complex iterators using Jinja
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jinja 的复杂迭代器
- en: 'The iterators that we discussed earlier in this chapter are very simple in
    nature. Jinja also provides a more complex way of operating loops within Jinja.
    Complex (or compound) iterators are common practice within programming and are
    what make modern algorithms possible. A complex iterator may take many forms,
    but often includes adding additional compound conditionals or nested loops within
    the loop sequence. Let''s look at a flowchart illustrating a complex iterator
    (nested loop):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章早些时候讨论的迭代器非常简单。Jinja 还提供了一种更复杂的循环实现方式。复杂（或复合）迭代器是编程中的常见实践，也是现代算法得以实现的原因。复杂的迭代器可能有多种形式，但通常包括在循环序列中添加额外的复合条件或嵌套循环。让我们看一个说明复杂迭代器（嵌套循环）的流程图：
- en: '![](img/c96816bd-c34c-48ea-90b1-798d11a3db48.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c96816bd-c34c-48ea-90b1-798d11a3db48.png)'
- en: 'Does this flowchart looks pretty complex? It doesn''t need to be. Let''s look
    at the same algorithm in Python:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流程图看起来很复杂吗？其实不需要。让我们来看一下用 Python 表示的相同算法：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In Jinja, implementing nested for loops can be done in much the same way. Let''s
    look at an example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jinja 中，实现嵌套的 for 循环与此类似。让我们看一个示例：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The Jinja template would look like the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja 模板将如下所示：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As we can see, the implementation of this Jinja loop is also pretty simple.
    Let''s take a look at how to make a slightly more complex loop that uses both
    iterators and conditionals. Following are the code fragments for variables in
    loops from a `vars` file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个 Jinja 循环的实现也相当简单。接下来让我们看看如何构建一个稍微复杂一点的循环，使用迭代器和条件语句。以下是 `vars` 文件中变量在循环中的代码片段：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now run it and check the output. Nice right?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行它并检查输出。不错吧？
- en: Applying Jinja in Ansible Playbook's
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Ansible Playbook 中应用 Jinja
- en: 'Jinja can be applied to playbooks in a few specific ways. The most common implementation
    of Jinja is the use of filters and variables within playbook YAML files. This
    information must be placed within the quoted context of YAML key/value structures.
    The key/value structure of YAML *does* normally support non-quoted values, but
    within the context of Jinja, we *must* have it within quotes. For example, let''s
    consider the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja 可以通过几种特定的方式应用于 Playbook。Jinja 最常见的实现方式是在 Playbook 的 YAML 文件中使用过滤器和变量。此信息必须放置在
    YAML 键/值结构的引号上下文中。YAML 的键/值结构*确实*通常支持非引号值，但在 Jinja 的上下文中，我们*必须*将其放在引号内。例如，我们可以考虑以下内容：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As we can see from this playbook, the implementation of Jinja within the playbook
    has the `{{...}}` tags directly within quotes. The *only* location that supports
    non-quoted implementations of Jinja tags is within a Jinja template. Jinja templates
    are parsed differently from YAML and therefore support loose implementations of
    Jinja tags. Let''s consider the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个 playbook 中我们可以看到，Jinja 的实现方式是在引号内直接使用 `{{...}}` 标签。*唯一*支持未加引号的 Jinja 标签实现的地方是在
    Jinja 模板中。Jinja 模板的解析方式不同于 YAML，因此支持宽松的 Jinja 标签实现。我们来考虑以下内容：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered how Jinja specifically and uniquely fits within
    the Ansible world. We learned how Jinja filters work and discovered how these
    filters can be leveraged within a playbook to provide us with clever playbook
    implementations. In addition to Jinja filters, we spent time learning how to perform
    mathematical operations on variables within a Jinja filter context.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讲解了 Jinja 如何特别且独特地融入 Ansible 世界。我们学习了 Jinja 过滤器的工作原理，并发现如何在 playbook
    中利用这些过滤器，为我们提供巧妙的 playbook 实现。除了 Jinja 过滤器外，我们还花时间学习了如何在 Jinja 过滤器上下文中对变量执行数学运算。
- en: In addition to the concept of Jinja filters, we also learned about loops and
    iterators. These iterators provided us with good insights into iterating over
    structured data, counting forward and in reverse. We learned also that iterators
    can be used for iterating through lists (such as the list of fruits that we iterated
    over in our example). Finally, we learned how to apply Jinja within our playbooks
    and the specific requirements that surround leveraging Jinja.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Jinja 过滤器的概念，我们还学习了循环和迭代器。这些迭代器为我们提供了对遍历结构化数据的深刻理解，包括正向和反向计数。我们还学习到，迭代器可以用于遍历列表（例如我们在示例中遍历的水果列表）。最后，我们学习了如何在我们的
    playbook 中应用 Jinja，以及利用 Jinja 时的具体要求。
- en: In the next chapter, we will cover the Ansible vault. The Ansible vault represents
    a unique and secure solution for encrypting, storing, and decrypting data with
    Ansible. This solution is *highly* useful as it can be used to store password
    data, usernames, secure database queries, and so much more. Oftentimes within
    an organization, sensitive user data is needed to configure and deploy software.
    This sensitive data is often usernames and passwords. Ansible provides an out-of-the-box
    solution to help encrypt and hide sensitive information. The next chapter will
    be on the Ansible vault. The next chapter of the book will outline the Ansible
    way of managing, storing, and deploying sensitive information. We will cover how
    to best leverage the Ansible vault utility to ensure that sensitive data is kept
    safe and secret. We will learn (by example) how to best control and manage highly
    secure information and learn the underpinnings of how Ansible keeps your information
    secure.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将介绍 Ansible Vault。Ansible Vault 提供了一种独特且安全的解决方案，用于加密、存储和解密数据。这个解决方案*非常*有用，因为它可以用来存储密码数据、用户名、安全的数据库查询等等。在一个组织中，常常需要敏感用户数据来配置和部署软件。这些敏感数据通常是用户名和密码。Ansible
    提供了一种现成的解决方案，帮助加密和隐藏敏感信息。下一章将讲解 Ansible Vault。本书的下一章将概述 Ansible 管理、存储和部署敏感信息的方式。我们将介绍如何最好地利用
    Ansible Vault 工具，确保敏感数据保持安全和保密。我们将通过示例学习如何最佳地控制和管理高度安全的信息，并了解 Ansible 如何保障你的信息安全。
- en: Let's proceed to learning about the Ansible vault.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续学习关于 Ansible Vault 的内容。
