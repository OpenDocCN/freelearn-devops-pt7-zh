- en: Configuration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Configuration targets
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置目标
- en: Querying the existing configuration
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询现有配置
- en: Templates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: A .git directory template
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.git` 目录模板'
- en: A few configuration examples
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些配置示例
- en: Git aliases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 别名
- en: The refspec exemplified
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例化的 refspec
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Git, while serving a basic and crucial role in the life of a developer, is also
    quite complex and highly configurable. This chapter will give an overview of the
    most important options available and will provide the right tools for learning
    and navigating the multitude of configuration flags and fields available, in order
    to tailor your Git experience to your own needs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Git 在开发者的日常工作中扮演着基本且至关重要的角色，但它也非常复杂且高度可配置。本章将概述最重要的可用选项，并提供正确的工具，以便学习和浏览各种配置标志和字段，从而根据个人需求定制你的
    Git 使用体验。
- en: Configuration targets
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置目标
- en: 'In this section, we will look at the different layers that can be configured.
    The layers are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看可以配置的不同层级。这些层级如下：
- en: '`SYSTEM`: This layer is system-wide and can be found in `/etc/gitconfig`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYSTEM`：此层级是全系统范围的，可以在 `/etc/gitconfig` 中找到。'
- en: '`GLOBAL`: This layer is global for the user and can be found in `~/.gitconfig`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GLOBAL`：此层级是用户的全局配置，可以在 `~/.gitconfig` 中找到。'
- en: '`LOCAL`: This layer is local to the current repository and can be found in
    `.git/config`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOCAL`：此层级仅限于当前仓库，并可以在 `.git/config` 中找到。'
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will use the `jgit` repository for this example; clone it, or use the clone
    you already have from [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml),
    *Navigating Git*, as shown in the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此示例中使用 `jgit` 仓库；克隆它，或者使用你在 [第1章](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml)，《导航
    Git》中已经克隆的版本，如以下命令所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the previous chapter, we saw how we could use the command `git config --list`
    to list configuration entries. This list is actually made from three different
    levels of configuration that Git offers: system-wide configuration, `SYSTEM`;
    global configuration for the user, `GLOBAL`; and local repository configuration,
    `LOCAL`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到如何使用命令 `git config --list` 列出配置项。这个列表实际上是由 Git 提供的三个不同层级的配置构成的：全系统配置
    `SYSTEM`，用户的全局配置 `GLOBAL`，以及本地仓库配置 `LOCAL`。
- en: 'For each of the configuration layers, we can query the existing configuration.
    On a Windows box with a default installation of the Git extensions, the different
    configuration layers will look something like the following:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个配置层级，我们都可以查询现有配置。在默认安装 Git 扩展的 Windows 系统中，不同的配置层级大致如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also query a single key and limit the scope to one of the three layers,
    by using the following command:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过使用以下命令查询单个键，并将作用范围限制在三层中的一个：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can set the email address of the user to a different one for the current
    repository:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以为当前仓库设置不同的用户电子邮件地址：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, listing the `GLOBAL` layer `user.email` will return `john.doe@example.com`,
    listing `LOCAL` will give `john@example.com`, and listing `user.email` without
    specifying the layer will give the effective value that is used in the operations
    on this repository; in this case, the `LOCAL` value `john@example.com`. The effective
    value will take precedence when needed. When two or more values are specified
    for the same key, but on different layers, the lowest layer takes precedence.
    When a configuration value is needed, Git will first look in the `LOCAL` configuration.
    If not found here, the `GLOBAL` configuration is queried. If it is not found in
    the `GLOBAL` configuration, the `SYSTEM` configuration is used.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，列出 `GLOBAL` 层级的 `user.email` 将返回 `john.doe@example.com`，列出 `LOCAL` 层级将返回
    `john@example.com`，而在不指定层级的情况下列出 `user.email` 将返回当前仓库操作中使用的有效值；在这种情况下，`LOCAL`
    层级的值 `john@example.com`。当需要有效值时，它将优先使用该值。如果在不同的层级中指定了两个或更多相同键的值，则较低层级的值会优先。Git
    在需要配置值时，首先会查看 `LOCAL` 配置。如果在此未找到，则查询 `GLOBAL` 配置。如果在 `GLOBAL` 配置中也未找到，则使用 `SYSTEM`
    配置。
- en: If none of this works, the default value in Git is used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些都无效，则会使用 Git 中的默认值。
- en: In the previous example, `user.email` is specified in both the `GLOBAL` and
    `LOCAL` layers. Therefore, the `LOCAL` layer will be used.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`user.email` 在 `GLOBAL` 和 `LOCAL` 层级中都有指定。因此，将使用 `LOCAL` 层级的值。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Querying the three layers of configuration simply returns the content of the
    configuration files; `/etc/gitconfig` for system-wide configuration, `~/.gitconfig`
    for user-specific configuration, and `.git/config` for repository-specific configuration.
    When not specifying the configuration layer, the returned value will be the effective
    value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 查询三层配置时，简单地返回配置文件的内容；`/etc/gitconfig`用于系统范围配置，`~/.gitconfig`用于用户特定配置，`.git/config`用于仓库特定配置。如果未指定配置层，则返回的值为有效值。
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Instead of setting all the configuration values on the command line by the
    key value, it is possible to set them by just editing the configuration file directly.
    Open the configuration file in your favorite editor and set the configuration
    you need, or use the built-in `git config -e` repository to edit the configuration
    directly in the Git-configured editor. You can set the editor to the editor of
    your choice either by changing the $`EDITOR` environment variable or with the
    `core.editor` configuration target, for example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过键值在命令行中设置所有配置值外，你还可以直接编辑配置文件来设置它们。打开你喜欢的编辑器中的配置文件，设置你需要的配置，或者使用内置的`git config
    -e`命令在 Git 配置的编辑器中直接编辑配置。你可以通过更改`$EDITOR`环境变量或使用`core.editor`配置目标来设置你喜欢的编辑器，例如：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Querying the existing configuration
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询现有配置
- en: In this example, we will look at how we can query the existing configuration
    and set the configuration values.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将看看如何查询现有的配置并设置配置值。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll use `jgit` again by using the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用`jgit`，通过以下命令来操作：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: You can use `git config` to query your local and global Git configuration. In
    this section, we will show a couple of examples.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`git config`查询你的本地和全局 Git 配置。在这一部分，我们将展示几个例子。
- en: 'To view all the effective configurations for the current Git repository, run
    the following command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看当前 Git 仓库的所有有效配置，请运行以下命令：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The previous output will, of course, reflect the user running the command. Instead
    of `John Doe` as the name and the email, the output should reflect your settings.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出当然会反映运行命令的用户。输出中的名字和电子邮件将反映你的设置，而不是`John Doe`。
- en: 'If we are just interested in a single configuration item, we can just query
    it by its `section.key` or `section.subsection.key`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只对单个配置项感兴趣，可以通过其`section.key`或`section.subsection.key`来查询：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Git''s configuration is stored in plain text files and works like a key-value
    storage. You can set/query by key and get the value back. An example of the text-based
    configuration file is shown as follows (from the `jgit` repository):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Git 的配置存储在纯文本文件中，类似于键值存储。你可以通过键来设置/查询并获取值。以下是基于文本的配置文件示例（来自`jgit`仓库）：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's more...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'It is also easy to set configuration values. You can use the same syntax as
    you did when querying the configuration, except you need to add an argument to
    the value. To set a new email address on the `LOCAL` layer, we can execute the
    following command line:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 设置配置值也很简单。你可以使用与查询配置时相同的语法，只不过需要在值后加上一个参数。要在`LOCAL`层设置一个新的电子邮件地址，我们可以执行以下命令：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `LOCAL` layer is the default, if nothing else is specified. If you require
    whitespaces in the value, you can enclose the string in quotation marks, as you
    would do when configuring your name:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOCAL`层是默认层，如果没有其他指定。如果值中需要空格，你可以像配置姓名时那样用引号将字符串括起来：'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can even set your own configuration, which does not have any effect on
    the core Git, but which can be useful for scripting/builds, and so on:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以设置自己的配置，这对核心 Git 没有任何影响，但在脚本编写/构建等方面会很有用：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'List the value:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列出该值：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It is also very easy to delete/unset configuration entries:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 删除/取消配置项也非常容易：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'List the value:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列出该值：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Templates
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: In this example, we will see how to create a template commit message that will
    be displayed in the editor when creating a commit. The template is only for the
    local user and not distributed with the repository in general.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将看到如何创建一个模板提交信息，这将在创建提交时显示在编辑器中。该模板仅适用于本地用户，而不会与仓库一起分发。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this example, we will use the example repository from [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml),
    *Navigating Git*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用[第 1 章](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml)中的示例仓库，*Navigating
    Git*：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ll use the following command as a commit message template for commit messages:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令作为提交信息的模板：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save the commit message template in `$HOME/.gitcommitmsg.txt`. The filename
    isn't fixed and you can choose a filename of your liking.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将提交信息模板保存在`$HOME/.gitcommitmsg.txt`。文件名不是固定的，你可以选择任何你喜欢的文件名。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To let Git know about our new commit message template, we can set the configuration
    variable `commit.template` to point at the file we just created with that template;
    we''ll do it globally so it is applicable to all our repositories:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让 Git 知道我们新的提交信息模板，我们可以设置配置变量`commit.template`，指向我们刚刚创建的包含该模板的文件；我们将全局设置它，以便适用于我们所有的仓库：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can try to change a file, add it, and create a commit. This will bring
    up our preferred editor with the commit message template preloaded:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试修改一个文件，添加它，并创建一个提交。这将打开我们首选的编辑器，并预加载提交信息模板：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can now edit the message according to our commit and save to complete the
    commit.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以根据我们的提交编辑信息并保存，以完成提交。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When `commit.template` is set, Git simply uses the content of the template file
    as a starting point for all commit messages. This is quite convenient if you have
    a commit-message policy, as it greatly increases the chances of the policy being
    followed. You can even have different templates tied to different repositories
    since you can just set the configuration at the local level.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当`commit.template`被设置时，Git 会将模板文件的内容作为所有提交信息的起点。如果你有提交信息的策略，这非常方便，因为它大大增加了遵循该策略的机会。你甚至可以为不同的仓库设置不同的模板，因为你可以在本地级别设置配置。
- en: A .git directory template
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 .git 目录模板
- en: Sometimes, having a global configuration isn't enough. You will also need to
    trigger the execution of scripts (also known as Git hooks), exclude files, and
    so on. It is possible to achieve this with the template option set to `git init`.
    It can be given as a command-line option to `git clone` and `git init`, or as
    the `$GIT_TEMPLATE_DIR` environment variable, or as the configuration option `init.templatedir`.
    It defaults to `/usr/share/git-core/templates`. The template option works by copying
    files in the template directory to the `.git ($GIT_DIR)` folder after it has been
    created. The default directory contains sample hooks and some suggested exclude
    patterns. In the following example, we'll see how we can set up a new template
    directory, and add a commit message hook and an exclude file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，单单拥有全局配置是不够的。你还需要触发脚本（也称为 Git 钩子）、排除文件等的执行。可以通过设置模板选项`git init`来实现这一点。它可以作为命令行选项传递给`git
    clone`和`git init`，或者作为环境变量`$GIT_TEMPLATE_DIR`，或者作为配置选项`init.templatedir`。默认为`/usr/share/git-core/templates`。模板选项通过将模板目录中的文件复制到`.git
    ($GIT_DIR)`文件夹中来工作。默认目录包含示例钩子和一些建议的排除模式。在下面的示例中，我们将看到如何设置一个新的模板目录，并添加提交信息钩子和排除文件。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, we will create the template directory. We can use any name we want,
    and we''ll use `~/.git_template`, as shown in the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建模板目录。我们可以使用任何我们想要的名称，这里我们使用`~/.git_template`，如以下命令所示：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we need to populate the directory with some template files. This could
    be a hook or an exclude file. We will create one hook file and one exclude file.
    The hook file is located in `.git/hooks/name-of-hook` and the exclude file in
    `.git/info/exclude`. Create the two directories needed, `hooks` and `info`, as
    shown in the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在目录中填充一些模板文件。可以是一个钩子文件或排除文件。我们将创建一个钩子文件和一个排除文件。钩子文件位于`.git/hooks/name-of-hook`，排除文件位于`.git/info/exclude`。创建所需的两个目录，`hooks`和`info`，如以下命令所示：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To keep the sample hooks provided by the default template directory (the Git
    installation), we copy the files in the default template directory to the new
    one. When we use our newly created template directory, we''ll override the default
    one. So, copying the default files to our template directory will make sure that,
    excepting our specific changes, the template directory is similar to the default
    one, as shown in the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保留默认模板目录（Git 安装提供的）中的示例钩子，我们将默认模板目录中的文件复制到新目录中。当我们使用新创建的模板目录时，它会覆盖默认目录。所以，将默认文件复制到我们的模板目录中会确保，除了我们的特定更改外，模板目录与默认目录相似，如以下命令所示：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ll use the `commit-msg` hook as the example hook:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`commit-msg`钩子作为示例钩子：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The hook is very simple and will just add `Hi from the template commit-msg
    hook` to the end of the commit message. Save it as `commit-msg` in the `~/.git_template/hooks`
    directory and make it executable by using the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个钩子非常简单，它只会将`Hi from the template commit-msg hook`添加到提交信息的末尾。将其保存为`commit-msg`文件到`~/.git_template/hooks`目录，并通过以下命令使其可执行：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that the commit message hook is done, let's also add an exclude file to
    the example. The exclude file works like the `.gitignore` file, but is not tracked
    in the repository.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在提交信息钩子已完成，我们还将向示例中添加一个排除文件。排除文件的作用类似于`.gitignore`文件，但它不会被仓库跟踪。
- en: 'We''ll create an exclude file that excludes all the `*.txt` files, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个排除文件，排除所有`*.txt`文件，如下所示：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, our template directory is ready for use.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的模板目录已准备就绪，可以使用了。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Our template directory is ready, and we can use it, as described earlier, as
    a command-line option, an environment variable or, as in this example, to be set
    as a configuration:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的模板目录已准备好，并且可以按照前面描述的方式，作为命令行选项、环境变量，或者像这个例子一样，作为配置来设置：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, all Git repositories we create using `init` or `clone` will have the default
    files of the template directory. We can test whether it works by creating a new
    repository as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，所有使用`init`或`clone`创建的Git仓库将拥有模板目录的默认文件。我们可以通过创建一个新仓库来测试它是否有效，方法如下：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s try to create a `.txt` file and see what `git status` tells us. It should
    be ignored by the exclude file from the template directory:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个`.txt`文件，并查看`git status`告诉我们什么。它应该会被模板目录中的排除文件忽略：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The exclude file worked! You can put in the file endings yourself, or just leave
    it blank and keep to the `.gitignore` files.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 排除文件生效了！你可以自己添加文件扩展名，或者直接留空并继续使用`.gitignore`文件。
- en: 'To test whether the `commit-msg` hook works, let''s try to create a commit.
    First, we need a file to commit. So, let''s create that and commit it as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试`commit-msg`钩子是否有效，我们来尝试创建一个提交。首先，我们需要一个文件来提交。接下来，我们按如下方式创建并提交它：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now check the history with `git log`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过`git log`来查看历史记录：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When Git creates a new repository, either via `init` or `clone`, it will copy
    the files from the `template` directory (the default location is `/usr/share/git-core/templates`)
    to the new repository when creating the directory structure. The template directory
    can be defined either by a command-line argument, an environment variable, or
    a configuration option. If nothing is specified, the default template directory
    will be used (distributed with the Git installation). By setting the configuration
    as a `--global` option, the template directory defined will apply to all of the
    user's (new) repositories. This is a very nice way to distribute the same hooks
    across repositories, but it also has some drawbacks. As the files in the template
    directory are only copied to the Git repositories, updates to the template directory
    do not affect the existing repositories. This can be solved by running `git init`
    in each existing repository to reinitialize the repository, but this can be quite
    cumbersome. Also, the template directory can enforce hooks on some repositories
    where you don't want them. This is quite easily solved by simply deleting the
    hook files in `.git/hooks` of that repository.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当Git创建一个新仓库时，无论是通过`init`还是`clone`，它会在创建目录结构时将`template`目录中的文件（默认位置是`/usr/share/git-core/templates`）复制到新仓库中。模板目录可以通过命令行参数、环境变量或配置选项来定义。如果没有指定，将使用默认的模板目录（与Git安装一起分发）。通过将配置设置为`--global`选项，所定义的模板目录将适用于所有用户（新的）仓库。这是一个很好的方式来在仓库之间分发相同的钩子，但它也有一些缺点。由于模板目录中的文件仅复制到Git仓库，因此对模板目录的更新不会影响现有的仓库。这可以通过在每个现有仓库中运行`git
    init`来重新初始化仓库来解决，但这可能相当繁琐。另外，模板目录可能会强制某些仓库应用钩子，而你并不希望这样做。这个问题可以通过简单地删除该仓库中`.git/hooks`目录里的钩子文件来轻松解决。
- en: See also
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on hooks in Git, please refer to [Chapter 7](fcc6f77f-119c-41e9-b4b0-9b7df263b7f1.xhtml),
    *Enhancing Your Daily Work with Git Hooks, Aliases, and Scripts*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于Git钩子的信息，请参考[第7章](fcc6f77f-119c-41e9-b4b0-9b7df263b7f1.xhtml)，*使用Git钩子、别名和脚本提升你的日常工作效率*。
- en: A few configuration examples
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些配置示例
- en: There are configuration targets in the core Git system. In this section, we'll
    take a closer look at a few of them that might be useful in your daily work.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 核心Git系统中有配置目标。在本节中，我们将更详细地查看一些在日常工作中可能有用的配置目标。
- en: 'We''ll look at the following three different configuration areas:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看以下三个不同的配置区域：
- en: Rebase and merge setup
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重基与合并设置
- en: Expiry of objects
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象过期
- en: Autocorrect
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动更正
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this exercise, we''ll just set a few configurations. We''ll use the data
    model repository from [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml),
    *Navigating Git*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将设置一些配置。我们将使用[第一章](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml)《Navigating
    Git》中的数据模型仓库：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's take a closer look at the previously mentioned configuration areas.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看前面提到的配置区域。
- en: Rebase and merge setup
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重基与合并设置
- en: 'By default, when performing `git pull`, a merge commit will be created if the
    history of the local branch has diverged from the remote one. However, to avoid
    all these merge commits, a repository can be configured so that it will default
    to rebase instead of merging when doing `git pull`. Several configuration targets
    related to the option are available as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当执行`git pull`时，如果本地分支的历史与远程分支发生分歧，Git将创建一个合并提交。然而，为了避免所有这些合并提交，可以配置仓库，使其在执行`git
    pull`时默认使用重基（rebase）而不是合并。与此选项相关的几个配置目标如下：
- en: '`pull.rebase`: This configuration, when set to `true`, will pull to rebase
    the current branch on top of the fetched one when performing a `git pull`. It
    can also be set to `preserve` so that the local merge commit will not be flattened
    in the rebase, by passing `--preserve-merges` to `git rebase`. The default value
    is `false`,as the configuration is not set. To set this option in your local repository,
    run the following command:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pull.rebase`：当此配置设置为`true`时，在执行`git pull`时，会将当前分支拉取并重基到获取的分支上。也可以设置为`preserve`，以便在重基时不会压平本地的合并提交，方法是将`--preserve-merges`传递给`git
    rebase`。默认值为`false`，即该配置未设置。要在本地仓库中设置此选项，请运行以下命令：'
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`branch.autosetuprebase`: When this configuration is set to `always`, any new
    branch created with `<git branch` or `git checkout` that tracks another branch
    will be set up to pull to rebase (instead of merge). The valid options are as
    follows:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`branch.autosetuprebase`：当此配置设置为`always`时，通过`<git branch`或`git checkout`创建的任何新分支，如果跟踪其他分支，将会设置为拉取时进行重基（而非合并）。有效的选项如下：'
- en: '`never`: This is set to pull to rebase (default)'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`never`：此设置用于拉取时默认执行重基（rebase）。'
- en: '`local`: This is set to pull to rebase for local tracked branches'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local`：此设置用于本地跟踪分支执行拉取时重基（rebase）。'
- en: '`remote`: This is set to pull to rebase for remote tracked branches'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remote`：此设置用于远程跟踪分支执行拉取时重基（rebase）。'
- en: '`always`: This is set to pull to rebase for all tracked branches'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`always`：此设置用于所有被跟踪的分支执行拉取时重基（rebase）。'
- en: 'To set this option for all the new branches regardless of tracking remote or
    local branches, run the following command:'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要为所有新分支设置此选项，无论其跟踪远程还是本地分支，请运行以下命令：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`branch.<name>.rebase`: This configuration, when set to `true`, applies only
    to the `<name>` branch and tells Git to pull to rebase when performing `git pull`
    on the given branch. It can also be set to `preserve` so that the local merge
    commit will not be flattened when running `git pull`. By default, the configuration
    is not set for any branch. To set the `feature/2` branch in the repository to
    default to rebase, instead of merge, we can run the following command:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`branch.<name>.rebase`：当此配置设置为`true`时，仅适用于`<name>`分支，指示Git在执行`git pull`时进行重基。它也可以设置为`preserve`，以便在执行`git
    pull`时不会压平本地的合并提交。默认情况下，任何分支都未设置此配置。要将仓库中的`feature/2`分支设置为默认重基，而非合并，可以运行以下命令：'
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Expiry of objects
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象过期
- en: 'By default, Git will perform garbage collection on unreferenced objects and
    clean `reflog` for entries that are more than 90 days old. For an object to be
    referenced, something must point to it; a tree, a commit, a tag, a branch, or
    some of the internal Git bookkeeping, such as `stash` or `reflog`. There are three
    settings that can be used to change this time as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Git将在未引用的对象上执行垃圾回收，并清理`reflog`中超过90天的条目。为了让某个对象被引用，必须有某些内容指向它；如树、提交、标签、分支，或者一些内部Git记录，例如`stash`或`reflog`。有三个设置可以用来更改这个时间，如下所示：
- en: '`gc.reflogexpire`: This is the general setting to know for how long a branch''s
    history is kept in `reflog`. The default time is 90 days. The setting is a length
    of time, for example, `10 days, 6 months`, and it can be turned completely with
    the value `never`. The setting can be set to match a `refs` pattern by supplying
    the pattern in the configuration setting. `gc.<pattern>.reflogexpire`: This pattern
    can, for example, be `/refs/remotes/*`,and the expire setting would then only
    apply for those refs.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc.reflogexpire`：这是了解分支历史在`reflog`中保存时间的一般设置。默认时间为 90 天。该设置是一个时间长度，例如`10 days`、`6
    months`，也可以通过值`never`完全禁用。此设置可以通过在配置中提供模式来匹配`refs`模式。`gc.<pattern>.reflogexpire`：例如，此模式可以是`/refs/remotes/*`，并且过期设置仅适用于这些
    refs。'
- en: '`gc.reflogexpireunreachable`: This setting controls how long the `reflog` entries
    that are not a part of the current branch history should be available in the repository.
    The default value is `30 days`, and similar to the previous option, it is expressed
    as a length of time or set to `never` in order to turn it off. This setting can,
    as the previous one, be set to match a `refs` pattern.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc.reflogexpireunreachable`：此设置控制不属于当前分支历史的`reflog`条目在仓库中的可用时间。默认值为`30 days`，与前一个选项类似，它表示一个时间长度，或者设置为`never`以关闭该设置。此设置可以像前一个选项一样，设置为匹配`refs`模式。'
- en: '`gc.pruneexpire`: This option tells `git gc` to prune objects older than the
    value. The default is `2.weeks.ago`, and the value can be expressed as a relative
    date, such as `3.months.ago`. To disable the grace period, the value `now` can
    be used. To set a non-default expiry date on remote branches only, use the following
    command:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc.pruneexpire`：此选项告知`git gc`修剪比设定时间更久的对象。默认值为`2.weeks.ago`，并且值可以表示为相对日期，例如`3.months.ago`。若要禁用宽限期，可以使用`now`作为值。要仅在远程分支上设置非默认的过期日期，可以使用以下命令：'
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can also set a date so `git gc` will prune objects sooner:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以设置一个日期，以便`git gc`更早地修剪对象：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Autocorrect
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动更正
- en: 'This configuration is useful when you get tired of messages such as the following
    one just because you made a typo on the keyboard:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你因为键入错误而看到如下消息时，这个配置非常有用：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'By setting the configuration to `help.autocorrect`, you can control how Git
    will behave when you accidentally send a typo to it. By default, the value is
    `0` and it means to list the possible options similar to the input (if `statis`is
    given, `status` will be shown). A negative value means to immediately execute
    the corresponding command. A positive value means to wait the given number of
    deciseconds (0.1 sec) before running the command (so there is an amount of time
    in which to cancel it). If several commands can be deduced from the text entered,
    nothing will happen. Setting the value to half a second gives you some time to
    cancel a wrong command, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`help.autocorrect`配置，你可以控制 Git 在意外输入错误时的行为。默认值为`0`，表示列出与输入相似的可选项（例如输入`statis`时，显示`status`）。负值表示立即执行相应的命令。正值表示在执行命令之前等待指定的十分之一秒（0.1秒），因此在这段时间内可以取消命令。如果可以从输入的文本中推断出多个命令，则什么也不会发生。将值设置为半秒，给你一些时间来取消错误的命令，如下所示：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: Setting the configuration targets will change the way Git behaves. The previous
    examples describe a few useful methods to get Git to act differently than its
    default behavior. You should be sure when you are changing a configuration that
    you completely understand what that configuration does. Therefore, check the Git
    configuration help page by using `git help config`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 设置配置目标会改变 Git 的行为。前面的示例描述了几种常用的方法，使 Git 的行为不同于默认设置。在更改配置时，你应确保完全理解该配置的作用。因此，可以通过使用`git
    help config`来查看 Git 配置帮助页面。
- en: There's more...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are a lot of configuration targets available in Git. You can run `git
    help config` and all of them will be displayed and explained over a few pages.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Git 中有许多可用的配置目标。你可以运行`git help config`，所有配置项将显示并在几页中解释。
- en: Git aliases
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 别名
- en: An alias is a nice way to configure long and/or complicated Git commands to
    represent short useful ones. An alias is simply a configuration entry under the
    alias section. It is usually configured to `--global` to apply it everywhere.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 别名是配置长且/或复杂的 Git 命令以表示简短实用命令的好方法。别名只是别名部分下的一个配置项。通常配置为`--global`，使其在任何地方都适用。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this example, we will use the `jgit` repository, which was also used in
    [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml), *Navigating Git*, with
    the `master` branch pointing at `b14a93971837610156e815ae2eee3baaa5b7a44b`. Either
    use the clone from [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml), *Navigating
    Git*, or clone the repository again, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`jgit`仓库，这也是在[第1章](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml)《导航Git》中使用的，`master`分支指向`b14a93971837610156e815ae2eee3baaa5b7a44b`。可以使用[第1章](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml)《导航Git》中的克隆，也可以重新克隆该仓库，如下所示：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we''ll create a few simple aliases, then a couple of more special ones,
    and finally, a couple of aliases using external commands. Instead of writing `git
    checkout` every time we need to switch branches, we can create an alias of that
    command and call it `git co`. We can do the same for `git branch`, `git commit`,
    and `git status` as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一些简单的别名，然后创建几个更特殊的别名，最后创建几个使用外部命令的别名。我们可以为每次需要切换分支时创建一个别名，而不是每次都输入`git
    checkout`，并命名为`git co`。我们可以对`git branch`、`git commit`和`git status`做相同的操作，如下所示：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, try to run `git st` in the `jgit` repository as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试在`jgit`仓库中运行`git st`，如下所示：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `alias` method is also good for creating the Git commands you think are
    missing in Git. One of the common Git aliases is `unstage`, which is used to move
    a file out of the staging area, as shown in the following command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`alias`方法对于创建你认为Git缺失的命令也很有用。一个常见的Git别名是`unstage`，它用于将文件从暂存区移出，如下所示：'
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Try to edit the `README.md` file in the root of the `jgit` repository and add
    it to the root.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编辑`jgit`仓库根目录中的`README.md`文件并将其添加到根目录中。
- en: 'Now, `git status/git st` should display something like the following:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`git status/git st`应该显示如下内容：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s try to unstage `README.md` and then look at `git st` as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试取消暂存`README.md`，然后查看`git st`，如下所示：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A common use case for aliases is to format the history of Git in specific ways.
    Let''s say you want the number of lines added and deleted for each file in the
    commit displayed along with some common commit data. For this, we can create the
    following alias so we don''t have to type everything each time:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 别名的一个常见用例是以特定方式格式化Git的历史记录。假设你希望在提交时显示每个文件的新增和删除行数，并附带一些常见的提交数据。为此，我们可以创建以下别名，这样每次就不必输入所有内容：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we can execute `git ll` in the terminal and get a nice stat output, as
    shown in the following command:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在终端中执行`git ll`命令并获得一个漂亮的统计输出，如下所示：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It is also possible to use an external command instead of a Git command. So,
    small shell scripts and so on can be embedded. To create an `alias` method with
    an external command, the alias must start with an exclamation mark `!`. The examples
    can be used when resolving conflicts from a rebase or merge. In your `~/.gitconfig`
    file under `[alias]`, add the following:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也可以使用外部命令代替Git命令。因此，小的Shell脚本等可以被嵌入。要使用外部命令创建`alias`方法，别名必须以感叹号`!`开头。当解决rebase或merge冲突时，可以使用这些示例。在`~/.gitconfig`文件的`[alias]`下，添加以下内容：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will bring up your configured $`EDITOR` with all the files that are in
    the conflict state due to the merge/rebase. This quickly allows you to fix the
    conflicts and get on with the merge/rebase.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调出你配置的`$EDITOR`，并显示由于合并/rebase而处于冲突状态的所有文件。这使得你可以快速修复冲突并继续合并/rebase。
- en: 'In the `jgit` repository, we can create two branches at an earlier point in
    time and merge these two branches:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jgit`仓库中，我们可以在较早的时间点创建两个分支并合并这两个分支：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, you'll see that this fails to perform the merge, and you can run `git st`
    to check the statuses of a lot of files that are in a conflicted state, `both
    modified`. To open and edit all the conflicted files, we can now run `git editconflicted`.
    This brings up `$EDITOR` with the files. If your environment variable isn't set,
    use the `EDITOR=<your-favorite-editor>` export to set it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会看到这个操作无法执行合并，你可以运行`git st`来检查很多处于冲突状态的文件的状态，`both modified`。要打开并编辑所有冲突文件，我们可以运行`git
    editconflicted`。这将使用`$EDITOR`打开文件。如果你的环境变量未设置，可以使用`EDITOR=<your-favorite-editor>`来设置它。
- en: For this example, we don't actually resolve the conflicts. Just check that the
    alias works and you're ready for the next alias.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们实际上并不解决冲突。只需检查别名是否有效，然后准备好下一个别名。
- en: 'Now that we have solved all the merge conflicts, it is time to add all of those
    files before we conclude the merge. Luckily, we can create an `alias` method that
    can help us with that, as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经解决了所有的合并冲突，接下来是添加所有这些文件，在合并结束之前。幸运的是，我们可以创建一个`alias`方法来帮助我们实现，如下所示：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we can run `git addconflicted`. Later, `git status` will tell us that
    all the conflicted files are added:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行`git addconflicted`。稍后，`git status`会告诉我们所有冲突的文件都已添加：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Git simply runs the command the alias is short for. It is very convenient for
    long Git commands, or Git commands that are hard to remember exactly how to write.
    Now, all you have to remember is the alias and you can always look in the configuration
    file for it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Git只是运行别名所代表的命令。这对长的Git命令或那些难以记住具体如何写的Git命令非常方便。现在，你只需要记住别名，并且可以随时查看配置文件来查找它。
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another way to create a kind of Git alias is to make a shell script and save
    the file with the name `git-<your-alias-name>`. Make the file executable and place
    it somewhere in your `$PATH`. You can now run that file simply by running `git<your-alias-name>` from
    the command line.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一种Git别名的另一种方法是创建一个shell脚本，并将文件保存为`git-<你的别名>`。使文件具有可执行权限，并将其放置在你的`$PATH`中。现在，你只需通过从命令行运行`git<你的别名>`即可运行该文件。
- en: The refspec exemplified
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例中的refspec
- en: 'Though the `refspec` isn''t the first thing that comes to mind when thinking
    about the Git configuration, it is actually quite close. In a lot of the Git commands,
    the `refspec` is used, but often implicitly, that is, the `refspec` is taken from
    the configuration file. If you don''t remember setting a `refspec` configuration,
    you are probably right, but if you cloned the repository or added a remote, you''ll
    have a section in `.git/config` that looks something like the following (this
    is for the `jgit` repository):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`refspec`并不是想到Git配置时第一个想到的内容，但它实际上是非常接近的。在许多Git命令中都会使用`refspec`，但通常是隐式使用的，即`refspec`是从配置文件中获取的。如果你不记得设置过`refspec`配置，可能是对的，但如果你克隆了仓库或添加了远程仓库，那么`.git/config`文件中会有一个类似以下内容的部分（这是针对`jgit`仓库的）：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The fetch line contains the configured `refspec` to fetch in relation to this
    repository.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: fetch行包含与此仓库相关的已配置`refspec`。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we'll be using the `jgit` repository as our server repository,
    but we have to make a clone of it to a bare repository so we can push it. You
    can't push to the checked-out branch on a non-bare repository, as this can overwrite
    the work area and index.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`jgit`仓库作为我们的服务器仓库，但我们需要将其克隆到一个裸仓库中，以便可以推送。你不能推送到非裸仓库的已检出分支，因为这可能会覆盖工作区和索引。
- en: 'Create a bare repository from the `jgit` repository and create a new Git repository
    where we can play with the `refspec` as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从`jgit`仓库创建一个裸仓库，并创建一个新的Git仓库，在其中我们可以操作`refspec`，如下所示：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We also need to change the branch names on some of the branches to match the
    example for namespacing; the following will rename the `stable-xxx` branches to
    `stable/xxx`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改某些分支的分支名称，以匹配命名空间的示例；以下命令将`stable-xxx`分支重命名为`stable/xxx`：
- en: '[PRE52]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the previous shell scripting, the `$new` and `$br` variables aren't placed
    in double quotes (`"`), as good practice for shell scripting would otherwise suggest.
    This is okay, as the variables reflect the names of the branches in the repository
    and branch names cannot contain spaces.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的shell脚本中，`$new`和`$br`变量没有放在双引号（`"`）中，虽然良好的shell脚本实践建议这样做。这是可以的，因为这些变量反映的是仓库中分支的名称，而分支名不能包含空格。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s set up our new repository to only fetch the `master` branch. We do this
    by changing the fetch line under `[remote "origin"]` in the configuration file
    (`.git/config`), as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置新的仓库，只获取`master`分支。我们通过在配置文件（`.git/config`）中更改`[remote "origin"]`下的fetch行来实现，如下所示：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we will only fetch the `master` branch and not all the other branches
    when executing a `git fetch`, `git pull`, or a `git remote` update origin, as
    follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在执行`git fetch`、`git pull`或`git remote`更新origin时，只会获取`master`分支，而不会获取其他分支，如下所示：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s also set up a separate refspec to fetch all the `stable/*` branches
    to the local repository as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以设置一个单独的refspec，将所有`stable/*`分支获取到本地仓库，具体如下：
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, fetch the branches locally, as shown in the following command:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按如下命令在本地获取分支：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can also set up a push `refspec` that specifies where branches are pushed
    to by default. Let''s create a branch called `develop` and create one commit,
    as shown in the following commands:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以设置一个推送（push）`refspec`，指定默认推送到哪个分支。让我们创建一个名为`develop`的分支并提交一个更改，如以下命令所示：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, let''s create a push `refspec` that will send the content of the `develop`
    branch to `integration/master` on origin:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个推送（push）`refspec`，将`develop`分支的内容推送到远程`integration/master`：
- en: '[PRE59]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s push our commit on `develop` as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将我们的提交推送到`develop`分支，如下所示：
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As the `integration/master` branch didn't exist on the remote side, it was created
    for us.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`integration/master`分支在远程端不存在，因此它为我们创建了该分支。
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The format of the `refspec` is in the form of `<source>:<destination>`. For
    a fetch `refspec`, this means that `<source>` is the source on the remote side
    and `<destination>` is `local`. For a push `refspec`, `<source>` is `local` and
    `<destination>` is `remote`. The `refspec` can be prefixed by a `+` to indicate
    that the `ref` pattern can be updated even though it isn''t a fast-forward update.
    It is not possible to use partial globs in the `refspec` pattern, as shown in
    the following line:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`refspec`的格式为`<source>:<destination>`。对于拉取（fetch）`refspec`，这意味着`<source>`是远程端的源，而`<destination>`是本地的。对于推送（push）`refspec`，`<source>`是本地的，`<destination>`是远程的。`refspec`可以通过`+`前缀来表示即使不是快进更新，`ref`模式也可以被更新。`refspec`模式中不能使用部分通配符，如以下行所示：'
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'However, it is possible to use namespacing. That''s why we had to rewrite the
    `stable-xxx` branches to `stable/xxx` to fit into a namespace pattern:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用命名空间是可能的。这就是为什么我们必须将`stable-xxx`分支重写为`stable/xxx`以符合命名空间模式的原因：
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
