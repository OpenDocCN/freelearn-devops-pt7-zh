- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Exploring Alternative Infrastructure-as-Code Tools
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索替代的基础设施即代码工具
- en: Welcome to the final chapter of our **Infrastructure as Code** (**IaC**) journey!
    By now, you should be familiar with the basics of IaC and have gained hands-on
    experience with Terraform and Ansible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们**基础设施即代码**（**IaC**）之旅的最后一章！到目前为止，你应该已经掌握了IaC的基础知识，并且获得了使用Terraform和Ansible的实践经验。
- en: 'As you progress in your career, being aware of and adept with tools in the
    market is crucial. This chapter aims to expand your IaC toolset by introducing
    you to three additional tools: **Pulumi**, **Azure Bicep**, and **AWS CloudFormation**.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你职业生涯的进展，了解并熟练使用市场上的工具至关重要。本章旨在通过介绍另外三种工具来扩展你的IaC工具集：**Pulumi**、**Azure Bicep**和**AWS
    CloudFormation**。
- en: While the previous tools we explored were cloud-agnostic, Azure Bicep and AWS
    CloudFormation are specific to their respective cloud providers. On the other
    hand, Pulumi sets itself apart by enabling you to use familiar programming languages
    such as Python to define and manage your infrastructure in actual code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们之前探讨的工具都是云平台无关的，但Azure Bicep和AWS CloudFormation是针对各自云服务提供商的工具。另一方面，Pulumi通过允许你使用熟悉的编程语言（如Python）来定义和管理基础设施，将自己与众不同，所有这些都通过实际的代码来实现。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting a hands-on understanding of Pulumi
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实践了解Pulumi
- en: Getting hands-on knowledge of Azure Bicep
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实践掌握Azure Bicep
- en: Getting hands-on expertise in AWS CloudFormation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实践掌握AWS CloudFormation
- en: Before discussing the next steps in your IaC journey, as we have a lot to cover
    in this chapter, let’s dive straight in and discuss Pulumi, which is, at the time
    of writing, the new kid on the block when it comes to IaC tools.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论你IaC之旅的下一步之前，由于本章内容较多，我们先深入讨论Pulumi，它是目前（截至本文写作时）在IaC工具中出现的新成员。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available here: [https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners-/tree/main/Chapter09](https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners-/tree/main/Chapter09).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在这里找到：[https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners-/tree/main/Chapter09](https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners-/tree/main/Chapter09)。
- en: Getting hands-on with Pulumi
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Pulumi进行实践操作
- en: '*So, what is Pulumi, and why has it yet to be mentioned up* *until now?*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，Pulumi是什么，它为何直到现在才被提及？*'
- en: Pulumi is an open source IaC platform that allows developers to define, provision,
    and manage cloud infrastructure; however, rather than using a descriptive language
    with YAML (Ansible) or HCL (Terraform), it allows you to use popular programming
    languages such as JavaScript, TypeScript, Python, Go, and C#, as well as YAML
    for non-programmers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Pulumi是一个开源的IaC平台，允许开发者定义、配置和管理云基础设施；然而，它并不像使用YAML（Ansible）或HCL（Terraform）那样使用描述性语言，而是允许你使用流行的编程语言，如JavaScript、TypeScript、Python、Go和C#，以及非程序员使用的YAML。
- en: With Pulumi, you can build, manage, and deploy IaC more familiarly and expressively,
    making it easier to reason about complex cloud architectures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pulumi，你可以更熟悉和直观地构建、管理和部署IaC，从而更容易理解复杂的云架构。
- en: Pulumi supports popular cloud providers such as AWS, Azure, and Google Cloud.
    There is also support for tools such as Kubernetes, among others, all of which
    enable you to define and manage resources across multiple platforms using a single
    tool.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Pulumi支持流行的云服务提供商，如AWS、Azure和Google Cloud。它还支持诸如Kubernetes等工具，所有这些都使你能够通过一个工具在多个平台上定义和管理资源。
- en: Great, you may be thinking to yourself – but why hasn’t it been mentioned until
    now?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，你可能在心里想——但是为什么直到现在它才被提及？
- en: The answer is that it should be considered something other than a beginner’s
    tool – given the number of different ways you can interact with it, it can be
    highly complex. It would require a dedicated book to do more than scratch the
    surface.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，它不应该被认为是一个初学者工具——鉴于你可以与之交互的方式有很多种，它可能会非常复杂。仅仅触及表面就需要一本专门的书籍。
- en: Information
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Links to the instructions on installing Pulumi can be found in the *Further
    reading* section at the end of this chapter if you would like to follow along.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟着本章内容一起操作，可以在本章末尾的*进一步阅读*部分找到安装Pulumi的相关说明链接。
- en: To give you an idea of how you would use Pulumi, let’s look at launching a few
    resources in Microsoft Azure, as we did in the early examples of Terraform and
    Ansible we covered; we will be creating a resource group and a storage account.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个使用Pulumi的概念，我们来看看如何在Microsoft Azure中启动一些资源，正如我们在早期示例中使用Terraform和Ansible所做的那样；我们将创建一个资源组和一个存储账户。
- en: We will start by using YAML and then look at the same deployment in Python.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用YAML，然后再看用Python实现同样的部署。
- en: Using Pulumi and YAML
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Pulumi和YAML
- en: 'We have two files, both of which can be found in the GitHub repository accompanying
    this book. The first file, which defines some environment-specific configurations,
    is called `Pulumi.dev.yaml` and, for our example, contains the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个文件，这两个文件都可以在伴随本书的GitHub仓库中找到。第一个文件定义了一些特定环境的配置，名为`Pulumi.dev.yaml`，对于我们的示例，它包含以下代码：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, all we are doing is defining the default `location` to be used
    by the Azure Native provider.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们所做的就是定义默认的`location`，以供Azure Native提供者使用。
- en: 'The second of the two files is called `Pulumi.yaml`, and it starts by defining
    some information and settings for our project:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件中的第二个文件名为`Pulumi.yaml`，它开始时定义了一些关于我们项目的信息和设置：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first three lines, `name`, `runtime`, and `description`, all define some
    basic meta information about our deployment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行，`name`、`runtime`和`description`，都定义了我们部署的一些基本元信息。
- en: The following two lines define the output, which in our case will be the primary
    key of the storage account that will be created.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两行定义了输出，在我们的例子中，输出将是将要创建的存储账户的主密钥。
- en: Here, we are defining an output variable of `primaryStorageKey`, which is taking
    its value from a variable we will define at the end; this variable will contain
    the outpoint of a function we will be running once the storage account has been
    created.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`primaryStorageKey`的输出变量，它的值来自我们将在最后定义的一个变量；这个变量将包含我们在创建存储账户后运行的一个函数的输出。
- en: 'Now that we have the basics in place, let’s define the resources using a resource
    block, starting with the Azure Resource Group:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了基础设置，让我们通过一个资源块来定义资源，首先是Azure资源组：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this is not too dissimilar structurally from Terraform and Ansible
    – here, we are defining a resource that will be referred to as `resourceGroup`,
    which has a type of `azure-native:resources:ResourceGroup`, before finally setting
    a single property that contains the `resourceGroupName` key.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从结构上看，这与Terraform和Ansible并没有太大不同——在这里，我们定义了一个将被称为`resourceGroup`的资源，它的类型为`azure-native:resources:ResourceGroup`，然后最后设置一个包含`resourceGroupName`键的单一属性。
- en: 'Now that the Resource Group has been defined, we can add the storage account
    resource, which we are going to refer to as `sa`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在资源组已经定义，我们可以添加存储账户资源，我们将其称为`sa`：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, it follows the same pattern as before; we set the resource reference
    and the type of resource we want to create and then define our `properties`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，它遵循之前的相同模式；我们设置资源引用和我们想要创建的资源类型，然后定义我们的`properties`。
- en: In this case, rather than the name of the resource, which Pulumi will create
    for us, we are passing in a `sku` name, the kind of storage account we want to
    create (via `kind`), and the `resourceGroupName` key to add the resource.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，代替由Pulumi为我们创建的资源名称，我们传入的是`sku`名称、我们想要创建的存储账户类型（通过`kind`），以及用于添加资源的`resourceGroupName`键。
- en: To do this, we must use the `${resourceGroup.name}` variable, which takes the
    name of the resource group we referenced as `resourceGroup`. Like in Terraform,
    this ensures that the resource group is created before the storage account.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们必须使用`${resourceGroup.name}`变量，该变量取的是我们作为`resourceGroup`引用的资源组的名称。像Terraform一样，这可以确保在创建存储账户之前，资源组已被创建。
- en: The final part of the `Pulumi.yaml` file sets the `storageAccountKeys` variable,
    which is used by the output section we start at the start of the file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pulumi.yaml`文件的最后部分设置了`storageAccountKeys`变量，它将被我们在文件开始时定义的输出部分所使用。'
- en: 'To do this, we need to define a `variables` section:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要定义一个`variables`部分：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we are setting the function (`fn`), which is an `azure-native` one that
    deals with `storage` and is called `listStorageAccountKeys`. It requires two inputs
    – `accountName`, which we pass in using `${sa.name}` and, as most things need
    in Azure, the `resourceGroupName` key. So, as before, we pass this in programmatically
    by using the `${``resourceGroup.name}` variable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了一个函数（`fn`），它是一个 `azure-native` 函数，用于处理 `storage`，并且名为 `listStorageAccountKeys`。它需要两个输入——`accountName`，我们通过
    `${sa.name}` 传递它，以及在 Azure 中大多数情况下需要的 `resourceGroupName` 键。所以，和之前一样，我们通过使用 `${``resourceGroup.name}`
    变量以编程方式传递这个值。
- en: 'Now that we have all of the code, let’s launch the resources. To do this, we
    need to issue the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有所有代码，接下来让我们启动这些资源。为此，我们需要执行以下命令：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is where things get a little different than Terraform and Ansible; the
    first thing that happens is that you are asked to log in, as shown in the following
    screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的过程与 Terraform 和 Ansible 有些不同；首先发生的事情是，你会被要求登录，如以下截图所示：
- en: '![Figure 9.1 – Running Pulumi up for the first time](img/Figure_9.01_B19537.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 第一次运行 Pulumi](img/Figure_9.01_B19537.jpg)'
- en: Figure 9.1 – Running Pulumi up for the first time
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 第一次运行 Pulumi
- en: 'Follow the onscreen prompts and press the *Enter* key to be taken to the login
    page. Here, you can sign up or log in using one of the many supported identity
    providers; I used GitHub. Once you have logged in or signed up, you should get
    the option to create a stack:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随屏幕上的提示，按下 *Enter* 键进入登录页面。在这里，你可以使用支持的身份提供者之一进行注册或登录；我使用了 GitHub。登录或注册后，你应该会看到创建堆栈的选项：
- en: '![Figure 9.2 – Time to create a stack](img/Figure_9.02_B19537.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 创建堆栈的时间](img/Figure_9.02_B19537.jpg)'
- en: Figure 9.2 – Time to create a stack
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 创建堆栈的时间
- en: 'Once you have created your stack, Pulumi will run a check against your code
    and give you the option to deploy the update. In this case, this is going to create
    three resources – the two in Azure and our output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了堆栈，Pulumi 将对你的代码进行检查，并为你提供部署更新的选项。在这种情况下，这将创建三个资源——两个在 Azure 中，另一个是我们的输出：
- en: '![](img/Figure_9.03_B19537.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_9.03_B19537.jpg)'
- en: Figure 9.3 – Should we run the update?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 我们是否要运行更新？
- en: 'If you use the arrow keys to select **yes** and then hit the *Enter* key, Pulumi
    will deploy the resources:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用箭头键选择**是**，然后按下 *Enter* 键，Pulumi 将部署资源：
- en: '![Figure 9.4 – The deployment has been completed](img/Figure_9.04_B19537.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 部署已完成](img/Figure_9.04_B19537.jpg)'
- en: Figure 9.4 – The deployment has been completed
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 部署已完成
- en: 'As shown in the preceding output, we have the output (which I have blurred
    out the value of) and an overview of the deployment. The eagle-eyed among you
    may have also noticed a URL – clicking on it opens an overview of the deployment
    in your browser. For me, this looked like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，我们有输出（我已模糊了其中的值）和部署概览。眼尖的你们可能已经注意到一个 URL——点击它会在浏览器中打开部署概览。对我来说，它看起来是这样的：
- en: '![Figure 9.5 – Viewing the deployment in a browser](img/Figure_9.05_B19537.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 在浏览器中查看部署](img/Figure_9.05_B19537.jpg)'
- en: Figure 9.5 – Viewing the deployment in a browser
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 在浏览器中查看部署
- en: 'I recommend having a look around your stack in the browser. Once you have finished,
    you can remove the resources by running the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在浏览器中查看一下你的堆栈。完成后，你可以通过运行以下命令来删除资源：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will remove the Azure resources but not the stack on the Pulumi website.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除 Azure 资源，但不会删除 Pulumi 网站上的堆栈。
- en: Now, let’s look at deploying the same resources again, but instead of using
    YAML, we will use Python.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次看看如何部署相同的资源，不过这次我们将使用 Python，而不是 YAML。
- en: Using Pulumi and Python
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Pulumi 和 Python
- en: This, as you may have already guessed, is where things start to get a little
    more advanced.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜测的，这也是事情开始变得稍微复杂的地方。
- en: 'In the repository that accompanies the book, you will find several files; these
    are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书随附的仓库中，你会找到几个文件，具体如下：
- en: '`.gitignore`: This contains entries for the `venv` and `__pycache__` folders,
    which we do not need to check into version control'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.gitignore`：此文件包含 `venv` 和 `__pycache__` 文件夹的条目，我们不需要将这些内容检查到版本控制中'
- en: '`__main__.py`: This is the main Python code; we will cover this in more detail
    shortly'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__main__.py`：这是主要的 Python 代码，我们稍后会详细讲解'
- en: '`Pulumi.dev.yaml`: This contains the environment config and has the same contents
    as we used YAML rather than Python'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pulumi.dev.yaml`：此文件包含环境配置，并且其内容与我们使用 YAML 而非 Python 时的内容相同'
- en: '`Pulumi.yaml`: This contains the basic metadata for our deployment'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pulumi.yaml`：它包含我们部署的基本元数据。'
- en: '`requirements.txt`: Like most Python scripts, there are external dependencies;
    this file lists these so that they can be installed using `pip`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requirements.txt`：像大多数 Python 脚本一样，这里有外部依赖项；此文件列出了这些依赖项，以便通过 `pip` 安装。'
- en: 'Let’s start by looking at the `requirements.txt` file. As mentioned, this contains
    the dependencies needed to run our Python code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看 `requirements.txt` 文件开始。如前所述，它包含了运行 Python 代码所需的依赖项：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, there are just two dependencies – Pulumi and the Azure Native
    provider.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，只有两个依赖项——Pulumi 和 Azure Native 提供程序。
- en: 'As already mentioned, we have the `Pulumi.yaml` file. Even though we are using
    Python, it contains the basic information and settings for the project:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们有 `Pulumi.yaml` 文件。尽管我们使用的是 Python，但它包含了项目的基本信息和设置：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, `runtime` is now `python`, and some settings define the folder
    where the Python virtual environment (`virtualenv`) will be stored. In our case,
    this is `venv` and is in the same folder as the rest of our project files.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`runtime` 现在是 `python`，一些设置定义了 Python 虚拟环境（`virtualenv`）的存储文件夹。在我们的案例中，它是
    `venv`，并且与项目的其他文件位于同一文件夹中。
- en: 'The final file is the `__main__.py` file and is where our resources are defined.
    The first part of the file imports the Python libraries needed to deploy the resources:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的文件是 `__main__.py` 文件，它定义了我们的资源。文件的第一部分导入了部署资源所需的 Python 库：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, of the two dependencies defined in the `requirements.txt` file,
    we are importing all of the `pulumi` library; however, `storage` and `resources`
    from the `pulumi_azure_native` library as the Resource Group and storage account,
    respectively, are the only two resources that we are launching. Therefore, we
    do not need to load the entire library.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在 `requirements.txt` 文件中定义的两个依赖项中，我们导入了整个 `pulumi` 库；然而，来自 `pulumi_azure_native`
    库的 `storage` 和 `resources` 作为资源组和存储帐户，是我们启动的唯一两个资源。因此，我们不需要加载整个库。
- en: 'Next up, we must define the Resource Group:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义资源组：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I wouldn’t call myself a Python programmer – I know enough to be dangerous and
    run the basics – but I am sure you will agree that the code looks simple enough.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会称自己是 Python 程序员——我知道足够的知识来做一些简单的事情——但我相信你会同意代码看起来足够简单。
- en: 'Now, let’s define the storage account:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义存储帐户：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, it is a little different from what we dealt with when defining our infrastructure
    in YAML or HCL.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，它与我们在定义基础设施时使用 YAML 或 HCL 时略有不同。
- en: But again, it is simple enough to follow what is going on within the code, mainly
    as we have already deployed this same project using Pulumi and YAML.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但再次说明，跟随代码的逻辑还是相当简单的，主要是因为我们已经使用 Pulumi 和 YAML 部署了相同的项目。
- en: 'This also means you should have an idea of what is coming up next – that is,
    the function to grab the storage account key:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着你应该对接下来要做的事情有一个大致的了解——即获取存储帐户密钥的函数：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is where things turn a little more into a traditional Python script; it
    is still relatively straightforward to follow what is going on but if, like me,
    you are not a Python developer, you may find it a little more challenging to write
    the preceding code from scratch.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是事情变得有点像传统 Python 脚本的地方；虽然跟随代码的逻辑相对直接，但如果你像我一样不是 Python 开发者，可能会觉得从零开始编写前面的代码有点挑战。
- en: 'Let’s try deploying the code. To do this, we simply use the same command as
    before:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试部署代码。为此，我们只需要使用与之前相同的命令：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will notice some differences when you first run the command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到第一次运行命令时有一些不同：
- en: '![Figure 9.6 – Installing the dependencies](img/Figure_9.06_B19537.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 安装依赖项](img/Figure_9.06_B19537.jpg)'
- en: Figure 9.6 – Installing the dependencies
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 安装依赖项
- en: As you may have already guessed, first, the dependencies defined in the `requirements.txt`
    file must be installed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，首先，必须安装在 `requirements.txt` 文件中定义的依赖项。
- en: 'Once our dependencies have been installed, we drop back to the same options
    as we were presented with when we deployed the YAML version of the project:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的依赖项安装完成，我们就回到与之前部署 YAML 版本项目时相同的选项：
- en: '![Figure 9.7 – Back in familiar territory](img/Figure_9.07_B19537.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 回到熟悉的领域](img/Figure_9.07_B19537.jpg)'
- en: Figure 9.7 – Back in familiar territory
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 回到熟悉的领域
- en: Again, you get a URL to view your stack on the Pulumi website, and you can terminate
    the resources by running the `pulumi` `destroy` command.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你将获得一个 URL 来查看你的堆栈，并且可以通过运行 `pulumi` `destroy` 命令来终止这些资源。
- en: So, why do this?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要这样做呢？
- en: Most of the audience for this book, I imagine, comes from an operations or system
    administration background rather than a programming one – this means you are more
    familiar with working with configuration files of all types and understand the
    steps you need to take to deploy your infrastructure.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我想本书的大部分读者可能来自运维或系统管理的背景，而非编程背景——这意味着你更熟悉处理各种配置文件，并了解部署基础设施时需要采取的步骤。
- en: Pulumi aims to appeal to people from that background as well as developers by
    offering them a way of defining their infrastructure in a language that is familiar
    to them; as you may recall from the start of this section, JavaScript, TypeScript,
    Python, Go, and C# are all supported.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Pulumi 旨在通过提供一种使用开发人员熟悉的语言定义基础设施的方式，吸引那些有相关背景的人以及开发人员；正如你从本节开始时可能记得的，JavaScript、TypeScript、Python、Go
    和 C# 都受支持。
- en: Another advantage is that you can move your IaC into your existing build and
    deployment pipelines. For example, let’s say you have a mature C# build, test,
    and deployment workflow. If you are using Pulumi, you should be able to introduce
    your IaC into the process quickly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优势是，你可以将 IaC 纳入现有的构建和部署流水线中。例如，假设你有一个成熟的 C# 构建、测试和部署工作流。如果你使用 Pulumi，应该能够快速将
    IaC 引入到这个流程中。
- en: As mentioned at the start of this section, we have yet to begin to unlock the
    power of Pulumi in this section – but I am sure you will agree that it opens up
    many possibilities when approaching your IaC deployments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节开始时提到的，我们还没有开始揭开 Pulumi 的强大功能——但我相信你会同意，当你开始处理 IaC 部署时，它为你提供了许多可能性。
- en: Now that we have looked at the last of the cloud-agnostic tools, let’s look
    at the two cloud-native tools before we finish.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过最后一个云无关的工具，让我们在结束之前看一看这两个云原生工具。
- en: Getting hands-on knowledge of Azure Bicep
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亲手体验 Azure Bicep
- en: '**Azure Bicep** is the first of the two cloud-specific IaC tools we will be
    looking at in this chapter. For quite a while, if you wanted to use the native
    tool provided by Microsoft, you would need to write an ARM template.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure Bicep** 是我们将在本章中讨论的两个云特定 IaC 工具中的第一个。很长一段时间，如果你想使用微软提供的本地工具，你需要编写 ARM
    模板。'
- en: When we discussed Microsoft Azure in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*, we stated that ARM is short for Azure Resource
    Manager – that is, the API that powers all of Azure. You will have been using
    ARM when using the Azure portal, command-line tools, PowerShell, or any IaC tool
    we have covered to launch or manage your Microsoft Azure resources.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 [*第 4 章*](B19537_04.xhtml#_idTextAnchor151) 中讨论 Microsoft Azure 时，*部署到
    Microsoft Azure*，我们提到 ARM 是 Azure Resource Manager 的缩写——也就是说，它是驱动所有 Azure 功能的
    API。当你使用 Azure 门户、命令行工具、PowerShell 或我们已经讨论过的任何 IaC 工具来启动或管理 Microsoft Azure 资源时，你其实已经在使用
    ARM 了。
- en: The best way I can think to describe ARM templates is that they are the JSON
    payloads that are sent to the API – I won’t include an example of what an ARM
    template looks like as there is a lot of it, but I have included an example file
    called `arm-template-example.json` in the same folder as the Bicep file in the
    accompanying repository. As you can see, there is a lot of it; the file is just
    short of 120 lines of code – and all that does is define a storage account.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为描述 ARM 模板的最佳方式是，它们是发送到 API 的 JSON 负载——我不会包括 ARM 模板的示例，因为内容很多，但我已经在与 Bicep
    文件同一文件夹中的附带仓库里提供了一个名为 `arm-template-example.json` 的示例文件。如你所见，它的内容非常多；文件将近 120
    行代码——而这些代码的作用只是定义一个存储帐户。
- en: So, now that we have provided a quick explanation of ARM templates, let’s look
    at Bicep.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经快速解释了 ARM 模板，那就让我们来看看 Bicep。
- en: Bicep is a `main.bicep`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Bicep 是一个 `main.bicep` 文件。
- en: Working through the Bicep file
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 Bicep 文件
- en: 'The first part of our Bicep code sets the parameters, of which we are going
    to set three up, starting with the type of storage account we will be launching:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Bicep 代码的第一部分设置了参数，其中我们将设置三个参数，第一个是我们将要启动的存储帐户类型：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, here, we provide an array of the `allowed` possible values before
    defining a parameter (`param`) called `storageAccountType` with a string value
    of `Standard_LRS`. This means that if we override the default parameter at runtime,
    it will only accept one of the allowed parameters rather than just any old string.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这里，我们在定义一个名为 `storageAccountType` 的参数（其字符串值为 `Standard_LRS`）之前，提供了一个 `allowed`
    的可能值数组。这意味着如果我们在运行时覆盖默认参数，它只会接受一个允许的参数，而不是任何一个随便的字符串。
- en: 'The second and third parameters are as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个参数如下：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The former sets the `location` parameter by inheriting the location of the
    Resource Group; we also use the ID of the Resource Group to generate a unique
    string for the storage account’s name:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前者通过继承资源组的位置来设置 `location` 参数；我们还使用资源组的 ID 来生成存储帐户名称的唯一字符串：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `uniqueString` function takes the Resource Group ID, which in itself is
    unique to your deployment, and uses that to generate a string. This means that
    you know a consistent string is being generated rather than a random string each
    time the Bicep code is executed. However, as it is based on the Resource Group
    ID that is unique to your deployment, you should never have two strings that are
    the same.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniqueString` 函数接受资源组 ID，它本身对于你的部署是唯一的，并利用这个 ID 生成一个字符串。这意味着你知道每次执行 Bicep
    代码时生成的是一致的字符串，而不是随机字符串。然而，由于它是基于你部署的唯一资源组 ID，所以你永远不可能有两个相同的字符串。'
- en: So, now that we have defined our three parameters, we can add the code to create
    the storage account resource.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了三个参数，我们可以添加代码来创建存储帐户资源。
- en: 'The block to do this looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作的代码块如下所示：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we are creating a `resource` block that is going to be referred to as
    `sa`; it uses the `Microsoft.Storage/storageAccounts@2022-09-01` API endpoint.
    We are also passing in the parameters for `name`, `location`, and `sku`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `sa` 的 `resource` 块，它将使用 `Microsoft.Storage/storageAccounts@2022-09-01`
    API 端点。我们还传入了 `name`、`location` 和 `sku` 的参数。
- en: 'The final two lines of code set some output, which is the storage account name
    and the ID:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两行代码设置了一些输出内容，包括存储帐户名称和 ID：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You may have noticed that’s something missing… have you guessed what it is?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到少了点什么……你猜到是什么了吗？
- en: Deploying the Bicep file
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 Bicep 文件
- en: 'If you guessed the following, then you would be correct:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你猜到以下内容，那么你是对的：
- en: “*Hang on a minute; we are referencing a Resource Group, but we are not defining
    a block* *for one.*”
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: “*等一下，我们引用了一个资源组，但我们没有定义一个* *用于该资源组的代码块*。”
- en: By default, both Bicep and ARM templates expect you to deploy into a resource
    rather than have one defined within the Bicep file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Bicep 和 ARM 模板都期望你将资源部署到现有资源中，而不是在 Bicep 文件中定义资源。
- en: Another thing that you may have noticed is that I haven’t given any instructions
    on how to install Azure Bicep.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到，我没有给出如何安装 Azure Bicep 的说明。
- en: 'The reason for this is that Bicep is built into the Azure CLI, which we will
    also use to create a resource group. Do this by running the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是 Bicep 已内置在 Azure CLI 中，我们也将使用它来创建资源组。通过运行以下命令来执行此操作：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When I ran the command, I got the following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行该命令时，得到了以下输出：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The command will create a resource group called `rg-bicep-example` in the UK
    South region, which we can now deploy our Bicep file into by running the following
    code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将在英国南部区域创建一个名为 `rg-bicep-example` 的资源组，我们现在可以通过运行以下代码将 Bicep 文件部署到该资源组中：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will output quite a bit of information, but the two import bits we are
    interested in are the outputs. For me, these looked like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出大量信息，但我们感兴趣的两个主要部分是输出结果。对我来说，这些看起来是这样的：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, `storageAccountId` and `storageAccountName` are visible.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`storageAccountId` 和 `storageAccountName` 是可见的。
- en: Important
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: The following command deletes the whole resource group and everything within
    it, so please be careful and only run if you want everything to be deleted.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将删除整个资源组及其内的所有内容，所以请小心，只有在你确实想删除所有内容时再执行。
- en: 'You can remove the resources we launched with Bicep by running the following
    command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令删除我们使用 Bicep 启动的资源：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Again, this section wasn’t planned to be a deep dive into Bicep; I wanted to
    give a basic example to show you how IaC tools are not just limited to the “big
    two” of Terraform and Ansible. We have yet to come close to scratching the surface
    of what is possible with Bicep.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，本节并不是为了深入探讨 Bicep；我想给出一个基本示例，向你展示基础设施即代码（IaC）工具不仅仅局限于 Terraform 和 Ansible
    这“两大工具”。我们甚至还没有触及到 Bicep 所能实现的所有可能性。
- en: Since Microsoft first launched the alpha release of Bicep in August 2020, it
    has quickly grown and become a first-class citizen within the Azure ecosystem;
    for example, all of the official Azure documentation now includes references to
    and examples of both ARM templates and Bicep code for launching and interacting
    with your Azure resources.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 自从微软在 2020 年 8 月发布 Bicep 的 alpha 版本以来，它迅速发展并成为 Azure 生态系统中的一等公民；例如，所有官方的 Azure
    文档现在都包含了有关 ARM 模板和 Bicep 代码的引用和示例，用于启动和与 Azure 资源交互。
- en: Also, as we have experienced, it is built directly into the Azure CLI, meaning
    you already have it at your disposal if you are already working with Microsoft
    Azure.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们所经历的，它直接内置在 Azure CLI 中，这意味着如果你已经在使用 Microsoft Azure，你已经可以使用它了。
- en: Before we discuss why you should use Bicep over one of the other tools, let’s
    look at the other cloud-native option – AWS CloudFormation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论为什么你应该使用 Bicep 而不是其他工具之前，让我们先看看另一个云原生选项——AWS CloudFormation。
- en: Getting hands-on with AWS CloudFormation
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亲自操作 AWS CloudFormation
- en: '**AWS CloudFormation** is a service provided by Amazon Web Services that enables
    you to manage and provision your AWS resources using templates.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**AWS CloudFormation** 是 Amazon Web Services 提供的一项服务，允许你使用模板管理和配置 AWS 资源。'
- en: Of all the tools we have looked at in this book, AWS CloudFormation is the oldest,
    with its original public release in May 2010\. Also, in the description, I described
    it as a service that uses templates – this all makes the approach slightly different
    than the other tools we have covered.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们本书中看到的所有工具中，AWS CloudFormation 是最老的，最初在 2010 年 5 月发布。此外，在描述中，我提到它是一个使用模板的服务——这使得它与我们所讨论的其他工具略有不同。
- en: CloudFormation uses JSON or YAML templates to describe your desired AWS resources
    and their configurations. These templates define a stack, which is a collection
    of related resources that can be created, updated, or deleted together.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation 使用 JSON 或 YAML 模板来描述你期望的 AWS 资源及其配置。这些模板定义了一个堆栈，堆栈是一个相关资源的集合，这些资源可以一起创建、更新或删除。
- en: It provides automatic rollback and drift detection capabilities to help you
    maintain the desired state of your infrastructure. CloudFormation can automatically
    revert to the previous working state if a stack update fails. Drift detection
    allows you to identify and correct discrepancies between the actual infrastructure
    and the desired state defined in the template.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了自动回滚和漂移检测功能，帮助你保持基础设施的期望状态。如果堆栈更新失败，CloudFormation 可以自动恢复到之前的工作状态。漂移检测允许你识别并修正实际基础设施与模板中定义的期望状态之间的差异。
- en: Also, before deploying a stack, you can estimate the cost of the resources defined
    in your template. Additionally, you can use tags to categorize and track costs
    associated with specific resources, projects, or environments.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在部署堆栈之前，你可以估算模板中定义的资源的成本。此外，你还可以使用标签对与特定资源、项目或环境相关的成本进行分类和追踪。
- en: We will look at deploying a single Amazon S3 bucket using both the AWS command
    line and the AWS Management Console.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 AWS 命令行和 AWS 管理控制台来部署一个单独的 Amazon S3 存储桶。
- en: AWS CloudFormation template
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS CloudFormation 模板
- en: First, let’s look at the template file we will be using. I prefer to use YAML
    over JSON as it is much easier to read and follow what is going on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一下我们将使用的模板文件。我更喜欢使用 YAML 而不是 JSON，因为它更容易阅读并理解发生了什么。
- en: The template we will be using is split into four small sections. The template
    is a small 20-line file; I have seen templates containing several hundred lines
    of code, so this is the most basic example we can use.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的模板分为四个小部分。模板是一个包含 20 行代码的小文件；我见过的模板有几百行代码，所以这是我们可以使用的最基本的示例。
- en: 'The start of the template contains some basic information, including a description
    of what the template does and which format to use:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的开始部分包含一些基本信息，包括模板的功能描述和使用的格式：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we must set some `Parameters`; in our case, this is just going to be
    `BucketName`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须设置一些 `Parameters`；在我们的例子中，这只会是 `BucketName`：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we have the resources, where we define our S3 bucket:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是资源部分，我们在这里定义我们的S3存储桶：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we must set an output that returns the name of the bucket we created:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须设置一个输出，返回我们创建的存储桶的名称：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, there are some differences in how parameters are referenced;
    I am not a fan of using syntax such as `!Ref BucketName` only because the other
    tools, all of which came after, use a similar way of referencing parameters/variables.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，参数引用的方式有所不同；我不太喜欢使用像`!Ref BucketName`这样的语法，因为其他后来的工具使用了类似的参数/变量引用方式。
- en: Now that we have our template, let’s look at using the AWS CLI to deploy the
    stack.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了模板，让我们看看如何使用AWS CLI部署堆栈。
- en: Using the AWS CLI to deploy
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AWS CLI进行部署
- en: 'The AWS CLI makes it easy to deploy our template. To deploy the S3 bucket,
    run the following command, making sure you update the name of the bucket at the
    end of the command to your own. This is because bucket names need to be unique:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI使得部署我们的模板变得容易。要部署S3存储桶，请运行以下命令，确保在命令末尾更新存储桶的名称为您自己的名称。这是因为存储桶名称需要是唯一的：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once deployed, you should get some output that looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成后，您应该会看到类似于以下的输出：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have just deployed the stack but not the resources – the stack, which is
    an AWS service, will be deploying those for you in the background.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚部署了堆栈，但没有部署资源——堆栈作为AWS服务，会在后台为您部署这些资源。
- en: 'To delete the stack we just launched and the resources managed by it, run the
    following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除刚刚启动的堆栈及其管理的资源，请运行以下命令：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s see what creating a stack in the AWS Management Console looks like.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在AWS管理控制台中创建堆栈是什么样的。
- en: Using the AWS Management Console to deploy
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AWS管理控制台进行部署
- en: Once logged into the AWS Management Console, go to CloudFormation and click
    the **Create** **stack** button.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到AWS管理控制台后，进入CloudFormation并点击**创建** **堆栈**按钮。
- en: 'The first step of creating a stack is to define your template. Since you already
    have one, ensure that **Template is ready** is selected. Then, select the **Upload
    a template file** option and press the **Choose file** button to upload your file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 创建堆栈的第一步是定义您的模板。由于您已经有了模板，请确保选中了**模板已准备好**。然后，选择**上传模板文件**选项，并点击**选择文件**按钮上传您的文件：
- en: '![Figure 9.8 – Completing step one](img/Figure_9.08_B19537.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 完成第一步](img/Figure_9.08_B19537.jpg)'
- en: Figure 9.8 – Completing step one
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 完成第一步
- en: 'The second step is to provide some details about the stack and update any parameters:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是提供有关堆栈的一些详细信息，并更新任何参数：
- en: '![Figure 9.9 – Entering details of the stack](img/Figure_9.09_B19537.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 输入堆栈的详细信息](img/Figure_9.09_B19537.jpg)'
- en: Figure 9.9 – Entering details of the stack
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 输入堆栈的详细信息
- en: Step three is where you configure options for the stack; here, you can define
    tags and permissions and control the actions taken should a deployment fail.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是配置堆栈的选项；在这里，您可以定义标签和权限，并控制如果部署失败时采取的措施。
- en: 'For our deployment, you can leave all of the options at their defaults – however,
    I recommend that you review them before clicking on the **Next** button to proceed
    to the final step:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的部署，您可以保持所有选项为默认值——不过，我建议您在点击**下一步**按钮进行最后一步之前，先审查一下这些选项：
- en: '![Figure 9.10 – Reviewing the stack options](img/Figure_9.10_B19537.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 审查堆栈选项](img/Figure_9.10_B19537.jpg)'
- en: Figure 9.10 – Reviewing the stack options
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 审查堆栈选项
- en: 'The final step is to review your stack before clicking the **Submit** button,
    triggering the stack’s creation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是审查您的堆栈，然后点击**提交**按钮，触发堆栈的创建：
- en: '![Figure 9.11 – Reviewing the deployment](img/Figure_9.11_B19537.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11 – 审查部署](img/Figure_9.11_B19537.jpg)'
- en: Figure 9.11 – Reviewing the deployment
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – 审查部署
- en: From here, you can review your resources. Once you have finished, clicking on
    **Delete** will remove the stack.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以查看您的资源。完成后，点击**删除**将删除该堆栈。
- en: 'One thing that you will have noticed is that there are some sample templates,
    as well as a template designer. Loading one of the samples into the designer gives
    you a graphical view of the template and a drag-and-drop interface that you can
    use to design your templates:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到有一些示例模板，以及一个模板设计器。将其中一个示例加载到设计器中，您可以看到模板的图形视图，并且可以使用拖放界面设计您的模板：
- en: '![Figure 9.12 – Designing your template](img/Figure_9.12_B19537.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 – 设计您的模板](img/Figure_9.12_B19537.jpg)'
- en: Figure 9.12 – Designing your template
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 设计您的模板
- en: As you can see, there are options to export your finished template as JSON or
    YAML; in our example, there are just over 700 lines of code in the YAML file.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有选项可以将完成的模板导出为 JSON 或 YAML；在我们的示例中，YAML 文件中有超过 700 行代码。
- en: This is the biggest reason you want to use the designer and AWS Management Console.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你想要使用设计器和 AWS 管理控制台的最大原因。
- en: AWS CloudFormation can quickly become very complex, and it doesn’t lend itself
    well to sitting in front of an empty file and starting to code – I find it very
    overwhelming.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CloudFormation 很容易变得非常复杂，它不太适合坐在空白文件前开始编写代码——我觉得这非常让人不知所措。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this final chapter, we looked at three additional IaC tools, all of which
    work slightly differently from the two primary tools we looked at in previous
    chapters. So, why would you choose these over Terraform or Ansible?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们介绍了三种额外的 IaC 工具，它们与我们在前几章中讨论的两个主要工具有所不同。那么，为什么你会选择这些工具而不是 Terraform
    或 Ansible 呢？
- en: In [*Chapter 2*](B19537_02.xhtml#_idTextAnchor085), *Ansible and Terraform beyond
    the Documentation*, we concluded that you should choose the best tool for the
    job rather than trying to fit your project to the tool; the same goes for the
    tools we have discussed in this chapter.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B19537_02.xhtml#_idTextAnchor085)《超越文档的 Ansible 和 Terraform》中，我们得出结论，应该为任务选择最合适的工具，而不是试图将项目适配到工具上；这同样适用于本章中我们讨论的工具。
- en: When planning your IaC project, having an excellent working knowledge of more
    than one tool is always a bonus; throughout this book, there have been occasions
    when either Terraform or Ansible hasn’t supported a task we were trying to perform,
    so we had to use the built-in tools that provide support for the target cloud’s
    API.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划你的 IaC 项目时，熟练掌握多种工具总是一个加分项；在本书中曾多次出现过 Terraform 或 Ansible 无法支持我们尝试执行的任务的情况，因此我们不得不使用提供目标云
    API 支持的内建工具。
- en: If you have a project in Azure, for example, where coverage for the latest services
    in the tools may be behind by several months, then using Azure Bicep may be the
    best choice as you know you are exclusively targeting Azure; Bicep has day 1 support
    for 99.9% of all new Azure services.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个 Azure 项目，而这些工具对最新服务的支持可能会滞后几个月，那么使用 Azure Bicep 可能是最佳选择，因为你知道自己仅针对
    Azure；Bicep 对 99.9% 的所有新 Azure 服务提供第一天支持。
- en: Likewise, you may have to work alongside developers who want to bring your deployments
    into their existing processes and procedures; therefore, using Pulumi may be more
    suitable than introducing one of the other tools.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可能需要与开发人员一起工作，他们希望将你的部署集成到他们现有的流程和程序中；因此，使用 Pulumi 可能比引入其他工具更合适。
- en: So, what should your immediate next steps be?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你接下来的步骤应该是什么？
- en: Suppose you have access to a lab or a free cloud account. In that case, I recommend
    choosing a typical deployment and working through the steps covered in the first
    three chapters to define your project and then execute your IaC project.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个实验室或免费的云账户。那时，我建议选择一个典型的部署，并通过前面三章中的步骤来定义你的项目，然后执行你的 IaC 项目。
- en: Before starting, ensure you know what your end deployment will look like and
    how it needs to be configured. From there, you should be able to break it down
    into tasks, which will give you an idea of the dependencies.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，确保你知道最终部署将是什么样子，以及它需要如何配置。从那里，你应该能够将其分解为任务，这将帮助你了解依赖关系。
- en: Once you have an idea of the tasks and dependencies, this should allow you to
    work out the order in which the tasks would need to be executed – this is where
    you should choose which tool to use. However, you shouldn’t do this before as
    you need to know if you need a decorative or imperative tool and you must know
    the compatibility and service support each tool would need for your deployment
    to succeed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了任务和依赖关系，这将帮助你确定任务需要执行的顺序——在这一步你应该选择使用哪个工具。然而，你不应该在这之前做出选择，因为你需要知道自己是需要一个声明式工具还是命令式工具，并且你必须了解每个工具在部署成功所需的兼容性和服务支持。
- en: Once you know what it is you are deploying, in which order, and using which
    tool, you can open a blank file and start to write your code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道自己要部署什么、以何种顺序部署以及使用哪个工具，你就可以打开一个空白文件开始编写代码。
- en: I recommend writing some code and doing a test deployment – to deal with any
    issues – and then terminating the resources once you have resolved the problem.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议编写一些代码并进行测试部署——以解决任何问题——然后在解决问题后终止资源。
- en: Do not leave it to the end to try and debug your code. Also, ensure that when
    you do test deployments, you remove them – otherwise, you may end up introducing
    dependency issues into your deployments as resources may already exist, and therefore
    any issues or errors within your code may not reveal themselves.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 不要等到最后才尝试调试你的代码。同时，确保在进行测试部署时删除它们——否则，你可能会在部署过程中引入依赖问题，因为资源可能已经存在，因此代码中的任何问题或错误可能不会显现出来。
- en: Expect a lot of trial and error, especially if you are new to IaC deployments.
    Many considerations may not be completely apparent if you are used to deploying
    resources using the Azure portal or AWS Management Console, as these interfaces
    take a lot of the heavy lifting from you and do quite a bit of work in the background
    to make the process of launching your resources as smooth as possible.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 预计会有很多反复试验，特别是如果你是首次进行 IaC 部署的话。如果你习惯通过 Azure 门户或 AWS 管理控制台部署资源，许多考虑因素可能不太明显，因为这些接口已经为你做了大量工作，在后台处理了许多任务，目的是使资源启动过程尽可能平滑。
- en: Finally, once you have something up and running, make sure you show as many
    people as possible, give them access to your code if appropriate – show them it
    being deployed, try and sell them on the benefits of taking an IaC approach to
    their projects, and be as supportive as possible.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦你有了运行中的系统，确保让尽可能多的人看到，适当时给予他们访问你的代码的权限——展示部署过程，尝试向他们推销将 IaC 方法应用到他们项目中的好处，并尽量提供支持。
- en: Thank you for allowing me to accompany you on this journey; I wish you every
    success with your projects.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢你让我陪伴你度过这个过程；祝你在项目中取得成功。
- en: Further reading
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Pu[lumi:](https://www.pulumi.com/docs/get-started/install/)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Pu[lumi:](https://www.pulumi.com/docs/get-started/install/)
- en: '[Download and installation instructions:](https://www.pulumi.com/docs/get-started/install/)
    https://www.pulumi.com/docs/get-started/install/'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[下载和安装说明：](https://www.pulumi.com/docs/get-started/install/) https://www.pulumi.com/docs/get-started/install/'
- en: 'Getting started with Azure: [https://www.pulumi.com/docs/get-started/azure/](https://www.pulumi.com/docs/get-started/azure/)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Azure：[https://www.pulumi.com/docs/get-started/azure/](https://www.pulumi.com/docs/get-started/azure/)
- en: 'Getting started with AWS: [https://www.pulumi.com/docs/get-started/aws/](https://www.pulumi.com/docs/get-started/aws/)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 AWS：[https://www.pulumi.com/docs/get-started/aws/](https://www.pulumi.com/docs/get-started/aws/)
- en: 'Importing your infrastructure and converting your existing IaC: [https://www.pulumi.com/docs/guides/adopting/](https://www.pulumi.com/docs/guides/adopting/)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入你的基础设施并转换现有的基础设施即代码（IaC）：[https://www.pulumi.com/docs/guides/adopting/](https://www.pulumi.com/docs/guides/adopting/)
- en: 'Azure Bicep:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Bicep：
- en: 'Bicep overview: [https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep](https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bicep 概述：[https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep](https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep)
- en: 'Download and install: [https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/install](https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/install)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载并安装：[https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/install](https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/install)
- en: 'Learn Bicep Live: [https://learn.microsoft.com/en-us/events/learn-events/learnlive-iac-and-bicep/](https://learn.microsoft.com/en-us/events/learn-events/learnlive-iac-and-bicep/)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Bicep 实时课程：[https://learn.microsoft.com/en-us/events/learn-events/learnlive-iac-and-bicep/](https://learn.microsoft.com/en-us/events/learn-events/learnlive-iac-and-bicep/)
- en: 'AWS CloudFormation:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CloudFormation：
- en: 'Product page: [https://aws.amazon.com/cloudformation/](https://aws.amazon.com/cloudformation/)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品页面：[https://aws.amazon.com/cloudformation/](https://aws.amazon.com/cloudformation/)
- en: 'Full documentation: [https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整文档：[https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html)
