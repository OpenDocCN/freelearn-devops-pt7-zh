- en: Git Fundamentals - Working Remotely
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git基础 - 使用远程仓库
- en: In the previous chapter, we learned a lot about Git; we learned how it works
    internally and how to manage a local repository, but now it's time to learn how
    to share our goodies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了很多关于Git的知识；我们了解了Git的内部工作原理以及如何管理本地仓库，但现在是时候学习如何共享我们的代码了。
- en: 'In this chapter, we finally start to work in a distributed manner, using remote
    servers as a contact point for different developers. These are the main topics
    we will focus on:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们终于开始以分布式的方式工作，使用远程服务器作为不同开发者之间的联络点。我们将关注以下主要内容：
- en: Dealing with remotes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理远程仓库
- en: Cloning a remote repository
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆远程仓库
- en: Working with online hosting services, such as GitHub
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在线托管服务，例如GitHub
- en: 'As we said before, Git is a distributed version control system: this chapter
    concerns the *distributed* part.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，Git是一个分布式版本控制系统：本章涉及的是*分布式*部分。
- en: Working with remotes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用远程仓库
- en: Git is a tool for versioning files, as you know, but it has been built with
    collaboration in mind. In 2005, Linus Torvalds had the need for a light and efficient
    tool to share the Linux kernel code, allowing him and hundreds of other people
    to work on it without going crazy; the pragmatism that guided its development
    gave us a very robust layer for sharing data among computers, without the need
    of a central server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Git是一个文件版本控制工具，正如你所知道的，但它是为了协作而构建的。2005年，Linus Torvalds需要一个轻量且高效的工具来共享Linux内核代码，使他和其他几百人能够共同工作而不崩溃；这种务实的开发理念给我们带来了一个非常强大的数据共享层，不需要中央服务器。
- en: 'Basically, a Git **remote** is another "place" that has the same repository
    you have on your computer. As shown in the following image, you can think of it
    as different copies of the same repository that can exchange data between themselves:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Git的**远程仓库**是另一个“位置”，它拥有和你电脑上相同的仓库。如图所示，你可以将其视为同一仓库的不同副本，它们可以相互交换数据：
- en: '![](img/e86549ee-2280-4e74-9f98-ee6f972e265f.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e86549ee-2280-4e74-9f98-ee6f972e265f.png)'
- en: So, a remote Git repository is just a remote copy of the same Git repository
    we created locally; if you have access to that remote via common protocols such
    as SSH, the custom `git://` protocol, or other protocols, you can keep in sync
    your modification with it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，远程Git仓库只是我们在本地创建的Git仓库的远程副本；如果你通过SSH、`git://`协议或其他常见协议可以访问该远程仓库，你就可以与它同步修改。
- en: 'Even another folder in your computer can act as a remote: for Git, the filesystem
    is a *communication protocol* like any other, and you are allowed to use it if
    you like.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至你电脑上的另一个文件夹也可以充当远程仓库：对Git而言，文件系统就像任何其他*通信协议*，如果你愿意，可以使用它。
- en: This is what we will do to grasp the basic concepts about remotes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们掌握远程仓库基本概念的方法。
- en: Clone a local repository
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆本地仓库
- en: 'Create a new folder on your disk to clone our `grocery` repository:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的磁盘上创建一个新文件夹来克隆我们的`grocery`仓库：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then clone the `grocery` repository using the git clone command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`git clone`命令克隆`grocery`仓库：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Done.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。
- en: The dot `.` argument at the end of the command means *clone the repository in
    the current folder*, while the `~/grocery` argument is actually the path where
    Git has to look for the repository.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 命令末尾的点符号` .`参数意味着*将仓库克隆到当前文件夹*，而`~/grocery`参数实际上是Git查找仓库的路径。
- en: 'Now, go directly to the point with a `git log` command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，直接使用`git log`命令查看：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, other than the green `master` branch label, we have some red
    `origin/<branch>` labels on our log output.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，除了绿色的`master`分支标签，我们在日志输出中还看到一些红色的`origin/<branch>`标签。
- en: The origin
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: origin
- en: What is the *origin*?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是*origin*？
- en: 'Git uses origin as the default name of a remote. Like with `master` for branches,
    `origin` is just a convention: you can call remotes whatever you want.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Git默认将origin作为远程仓库的名称。就像分支的`master`一样，`origin`只是一个约定：你可以根据需要将远程仓库命名为任何你喜欢的名字。
- en: The interesting thing to note here is that Git, thanks to the `--all` option
    in the `git log` command, shows us that there are some more branches in the remote
    repository, but as you can see, they do not appear in the locally cloned one.
    In the cloned repository, there is only `master`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的地方需要注意，那就是Git通过`git log`命令中的`--all`选项，向我们展示了远程仓库中还有其他分支，但正如你所见，它们并没有出现在本地克隆的仓库中。在克隆的仓库中，只有`master`分支。
- en: 'But don''t worry: a local branch in which to work locally can be created by
    simply checking it out:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是不用担心：你可以通过简单地检出创建一个本地分支来进行本地工作：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Look at the message, Git says that a *local branch has been set up to track
    the remote* one; this means that, from now on, Git will actively track differences
    between the local branch and the remote one, notifying you of differences while
    giving you output messages (for example, while using the `git status` command).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 看看消息，Git 说*本地分支已设置为跟踪远程分支*；这意味着，从现在开始，Git 会主动跟踪本地分支与远程分支之间的差异，并在输出消息中通知你这些差异（例如，在使用
    `git status` 命令时）。
- en: Having said that, if you do a commit in this branch, you can send it to the
    remote and it will be part of the remote `origin/berries`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果你在这个分支上做一个提交，你可以将它发送到远程，它将成为远程 `origin/berries` 的一部分。
- en: This seems obvious, but, in Git, you can pair branches as you want; for example,
    you can track a remote `origin/foo` branch by a local `bar` branch, if you like.
    Alternatively, you can have local branches that simply don't exist on the remote.
    Later, we will look at how to work with remote branches.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来显而易见，但在 Git 中，你可以根据需要配对分支；例如，如果你愿意，可以通过本地的 `bar` 分支来跟踪远程的 `origin/foo` 分支。或者，你也可以有一些本地分支，它们在远程并不存在。稍后我们将看看如何处理远程分支。
- en: 'Now, look at the log again:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次查看日志：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now a green `berries` label appears, just near the red `origin/berries` one;
    this makes us aware that the local `berries` branch and remote `origin/berries`
    branch point to the same commit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个绿色的 `berries` 标签出现在靠近红色的 `origin/berries` 标签的位置；这让我们意识到，本地的 `berries` 分支和远程的
    `origin/berries` 分支指向相同的提交。
- en: What happens if I do a new commit?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我做了一个新的提交，会发生什么？
- en: 'Let''s try:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Your name and email address were configured automatically based on your *username*
    and *hostname*. Please check that they are accurate.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你的姓名和电子邮件地址已根据你的*用户名*和*主机名*自动配置。请检查它们是否准确。
- en: 'You can suppress this message by setting them explicitly:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过显式设置来抑制此消息：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After doing this, you may fix the identity used for this commit with the following
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，你可以通过以下代码修复此提交所使用的身份：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As in the previous chapter, Git warns me about author and email; this time I
    will go with the suggested ones.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章一样，Git 提示我关于作者和电子邮件的问题；这次我将使用建议的设置。
- en: 'OK, let''s see what happened:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看看发生了什么：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Nice! The local `berries` branch moved forward, while `origin/berries` is still
    in the same place.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！本地的 `berries` 分支向前推进，而 `origin/berries` 仍然停留在原地。
- en: Sharing local commits with git push
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 git push 分享本地提交
- en: As you may already know, Git works locally; there's no need for a remote server.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Git 在本地工作；不需要远程服务器。
- en: So, when you do a commit, it is available only locally; if you want to share
    it with a remote counterpart, you have to send it in some manner.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当你做一个提交时，它仅在本地可用；如果你想与远程对等体共享它，你必须以某种方式发送它。
- en: In Git, this is called **push**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 中，这叫做 **push**。
- en: 'Now, we will try to push the modifications in the `berries` branch to the `origin`;
    the command is `git push`, followed by the name of the remote and the target branch:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试将 `berries` 分支中的修改推送到 `origin`；命令是 `git push`，后跟远程名称和目标分支：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Wow! There is a lot of things in this output message. Basically, Git informed
    us about the operations it does before and during the sending of commits to the
    remote.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这个输出信息包含了很多内容。基本上，Git 在发送提交到远程之前和过程中向我们提供了操作的相关信息。
- en: 'Note that, as Git will send only the objects it knows are not present in the
    remote to the remote (three, in this case: a commit, a tree, and a blob), it will
    not send unreachable commits, nor other related unreachable objects (such as trees,
    blobs, or annotated that tighten only with unreachable commits).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Git 只会将它知道的远程不存在的对象（在这种情况下是三个：一个提交、一个树和一个 Blob）发送到远程，它不会发送无法访问的提交，也不会发送与无法访问的提交相关的其他对象（例如树、Blob
    或注释，这些对象仅与无法访问的提交相关）。
- en: 'Finally, Git tells us where it is sending objects, the destination, which in
    this case is just another folder on my computer: `To C:/Users/san/Google Drive/Packt/PortableGit/home/grocery`.
    It then tells the commit hash remote where the `origin/berries` originally was
    and the hash of the new tip commit, that is the same as the one in the local `berries`
    branch, `ef6c382..ab9f231`. Lastly, it gives the name of the two branches, the
    local and the remote branches, `berries -> berries`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Git 告诉我们它正在将对象发送到哪里，目标是我的计算机上的另一个文件夹：`To C:/Users/san/Google Drive/Packt/PortableGit/home/grocery`。然后，它告诉我们
    `origin/berries` 原本的位置的提交哈希值，以及与本地 `berries` 分支相同的新提交哈希值 `ef6c382..ab9f231`。最后，它给出了两个分支的名称，本地分支和远程分支，`berries
    -> berries`。
- en: 'Now, we obviously want to see if, in the remote repository, there is a new
    commit in the `berries` branch; so, open the `grocery` folder in a new console
    and do `git log`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们显然想查看在远程仓库中，`berries` 分支是否有新的提交；所以，打开 `grocery` 文件夹，在新的控制台中执行 `git log`：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Yes, wonderful!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，太棒了！
- en: 'Just a little warning: usually, a remote repository copy is managed as a **bare
    repository**; in [Chapter 4](406afcc0-b4a9-45b3-b238-a4d52873c9df.xhtml), *Git
    Fundamentals - Niche Concepts, Configurations, and Commands*, we will spend some
    words on it. As you normally won''t work directly on it, a bare repository contains
    only the `.git` folder; it doesn''t have a checked out working tree nor a HEAD
    reference. Instead, we use a normal repository as a remote. This is not a problem;
    you have just to remember one thing: you cannot push changes to the actual checked
    out remote branch.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 提个小提醒：通常，远程仓库副本被管理为 **裸仓库**；在[第4章](406afcc0-b4a9-45b3-b238-a4d52873c9df.xhtml)中，*Git
    基础 - 小众概念、配置与命令*，我们将对其做一些介绍。因为你通常不会直接在其上工作，裸仓库只包含 `.git` 文件夹；它没有已检出的工作树，也没有 HEAD
    引用。相反，我们使用一个普通仓库作为远程仓库。这并不是问题；你只需要记住一件事：你不能向实际检出的远程分支推送更改。
- en: In fact, in that `grocery` repository, we are actually on the `master` branch,
    and in the `grocery-cloned` repository, we push the `berries` branch.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在那个 `grocery` 仓库中，我们实际上是在 `master` 分支上，而在 `grocery-cloned` 仓库中，我们推送了 `berries`
    分支。
- en: 'The reason for this is quite simple to understand: by pushing to a remote checked
    out branch, you will affect the work in progress on that repository, maybe destroying
    ongoing changes, and this is not fair.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因非常简单易懂：通过推送到一个远程的已检出的分支，你会影响该仓库中的工作进展，可能会破坏正在进行的更改，这是不公平的。
- en: Getting remote commits with git pull
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 git pull 获取远程提交
- en: 'Now, it''s time to experiment the inverse: retrieving updates from the remote
    repository and applying them to our local copy.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候尝试相反的操作了：从远程仓库获取更新并将它们应用到我们的本地副本。
- en: 'So, make a new commit in the `grocery` repository, and then, we will download
    it into the `grocery-cloned` one:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在 `grocery` 仓库中做一个新的提交，然后我们将其下载到 `grocery-cloned` 仓库中：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I firstly need to create a new line, because due to the previous *grape rebase*,
    we ended having the `shoppinList.txt` file with no new line at the end, as `echo
    "" >> <file>` usually does:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先需要创建一个新行，因为由于之前的 *葡萄 rebase*，我们最终发现 `shoppinList.txt` 文件的末尾没有新的一行，这是 `echo
    "" >> <file>` 通常会做的事：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: OK, now back to the `grocery-cloned` repository.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在回到 `grocery-cloned` 仓库。
- en: We can retrieve objects from a remote with `git pull`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `git pull` 从远程获取对象。
- en: In truth, `git pull` is a *super command*; in fact, it is basically the sum
    of two other Git commands, `git fetch` and `git merge`. While obtaining objects
    from a remote, Git won't force you to merge them into a local branch; this can
    seem a little bit confusing at first, as in other versioning systems, such as
    Subversion, this is the default behavior.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`git pull` 是一个 *超级命令*；实际上，它基本上是另外两个 Git 命令 `git fetch` 和 `git merge` 的合成。在从远程获取对象时，Git
    不会强制你将它们合并到本地分支；这可能一开始会让人感到困惑，因为在其他版本控制系统中，如 Subversion，这是默认行为。
- en: 'Instead, Git is more conservative: it could happen that someone pushed a commit
    or more on top of a branch, but you realized those commits are not good for you,
    or simply they are just wrong. So, using `git fetch`, you can get and inspect
    them before applying them on your local branch with a `git merge`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Git 更加保守：可能有人在一个分支上推送了一个或多个提交，但你意识到这些提交对你来说不合适，或者它们根本就是错的。所以，通过使用 `git fetch`，你可以获取并检查这些提交，然后再通过
    `git merge` 将它们应用到你的本地分支上。
- en: Let's try `git pull` for now, then we will try to use `git fetch` and `git merge`
    separately.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在先尝试一下 `git pull`，然后我们会分别尝试使用 `git fetch` 和 `git merge`。
- en: 'Go back to the `grocery-cloned` repository, switch to the `master` branch,
    and do a `git pull`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `grocery-cloned` 仓库，切换到 `master` 分支，然后执行 `git pull`：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Git says that our branch is up-to-date with `'origin/master'`, but this is not
    true, as we just did a new commit there. This is because, for Git, the only way
    to know if we are updated in respect a remote repository is to perform a `git
    fetch`, and we didn't. Later we will see this more clearly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Git 说我们的分支与 `'origin/master'` 是最新的，但这并不是真的，因为我们刚刚在那里做了一个新的提交。这是因为，对于 Git 来说，唯一能知道我们是否已更新相对于远程仓库的方式是执行
    `git fetch`，而我们没有这么做。稍后我们将更加清楚地看到这一点。
- en: 'For now, go with `git pull`: the command wants you to specify the name of the
    remote you want to pull from, which is `origin` in this case, and then the branch
    you want to merge into your local one, which is `master`, of course:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，使用 `git pull`：该命令需要你指定要拉取的远程仓库名称，这里是 `origin`，然后是你想要合并到本地分支的分支，当然是 `master`：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Good! Git tells us that there are three new objects to fetch; after it has obtained
    them, it performs a merge on top of the local `master` branch, and in this case,
    it performs a fast-forward merge.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！Git 告诉我们有三个新的对象需要获取；在获取它们后，它会在本地 `master` 分支上执行合并，在这种情况下，它执行的是快进合并。
- en: 'OK, now I want you to try doing these steps in a separate manner; create the
    umpteenth new commit in the `grocery` repository, the `master` branch:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我想让你分开执行这些步骤；在 `grocery` 仓库的 `master` 分支上创建一个新的提交：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now perform a `git fetch` on `grocery-cloned` repository:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 `grocery-cloned` 仓库上执行 `git fetch`：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, Git found new objects on the remote, and it downloaded them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Git 在远程找到了新的对象，并下载了它们。
- en: Note that you can do a `git fetch` in whatever branch you are in, as it simply
    downloads remote objects; it won't merge them. Instead, while doing a `git pull`,
    you have to be sure to be in the right local target branch.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以在任何分支中执行 `git fetch`，因为它只是下载远程对象；它不会合并这些对象。而在执行 `git pull` 时，你必须确保自己处于正确的本地目标分支。
- en: 'Do a `git status` now:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行 `git status`：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: OK, as you can see, when there is a remote, `git status` informs you even on
    the state of the *synchronization* between your local repository and the remote
    one; here it tells us we are behind the remote because it has because it has one commit
    more than us in the `master` branch, and that commit can be fast-forwarded.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，正如你所见，当有远程仓库时，`git status` 会告诉你本地仓库与远程仓库之间的 *同步* 状态；在这里它告诉我们，我们落后于远程仓库，因为远程仓库的
    `master` 分支比我们多了一个提交，而这个提交可以通过快进合并。
- en: 'Now, let''s sync with a `git merge`; to merge a remote branch, we have to specify,
    other than the branch name, even the remote one, as we did in the `git pull` command
    previously:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过 `git merge` 进行同步；为了合并一个远程分支，我们必须指定分支名称和远程仓库名称，正如我们之前在 `git pull` 命令中所做的那样：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's all!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！
- en: This is basically what you need to know to work with remotes. Note that, if
    some changes on the remote are in conflict with the local ones, you will have
    to solve them as we did in the previous merge examples.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是你需要了解的远程仓库操作的全部内容。注意，如果远程仓库的某些更改与你本地的更改发生冲突，你需要像我们在前面的合并示例中一样解决这些冲突。
- en: How Git keeps track of remotes
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 如何跟踪远程仓库
- en: 'Git stores remote branch labels in a similar way to how it stores the local
    branches ones; it uses a subfolder in `refs` for the scope, with the symbolic
    name we used for the remote, in this case `origin`, the default one:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Git 以类似存储本地分支标签的方式存储远程分支标签；它在 `refs` 目录下为作用域创建一个子文件夹，并使用我们为远程仓库指定的符号名称，在这种情况下是
    `origin`，默认名称：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The command to deal with remotes is `git remote`; you can add, remove, rename,
    list, and do a lot of other things with them; there's no room here to see all
    the options. Please refer to the Git guide if you need to know more about the
    `git remote` command.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 处理远程仓库的命令是 `git remote`；你可以用它添加、删除、重命名、列出远程仓库，还可以做很多其他操作；这里没有空间展示所有选项。如果你需要了解更多关于
    `git remote` 命令的信息，请参考 Git 指南。
- en: Now, we will play a little bit with a remote on a public server; we will use
    free GitHub hosting for this purpose.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在公共服务器上玩一点远程仓库；我们将使用免费的 GitHub 托管服务。
- en: Working with a public server on GitHub
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 GitHub 上使用公共服务器
- en: To start working with a public hosted remote, we have to get one. Today, it
    is not difficult to achieve; the world has plenty of free online services offering
    room for Git repositories. One of the most commonly used is **GitHub**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用公共托管远程仓库，我们需要先获得一个。如今，实现这一点并不困难；世界上有许多免费的在线服务提供 Git 仓库空间，其中最常用的之一是 **GitHub**。
- en: Setting up a new GitHub account
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个新的 GitHub 账户
- en: GitHub offers unlimited free public repositories, so we can make use of it without
    investing a penny. In GitHub, you have to pay only if you need private repositories;
    for example, to store closed source code you base your business on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 提供无限的免费公共仓库，因此我们可以在不投入一分钱的情况下使用它。在 GitHub 上，只有需要私有仓库时才需要付费；例如，用于存储你基于其业务的闭源代码。
- en: 'Creating a new account is simple:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新账户很简单：
- en: Go to [https://github.com](https://github.com/).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://github.com](https://github.com/)。
- en: 'Sign up, filling the textboxes, as per the following image, and provide a username,
    a password, and your email:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下图片填写文本框，提供用户名、密码和你的电子邮件来注册：
- en: '![](img/88f28145-6321-46de-a694-06d66c0b087b.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88f28145-6321-46de-a694-06d66c0b087b.png)'
- en: 'When done, we are ready to create a brand new repository in which to push our
    work:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以创建一个全新的仓库，将我们的工作推送到其中：
- en: '![](img/b0e47506-62c7-4fc3-8433-322436fbf9c1.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0e47506-62c7-4fc3-8433-322436fbf9c1.png)'
- en: 'Go to the Repositories tab, click the green New button, and choose a name for
    your repository, as you can see in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 转到“Repositories”标签页，点击绿色的“New”按钮，并为你的仓库选择一个名称，如下截图所示：
- en: '![](img/290ff070-b9e4-4385-8fc0-ac91f4953974.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/290ff070-b9e4-4385-8fc0-ac91f4953974.png)'
- en: 'For the purpose of learning, I will create a simple repository for my personal
    recipes, written using the **markdown markup language** ([http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/)):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习的目的，我将创建一个简单的个人食谱仓库，使用**Markdown 标记语言**编写（[http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/)）：
- en: '![](img/06dd1613-78b2-49db-b3aa-9c19dd509dc0.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06dd1613-78b2-49db-b3aa-9c19dd509dc0.png)'
- en: Then, you can write a description for your repository; this is useful for allowing
    people that come to visit your profile to better understand what your project
    is intended for. We create our repository as public because private repositories
    have a cost, as we said before, and then we initialize it with a `README` file;
    choosing this, GitHub makes a first commit for us, initializing the repository
    that now is ready to be cloned.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以为仓库编写描述；这有助于让访问你个人资料的人更好地了解你的项目用途。我们创建的是公共仓库，因为私有仓库有费用，正如我们之前所说的，然后我们初始化时选择了一个`README`文件；选择这一项时，GitHub
    会为我们进行第一次提交，初始化仓库，现在它已准备好进行克隆。
- en: Cloning the repository
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆仓库
- en: Now that we have a remote repository, it's time to *hook* it locally. For this,
    Git provides the `git clone` command, as we have already seen.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了一个远程仓库，是时候将它*挂载*到本地了。为此，Git 提供了`git clone`命令，正如我们已经看到的那样。
- en: 'Using this command is quite simple; in this case, all we need to know is the
    URL of the repository to clone. The URL is provided by GitHub on the right down
    part of the repository home page:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令很简单；在这种情况下，我们需要知道的唯一信息就是要克隆的仓库 URL。这个 URL 由 GitHub 提供，在仓库主页的右下方：
- en: '![](img/0ff5ab15-8bf0-43da-863e-5d64b80fbe74.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ff5ab15-8bf0-43da-863e-5d64b80fbe74.png)'
- en: To copy the URL, you can simply click the clipboard button at the right of the
    textbox.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制 URL，你可以简单地点击文本框右侧的剪贴板按钮。
- en: 'So, let''s try to follow these steps together:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们一起尝试按以下步骤操作：
- en: Go to a local root folder for the repositories.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到本地仓库的根文件夹。
- en: Open a Bash shell within it.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中打开一个 Bash shell。
- en: Type `git clone https://github.com/fsantacroce/Cookbook.git`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`git clone https://github.com/fsantacroce/Cookbook.git`。
- en: 'Obviously, the URL of your repository will be different; as you can see, GitHub
    URLs are composed as follows: `https://github.com/<Username>/<RepositoryName>.git`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你的仓库 URL 会有所不同；正如你所看到的，GitHub 的 URL 形式如下：`https://github.com/<Username>/<RepositoryName>.git`：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At this point, Git creates a new `Cookbook` folder containing the downloaded
    copy of our repository; inside, we will find a `README.md` file, a classical one
    for a GitHub repository. In that file, you can describe your repository using
    the common markdown markup language to users who will chance upon it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Git 会创建一个新的`Cookbook`文件夹，其中包含我们仓库的下载副本；在里面，我们会找到一个`README.md`文件，这是一个经典的 GitHub
    仓库文件。在该文件中，你可以使用常见的 Markdown 标记语言描述你的仓库，供其他偶然访问的人使用。
- en: Uploading modifications to remotes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将修改上传到远程仓库
- en: 'So, let''s try to edit the `README.md` file and upload modifications to GitHub:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们尝试编辑`README.md`文件并将修改上传到 GitHub：
- en: Edit the `README.md` file using your preferred editor, adding, for example,
    a new sentence.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器编辑`README.md`文件，例如，添加一句新话。
- en: Add it to the index and then commit.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其添加到索引中，然后提交。
- en: Put your commit on the remote repository using the `git push` command.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`git push`命令将你的提交推送到远程仓库。
- en: 'But firstly, set the user and email this time, so Git will not output the message
    we have seen in the previous chapters:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，设置用户和电子邮件，这样 Git 就不会输出我们在前面章节看到的消息：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, try to type `git push` and press `ENTER`, without specifying anything
    else:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，试着输入`git push`并按下`ENTER`，无需指定其他内容：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, in my Windows 10 workstation, this window appears:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 Windows 10 工作站中，会出现如下窗口：
- en: '![](img/81e9d578-11b8-4fbc-b3c4-29c0eadd2ad8.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81e9d578-11b8-4fbc-b3c4-29c0eadd2ad8.png)'
- en: 'This is the **Git Credential Manager**; it allows you to set credentials on
    your Windows machine. If you are on Linux or macOS, the situation may be different,
    but the underlying concept is the same: we have to give Git the credentials in
    order to access the remote GitHub repository; they will then be stored to our
    system.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**Git凭证管理器**；它允许你在 Windows 机器上设置凭证。如果你使用的是 Linux 或 macOS，情况可能有所不同，但基本概念是一样的：我们必须给
    Git 提供凭证以访问远程的 GitHub 仓库；然后这些凭证将被存储到我们的系统中。
- en: 'Input your credentials, and then press the Login button; after that, Git continues
    with:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 输入你的凭证，然后按下登录按钮；之后，Git 会继续执行：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `git push` command allows you to *upload* local work to a configured remote
    location; in this case, a remote GitHub repository, as you can see in the following
    screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`git push`命令允许你将本地工作内容*上传*到配置的远程位置；在这种情况下，上传到一个远程的 GitHub 仓库，如下图所示：'
- en: '![](img/b4855a7b-154d-4736-99c2-65139bc5ec6c.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4855a7b-154d-4736-99c2-65139bc5ec6c.png)'
- en: There are a few more things we need know about pushing; we can begin to understand
    the message Git gave us just after we ran the `git push` command.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解更多关于推送的内容；我们可以开始理解在执行`git push`命令后 Git 给我们的信息。
- en: What do I send to the remote when I push?
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当我推送时，我会发送什么到远程仓库？
- en: When you give a `git push` without specifying anything else, Git sends all the
    **new commits** and all the related objects you did locally in your current branch
    to the remote; for *new commits*, it mean that we will send only local commits
    that have not been uploaded yet.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行一个没有指定其他内容的`git push`时，Git会将所有**新提交**以及你在当前分支本地做的所有相关对象发送到远程；对于*新提交*来说，意味着我们只会发送那些尚未上传的本地提交。
- en: Pushing a new branch to the remote
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将新分支推送到远程
- en: 'Obviously, we can create and push a new branch to the remote to make our work
    public and visible to other collaborators; for instance, I will create a new branch
    for a new recipe, then I will push to the remote GitHub server. Follow these simple
    steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以创建并将新分支推送到远程，使我们的工作对其他协作者公开可见；例如，我将为一个新食谱创建一个新分支，然后推送到远程的 GitHub 服务器。按照以下简单步骤操作：
- en: Create a new branch, for instance `Risotti`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新分支，例如`Risotti`。
- en: Add to it a new file, for example, `Risotto-alla-Milanese.md`, and commit it.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给它添加一个新文件，例如`Risotto-alla-Milanese.md`，然后提交。
- en: 'Push the branch to the remote using `git push -u origin Risotti`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`git push -u origin Risotti`命令将分支推送到远程仓库：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Before continuing, we have to examine in depth some things that happened after
    this `git push` command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要深入检查一些在执行`git push`命令后发生的事情。
- en: The origin
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: origin
- en: With the `git push -u origin Risotti` command, we told Git to upload our `Risotti`
    branch (and the commits within it) to the `origin`; with the `-u` option, we set
    the local branches to track the remote one.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`git push -u origin Risotti`命令，我们告诉 Git 将我们的`Risotti`分支（以及其中的提交）上传到`origin`；使用`-u`选项，我们设置本地分支以跟踪远程分支。
- en: We know that `origin` is the default remote of a repository, just as `master`
    is the default branch name; when you clone a repository from a remote, that remote
    becomes your `origin` alias. When you tell Git to push or pull something, you
    often have to tell it the remote you want to use; using the alias `origin`, you
    say to Git you want to use your default remote.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，`origin`是仓库的默认远程仓库，就像`master`是默认的分支名称一样；当你从远程克隆一个仓库时，那个远程仓库会变成你的`origin`别名。当你告诉
    Git 推送或拉取某些内容时，你通常需要指定你想使用的远程仓库；使用别名`origin`，你告诉 Git 你想使用默认的远程仓库。
- en: 'If you want to see remotes actually configured in your repository, you can
    type a simple `git remote` command, followed by `-v` (`--verbose`) to get some
    more details:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看在你的仓库中实际配置的远程仓库，可以输入简单的`git remote`命令，然后加上`-v`（`--verbose`）来获取更多细节：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the details, you will see the full URL of the remote and discover that Git
    stores two different URLs:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在详情中，你将看到远程仓库的完整 URL，并且发现 Git 存储了两个不同的 URL：
- en: The Fetch URL, which is where we take updates from others
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fetch URL，指的是我们从其他地方获取更新的地址
- en: The Push URL, which is where we send out updates to others
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Push URL，指的是我们将更新发送给其他人的地址
- en: This allows us to push and pull changes from different remotes, if you like,
    and underlines how Git can be considered a peer-to-peer versioning system.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们可以从不同的远程仓库推送和拉取更改，如果你愿意的话，并且强调了 Git 如何被认为是一个对等版本控制系统。
- en: You can add, update, and delete remotes using the `git remote` command.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`git remote`命令来添加、更新和删除远程仓库。
- en: Tracking branches
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪分支
- en: Using the `-u` option, we told Git to **track** the remote branch. Tracking
    a remote branch is *the way to tie your local branch with the remote one*; please
    note that this behavior is not automatic, you have to set it if you want it. When
    a local branch tracks a remote branch, you actually have a local and a remote
    branch that can be kept easily in sync (please note that a local branch can track
    only one remote branch). This is very useful when you need to collaborate with
    some remote coworkers at the same branch, allowing all of them to keep their work
    in sync with other people's changes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-u` 选项，我们告诉 Git **追踪**远程分支。追踪远程分支是 *将你的本地分支与远程分支关联起来的方式*；请注意，这种行为不是自动的，如果你想要它，你必须手动设置。当一个本地分支追踪一个远程分支时，实际上你有一个本地和一个远程分支，它们可以轻松同步（请注意，一个本地分支只能追踪一个远程分支）。这在你需要与远程同事在同一分支上协作时非常有用，可以让所有人保持自己的工作与其他人的更改同步。
- en: 'To better understand the way our repository is now configured, try to type
    `git remote show origin`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解我们当前仓库的配置方式，可以尝试输入 `git remote show origin`：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the `Pasta` **,** `Risotti`, and `master` branches are all tracked.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Pasta` **,** `Risotti` 和 `master` 分支都在被追踪。
- en: 'You see also that your local branches are configured to push and pull to remote
    branches with the same name, but remember: it is not mandatory to have local and
    remote branches with the same name; the local branch, `foo`, can track the remote
    branch, `bar`, and vice versa; there''s no restrictions.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到你的本地分支已配置为推送和拉取具有相同名称的远程分支，但请记住：本地和远程分支不需要具有相同的名称；本地分支 `foo` 可以追踪远程分支 `bar`，反之亦然；没有任何限制。
- en: Going backward – publishing a local repository to GitHub
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回退操作 – 将本地仓库发布到 GitHub
- en: Commonly, you will find yourself needing to put your local repository on a shared
    place where someone else can look at your work; in this section, we will learn
    how to achieve this purpose.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你会需要将本地仓库放置到一个共享的位置，以便其他人查看你的工作；在这一节中，我们将学习如何实现这个目的。
- en: 'Create a new local repository to publish, following these simple steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下简单步骤创建一个新的本地仓库进行发布：
- en: Go to our local repositories folder.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入我们的本地仓库文件夹。
- en: Create a new `HelloWorld` folder.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `HelloWorld` 文件夹。
- en: In it place a new repository, as we did in first chapter.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中创建一个新的仓库，像我们在第一章中做的那样。
- en: 'Add a new `README.md` file and commit it:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的`README.md`文件并提交：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, create the GitHub repository as we did previously; this time leave it
    empty. Don''t initialize it with a readme file; we already have one in our local
    repository. The following is a screenshot taken directly from the GitHub repository
    creation page:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，像我们之前一样创建 GitHub 仓库；这次将它留空，不要初始化 README 文件，因为我们已经在本地仓库中有一个。以下是直接从 GitHub
    仓库创建页面截取的截图：
- en: '![](img/abda2e4b-32cb-466c-8579-d53ae9113ba7.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abda2e4b-32cb-466c-8579-d53ae9113ba7.png)'
- en: At this point, we are ready to publish our local repository on GitHub or, even
    better, to add a remote to it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们准备好将本地仓库发布到 GitHub，或者更好地说，向其添加一个远程仓库。
- en: Adding a remote to a local repository
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向本地仓库添加远程仓库
- en: 'To publish our `HelloWorld` repository, we simply have to add its first remote;
    adding a remote is quite simple: `git remote add origin <remote-repository-url>`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发布我们的 `HelloWorld` 仓库，我们只需添加它的第一个远程仓库；添加远程仓库非常简单：`git remote add origin <remote-repository-url>`
- en: 'So, this is the full command we have to type in the Bash shell:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是我们需要在 Bash shell 中输入的完整命令：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Adding a remote, like adding or modifying other configuration parameters, simply
    consists of editing some text files in the `.git` folder, so it is blazing fast.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 向本地仓库添加远程仓库就像添加或修改其他配置参数一样，简单地编辑 `.git` 文件夹中的一些文本文件，所以速度非常快。
- en: Pushing a local branch to a remote repository
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将本地分支推送到远程仓库
- en: 'After that, push your local changes to the remote using `git push -u origin
    master`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用 `git push -u origin master` 将本地更改推送到远程：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That's all!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: Social coding - collaborating using GitHub
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社交编程 - 使用 GitHub 协作
- en: 'GitHub''s trademark is the concept of so-called **social coding**; from its
    first steps, GitHub made it easy to share code, track other people''s work, and
    collaborate using two basic concepts: **forks** and **pull requests**. In this
    section, I will illustrate them in brief.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 的商标就是所谓的 **社交编程** 概念；从一开始，GitHub 就让分享代码、跟踪他人工作以及使用两种基本概念进行协作变得简单：**分叉**
    和 **拉取请求**。在这一节中，我将简要说明它们。
- en: Forking a repository
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分叉一个仓库
- en: Forking is a common concept for a developer; if you have already used a GNU-Linux
    based distribution, you know that there are some forefathers, such as Debian,
    and some derived distro, such as Ubuntu, also commonly called *forks* of the original
    distribution.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 分叉是开发者常见的概念；如果你曾经使用过基于 GNU-Linux 的发行版，你就会知道有一些先驱者，比如 Debian，以及一些衍生发行版，比如 Ubuntu，这些通常被称为原始发行版的
    *fork*。
- en: 'In GitHub things are similar. At some point, you find an interesting open-source
    project you want to modify slight to perfectly fit your needs; at the same time,
    you want to benefit from bug fixes and new features from the original project,
    keeping your work in touch. The right thing to do in this situation is to *fork*
    the project. But first, remember: **fork is not a Git term**, but GitHub terminology.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 中也类似。某个时刻，你会发现一个你希望稍微修改、甚至完美契合你需求的有趣开源项目；同时，你还希望从原始项目中受益，获取 bug 修复和新功能，保持你的工作与原始项目的联系。在这种情况下，正确的做法是
    *fork* 该项目。但首先，请记住：**fork 并不是 Git 的术语**，它是 GitHub 的术语。
- en: 'When you fork on GitHub, what you get *is essentially a server-side clone of
    the repository* on your GitHub account; if you clone your forked repository locally,
    in the remote list, you will find an `origin` that points to your account repository,
    while the original repository will assume the *upstream* alias (you have to add
    it manually anyway):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 GitHub 上进行分叉时，*你实际上获得的是该仓库在你 GitHub 账户上的服务器端克隆*；如果你将分叉后的仓库克隆到本地，在远程列表中，你会看到一个指向你账户仓库的
    `origin`，而原始仓库则会使用 *upstream* 别名（反正你需要手动添加它）：
- en: '![](img/f40a810c-1bc9-47bb-a10e-590a4e3e615d.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f40a810c-1bc9-47bb-a10e-590a4e3e615d.png)'
- en: 'To better understand this feature, go to your GitHub account and try to fork
    a common GitHub repository called `Spoon-Knife`, made by GitHub mascot user `octocat`;
    so:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个功能，去你的 GitHub 账户并尝试分叉一个名为 `Spoon-Knife` 的常见 GitHub 仓库，它由 GitHub 吉祥物用户
    `octocat` 创建；所以：
- en: Log in to your GitHub account
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到你的 GitHub 账户
- en: Look for `spoon-knife` using the search textbox located up on the left of the
    page:![](img/903d4a2e-a861-4b04-b755-1e5b69a212ad.png)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位于页面左上方的搜索框搜索 `spoon-knife`：![](img/903d4a2e-a861-4b04-b755-1e5b69a212ad.png)
- en: Click on the first result, octocat/Spoon-Knife repository
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击第一个结果，octocat/Spoon-Knife 仓库
- en: 'Fork the repository using the Fork button at the right of the page:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用页面右侧的 Fork 按钮分叉仓库：
- en: '![](img/be37c6fd-ee2d-40c1-88d6-2a044217d435.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be37c6fd-ee2d-40c1-88d6-2a044217d435.png)'
- en: After a funny photocopy animation, you will get a brand-new Spoon-Knife repository
    in your GitHub account:![](img/d6a1bfda-c56b-43ce-9b96-1c2e38833649.png)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一次有趣的复印动画后，你将在 GitHub 账户中获得一个全新的 Spoon-Knife 仓库：![](img/d6a1bfda-c56b-43ce-9b96-1c2e38833649.png)
- en: 'Now, you can clone that repository locally, as we did before:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以像之前那样将该仓库克隆到本地：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see, the `upstream` remote is not present, you have to add it manually;
    to add it, use the `git remote add` command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`upstream` 远程并未出现，你需要手动添加它；要添加它，可以使用 `git remote add` 命令：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, you can keep your local repository in sync with the changes in your remote,
    the `origin`, and you can also get those ones coming from the `upstream` remote,
    the original repository you forked. At this point. you are probably wondering
    how to deal with two different remotes; well, it is easy: simply pull from the
    `upstream` remote and merge those modifications in your local repository, then
    push them into your `origin` remote in a bundle with your changes. If someone
    else clones your repository, he or she will receive your work merged with the
    work done by someone else on the original repository.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以保持本地仓库与远程仓库 `origin` 中的更改同步，同时你也可以获取来自 `upstream` 远程的更改，即你分叉的原始仓库的更改。此时，你可能会想知道如何处理两个不同的远程仓库；其实很简单：只需从
    `upstream` 远程拉取并将这些修改合并到本地仓库，然后将它们与你的更改一起推送到 `origin` 远程。如果其他人克隆了你的仓库，他或她将收到你的工作与其他人在原始仓库上所做工作的合并结果。
- en: Submitting pull requests
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交拉取请求
- en: If you created a fork of a repository, it is because you are not a direct contributor
    of the original project, or simply you don't want to make a mess in other people's
    work before becoming familiar with the code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个仓库的分叉，那是因为你不是原始项目的直接贡献者，或者你只是想在熟悉代码之前避免在他人的工作中做出干扰。
- en: 'However, at a certain point, you realize your work can be useful even for the
    original project: you realize a better implementation of a previous piece of code,
    you add a missing feature, and so on.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，某个时候，你意识到你的工作甚至对原始项目也有帮助：你实现了之前代码的更好版本，增加了缺失的功能，等等。
- en: So, you find yourself needing to notify the original author that you did something
    interesting, asking him if he wants to take a look and, maybe, integrate your
    work. This is the moment when **pull requests** come in handy.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你发现自己需要通知原作者你做了一些有趣的事情，询问他是否想看看，或者是否可能整合你的工作。这时，**拉取请求**就派上用场了。
- en: 'A pull request is a way to tell the original author *Hey! I did something interesting
    using your original code, do you want to take a look and integrate my work, if
    you find it good enough?* This is not only a technical way to achieve the purpose
    of integrating work, but it is even a powerful practice for promoting **code reviews**
    (and then the so-called *social coding*) as recommended by *eXtreme Programming*
    fellows (for more information, visit: [http://en.wikipedia.org/wiki/Extreme_programming](http://en.wikipedia.org/wiki/Extreme_programming)).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求是一种告诉原作者的方式，*嘿！我用你的原始代码做了一些有趣的事情，你想看看并整合我的工作吗，如果你觉得足够好？* 这不仅是一个技术手段来实现工作整合的目的，它甚至是一个推广**代码审查**（然后是所谓的*社交编程*）的强大实践，这种做法是*极限编程*（eXtreme
    Programming）倡导者推荐的（更多信息，请访问：[http://en.wikipedia.org/wiki/Extreme_programming](http://en.wikipedia.org/wiki/Extreme_programming)）。
- en: 'Another reason to use a pull request is that **you cannot push directly** to
    the `upstream` remote **if you are not a contributor** of the original project:
    pull requests are the only way. In small scenarios (such as a team of two or three
    developers that works in the same room) probably the *fork and pull* model represents
    an overhead, so it is more common to directly share the original repository with
    all the contributors, skipping the fork and pull ceremony.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用拉取请求的另一个原因是，**如果你不是原始项目的贡献者，你无法直接推送**到`upstream`远程仓库：拉取请求是唯一的方式。在一些小的场景下（比如一个由两三位开发人员组成的团队在同一房间工作），*分叉和拉取*模式可能显得有些额外开销，因此更常见的做法是直接与所有贡献者共享原始代码库，跳过分叉和拉取的过程。
- en: Creating a pull request
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个拉取请求
- en: To create a pull request, you have to go on your GitHub account and make it
    directly from your forked account; but first, you have to know that **pull requests
    can be made only from separated branches**. At this point of the book, you are
    probably used to creating a new branch for a new feature or refactor purpose,
    so this is nothing new, isn't it?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个拉取请求，你必须进入你的GitHub账户，并直接在你的分叉账户中创建；但首先，你需要知道**拉取请求只能从不同的分支创建**。到目前为止，你应该已经习惯了为新的特性或重构目的创建一个新分支，所以这并不算新鲜事，对吧？
- en: 'To make an attempt, let''s create a local `TeaSpoon` branch in our repository,
    commit a new file, and push it to our GitHub account:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行尝试，让我们在我们的代码库中创建一个本地的`TeaSpoon`分支，提交一个新文件，并推送到我们的GitHub账户：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you take a look at your account, you will find a surprise: in your `Spoon-Knife`
    repository, there is now a New pull request button made for the purpose of starting
    a pull request, as you can see in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看你的账户，你会发现一个惊喜：在你的`Spoon-Knife`代码库中，现在有一个“新建拉取请求”按钮，目的是启动一个拉取请求，如下图所示：
- en: '![](img/b0306886-7497-4f8e-a786-d28985c538ba.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0306886-7497-4f8e-a786-d28985c538ba.png)'
- en: 'Clicking that button makes GitHub open a new page; you now have to select the
    branch you want to compare to the original repository; look at the following screenshot:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 点击该按钮后，GitHub会打开一个新页面；现在你需要选择要与原始代码库进行比较的分支；请查看以下截图：
- en: '![](img/75b3eb4c-4364-41cf-9086-a633ecb5206d.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75b3eb4c-4364-41cf-9086-a633ecb5206d.png)'
- en: 'Go to the branches combo (1), select TeaSpoon branch (2), and then GitHub will
    show you something similar to the following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 转到分支选择框（1），选择`TeaSpoon`分支（2），然后GitHub会显示类似下面的截图：
- en: '![](img/032e325b-307a-4a93-a6bd-6a3d7e8fa421.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/032e325b-307a-4a93-a6bd-6a3d7e8fa421.png)'
- en: 'This is a report, where you can see what you are going to propose: a commit
    containing a new file.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个报告，你可以在其中看到你将要提议的内容：包含新文件的提交。
- en: But let me analyze the page.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我来分析一下这个页面。
- en: 'In the top left corner of the preceding screenshot, you will find what branches
    GitHub is about to compare for you; take a look at details in the following image:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图的左上角，你会看到GitHub正在为你比较哪些分支；请看下面的图片了解更多细节：
- en: '![](img/a9a033e7-155d-4c5f-bbf3-11e61eccd837.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9a033e7-155d-4c5f-bbf3-11e61eccd837.png)'
- en: 'This means that you are about to compare your local `TeaSpoon` branch with
    the original `master` branch of the `octocat` user. At the end of the page, you
    can see all the different details (files added, removed, changed, and so on):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你即将比较你本地的`TeaSpoon`分支与`octocat`用户的原始`master`分支。页面底部，你可以看到所有不同的细节（添加、删除、修改的文件等）：
- en: '![](img/99b0ef05-12dd-4830-b66d-a5241e17aabc.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99b0ef05-12dd-4830-b66d-a5241e17aabc.png)'
- en: 'Now, you can click on the green Create pull request button; the window in the
    following screenshot will appear:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以点击绿色的“创建拉取请求”按钮；以下截图中的窗口将会出现：
- en: '![](img/a5347094-ea35-4be5-a770-bf2922665f1d.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5347094-ea35-4be5-a770-bf2922665f1d.png)'
- en: In the central part of the page, you can describe the work you did in your branch.
    A green Able to merge text on the top left informs you that these two branches
    can be automatically merged (there are no unresolved conflicts; that is always
    good if you want to see your work considered).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面的中央部分，你可以描述你在分支上所做的工作。左上角的绿色“可以合并”文本通知你，这两个分支可以自动合并（没有未解决的冲突；如果你希望看到你的工作被采纳，这是非常好的）。
- en: 'And now the last step: click the Create pull request button to send your request
    to the original author, letting him get your work and analyze it before accepting
    the pull request.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后一步：点击“创建拉取请求”按钮，将你的请求发送给原始作者，让他接收你的工作并在接受拉取请求之前进行分析。
- en: At this point, a new conversation begins, where you and the project collaborators
    can start to discuss your work; during this period, you and other collaborators
    can change the code to better fit common needs, until an original repository collaborator
    decides to accept your request or discard it, closing the pull request.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，一个新的对话开始了，你和项目协作者可以开始讨论你的工作；在此期间，你和其他协作者可以修改代码，以更好地满足共同需求，直到原始仓库的协作者决定接受或丢弃你的请求，从而关闭拉取请求。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we finally got in touch with the Git ability to manage multiple
    remote copies of repositories. This gives you a wide range of possibilities to
    better organize your collaboration workflow inside your team. In the next chapter,
    you will learn some advanced techniques using well-known and niche commands. This
    will make you a more secure and proficient Git user, allowing you to resolve some
    common issues that occur in a developer's life with ease.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们终于接触到了Git管理多个远程仓库副本的能力。这为你提供了广泛的可能性，以更好地组织团队内部的协作工作流程。在下一章中，你将学习一些高级技巧，使用知名和小众的命令，这将使你成为一个更安全、更熟练的Git用户，轻松解决开发者生活中常见的问题。
