- en: Navigating Git
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航 Git
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Git's objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 的对象
- en: The three stages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个阶段
- en: Viewing the DAG
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看有向无环图（DAG）
- en: Extracting fixed issues
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取已修复的问题
- en: Getting a list of the changed files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取已更改文件的列表
- en: Viewing the history with gitk
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 gitk 查看历史
- en: Finding commits in the history
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找历史中的提交
- en: Searching through the history code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索历史代码
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will take a look at Git's data model. We will learn how
    Git references its objects and how the history is recorded. We will learn how
    to navigate the history, from finding certain text snippets in commit messages,
    to the introducing a particular string in the code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将深入了解 Git 的数据模型。我们将学习 Git 如何引用其对象以及历史如何记录。我们将学习如何导航历史，从查找提交消息中的特定文本片段，到引入代码中的特定字符串。
- en: 'The data model of Git is different from other common **version control systems**
    (**VCSs**) in the way Git handles its data. Traditionally, a VCS will store its
    data as an initial file, followed by a list of patches for each new version of
    the file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Git 的数据模型与其他常见的**版本控制系统**（**VCSs**）在数据处理方式上有所不同。传统上，VCS 会将数据存储为初始文件，接着是每个新版本文件的补丁列表：
- en: '![](img/36c11aeb-a197-4e01-bcfc-d9ad3d453752.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36c11aeb-a197-4e01-bcfc-d9ad3d453752.png)'
- en: 'Git is different: Instead of the regular file and patches list, Git records
    a snapshot of all the files tracked by Git and their paths relative to the repository
    root—that is, the files tracked by Git in the filesystem tree. Each commit in
    Git records the full tree state. If a file does not change between commits, Git
    will not store the file again. Instead, Git stores a link to the file. This is
    shown in the diagram below where you see how the files will be after every commit/version.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Git 的不同之处在于：Git 不像常规的文件和补丁列表那样，而是记录了 Git 跟踪的所有文件及其相对于仓库根目录的路径的快照——也就是说，Git 在文件系统树中跟踪的文件。Git
    中的每个提交都记录了完整的树状态。如果文件在提交之间没有变化，Git 不会重新存储该文件，而是存储该文件的链接。如下图所示，你可以看到每个提交/版本后文件的状态。
- en: '![](img/54662a83-7cbd-40b5-973b-dbf46a31cdd9.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54662a83-7cbd-40b5-973b-dbf46a31cdd9.png)'
- en: This is what makes Git different from most other VCSs, and, in the following
    chapters, we will explore some of the benefits of this powerful model.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Git 与大多数其他版本控制系统不同之处，在接下来的章节中，我们将探讨这种强大模型的一些好处。
- en: 'The way Git references files and directories is directly built into the data
    model. In short, the Git data model can be summarized as shown in the following
    diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Git 引用文件和目录的方式直接内建于数据模型中。简而言之，Git 的数据模型可以通过下图总结：
- en: '![](img/7a16ae26-fd8c-48f1-87b0-09b55e763323.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a16ae26-fd8c-48f1-87b0-09b55e763323.png)'
- en: The `commit` object points to the root tree. The root tree points to subtrees
    and files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`commit` 对象指向根树。根树指向子树和文件。'
- en: Branches and tags point to a `commit` object and the `HEAD` object points to
    the **branch** that is currently checked out. So, for every commit, the full tree
    state and snapshot are identified by the root tree.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 分支和标签指向一个 `commit` 对象，而 `HEAD` 对象指向当前检出的**分支**。因此，每个提交的完整树状态和快照由根树标识。
- en: Git's objects
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 的对象
- en: Now, since you know that Git stores every commit as a full tree state or snapshot,
    let's take a closer look at the object's Git store in the repository.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然你知道 Git 将每次提交存储为完整的树状态或快照，让我们仔细看看存储库中的 Git 对象存储。
- en: 'Git''s object storage is a key-value storage, the key being the ID of the object
    and the value being the object itself. The key is an SHA-1 hash of the object,
    with some additional information, such as size. There are four types of objects
    in Git, as well as branches (which are not objects, but which are important) and
    the special `HEAD` pointer that refers to the branch/commit currently being checked
    out. The four object types are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Git 的对象存储是一个键值存储，键是对象的 ID，值是对象本身。键是对象的 SHA-1 哈希值，包含一些额外的信息，如大小。Git 中有四种类型的对象，还有分支（虽然不是对象，但很重要）以及特殊的
    `HEAD` 指针，它指向当前检出的分支/提交。Git 中的四种对象类型如下：
- en: Files, or blobs as they are also called in the Git context
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件，或者在 Git 上下文中也叫做 blobs
- en: Directories, or trees in the Git context
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录，或在 Git 上下文中的树
- en: Commits
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交
- en: Tags
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: We will start by looking at the most recent `commit` object in the repository
    we just cloned, keeping in mind that the special `HEAD` pointer points to the
    branch that is currently being checked out.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看我们刚刚克隆的仓库中的最新 `commit` 对象开始，记住，特殊的 `HEAD` 指针指向当前检出的分支。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'To view the objects in the Git database, we first need a repository to be examined.
    For this recipe, we will clone an example repository in the following location:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Git 数据库中的对象，我们首先需要一个需要检查的仓库。对于这个实例，我们将克隆一个位于以下位置的示例仓库：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now you are ready to look at the objects in the database. We will start by looking
    first at the `commit` object, followed by the trees, the files, and finally, the
    branches and tags.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已准备好查看数据库中的对象。我们将首先查看 `commit` 对象，然后是 `tree`，文件，最后是分支和标签。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's take a closer look at the object's Git stores in the repository.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看仓库中对象的 Git 存储情况。
- en: The commit object
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`commit` 对象'
- en: 'The Git''s special `HEAD` object always points to the current snapshot/commit,
    so we can use that as the target for our request of the commit that we want to
    have a look at:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Git 的特殊 `HEAD` 对象始终指向当前的快照/提交，因此我们可以将其作为目标来查看我们想要检查的提交：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the subject line of the commit message. It should be followed by a blank
    line and then the body, which is this text. Here, you can use multiple paragraphs
    to explain your commit. It's like an email with a subject and a body to try to
    attract people's attention to the subject.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提交消息的主题行。它应该后跟一个空行，然后是正文，正文是这段文本。在这里，您可以使用多个段落来解释您的提交。它就像一封电子邮件，有主题和正文，目的是吸引人们的注意力。
- en: The `cat-file` command with the `-p` option prints the object given on the command
    line; in this case, `HEAD`, points to `master`, which, in turn, points to the
    most recent commit on the branch.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `-p` 选项的 `cat-file` 命令会打印命令行中给出的对象；在这种情况下，`HEAD` 指向 `master`，`master` 进一步指向该分支上的最新提交。
- en: We can now see the `commit` object, consisting of the root tree (`tree`), the
    parent `commit` object's ID (`parent`), the author and timestamp information (`author`),
    the committer and timestamp information (`committer`), and the commit message.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到 `commit` 对象，它由根 `tree`（`tree`）、父 `commit` 对象的 ID（`parent`）、作者和时间戳信息（`author`）、提交者和时间戳信息（`committer`）以及提交消息组成。
- en: The tree object
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`tree` 对象'
- en: 'To see the `tree` object, we can run the same command on the tree, but with
    the tree ID (`34fa038544bcd9aed660c08320214bafff94150b`) as the target:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `tree` 对象，我们可以对该 `tree` 运行相同的命令，但目标是该 `tree` 的 ID（`34fa038544bcd9aed660c08320214bafff94150b`）：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can also specify that we want the `tree` object from the commit pointed to
    by `HEAD` by specifying `git cat-file -p HEAD^{tree}`, which would give the same
    results as the previous command. The special notation `HEAD^{tree}` means that
    from the reference given, `HEAD` recursively dereferences the object at the reference
    until a `tree` object is found.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过指定`git cat-file -p HEAD^{tree}`来指定想要查看 `HEAD` 所指向提交的 `tree` 对象，这将与之前的命令给出相同的结果。特殊符号`HEAD^{tree}`表示从给定的引用中，`HEAD`
    会递归地解引用该引用所指向的对象，直到找到一个 `tree` 对象。
- en: The first `tree` object is the root `tree` object found from the commit pointed
    to by the `master` branch, which is pointed to by `HEAD`. A generic form of the
    notation is `<rev>^<type>`, and will return the first object of `<type>`, searching
    recursively from `<rev>`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `tree` 对象是从 `master` 分支指向的提交中找到的根 `tree` 对象，而 `HEAD` 也指向该分支。该符号的一般形式是 `<rev>^<type>`，它将递归查找
    `<rev>` 中的第一个 `<type>` 对象。
- en: 'From the `tree` object, we can see what it contains: the file type/permissions,
    type (`tree`/`blob`), ID, and pathname:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从`tree`对象中，我们可以看到它包含的内容：文件类型/权限、类型（`tree`/`blob`）、ID 和路径名：
- en: '| **Type/****Permissions** | **Type** | **ID/SHA-1** | **Pathname** |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **类型/****权限** | **类型** | **ID/SHA-1** | **路径名** |'
- en: '| 100644 | `blob` | `f21dc2804e888fee6014` `d7e5b1ceee533b222c15` | `README.md`
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 100644 | `blob` | `f21dc2804e888fee6014` `d7e5b1ceee533b222c15` | `README.md`
    |'
- en: '| 040000 | `tree` | `abc267d04fb803760b75` `be7e665d3d69eeed32f8` | `a_sub_directory`
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 040000 | `tree` | `abc267d04fb803760b75` `be7e665d3d69eeed32f8` | `a_sub_directory`
    |'
- en: '| 100644 | `blob` | `b50f80ac4d0a36780f9c` `0636f43472962154a11a` | `another-file.txt`
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 100644 | `blob` | `b50f80ac4d0a36780f9c` `0636f43472962154a11a` | `another-file.txt`
    |'
- en: '| 100644 | `blob` | `92f046f17079aa82c924` `a9acf28d623fcb6ca727` | `cat-me.txt`
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 100644 | `blob` | `92f046f17079aa82c924` `a9acf28d623fcb6ca727` | `cat-me.txt`
    |'
- en: '| 100644 | `blob` | `bb2fe940924c65b4a1ce` `fcbdbe88c74d39eb23cd` | `hello-world.c`
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 100644 | `blob` | `bb2fe940924c65b4a1ce` `fcbdbe88c74d39eb23cd` | `hello-world.c`
    |'
- en: The blob object
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`blob` 对象'
- en: 'Now, we can investigate the `blob` (file) object. We can do this using the
    same command, giving the `blob` ID as the target for the `cat-me.txt` file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看 `blob`（文件）对象。我们可以使用相同的命令，通过将 `blob` 的 ID 作为目标来查看 `cat-me.txt` 文件：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The content of the file is `cat-me.txt`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的内容是 `cat-me.txt`。
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is simply the content of the file, which we can also get by running a normal
    `cat cat-me.txt` command. So, the objects are tied together, blobs to trees, trees
    to other trees, and the root tree to the `commit` object, all connected by the
    SHA-1 identifier of the object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是文件的内容，我们也可以通过运行普通的`cat cat-me.txt`命令来获取。因此，这些对象是相互关联的，blob到树，树到其他树，根树到`commit`对象，所有的连接都通过对象的SHA-1标识符来实现。
- en: The branch object
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支对象
- en: 'The `branch` object is not really like any other Git objects; you can''t print
    it using the `cat-file` command as we can with the others (if you specify the
    `-p` pretty print, you''ll just get the `commit` object it points to), as shown
    in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`branch`对象并不像其他Git对象；你不能像其他对象一样通过`cat-file`命令打印它（如果你指定`-p`的漂亮打印选项，你只会得到它指向的`commit`对象），如下代码所示：'
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Instead, we can take a look at the branch inside the `.git` folder where the
    whole Git repository is stored. If we open the text file `.git/refs/heads/master`,
    we can actually see the commit ID that the `master` branch points to. We can do
    this using `cat`, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以查看`.git`文件夹中的分支，该文件夹存储着整个Git仓库。如果我们打开文本文件`.git/refs/heads/master`，就能看到`master`分支指向的提交ID。我们可以使用`cat`命令查看，方法如下：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can verify that this is the latest commit by running `git log -1`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行`git log -1`来验证这是否是最新的提交：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also see that `HEAD` is pointing to the active branch by using `cat`
    with the `.git/HEAD` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`cat`命令查看`.git/HEAD`文件，确认`HEAD`指向的是活动分支：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `branch` object is simply a pointer to a commit, identified by its SHA-1
    hash.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`branch`对象只是一个指向提交的指针，通过其SHA-1哈希值来标识。'
- en: The tag object
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签对象
- en: 'The last object to be analyzed is the `tag` object. There are three different
    kinds of tag: a lightweight (just a `label`) tag, an annotated tag, and a signed
    tag. In the example repository, there are two annotated tags:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要分析的对象是`tag`对象。`tag`有三种不同的类型：轻量标签（仅是一个`label`）、注释标签和签名标签。在示例仓库中，有两个注释标签：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s take a closer look at the `v1.0` tag:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来仔细看看`v1.0`标签：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the tag consists of an object—which, in this case, is the latest
    commit on the master branch—the object's type (commits, blobs, and trees can be
    tagged), the tag name, the tagger and timestamp, and finally the tag message.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，标签由一个对象组成——在这种情况下，是`master`分支上的最新提交——对象的类型（提交、blob和树都可以被标记）、标签名称、标签创建者和时间戳，最后是标签信息。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Git command `git cat-file -p` will print the object given as an input. Normally,
    it is not used in everyday Git commands, but it is quite useful to investigate
    how it ties the objects together.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Git命令`git cat-file -p`会打印作为输入的对象。通常，它不用于日常的Git命令中，但它在调查对象如何相互关联时非常有用。
- en: 'We can also verify the output of `git cat-file` by rehashing it with the Git
    command `git hash-object`; for example, if we want to verify the `commit` object
    at `HEAD` (`34acc370b4d6ae53f051255680feaefaf7f7850d`), we can run the following
    command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用Git命令`git hash-object`重新哈希来验证`git cat-file`的输出；例如，如果我们想验证`HEAD`上的`commit`对象（`34acc370b4d6ae53f051255680feaefaf7f7850d`），可以运行以下命令：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you see the same commit hash as `HEAD` pointing towards you, you can verify
    whether it is correct using `git log -1`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到的提交哈希与`HEAD`指向的哈希相同，可以通过`git log -1`来验证它是否正确。
- en: There's more...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: There are many ways to see the objects in the Git database. The `git ls-tree`
    command can easily show the content of trees and subtrees, and `git show` can
    show the Git objects, but in a different way.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Git数据库中的对象有很多种方法。`git ls-tree`命令可以轻松显示树和子树的内容，而`git show`则可以以不同的方式显示Git对象。
- en: The three stages
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三个阶段
- en: We have seen the different objects in Git, but how do we create them? In this
    example, we'll see how to create a `blob`, `tree`, and `commit` object in the
    repository. We'll also learn about the three stages of creating a commit.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过Git中的不同对象，那么我们如何创建它们呢？在这个示例中，我们将看到如何在仓库中创建`blob`、`tree`和`commit`对象。我们还将学习创建提交的三个阶段。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We''ll use the same `Git-Version-Control-Cookbook-Second-Edition` repository
    that we saw in the last recipe:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一个示例中的相同仓库`Git-Version-Control-Cookbook-Second-Edition`：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we''ll make a small change to the file and check `git status`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们对文件进行一个小修改，然后检查`git status`：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This, of course, just tells us that we have modified `another-file.txt` and
    we need to use `git add` to stage it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是告诉我们我们修改了`another-file.txt`，并且我们需要使用`git add`将其暂存。
- en: 'Let''s add the `another-file.txt` file and run `git status` again:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加`another-file.txt`文件并再次运行`git status`：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The file is now ready to be committed, just as you have probably seen before.
    But what happens during the `add` command? The `add` command, generally speaking,
    moves files from the working directory to the staging area; however, this is not
    all that actually happens, though you don't see it. When a file is moved to the
    staging area, the SHA-1 hash of the file is created and the `blob` object is written
    to Git's database. This happens every time a file is added, but if nothing changes
    for a file, it means that it is already stored in the database. At first, this
    might seem that the database will grow quickly, but this is not the case. Garbage
    collection kicks in at times, compressing, and cleaning up the database and keeping
    only the objects that are required.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，文件已经准备好提交，就像你可能之前看到的那样。但`add`命令到底发生了什么呢？一般来说，`add`命令会将文件从工作目录移动到暂存区；然而，这并不是唯一发生的事情，尽管你看不到。当文件被移到暂存区时，文件的SHA-1哈希值会被创建，并且`blob`对象会被写入Git的数据库。每次添加文件时都会发生这种情况，但如果文件没有发生变化，意味着它已经存储在数据库中。刚开始时，这看起来数据库会迅速增长，但实际情况并非如此。垃圾回收机制会定期启动，压缩并清理数据库，只保留需要的对象。
- en: 'We can edit the file again and run `git status`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以再次编辑文件并运行`git status`：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, the file shows up in both the `Changes to be committed` and `Changes not
    staged for commit` sections. This looks a bit weird at first, but there is, of
    course, a reason for this. When we added the file the first time, the content
    of it was hashed and stored in Git''s database. The changes arising from the second
    change to the file have not yet been hashed and written to the database; it only
    exists in the working directory. Therefore, the file shows up in both the `Changes
    to be committed` and `Changes not staged for commit` sections; the first change
    is ready to be committed, the second is not. Let''s also add the second change:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，文件同时出现在`待提交更改`和`未暂存的更改`部分。刚开始看起来有点奇怪，但当然是有原因的。当我们第一次添加文件时，它的内容被哈希并存储在Git的数据库中。第二次对文件所做的更改尚未被哈希并写入数据库；它仅存在于工作目录中。因此，文件会同时出现在`待提交更改`和`未暂存的更改`部分；第一次的更改已准备好提交，第二次的更改则没有。我们也来添加第二次更改：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, all the changes we have made to the file are ready to be committed, and
    we can record a commit:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们对文件所做的所有更改都已经准备好提交，我们可以记录一次提交：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'As we learned previously, the `add` command creates the `blob`, `tree`, and
    `commit` objects; however, they are also created when we run the `commit` command.
    We can view these objects using the `cat-file` command, as we saw in the previous
    recipe:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，`add`命令会创建`blob`、`tree`和`commit`对象；不过，当我们运行`commit`命令时，它们也会被创建。我们可以使用`cat-file`命令查看这些对象，正如我们在前面的方法中所看到的：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Making changes to another file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对另一个文件进行了更改。
- en: 'The `root-tree` object from the commit is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 提交中的`root-tree`对象如下所示：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From the previous recipe, we know that the SHA-1 of the root tree was `34fa038544bcd9aed660c08320214bafff94150b`
    and the SHA-1 of the `another-file.txt` file was `b50f80ac4d0a36780f9c0636f43472962154a11a`,
    and, as expected, they changed in our latest commit when we updated the `another-file.txt`
    file. We added the same file, `another-file.txt`, twice before we created the
    commit, recording the changes to the history of the repository. We also learned
    that the `add` command creates a blob object when called. So, in the Git database,
    there must have been an object similar to the content of `another-file.txt` the
    first time we added the file to the staging area. We can use the `git fsck` command
    to check for dangling objects—that is, objects that are not referred to by other
    objects or references:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的方法中我们知道，根树的SHA-1值是`34fa038544bcd9aed660c08320214bafff94150b`，`another-file.txt`文件的SHA-1值是`b50f80ac4d0a36780f9c0636f43472962154a11a`，并且如预期的那样，它们在我们更新`another-file.txt`文件时发生了变化。在我们创建提交之前，我们添加了同一个文件`another-file.txt`两次，将更改记录到版本库的历史中。我们还了解到，`add`命令会在调用时创建一个`blob`对象。因此，在Git数据库中，第一次将文件添加到暂存区时，应该已经存在一个类似于`another-file.txt`内容的对象。我们可以使用`git
    fsck`命令检查悬空对象——即没有被其他对象或引用所指向的对象：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s check the content of the blob using the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令检查`blob`对象的内容：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The blob was, as expected, similar to the content of `another-file.txt` when
    we added it to the staging area the first time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，当我们第一次将`another-file.txt`文件添加到暂存区时，`blob`对象的内容与文件内容相似。
- en: 'The following diagram describes the tree stages and the commands used to move
    between the stages:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示描述了树的各个阶段及用于在各阶段之间移动的命令：
- en: '![](img/8b8aecf9-b35d-4116-9a8d-ec4e9ed6f19c.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b8aecf9-b35d-4116-9a8d-ec4e9ed6f19c.png)'
- en: See also
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: For more examples and information on the `cat-file` and `fsck` commands, please
    consult the Git documentation at [https://git-scm.com/docs/git-cat-file](https://git-scm.com/docs/git-cat-file)
    and [https://git-scm.com/docs/git-fsck](https://git-scm.com/docs/git-fsck).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多关于 `cat-file` 和 `fsck` 命令的示例和信息，请查阅 Git 文档：[https://git-scm.com/docs/git-cat-file](https://git-scm.com/docs/git-cat-file)
    和 [https://git-scm.com/docs/git-fsck](https://git-scm.com/docs/git-fsck)。
- en: Viewing the DAG
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看 DAG
- en: The history in Git is formed from the `commit` objects; as development advances,
    branches are created and merged, and the history will create a directed acyclic
    graph, the DAG, because of the way that Git ties a commit to its parent commit.
    The DAG makes it easy to see the development of a project based on the commits.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Git 中的历史记录由 `commit` 对象构成；随着开发的推进，分支被创建和合并，历史记录将形成一个有向无环图（DAG），因为 Git 将提交与其父提交关联的方式。DAG
    使得通过提交轻松查看项目的开发进度。
- en: 'Please note that the arrows in the following diagram are dependency arrows,
    meaning that each commit points to its parent commit(s), which is why the arrows
    point in the opposite direction to the normal flow of time:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下图示中的箭头是依赖箭头，这意味着每个提交指向它的父提交，因此箭头的方向与时间流逝的正常方向相反：
- en: '![](img/77587a7b-661f-427c-9ce6-0a398888ed32.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77587a7b-661f-427c-9ce6-0a398888ed32.png)'
- en: A graph of the example repository with abbreviated commit IDs
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 示例仓库的图形，带有简化的提交 ID
- en: You can view the history (the DAG) in Git by using its `git log` command. There
    are also a number of visual Git tools that can graphically display the history.
    This section will show some features of `git log`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `git log` 命令查看 Git 中的历史记录（DAG）。也有一些可视化 Git 工具可以图形化地显示历史记录。本节将展示 `git
    log` 的一些功能。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the example repository from the last section and ensure that the
    master branch is pointing to `34acc37`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一节中的示例仓库，并确保 master 分支指向 `34acc37`：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the previous command, we only use the first seven characters (`34acc37`)
    of the commit ID; this is fine as long as the abbreviated ID that is used is unique
    in the repository.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们只使用提交 ID 的前七个字符（`34acc37`）；只要所使用的简化 ID 在仓库中是唯一的，这样做是没问题的。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The simplest way to see the history is to use the `git log` command; this will
    display the history in reverse chronological order. The output is paged through
    `less` and can be further limited, for example, by providing only the number of
    commits in the history to be displayed:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看历史的最简单方法是使用 `git log` 命令；这将以逆时间顺序显示历史记录。输出通过 `less` 分页显示，还可以进一步限制显示的内容，例如，通过提供要显示的提交数：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will display the following result:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将显示以下结果：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Turn on colors in the Git output by running `git config --global color.ui auto`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `git config --global color.ui auto` 来在 Git 输出中启用颜色。
- en: 'By default, `git log` prints the commit, author''s name and email ID, timestamp,
    and the commit message. However, the information isn''t very graphical, especially
    if you want to see branches and merges. To display this information and limit
    some of the other data, you can use the following options with `git log`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`git log` 会打印提交、作者的姓名和电子邮件 ID、时间戳以及提交信息。然而，这些信息并不是非常直观，尤其是当你想查看分支和合并时。要显示这些信息并限制其他一些数据，你可以使用以下选项与
    `git log` 一起使用：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The previous command will show one commit per line (`--oneline`), identified
    by its abbreviated commit ID, and the commit message subject. A graph will be
    drawn between the commits depicting their dependency (`--graph`). The `--decorate`
    option shows the branch names after the abbreviated commit ID, and the `--all`
    option shows all the branches, instead of just the current one(s):'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的命令将每行显示一个提交（`--oneline`），并用简化的提交 ID 和提交信息主题进行标识。提交之间将绘制一条图形，表示它们的依赖关系（`--graph`）。`--decorate`
    选项会在简化的提交 ID 后显示分支名称，`--all` 选项则显示所有分支，而不仅仅是当前分支：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This output, however, gives neither the timestamp nor the author information,
    because of the way the `--oneline` option formats the output.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个输出不会显示时间戳或作者信息，因为 `--oneline` 选项的格式化方式。
- en: 'Fortunately, the `log` command gives us the ability to create our own output
    format. So, we can make a history view similar to the previous one. The colors
    are made with the `%C<color-name>text-be-colored%Creset` syntax, along with the
    author and timestamp information and some colors to display it nicely:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，`log`命令使我们能够创建自己的输出格式。因此，我们可以制作一个类似于之前的历史视图。颜色使用`%C<color-name>text-be-colored%Creset`语法，并结合作者和时间戳信息以及一些颜色来漂亮地显示它：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![](img/0b832625-9acc-45ce-a2e9-41d088a5dad4.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b832625-9acc-45ce-a2e9-41d088a5dad4.png)'
- en: 'This is a bit cumbersome to write, but luckily, it can be made as an alias
    so you only have to write it once:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写起来有点麻烦，但幸运的是，它可以作为别名来简化，你只需要写一次：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, all you need to do is call `git graph` to show the history, as you have
    seen previously.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需调用`git graph`来显示历史记录，正如你之前看到的那样。
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Git traverses the DAG by following the parent IDs (hashes) from the given commit(s).
    The options passed to `git log` can format the output in different ways; this
    can serve several purposes—for example, to give a nice graphical view of the history,
    branches, and tags, as seen previously, or to extract specific information from
    the history of a repository to use, for example, in a script.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Git通过跟踪给定提交的父ID（哈希值）来遍历DAG。传递给`git log`的选项可以以不同方式格式化输出；这可以服务于多个目的——例如，像之前看到的那样，以漂亮的图形方式显示历史、分支和标签，或者提取仓库历史中的特定信息，供脚本使用等。
- en: Extracting fixed issues
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取已修复的问题
- en: 'A common use case of creating a release is to create a release note, containing,
    among other things, the bugs fixed in the release. A good practice is to write
    in the commit message whether a bug is fixed by the commit. A better practice
    is to have a standard way of doing this—for example, a line with the string `"Fixes-bug:
    "`, followed by the bug identifier in the last part of the commit message. This
    makes it easy to compile a list of bugs fixed for a release note. The JGit project
    is a good example of this; their bug identifier in the commit messages is a simple
    `"Bug: "` string followed by the bug ID.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '创建发布版本的常见用例是生成发布说明，其中包括修复的漏洞等内容。一个好的实践是，在提交信息中写明该提交是否修复了某个漏洞。更好的做法是采用标准化的方式来进行标记——例如，在提交信息的最后部分添加一行`"Fixes-bug:
    "`，后面跟上漏洞标识符。这使得我们能够轻松编译出修复的漏洞列表用于发布说明。JGit项目就是一个很好的例子，他们的提交信息中的漏洞标识符是简单的`"Bug:
    "`字符串，后面跟着漏洞ID。'
- en: This recipe will show you how to limit the output of `git log` to only list
    the commits since the last release (tag), which contains a bug fix.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将向你展示如何将`git log`的输出限制为仅列出自上次发布（标签）以来的、包含漏洞修复的提交。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Clone the JGit repository using the following command lines:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令行克隆JGit仓库：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you want the exact same output as in this example, reset your `master` branch
    to `b14a93971837610156e815ae2eee3baaa5b7a44b`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要和这个示例完全一样的输出，请将`master`分支重置为`b14a93971837610156e815ae2eee3baaa5b7a44b`：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: You are now ready to look through the commit log for commit messages that describe
    the bugs fixed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好查看提交日志，查找描述已修复漏洞的提交信息。
- en: 'First, let''s limit the log to only look through the history since the last
    tag (release). To find the last tag, we can use `git describe`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将日志限制为只查看上一个标签（发布）以来的历史记录。为了找到上一个标签，我们可以使用`git describe`：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding output tells us three things:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出告诉我们三件事：
- en: The last tag was `v3.1.0.201310021548-r`
  id: totrans-157
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一个标签是`v3.1.0.201310021548-r`
- en: The number of commits since the tag was `96`
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自该标签以来的提交数量是`96`
- en: The current commit in abbreviated form is `b14a939`
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的提交简写形式是`b14a939`
- en: 'Now, the log can be parsed from `HEAD` to `v3.1.0.201310021548-r`. But just
    running `git log 3.1.0.201310021548-r..HEAD` will give us all 96 commits, and
    we just want the commits with the commit messages that contain `"Bug: xxxxxx"`
    for our release note. The `xxxxxx` is an identifier for the bug, and will be a
    number. We can use the `--grep` option with `git log` for this purpose, making
    the code phrase `git log --grep "Bug: "`. This will give us all the commits containing `"Bug:
    "` in the commit message; all we need to do now is just to format it to something
    that we can use for our release note.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，日志可以从`HEAD`解析到`v3.1.0.201310021548-r`。但是仅仅运行`git log 3.1.0.201310021548-r..HEAD`将会返回所有96个提交，而我们只需要包含`"Bug:
    xxxxxx"`的提交信息来生成发布说明。`xxxxxx`是漏洞的标识符，将是一个数字。我们可以使用`--grep`选项和`git log`来达到此目的，形成代码片段`git
    log --grep "Bug: "`。这将返回所有提交信息中包含`"Bug: "`的提交；现在我们只需要将它格式化成可以用于发布说明的内容。'
- en: 'Now, let''s say we want the release note format to look like the following
    template:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们希望发布说明的格式如以下模板所示：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our command line so far is as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们的命令行如下：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This gives us all the bug fix commits, but we can format this to a format that
    is easily parsed with the `--pretty` option.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了所有修复 bug 的提交，但我们可以使用 `--pretty` 选项将其格式化为易于解析的格式。
- en: 'First, we will print the abbreviated commit ID (`%h`), followed by a separator
    of our choice (`|`), and then the commit subject (`%s`, the first line of the
    commit message), followed by a new line (`%n`), and the body (`%b`):'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将打印缩写的提交 ID（`%h`），后面是我们选择的分隔符（`|`），然后是提交主题（`%s`，提交消息的第一行），再加上一个新行（`%n`），以及正文（`%b`）：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The output, of course, needs to be parsed, but that's easy with regular Linux
    tools, such as `grep` and `sed`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，输出需要被解析，但这在常规的 Linux 工具如 `grep` 和 `sed` 中很容易实现。
- en: 'First, we just want the lines that contain `"|"` or `"Bug: "`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，我们只需要包含 `"|"` 或 `"Bug: "` 的行：'
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we replace these with `sed`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `sed` 替换这些：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The entire command put together is as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个命令如下所示：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The previous set of commands gives the following output:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面一组命令给出了以下输出：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, we can extract the bug information from the bug tracker and put the preceding
    code in the release note as well, if necessary.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果必要的话，我们可以从 bug 跟踪器中提取 bug 信息，并将上述代码放入发布说明中。
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'First, we limit the `git log` command to only show the range of commits we
    are interested in, and then we further limit the output by filtering the `"Bug:
    "` string in the commit message. We pretty print the string so we can easily format
    it to a style we need for the release note, and finally, find `"Bug: "` and replace
    it by `"Fixes-bug: "` using `grep` and `sed` to completely match the style of
    the release note.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们将 `git log` 命令限制为仅显示我们感兴趣的提交范围，然后进一步通过在提交消息中过滤 `"Bug: "` 字符串来限制输出。我们将字符串漂亮地打印出来，以便我们可以轻松地将其格式化为我们需要的发布说明样式，并最终使用
    `grep` 和 `sed` 找到 `"Bug: "` 并将其替换为 `"Fixes-bug: "`，以完全匹配发布说明的样式。'
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we just wanted to extract the bug IDs from the commit messages and didn''t
    care about the commit IDs, we could have just used `grep` after the `git log`
    command, still limiting the log to the last tag:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想从提交消息中提取 bug ID 而不关心提交 ID，我们可以在 `git log` 命令之后使用 `grep`，仍然将日志限制为最后一个标签：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we just want the commit IDs and their subjects, but not the actual bug IDs,
    we can use the `--oneline` feature of `git log` combined with the `--grep` option:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想获取提交 ID 和它们的主题，但不想获取实际的 bug ID，我们可以结合 `git log` 的 `--oneline` 功能和 `--grep`
    选项使用：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Getting a list of the changed files
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取已更改文件的列表
- en: As we saw in the previous recipe, where a list of fixed issues was extracted
    from the history, a list of all the files that have been changed since the last
    release can also easily be extracted. The files can be further filtered to find
    those that have been added, deleted, modified, and so on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一篇文章中看到的，从历史记录中提取到的固定问题列表，也可以轻松地提取出自上次发布以来已更改的所有文件列表。文件可以进一步过滤，以查找已添加、已删除、已修改等文件。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The same repository and `HEAD` position (`HEAD` pointing to `b14a939`) that
    we saw in the previous recipe will be used. The release is also the same, which
    is `v3.1.0.201310021548-r`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一篇文章中看到的相同仓库和 `HEAD` 位置（`HEAD` 指向 `b14a939`）将被使用。发布版本也相同，即 `v3.1.0.201310021548-r`。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following command lists all the files that have changed since the last
    release (`v3.1.0.201310021548-r`):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令列出自上次发布（`v3.1.0.201310021548-r`）以来已更改的所有文件：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `git diff` command operates on the same revision range as `git log` did
    in the previous recipe. By specifying `--name-only`, Git will only give the paths
    of the files that were changed by the commits in the range specified as output.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`git diff` 命令与前一篇文章中 `git log` 所做的相同的修订范围操作。通过指定 `--name-only`，Git 将仅将在指定范围内的提交更改的文件路径作为输出。'
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The output of the command can be further filtered: If we only want to show
    which files have been deleted in the repository since the last commit, we can
    use the `--diff-filter` switch with `git diff`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出可以进一步过滤：如果我们只想显示自上次提交以来在仓库中已删除的文件，我们可以使用 `git diff` 的 `--diff-filter` 开关：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There are also switches for the files that have been added (`A`), copied (`C`),
    deleted (`D`), modified (`M`), renamed (`R`), and so on.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 还有关于已添加 (`A`)、复制 (`C`)、删除 (`D`)、修改 (`M`)、重命名 (`R`) 等文件的开关。
- en: See also
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: For more information, visit the Help page by running the `git help diff` command.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请通过运行`git help diff`命令访问帮助页面。
- en: Viewing the history with gitk
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用gitk查看历史
- en: We saw earlier how we can view the history (the DAG) and visualize it by using
    `git log`. However, as the history grows, the terminal representation of the history
    can be a bit cumbersome to navigate. Fortunately, there are a lot of graphical
    tools in Git, one of them being gitk, which works on multiple platforms (Linux,
    Mac, and Windows).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看过如何通过使用`git log`查看历史（DAG图）并将其可视化。然而，随着历史的增长，终端中显示的历史可能会变得有些难以导航。幸运的是，Git中有许多图形化工具，其中一个是gitk，它支持多个平台（Linux、Mac和Windows）。
- en: This recipe will show you how to get started with gitk.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将向你展示如何开始使用gitk。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Make sure you have `gitk` installed:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已安装`gitk`：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If nothing shows up, then gitk is not installed on your system, or at least
    is not available on your `$PATH`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果什么都没有显示出来，那说明你的系统没有安装gitk，或者至少它不在你的`$PATH`中。
- en: 'Change the directory to the `Git-Version-Control-Cookbook-Second-Edition` repository
    from the objects and DAG examples. Make sure the master branch is checked out
    and pointing to `13dcad`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到`Git-Version-Control-Cookbook-Second-Edition`仓库，该仓库包含对象和DAG示例。确保已检出master分支并指向`13dcad`：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In the repository, run `gitk --all &` to bring up the `gitk` interface. You
    can also specify the commit range or branches you want, just as you did with `git
    log` (or provide `--all` to see everything):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中，运行`gitk --all &`以启动`gitk`界面。你还可以指定提交范围或分支，就像你使用`git log`时一样（或提供`--all`查看所有提交）：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Gitk shows the commit history of the repository:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Gitk展示了仓库的提交历史：
- en: '![](img/5d2104f1-f937-48b6-bc10-4635374f2e28.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d2104f1-f937-48b6-bc10-4635374f2e28.png)'
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Gitk parses the information for every commit and the objects attached to it
    to provide an easy graphical information screen that shows a graph of the history,
    author, and timestamp for each commit. In the bottom half is the result of selecting
    a commit. The commit message and the patches for each file that has changed .
    Moreover, a list of files that have been changed is displayed to the right.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Gitk解析每个提交及其附加的对象信息，提供一个易于使用的图形化信息界面，显示历史图、作者和每个提交的时间戳。底部则是选中某个提交后的结果，包括提交信息和每个修改文件的补丁内容。此外，修改过的文件列表会显示在右侧。
- en: Though very lightweight and fast, gitk is a very powerful tool. There are many
    different context menus that appear after the user clicks on a commit, a branch,
    or a tag in the history view. You can create and delete branches, revert and cherry-pick
    commits, `diff` selected commits, and much more.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然gitk非常轻量且速度很快，但它是一个功能非常强大的工具。用户点击历史视图中的提交、分支或标签后，会出现多个上下文菜单。你可以创建和删除分支、撤销和挑选提交、`diff`选定的提交等，功能非常多。
- en: There's more...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: From the interface, you can perform a find and search operation. Find looks
    through the history and Search looks through the information displayed in the
    lower half of gitk for the commit that is currently highlighted.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在界面中，你可以执行查找和搜索操作。查找会遍历历史，而搜索会遍历gitk下半部分显示的信息，查找当前高亮的提交。
- en: Finding commits in the history
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找历史中的提交
- en: 'You already saw in the previous recipe how we can filter the output of `git
    log` to only list commits with the `"Bug: "`string in the commit message. In this
    example, we will use the same technique to find specific commits in the entire
    history.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '你在前面的示例中已经看过如何过滤`git log`的输出，只列出提交信息中包含“`Bug: `”字符串的提交。在本例中，我们将使用相同的技术来查找整个历史中的特定提交。'
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Again, we will use the JGit repository, trying to find commits related to the
    `"Performance"` keyword. In this recipe, we will look through the entire history,
    so we don't need the master branch to point to a specific commit.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将使用JGit仓库，尝试查找与“`Performance`”关键字相关的提交。在本示例中，我们将浏览整个历史，因此不需要让master分支指向特定的提交。
- en: How to do it...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'As we tried earlier, we can use the `--grep` option to find specific strings
    in commit messages. In this recipe, we look at the entire history and search every
    commit that has `"Performance"` in its commit message:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的，我们可以使用`--grep`选项在提交信息中查找特定的字符串。在本示例中，我们查看整个历史并搜索所有提交信息中包含“`Performance`”的提交：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this example, we specifically ask Git to consider all of the commits in the
    history by supplying the `--all` switch. Git runs through the DAG and checks whether
    the `"Performance"` string is included in the commit message. For an easy overview
    of the results, the `--oneline` switch is also used to limit the output to just
    the subject of the commit message. Hopefully then, the commit(s) we needed to
    find can be identified from this, much shorter, list of commits.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们特别要求 Git 考虑历史中的所有提交，通过提供`--all`开关。Git 会遍历DAG（有向无环图），并检查提交信息中是否包含`"Performance"`字符串。为了更方便地查看结果，`--oneline`开关被用来限制输出仅显示提交信息的主题。希望这样，所需的提交记录可以从这个更简短的提交列表中被识别出来。
- en: 'Note that the search is case sensitive—had we searched for `"performance"`
    (all in lower case), the list of commits would have been very different:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，搜索是区分大小写的——如果我们搜索的是 `"performance"`（全小写），提交列表将会完全不同：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There's more...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We also could have used the Find feature in gitk to find the same commits.
    Open gitk with the `--all` switch, type `Performance` in the Find field, and hit
    *Enter*. This will highlight the commits in the history view, and you can navigate
    to the previous/next result by pressing *Shift* + up arrow, *Shift* + down arrow,
    or the buttons next to the Find field. You will still, however, be able to see
    the entire history in the view with the matching commits highlighted:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 gitk 的查找功能来查找相同的提交记录。打开 gitk 并使用 `--all` 开关，在查找字段中输入 `Performance`，然后按
    *Enter*。这会在历史视图中突出显示相关的提交记录，你可以通过按 *Shift* + 上箭头、*Shift* + 下箭头，或使用查找字段旁边的按钮，来导航到前一个或下一个结果。你仍然能够在视图中看到整个历史记录，并且匹配的提交会被高亮显示：
- en: '![](img/115db940-aff0-479a-9ae2-9e679dba2a97.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/115db940-aff0-479a-9ae2-9e679dba2a97.png)'
- en: Searching through the history code
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在历史代码中查找
- en: Sometimes, it is not enough to list the commit messages. You may want to know
    which commits touched a specific method or variable. This is also possible using
    `git log`. You can perform a search for a string, for example, or a variable or
    method, and `git log` will give you the commits, adding or deleting the string
    from the history. In this way, you can easily get the full commit context for
    the piece of code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，仅列出提交信息是不够的。你可能想知道哪些提交修改了特定的方法或变量。使用`git log`也可以做到这一点。例如，你可以对一个字符串、变量或方法进行搜索，`git
    log`会列出包含该字符串的提交记录，无论是添加还是删除了该字符串。通过这种方式，你可以轻松地获取该段代码的完整提交上下文。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Again, we will use the JGit repository with the master branch pointing to `b14a939`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将使用 JGit 仓库，master 分支指向 `b14a939`：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We would like to find all the commits that have had changes made to the lines
    that contain the `"isOutdated" `method. Again, we will just display the commits
    on one line each; we can then check them individually later:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望找到所有修改了包含 `"isOutdated"` 方法的行的提交记录。同样，我们将每个提交记录显示为一行；之后我们可以逐一检查：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can see that eight commits have patches that involve the string `"isOutdated"`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，八个提交包含了涉及 `"isOutdated"` 字符串的补丁。
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Git looks over the history (the DAG) looking at each commit for the `"isOutdated"` string in
    the patch between the parent commit and the current commit. This method is quite
    convenient to use in finding out when a given string was introduced or deleted,
    and to get the full context and commit at that point in time.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Git 会查看历史（DAG），检查每个提交中父提交与当前提交之间的补丁，寻找`"isOutdated"`字符串。这种方法非常方便，用来查找某个字符串被引入或删除的时间点，并获取该时刻的完整上下文和提交记录。
- en: There's more...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `-G` option used with `git log` will look for differences in the patches
    that contain added or deleted lines that match the given string. However, these
    lines could also have been added or removed because of some other refactoring/renaming
    of a variable or method. There is another option that can be used with `git log`,
    namely `-S`, which will look through the difference in the patch text in a similar
    way to the `-G` option, but will only match commits where there is a change in
    the number of occurrences of the specified string—that is, a line added or removed,
    but not added and removed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`-G` 选项与 `git log` 一起使用时，会查找补丁中包含的新增或删除的行，这些行与给定的字符串匹配。然而，这些行也可能是由于某些其他重构或变量/方法重命名而被添加或删除的。`git
    log` 还有另一个选项 `-S`，它将以类似 `-G` 选项的方式检查补丁文本中的差异，但只会匹配那些指定字符串出现次数发生变化的提交记录——也就是说，某行被添加或删除，而不是同时添加和删除。'
- en: 'Let''s see the output of the `-S` option:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `-S` 选项的输出：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The search matches seven commits, whereas the search with the `-G` option matches
    eight commits. The difference is that the commit with the ID `c9c57d3` is only
    found with the `-G` option in the first list. A closer look at this commit shows
    that the `isOutdated` string is only touched because of the renaming of another
    object, and this is why it is filtered away from the list of matching commits
    in the last list when using the `-S` option. We can see the content of the commit
    with the `git show` command, and use `grep -C4` to limit the output to just the
    four lines before and after the search string:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索匹配七个提交，而使用 `-G` 选项的搜索则匹配了八个提交。不同之处在于，在第一个列表中，只有使用 `-G` 选项才能找到ID为 `c9c57d3`
    的提交。仔细查看此提交显示，由于另一个对象的重命名，仅触及了 `isOutdated` 字符串，这就是在使用 `-S` 选项时将其从匹配提交列表中过滤掉的原因。我们可以使用
    `git show` 命令查看提交的内容，并使用 `grep -C4` 仅限制输出到搜索字符串前后的四行内容：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
