- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Advanced Branching Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级分支技术
- en: '[*Chapter 6*](B21194_06.xhtml#_idTextAnchor140), *Collaborative Development
    with Git*, described how to arrange teamwork while focusing on repository-level
    interactions. In that chapter, you learned about various centralized and distributed
    workflows, as well as their advantages and disadvantages.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第六章*](B21194_06.xhtml#_idTextAnchor140)，*Git的协作开发*，描述了如何在专注于仓库级交互时安排团队合作。在那一章中，您学习了各种集中式和分布式工作流及其优缺点。'
- en: This chapter will dive deeper into the details of collaboration in distributed
    development. We’ll explore the relationships between local branches and branches
    in remote repositories. Then, we’ll introduce the concept of remote-tracking branches,
    branch tracking, and upstream. This chapter will also teach us how to specify
    the synchronization of branches between repositories by using *refspecs* and *push
    modes*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨分布式开发中的协作细节。我们将探索本地分支与远程仓库中的分支之间的关系。接着，我们将介绍远程跟踪分支、分支跟踪以及上游的概念。本章还将教我们如何通过使用*引用规范*和*推送模式*来指定仓库之间分支的同步。
- en: 'You will also learn branching techniques: how branches can be used to create
    new features, prepare new releases, and fix bugs. You will learn about the advantages
    and disadvantages of different branching patterns. Among other things, this chapter
    will show you how to use branches so that it would be easy for you to select which
    features will go into the next version of the project.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将学习分支技术：如何使用分支来创建新功能、准备新版本并修复漏洞。您将了解不同分支模式的优缺点。本章将向您展示如何使用分支，以便您可以轻松选择哪些功能将进入项目的下一个版本。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Different kinds of branches, both long-lived and short-lived, and their purpose
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同种类的分支，包括长生命周期和短生命周期分支及其目的
- en: Various branching patterns, and how they can be composed into workflows
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种分支模式，以及它们如何组成工作流
- en: Release engineering for different branching models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同分支模型的发布工程
- en: Using branches to fix a security issue in more than one released version
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分支修复多个已发布版本中的安全问题
- en: Remote-tracking branches and refspecs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程跟踪分支和引用规范
- en: Rules for fetching and pushing branches and tags
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取和推送分支及标签的规则
- en: Selecting a push mode to fit the chosen collaboration workflow
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择适合所选协作工作流的推送模式
- en: The purpose of branching
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支的目的
- en: A **branch** in a version control system is an active parallel line of development
    (also called a **codeline**). They are used to isolate, separate, and gather different
    types of work. For example, branches can be used to prevent your current unfinished
    work on a feature in progress from interfering with the management of bug fixes
    (isolation), or to gather fixes for an older version of the developed software
    (gathering and integration).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本控制系统中，**分支**是一个活跃的并行开发线（也叫**代码线**）。它们用于隔离、分离和汇聚不同类型的工作。例如，分支可以用于防止当前未完成的功能开发工作干扰bug修复的管理（隔离），或者将旧版本软件的修复集中起来（汇聚与集成）。
- en: A single Git repository can have an arbitrarily large number of branches. Moreover,
    with a distributed version control system, such as Git, there could be many repositories
    for a single project (known as **forks** or **clones**), some public and some
    private; each such repository will have their own local branches. This can be
    considered **source branching**. Each developer would have at least one private
    clone of the project’s public repository to work in.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Git仓库可以拥有任意数量的分支。此外，使用像Git这样的分布式版本控制系统，单个项目可能有多个仓库（称为**分叉**或**克隆**），其中一些是公共的，一些是私有的；每个这样的仓库都会有自己的本地分支。这可以视为**源分支**。每个开发者至少会有一个项目公共仓库的私有克隆来进行工作。
- en: A bit of history – a note on the evolution of branch management
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一点历史——分支管理演进的简要说明
- en: Early distributed version control systems used one branch per repository model.
    Both *Bazaar* (then Bazaar-NG) and *Mercurial documentation*, at the time when
    they began their existence, recommended cloning the repository to create a new
    branch.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的分布式版本控制系统使用每个仓库一个分支的模型。当时，*Bazaar*（后来为Bazaar-NG）和*Mercurial文档*建议通过克隆仓库来创建新分支。
- en: Git, on the other hand, had good support for multiple branches in a single repository
    almost from the start. However, in the beginning, it was assumed that there would
    be one central multibranch repository interacting with many single-branch repositories
    (see, for example, the legacy **.git/branches** directory, which was used to specify
    URLs and fetch branches, as described in the **gitrepository-layout(7)** man page),
    though with Git it was more about defaults than capabilities.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Git 从一开始就很好地支持在单个仓库中使用多个分支。然而，最初假设会有一个中央的多分支仓库与多个单分支仓库交互（例如，遗留的 **.git/branches**
    目录用于指定 URL 并拉取分支，正如 **gitrepository-layout(7)** 手册页中所描述的那样），尽管在 Git 中，这更多是关于默认设置而非能力。
- en: Because branching is cheap in Git (and merging is easy), and collaboration is
    quite flexible, people started using branches more and more, even for solitary
    work. This led to the wide use of the extremely useful topic branch workflow (also
    known as feature branching).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在 Git 中创建分支非常便宜（而且合并也很容易），并且协作非常灵活，人们开始越来越多地使用分支，甚至是用于单独的工作。这导致了非常有用的主题分支工作流（也称为功能分支）的广泛使用。
- en: Isolation versus integration
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离与集成
- en: Version control systems such as Git allow different people to work on the same
    code base without interfering with each other. They also makes it easy to switch
    between different types of work. But this separated work would then need to be
    merged back together into some integration target to be useful and to be later
    included in a release.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统，如 Git，允许不同的人在相同的代码库上工作而不互相干扰。它们还使得在不同类型的工作之间切换变得容易。但这种分离的工作最终需要合并到某个集成目标中才能变得有用，并且稍后被包括在发布版本中。
- en: We need *isolation*, but we also need to *integrate* changes, combining work
    into a coherent whole. To avoid conflicts as best as possible, our changes need
    to be visible to others, or even better be integrated. For example, if we change
    a calling convention of some API, but our work remains isolated, others cannot
    easily adjust to those changes. They would use the old version of the API in their
    work – leading to merge conflicts and a more difficult integration in the future.
    So, from this point of view, earlier and more *frequent integration* is something
    to be desired.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要*隔离*，但我们也需要*集成*变更，将工作合并成一个连贯的整体。为了尽量避免冲突，我们的变更需要对其他人可见，或者更好的是被集成。例如，如果我们改变了某个
    API 的调用约定，但我们的工作仍然是隔离的，其他人就无法轻松地适应这些变化。他们会在工作中使用旧版的 API —— 导致合并冲突，并使未来的集成更加困难。因此，从这个角度来看，提前和更*频繁的集成*是值得追求的目标。
- en: However, some features are more involved, and their development consists of
    many steps. The goal of frequent integration conflicts with the need to *isolate
    unfinished work*, and to prevent such work from being visible. If we want frequent
    integration, we need to be able to handle such issues.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些功能更加复杂，它们的开发包含许多步骤。频繁集成的目标与*隔离未完成的工作*的需求相冲突，且防止这些工作可见。如果我们希望进行频繁集成，就需要能够处理这些问题。
- en: The path to production release
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通往生产发布的路径
- en: The main goal of software development is to deploy code into production, to
    create a usable release of the project, and to have something to be used. A proper
    branching technique helps us achieve a stable base for creating such a release.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发的主要目标是将代码部署到生产环境，创建可用的发布版本，并让其被使用。一个适当的分支技术帮助我们为创建这样的发布版本提供稳定的基础。
- en: What branching pattern to use depends on the particularities of the project.
    For example, the team may need to isolate a work in progress from a stable base.
    There can also be more or less friction in the release process. Additionally,
    you might need to manage multiple versions of releases, or multiple versions of
    the project in production.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用何种分支模式取决于项目的具体情况。例如，团队可能需要将正在进行的工作与稳定的基础隔离开来。发布过程也可能会有更多或更少的摩擦。此外，你可能需要管理多个版本的发布，或者生产环境中多个版本的项目。
- en: There are specific branching patterns to help you handle such issues.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特定的分支模式可以帮助你处理这些问题。
- en: Long-running and short-lived branches
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长期运行与短期存在的分支
- en: Branches whose main purpose is to gather and integrate changes need to be long-lived,
    or even permanent. They are intended to last indefinitely, or at least for a very
    long time; they are rarely deleted.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目的是收集并集成变更的分支需要长时间存在，甚至是永久性的。它们的设计目的是持续存在，或至少存在很长时间；这些分支很少会被删除。
- en: From a collaboration point of view, a **long-lived branch** can be expected
    to be there when you are next updating data or publishing changes. This means
    that you can safely start work by forking off any of the long-lived branches in
    the remote repository, and be assured that there should be no problems with integrating
    that work. This means that at least one such branch must exist. Branches that
    people usually base their work on, that define the *current version* of the project,
    are sometimes called **mainlines**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从协作的角度来看，**长期分支**可以预期在你下次更新数据或发布更改时仍然存在。这意味着你可以安全地从远程仓库中的任何长期分支派生开始工作，并确保在集成这些工作时不会遇到问题。这也意味着至少要有一个这样的分支存在。人们通常基于这些分支进行工作，定义了项目的*当前版本*，有时这些分支被称为**主干**。
- en: While long-lived branches stay forever, **short-lived** or **temporary branches**
    are created to deal with single issues, and are usually removed (deleted) after
    dealing with said issue (after the branch is merged or the feature is dropped).
    They are intended to last only as long as the issue is present. Their purpose
    is time-limited.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 长期存在的分支会一直存在，而**短期分支**或**临时分支**则用于处理单一问题，通常在问题解决后（分支合并或功能取消后）会被删除。它们的生命周期仅限于问题存在的时间。其目的是有时间限制的。
- en: Having a separate branch for a separate issue helps us isolate and gather subsequent
    steps in the process of resolving a problem, whether it’s adding a new feature
    or creating an urgent bug fix. Those branches are usually named after their topic.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为单独的问题创建一个独立的分支有助于我们隔离并收集解决问题过程中的后续步骤，无论是添加新功能还是创建紧急的修复。这些分支通常会根据它们的主题命名。
- en: Visibility of branches
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支的可见性
- en: What you can find in *public repositories* are usually only *long-lived branches*.
    In most cases, these branches should never rewind (the new version is always a
    descendant of the old versions). This makes it possible for you to safely build
    your work on top of the public branch.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在*公开仓库*中，通常只能看到*长期存在的分支*。在大多数情况下，这些分支应该永远不会回滚（新版本始终是旧版本的后代）。这使得你可以安全地在公开分支上构建你的工作。
- en: There are some special cases here, though; there can be branches that are rebuilt
    after each new release (requiring forced fetch at that time), and there can be
    branches that do not fast forward. Each such case should be explicitly mentioned
    in the developer documentation to help you avoid unpleasant surprises.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一些特殊情况；可能存在一些分支在每次新发布后都会被重建（此时需要强制拉取），也可能存在一些分支无法快速前进。每种情况都应该在开发者文档中明确提及，以帮助你避免不愉快的意外。
- en: Because of their provisional nature, *short-lived branches* are usually only
    present in the *local private repository* of a developer or integration manager
    (maintainer), and are not pushed to public distribution repositories. If they
    appear in public repositories, they are often only present in a public repository
    of an individual contributor as a target for a pull request (see the blessed repository
    workflow in [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140), *Collaborative Development*
    *with Git*).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其临时性，*短期分支*通常仅存在于开发者或集成管理者（维护者）的*本地私有仓库*中，并不会推送到公开分发仓库。如果它们出现在公开仓库中，通常也只是作为个人贡献者的公开仓库中的目标，用于拉取请求（参见[*第6章*](B21194_06.xhtml#_idTextAnchor140)，*与Git协作开发*）。
- en: Alternatives to branching
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支的替代方案
- en: With frequent integration, potential conflicts are discovered early. However,
    some features take longer to develop, and they are simply not ready when the time
    comes to push them to the mainline. But teams don’t want to expose half-developed
    features. With a branching workflow geared toward integration rather than isolation,
    there is often a need for some kind of mechanism to hide unfinished work.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过频繁的集成，可以及早发现潜在的冲突。然而，一些功能的开发需要更长时间，当推送到主干时它们可能尚未准备好。但团队不希望暴露半成品的功能。在这种以集成而非隔离为导向的分支工作流中，通常需要某种机制来隐藏未完成的工作。
- en: One technique is to build backend code first, and only create the user interface
    for it when it is ready, like a keystone. On the other hand, changing the existing
    code can be done by creating a temporary abstraction layer, which would then allow
    you to switch the underlying implementation to the new one when it is ready.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一种技巧是先构建后端代码，等到它准备好时再为其创建用户界面，就像基石一样。另一方面，修改现有代码可以通过创建临时的抽象层来实现，这样等新实现准备好时，你就可以切换到底层实现。
- en: Another useful method is to hide different unfinished implementations behind
    **feature switches** or **feature toggles**. This technique is useful outside
    providing separation for integrated but unfinished features. For example, with
    runtime feature toggles, you can compare two different algorithms on live production
    data, or you can perform A/B tests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有用的方法是通过**特性开关**或**特性切换**来隐藏不同的未完成实现。这种技术在为已集成但未完成的功能提供隔离时非常有用。例如，使用运行时特性切换，你可以在实际生产数据上比较两种不同的算法，或者进行A/B测试。
- en: Visibility without integration
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无集成可见性
- en: An alternative to frequent integration into the mainline could be to use outside
    channels. It can be done by creating a `proposed-updates` type of branch, which
    would be used to merge all feature branches. This improves the visibility of changes
    and provides a place to test branch integrations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 频繁集成到主线的替代方法是使用外部渠道。这可以通过创建一种`proposed-updates`类型的分支来实现，用来合并所有功能分支。这样可以提高更改的可见性，并提供一个测试分支集成的地方。
- en: Tools and services such as *GitLive* (available as a VS Code extension and as
    a JetBrains IDE plugin) exist that can show who is working on which branch, on
    which issue, and even show working copy local changes of teammates.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 像*GitLive*（可作为VS Code扩展和JetBrains IDE插件使用）这样的工具和服务，可以显示谁正在处理哪个分支、哪个问题，甚至显示团队成员的本地工作副本更改。
- en: Branching patterns
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支模式
- en: In many cases, the choice of branching pattern (of the branching technique)
    depends on how stable the branch is, or in other words how healthy it is. A **stable
    branch**, or a **healthy branch** is a branch in such a state that the current
    tip commit on that branch always builds and deploys successfully, and the software
    runs with zero or at most a few bugs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，分支模式的选择（即分支技术）取决于分支的稳定性，换句话说，就是分支的健康状态。一个**稳定分支**或**健康分支**是指该分支的当前提交总是能成功构建和部署，且软件运行时几乎没有或最多只有几个bug。
- en: Ensuring that a branch is healthy pretty much requires doing daily builds and
    having a comprehensive suite of automated tests that are run frequently – if not
    at each commit, then at least at each integration (merge). However, explaining
    how to do this is outside the scope of this book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 确保一个分支的健康状态基本上需要每天进行构建，并且有一套全面的自动化测试，这些测试需要频繁运行——如果不是每次提交时运行，至少在每次集成（合并）时运行。然而，如何做到这一点超出了本书的范围。
- en: Integration patterns
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成模式
- en: Deciding what branching strategy to use to integrate individual changes into
    a coherent and healthy mainline depends on various factors. Techniques that tend
    toward frequent integration, such as continuous integration, require the branch
    being merged into to be healthy. This requires a disciplined team, where each
    developer can make sure that each change is well-tested and does not break the
    developed application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 决定采用何种分支策略将各个变化集成到一个连贯且健康的主线中，取决于各种因素。倾向于频繁集成的技术，如持续集成，需要被合并的分支保持健康。这要求团队有高度的纪律性，确保每个开发者能够确保每个变化都经过充分测试且不会破坏已开发的应用程序。
- en: On the other hand, if it isn’t certain that the feature being developed is of
    a good enough quality, and we want it assessed as a unit only after it is finished,
    then integrating less frequently might make more sense. Requiring pre-integration
    code reviews also drives you toward specific branching patterns.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果不能确定正在开发的功能质量足够好，并且我们希望在功能完成后再作为一个单元进行评估，那么较少频繁的集成可能更有意义。要求预集成代码审查也会促使你采用特定的分支模式。
- en: Mainline integration
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主线集成
- en: The simplest possible branching strategy is to work directly out of the mainline
    (the **trunk**) and merge your changes (commits) directly into it. In this workflow,
    the developer starts from the mainline and creates their work on top of it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的分支策略就是直接在主线（**主干**）上工作，并将更改（提交）直接合并到主线中。在这种工作流程中，开发者从主线开始，在其基础上进行工作。
- en: This strategy is called **mainline integration** or **trunk-based development**
    (the name depends on how the main branch is called).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这一策略称为**主线集成**或**基于主干的开发**（名称取决于主分支的命名）。
- en: After the developer reaches a point where they want to integrate, they start
    by fetching the current state of the mainline. If other developers published their
    changes when they were working on the project, they would need to combine those
    changes, using either a merge or a rebase operation – see [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229),
    *Merging Changes Together* for more detail. Then, they verify that the code is
    healthy and push integrated changes into the mainline.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者达到想要集成的节点时，他们会先拉取主线的最新状态。如果其他开发者在他们工作期间发布了更改，他们需要将这些更改合并，可以使用合并或重基操作——详情请参见[*第9章*](B21194_09.xhtml#_idTextAnchor229)，*合并更改*。然后，开发者验证代码的健康状况，并将集成的更改推送到主线。
- en: Topic branches-based development
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于主题分支的开发
- en: In the **topic branching** pattern (also called **feature branching**), the
    idea is to make a new separate branch for each topic. This might be creating a
    new feature or a bug fix. This type of branch intends to gather subsequent development
    steps of a feature (where each step – a commit – should be a self-contained piece,
    easy to review), and to isolate the work on one feature from work on other topics.
    Using a feature branch allows topical changes to be kept together, and not mixed
    with other commits. It also makes it possible for a whole topic to be dropped
    (or reverted) as a unit, be reviewed as a unit, and be accepted (integrated) as
    a unit.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在**主题分支**模式下（也叫做**特性分支**），其理念是为每个主题创建一个新的独立分支。这可能是创建一个新特性或修复一个bug。此类分支旨在收集特性后续的开发步骤（每一步——每个提交——应该是一个独立的单元，易于审查），并将一个特性的工作与其他主题的工作隔离开来。使用特性分支可以将相关的更改保留在一起，而不是与其他提交混合。这还使得整个主题可以作为一个单元被丢弃（或回退）、作为一个单元进行审查，并作为一个单元被接受（集成）。
- en: The end goal for the commits on a topic branch is to have them included in a
    released version of a product. This means that, ultimately, the short-lived topic
    branch is to be merged into the long-lived branch, which is gathering stable work,
    and must be deleted.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 主题分支上的提交的最终目标是将它们包含在产品的发布版本中。这意味着，最终，短生命周期的主题分支将被合并到长期存在的稳定工作分支中，并且该主题分支必须被删除。
- en: To make it easier to integrate topic branches, the recommended practice is to
    create such branches by forking off the oldest, most stable integration branch
    that you will eventually merge into. Usually, this means creating a branch, starting
    from the stable-work graduation branch. However, if a given feature does depend
    on a topic not yet in the stable line, you need to fork off the appropriate topic
    branch containing the dependency you need.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于集成主题分支，推荐的做法是从你最终将合并的最古老、最稳定的集成分支上创建这些分支。通常，这意味着从稳定的工作毕业分支上创建一个新的分支。然而，如果某个特性依赖于尚未稳定的主题分支，你需要从包含所需依赖的合适主题分支上进行分支。
- en: Note that if it turns out that you forked off the wrong branch, you can always
    fix it by rebasing (see [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229), *Merging
    Changes Together*, and [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping History Clean*), because topic branches are not public.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你发现自己从错误的分支上进行了分支，可以通过重基来修复（参见[*第9章*](B21194_09.xhtml#_idTextAnchor229)，*合并更改*，以及[*第10章*](B21194_10_split_000.xhtml#_idTextAnchor247)，*保持历史清晰*），因为主题分支是非公开的。
- en: Continuous integration
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持续集成
- en: 'When using the mainline integration pattern, integrations are as frequent as
    possible: after each commit. Feature branching implies a lower bound to the period
    of integrations – you integrate fully developed cohesive features.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用主线集成模式时，集成尽可能频繁：每次提交后都进行集成。特性分支则意味着集成的周期有一个下限——你集成的是完全开发好的、具有凝聚力的特性。
- en: With the **continuous integration pattern** (which is also called **scaled trunk-based
    development**), you try to integrate as frequently as possible – that is, whenever
    you have made a worthwhile number of changes and the branch is still healthy.
    The work is best done with short-lived feature branches, just integrated more
    frequently. The recommended practice is to integrate at least daily, with the
    feature branch living a few days at most.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**持续集成模式**（也叫做**规模化主干开发**），你尽量进行频繁的集成——也就是说，每当你完成了足够的更改并且分支依然健康时，就进行集成。最佳的做法是使用短生命周期的特性分支，并进行更频繁的集成。推荐的做法是至少每天集成一次，特性分支最多存活几天。
- en: When using this pattern, you need to be able to deal with a partially built
    feature. If mainline code runs in production (continuous delivery), you need to
    consider how to avoid exposing such unfinished features in the running code. This
    was described in the *Alternatives to* *branching* section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式时，你需要能够处理部分构建的特性。如果主干代码在生产环境中运行（持续交付），你需要考虑如何避免在运行中的代码中暴露这些未完成的特性。此问题在*分支替代方案*一节中有所描述。
- en: Release engineering
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布工程
- en: If the mainline is kept healthy enough and is in an always-releasable state
    (following the tenets of continuous delivery), you can mark revision for release
    simply by creating a Git tag from the current tip. This simple branching pattern
    is called the **release-ready mainline**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主干保持足够健康，并且始终处于可发布状态（遵循持续交付的原则），你可以通过从当前提交点创建 Git 标签来标记发布版本。这种简单的分支模式称为**发布就绪主干**。
- en: But if this is not the case, or if you need to manage more than one version
    of the product, more complex branching patterns are needed. In that case, specialized
    branches are required on the path from the integration branch to the production
    release.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果情况不是这样，或者你需要管理多个版本的产品，就需要更复杂的分支模式。在这种情况下，从集成分支到生产发布的路径上需要专门的分支。
- en: Progressive-stability branches
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渐进稳定分支
- en: 'One possible solution to the problem of ongoing development not being stable
    enough to be always ready for the release (temporarily including some unstable
    code), is to put less mature and more mature code in separate `maint`, to `master`,
    to `next`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案是，对于持续开发不够稳定，无法始终准备好发布（临时包括一些不稳定代码）的问题，将较不成熟的代码和较成熟的代码放在不同的 `maint`、`master`、`next`
    分支中：
- en: '![Figure 8.1 – A linear view and a “silo” view of the maturity branches (also
    called progressive-stability branches)](img/B21194_08_01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 成熟度分支的线性视图和“筒仓”视图（也称为渐进稳定分支）](img/B21194_08_01.jpg)'
- en: Figure 8.1 – A linear view and a “silo” view of the maturity branches (also
    called progressive-stability branches)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 成熟度分支的线性视图和“筒仓”视图（也称为渐进稳定分支）
- en: These branches form a hierarchy with a decreasing level of **graduation** or
    **stability** of work, as shown in *Figure 8**.1*. In the linear view (top of
    the figure), the stable revisions are further down the line in your commit history,
    and the cutting-edge unstable work is further up the history. Alternatively, we
    can think of branches as work silos (bottom of the figure), where work goes depending
    on the stability (graduation) of changes. Note that, in real development, progressive-stability
    branches would not keep being this simple. There would be new revisions on the
    branches after the forking points. Nevertheless, the overall shape will be the
    same, even in the presence of merging.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分支形成一个层次结构，工作稳定性的**毕业**或**稳定性**级别逐渐降低，如*图 8.1*所示。在线性视图中（图的顶部），稳定的修订版本位于提交历史的较后位置，而最前沿的不稳定工作则位于较前的位置。或者，我们可以将分支看作工作筒仓（图的底部），根据更改的稳定性（毕业）将工作分配到不同的地方。请注意，在实际开发中，渐进稳定分支不会保持如此简单。在分叉点之后，分支上会有新的修订。然而，即使存在合并，整体形状仍然是相同的。
- en: Here and in the following figures, the chosen commit names (C1, C2, C3, and
    so on) are only to distinguish commits, and in some cases also to make it easy
    to see which commit corresponds to another.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里和接下来的图示中，所选的提交名称（C1、C2、C3 等）仅用于区分提交，在某些情况下，也用于便于查看哪些提交对应其他提交。
- en: With maturation branches, the rule is to always merge more stable branches into
    less stable ones – that is, **merge upwards**. This would preserve the overall
    shape of branch silos (see *Figure 8**.3* in the *Graduation or progressive-stability
    branches workflow* section of this chapter). This is because merging means including
    all the changes from the merged branch.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于成熟分支，规则是始终将更稳定的分支合并到较不稳定的分支中——也就是说，**向上合并**。这将保持分支筒仓的整体形状（参见本章“毕业或渐进稳定分支工作流”一节中的*图
    8.3*）。这是因为合并意味着将所有来自合并分支的更改包含在内。
- en: Therefore, merging a less stable branch into a more stable one would bring unstable
    work to the stable branch, violating the purpose and the contract of a stable
    branch.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将一个不太稳定的分支合并到一个更稳定的分支中，会将不稳定的工作带入稳定分支，违背了稳定分支的目的和契约。
- en: 'Often, we see the graduation branches of the following levels of stability:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们看到以下稳定级别的毕业分支：
- en: The **maint**, **maintenance**, or **fixes** branch only contains bug fixes
    to the last major release; minor releases are done with the help of this branch.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**maint**、**maintenance** 或 **fixes** 分支仅包含对上一个主要版本的漏洞修复；小版本更新通过这个分支进行。'
- en: The **main**, **master**, **trunk**, or **stable** branch, with the development
    intended for the next major release; the tip of this branch should always be in
    the production-ready state.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**main**、**master**、**trunk** 或 **stable** 分支，开发工作面向下一个主要版本；该分支的末端应始终保持在生产就绪状态。'
- en: The **next** **devel**, **development**, **unstable** branch, where the new
    development goes to test whether it is ready for the next release; the tip can
    be used for nightly builds.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**next**、**devel**、**development** 或 **unstable** 分支，新开发的功能会被推送到此分支以测试其是否准备好进行下一个版本的发布；该分支的末端可以用于每夜构建。'
- en: The **pu** or **proposed** branch for the proposed updates. This is the integration
    testing branch and is meant for checking compatibility between different new features.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pu** 或 **proposed** 分支，用于提议的更新。这是集成测试分支，旨在检查不同新特性之间的兼容性。'
- en: Having multiple long-running branches is not necessary, but it’s often helpful,
    especially in very large or complex projects. Often, in operations, each level
    of stability corresponds to its own platform or deployment environment.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多个长期运行的分支并非必要，但在非常大或复杂的项目中往往是有帮助的。在操作中，每个稳定性级别通常对应其自身的平台或部署环境。
- en: You don’t need to – and probably shouldn’t – use every type of branch listed
    here. Pick only what is needed for your project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要——也可能不应该——使用这里列出的每一种分支类型。只选择适合你项目所需的。
- en: Per-release branches and per-release maintenance
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按版本分支与按版本维护
- en: Preparing for the new release of a project can be a lengthy and involved process.
    **Per-release branches** can help with this. The release branch is meant to separate
    the ongoing development from preparing for the new release. It allows other developers
    to continue working on writing new features and on integration testing, while
    the quality assurance team, with the help of the release manager, takes time to
    test and stabilize the release candidate.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为项目准备新版本可能是一个漫长且复杂的过程。**按版本分支**可以帮助实现这一点。发布分支用于将持续的开发与准备新版本的工作区分开来。它允许其他开发人员继续进行新功能编写和集成测试，而质量保证团队则在发布经理的协助下，花时间测试和稳定发布候选版本。
- en: After creating a new release, keeping such per-release branches allows us to
    support and maintain older released versions of the software. At these times,
    such branches work as a place to gather bug fixes (for their software versions)
    and create minor releases.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新版本后，保持这种按版本划分的分支可以让我们支持和维护软件的旧版本。在这些时候，这些分支作为一个地方，用于集中修复漏洞（针对其软件版本）并创建小版本更新。
- en: Not all projects need to utilize per-release branches. You can prepare a new
    release on the stable-work graduation branch, or use a separate repository in
    place of using a separate branch. Also, not all projects must provide support
    for more than the latest version.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有项目都需要使用按版本分支。你可以在稳定工作毕业分支上准备新版本，或使用单独的仓库代替使用独立分支。同时，并非所有项目都必须支持超过最新版本的版本。
- en: This type of branch is often named after the release it is intended for – for
    example, `release-v1.4`. It is better not to give the branch the same name that
    the tag has for the release.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的分支通常以它所针对的发布版本命名，例如 `release-v1.4`。最好不要为分支取与发布标签相同的名称。
- en: Release train with feature-freeze
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布列车与特性冻结
- en: 'If your project is doing releases on a regular cadence (such as every 2 weeks
    or every 6 months), and the release process is complex and involved (for example,
    there is external testing or a verification process), then it might be beneficial
    to use a release train branching pattern. It can be considered a variant of the
    per-release branch pattern. It is depicted in *Figure 8**.2*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目按照固定的周期发布（例如每两周或每六个月发布一次），且发布过程复杂（例如有外部测试或验证过程），那么使用发布列车分支模式可能会更有利。这可以视为按版本发布分支模式的变体。它在*图
    8.2*中有示意：
- en: '![Figure 8.2 – Release train branching pattern for monthly releases, with the
    May “train” tagged and released into production and the June “train” in a state
    just after a feature freeze](img/B21194_08_02.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 每月发布的发布列车分支模式，五月的“列车”已标记并发布到生产环境，六月的“列车”处于特性冻结后](img/B21194_08_02.jpg)'
- en: Figure 8.2 – Release train branching pattern for monthly releases, with the
    May “train” tagged and released into production and the June “train” in a state
    just after a feature freeze
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 月度发布的发布火车分支模式，5月的“火车”已打标签并发布到生产，6月的“火车”则处于功能冻结后的状态
- en: In this approach, each per-release branch is coupled with a feature-freeze date
    (in advance of the planned release date). A new branch for the new release is
    created no later than the feature-freeze date for the previous release. After
    the feature freeze, an integration branch turns into a release branch, accepting
    only bug fixes and changes that prepare the project for release. This approach
    is often used with feature branching.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，每个发布分支都与一个功能冻结日期（在计划发布日期之前）相关联。新的发布分支必须不晚于前一个发布的功能冻结日期创建。功能冻结后，集成分支转变为发布分支，只接受修复bug和准备项目发布的更改。这个方法通常与特性分支一起使用。
- en: If there’s more than one per-release branch active and accepting features, the
    developer can estimate how long would it take to finish the new feature and push
    it to the “train” corresponding to the later date (loading future trains). Earlier
    departing “trains” can be regularly merged into later departing ones.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个每发布分支处于活跃状态并接受新特性，开发者可以估算完成新特性并推送到“火车”上的时间，并将其推送到较晚日期的“火车”（加载未来的火车）。较早出发的“火车”可以定期合并到较晚出发的“火车”中。
- en: This pattern can be transitioned into the continuous delivery pattern (production-ready
    mainline) by increasing the frequency of “trains” and reducing friction in the
    release process.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过增加“火车”的频率并减少发布过程中的摩擦，这种模式可以过渡到持续交付模式（生产就绪的主线）。
- en: Hotfix branches for security fixes
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全修复的热修复分支
- en: '**Hotfix branches** are like release branches but for unplanned releases. Their
    purpose is to act upon the undesired state of a live production or a widely deployed
    version, usually to resolve some critical bug in production (usually a severe
    security bug). This type of branch can be considered a longer-lived equivalent
    of the bugfix topic branches (see the *Bugfix branches* section of this chapter).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**热修复分支**类似于发布分支，但用于非计划发布。它们的目的是应对生产环境或广泛部署的版本的不良状态，通常是为了解决生产环境中的一些严重bug（通常是安全漏洞）。这种类型的分支可以视为bug修复主题分支的长生命周期等效物（参见本章的*Bugfix分支*部分）。'
- en: Other branching patterns involving long-lived branches
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他涉及长生命周期分支的分支模式
- en: The main purpose of the different types branches is to isolate and/or integrate
    lines of development. However, branching patterns exist that do not fit around
    the themes of team integration or the path to production (to release).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的分支主要目的是为了隔离和/或整合开发线路。然而，也存在一些不符合团队集成或生产发布路径主题的分支模式。
- en: Per-customer or per-deployment branches
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个客户或每个部署的分支
- en: Let’s say that some of your project’s customers require a few customization
    tweaks since they do things differently, or perhaps some deployment sites have
    special requirements. Suppose that these customizations cannot be done by simply
    changing the configuration. In this case, you would need to create separate lines
    of development for these customers or customizations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的项目有一些客户需要进行一些定制调整，因为他们的做法有所不同，或者某些部署站点有特殊要求。假设这些定制无法通过简单修改配置来完成。在这种情况下，你需要为这些客户或定制化需求创建独立的开发线路。
- en: But you don’t want these lines of development to remain separate. You expect
    that there will be changes that apply to all of them. One solution is to use one
    branch for each customization set, per customer, or per deployment. Another would
    be to use separate repositories. Both solutions help maintain parallel lines of
    development and transfer changes from one line to another.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你不希望这些开发线路保持独立。你期望会有一些变化适用于所有这些分支。一个解决方案是为每个定制集、每个客户或每个部署使用一个分支。另一个解决方案是使用独立的仓库。这两种方案都能帮助维持并行的开发线路，并将变更从一条线路传递到另一条线路。
- en: Such environment branches can be considered an *anti-pattern*. With this approach,
    it is very easy to introduce changes that lead to different behavior in production
    and on the developer’s workstation, or end with having to maintain wildly divergent
    products for each customer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种环境分支可以被视为一种*反模式*。采用这种方法时，很容易引入导致生产环境与开发者工作站上行为不一致的变更，或者最终不得不为每个客户维护截然不同的产品。
- en: Automation branches
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化分支
- en: Say that you are working on a web application, and you want to automate its
    deployment using a version control system. One solution would be to set up a daemon
    to watch a specific branch (for example, the one named `deploy`) for changes.
    Updating this branch would automatically update and reload the application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一个网页应用程序，并希望使用版本控制系统来自动化其部署。一种解决方案是设置一个守护进程来监视一个特定的分支（例如，名为`deploy`的分支）是否有变化。更新该分支将自动更新并重新加载应用程序。
- en: This is, of course, not the only possible solution. Another possibility would
    be to use a separate `deploy` repository and set up hooks there, so pushing would
    cause the web application to refresh. Alternatively, you could configure a hook
    in a public repository so that pushing to a specific branch triggers redeployment
    (this mechanism will be described in [*Chapter 14*](B21194_14.xhtml#_idTextAnchor349),
    *Git Administration*).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是唯一的解决方案。另一种可能是使用一个单独的`deploy`仓库并在那里设置钩子，这样推送就会导致网页应用程序刷新。或者，你可以在一个公共仓库中配置钩子，使得推送到特定分支时触发重新部署（该机制将在[*第14章*](B21194_14.xhtml#_idTextAnchor349)
    *Git管理*中描述）。
- en: These techniques can also be used for continuous integration; instead of deploying
    the application, pushing it into a specific branch would cause the test suite
    to run (the trigger could create a new commit on this branch or merge it).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术也可以用于持续集成；不是部署应用程序，而是将其推送到特定分支会触发测试套件运行（触发器可以在该分支上创建一个新的提交或合并它）。
- en: Mob branches for anonymous push access
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于匿名推送访问的Mob分支
- en: Having a branch in a remote repository (on a server) with special treatment
    on push is a technique that has many uses, including helping to collaborate. It
    can be used to enable *controlled anonymous push access* for a project.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程仓库（服务器上）拥有一个特别处理推送的分支是一种具有多种用途的技术，包括帮助协作。它可以用来为一个项目启用*受控的匿名推送访问*。
- en: 'Let’s assume that you want to allow random contributors to push into the central
    repository. However, you would want to do this in a managed way: one solution
    is to create a special `mob` branch or a `mob/*` namespace (set of branches) with
    relaxed access control.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望允许随机的贡献者推送到中央仓库。但你会希望以一种受管理的方式进行：一种解决方案是创建一个特殊的`mob`分支或一个`mob/*`命名空间（分支集），并放宽访问控制。
- en: You’ll learn how to set this up in [*Chapter 14*](B21194_14.xhtml#_idTextAnchor349),
    *Git Administration*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[*第14章*](B21194_14.xhtml#_idTextAnchor349) *Git管理*中学习如何进行设置。
- en: The orphan branch trick
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 孤立分支的技巧
- en: The different types of branches described up to this point differed in their
    purpose and management. However, from a technical point of view (that is, from
    the point of view of the graph of commits), they all look the same. This is not
    the case with the so-called orphan branches.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止描述的不同类型的分支在目的和管理上有所不同。然而，从技术角度来看（即，从提交图的角度来看），它们都是相同的。所谓的孤立分支则不同。
- en: An **orphan branch** is a parallel disconnected (orphaned) line of development
    that shares no revisions with the main history of a project. It is a reference
    to a disjoint subgraph in the DAG of revisions, without any intersection with
    the main DAG graph. In most cases, their checkout is also composed of different
    files.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**孤立分支**是一个与主历史记录不共享任何修订的平行断开（孤立）开发线。它是对修订DAG（有向无环图）中的一个不相交子图的引用，与主DAG图没有交集。在大多数情况下，它们的检出也由不同的文件组成。'
- en: 'Such branches are sometimes used as a trick to store tangentially related contents
    in a single repository, instead of using separate repositories. (When using separate
    repositories to store related content, you might want to use some naming convention
    to denote this fact – for example, a common prefix.) They can be used to do the
    following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这类分支有时被作为一种技巧，用于将与项目稍微相关的内容存储在同一个仓库中，而不是使用单独的仓库。（当使用单独的仓库存储相关内容时，你可能会想使用一些命名约定来表示这一事实——例如，使用一个常见的前缀。）它们可以用来执行以下操作：
- en: Store the project’s web page files. For example, GitHub uses a branch named
    **gh-pages** for the project’s pages.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储项目的网页文件。例如，GitHub使用一个名为**gh-pages**的分支来存储项目的网页。
- en: Store generated files when the process of creating them requires some nonstandard
    toolchain. For example, the project documentation can be stored in the **html**,
    **man**, and **pdf** orphan branches (the **html** branch can be also used to
    deploy the documentation). This way, the user can get specific format of the documentation
    without needing to install the toolchain required to generate it.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当生成文件的过程需要一些非标准工具链时，可以存储生成的文件。例如，项目文档可以存储在 **html**、**man** 和 **pdf** 孤立分支中（**html**
    分支还可以用来部署文档）。这样，用户可以获取特定格式的文档，而无需安装生成文档所需的工具链。
- en: Store the project TODO notes (for example, in the **todo** branch), perhaps
    together with storing there some specialized maintainer tools (scripts).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储项目 TODO 备注（例如，在 **todo** 分支中），可能还可以将一些专门的维护者工具（脚本）存储在其中。
- en: Have deployment configuration for GitOps in the same repository as the source
    code, instead of having two separate repositories – one for code and one for deployment
    configuration.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 GitOps 的部署配置与源代码存储在同一个仓库中，而不是将代码和部署配置分开存储在两个不同的仓库中。
- en: 'You can create such a branch with `git checkout --orphan <new branch>` or by
    pushing into (or fetching into) a specific branch from a separate repository,
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `git checkout --orphan <new branch>` 创建这样的分支，或者通过从一个独立的仓库推送到（或拉取到）特定分支，如下所示：
- en: '[PRE0]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command fetches the `master` branch from the unrelated `repo-htmldocs`
    repository into the unconnected `html` “orphan” branch.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将从不相关的 `repo-htmldocs` 仓库中获取 `master` 分支到未连接的 `html` “孤立”分支。
- en: Trivia
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 小知识
- en: Creating an orphan branch with **git checkout --orphan** does not technically
    create a branch – that is, it does not make a new branch reference. What it does
    is point the symbolic **HEAD** reference to an unborn branch. The reference is
    created after the first commit on a new orphan branch. That’s why there is no
    option to create an orphan branch with the **git** **branch** command.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **git checkout --orphan** 创建孤立分支在技术上并不创建分支——也就是说，它不会创建新的分支引用。它所做的是将符号 **HEAD**
    引用指向一个尚未存在的分支。引用是在新孤立分支的第一次提交之后创建的。因此，不能使用 **git** **branch** 命令创建孤立分支。
- en: Other types of short-lived branches
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他类型的短期分支
- en: While long-lived branches stay forever, short-lived or temporary branches are
    created to deal with single issues, and are usually removed after dealing with
    said issue. They are intended to last only as long as the issue is present.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 长期存在的分支永远存在，而短期或临时分支是为了解决单个问题而创建的，通常在处理完该问题后会被删除。它们的存在时间仅与问题存在的时间一致。
- en: Because of their provisional nature, they are usually only present in the local
    private repository of a developer or integration manager (maintainer), and are
    not pushed to public distribution repositories. If they appear in public repositories,
    they are there only in a public repository of an individual contributor (see the
    blessed repository workflow in [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140),
    *Collaborative Development with Git*), as a target for a pull request.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其临时性，孤立分支通常仅存在于开发者或集成经理（维护者）的本地私有仓库中，并不会推送到公共分发仓库。如果它们出现在公共仓库中，则仅存在于个人贡献者的公共仓库中（参见
    [*第6章*](B21194_06.xhtml#_idTextAnchor140)，*使用 Git 进行协作开发*），作为拉取请求的目标。
- en: Bugfix branches
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bugfix 分支
- en: We can distinguish a special case of a topic branch whose purpose is fixing
    a bug. Such a branch should be created starting from the oldest integration branch
    it applies to (the most stable branch that contains the bug). This usually means
    forking off the maintenance branch or the divergence point of all the integration
    branches rather than the tip of the stable branch. A bugfix branch’s goal is to
    be merged into relevant long-lived integration branches.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分一个特殊的主题分支，其目的是修复一个 bug。此类分支应从适用的最旧集成分支（包含该 bug 的最稳定分支）开始创建。这通常意味着从维护分支或所有集成分支的分叉点创建，而不是从稳定分支的最新提交开始。Bugfix
    分支的目标是合并到相关的长期集成分支中。
- en: Bugfix branches can be thought of as a short-lived equivalent of a long-lived
    hotfix branch. Using them is a better alternative to simply committing fixes on
    the maintenance branch (or another appropriate integration branch).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Bugfix 分支可以视为长期存在的 hotfix 分支的短期替代品。使用它们比仅仅在维护分支（或其他适当的集成分支）上提交修复要更好。
- en: Detached HEAD – the anonymous branch
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Detached HEAD – 匿名分支
- en: You can think of the **detached HEAD** state (described in [*Chapter 2*](B21194_02.xhtml#_idTextAnchor028),
    *Developing with Git*) as the ultimate in temporary branches – so temporary that
    it even doesn’t have a name. Git uses such anonymous branches automatically in
    a few situations, such as during bisection and rebasing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把**分离的 HEAD** 状态（在 [*第 2 章*](B21194_02.xhtml#_idTextAnchor028)，*使用 Git 开发*
    中描述）看作是最终的临时分支——临时到甚至没有名字。Git 在一些情况下会自动使用这样的匿名分支，比如在二分查找和变基时。
- en: Because, in Git, there is only one anonymous branch and it must always be the
    current branch, it is usually better to create a true temporary branch with a
    temporary name; you can always change the name of the branch later.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在 Git 中只有一个匿名分支，而且它必须始终是当前分支，所以通常更好地创建一个真正的临时分支，并为其指定一个临时名称；你始终可以稍后更改该分支的名称。
- en: One possible use of the detached `HEAD` is for proof-of-concept work. However,
    you need to remember to set the name of the branch if the changes turn out to
    be worthwhile (or if you need to switch branches). It is easy to go from an anonymous
    branch to a named branch. You simply need to create a new branch from the current
    detached `HEAD` state.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 分离的 `HEAD` 的一种可能用途是用作概念验证工作。然而，你需要记得在修改被证明有价值时设置分支的名称（或者如果你需要切换分支）。从匿名分支转到命名分支是很容易的。你只需从当前的分离
    `HEAD` 状态创建一个新分支。
- en: Branching workflows and release engineering
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支工作流与发布工程
- en: Now that we know about the different branching patterns and their purposes,
    let’s examine how they can be composed into different branching workflows. Different
    situations call for different uses of branches, as well as different policies.
    For example, smaller projects are better suited for simpler branching workflows,
    while larger projects might need more advanced ones.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了不同的分支模式及其目的，让我们来看看如何将它们组合成不同的分支工作流。不同的情况需要使用不同的分支以及不同的策略。例如，较小的项目更适合简单的分支工作流，而较大的项目可能需要更复杂的工作流。
- en: In this section, we’ll describe how to use a few common workflows. Each workflow
    is distinguished by the various types of branches it uses. In addition to getting
    to know what the ongoing development looks like for a given workflow, we’ll also
    examine what it recommends doing at the time of the new release (major and minor,
    where relevant).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述如何使用几种常见的工作流。每种工作流通过它所使用的不同类型的分支来区分。除了了解特定工作流的持续开发情况外，我们还将探讨在新版本发布时（对于重大版本和次要版本，视情况而定）推荐的做法。
- en: The release and trunk branches workflow
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布和主干分支工作流
- en: One of the simplest workflows is to use just a single integration branch. Such
    branches are sometimes called `main` or `master` branch (it is the default branch
    when creating a repository). In a pure version of this workflow, you would commit
    everything to the said branch, at least during the normal development stage. This
    way of working comes from the times of centralized version control, when branching
    and especially merging were more expensive, and people avoided branch-heavy workflows.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的工作流之一是仅使用一个集成分支。这样的分支有时被称为 `main` 或 `master` 分支（它是创建仓库时的默认分支）。在该工作流的纯粹版本中，你会将所有内容提交到这个分支，至少在正常开发阶段是这样。这种工作方式源自集中式版本控制时代，那时分支，尤其是合并，代价较高，因此人们避免使用过多分支的工作流。
- en: This workflow is well-suited for continuous integration. If you can maintain
    a healthy trunk, new releases can be cut directly from it via tagging.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该工作流非常适合持续集成。如果你能够保持主干的健康状态，可以通过标记直接从主干切出新的发布版本。
- en: On the other hand, if the release process is more involved, this workflow can
    be used together with per-release branches. In this case, when we decide to cut
    the new release, we create the new release branch out of the trunk. This is done
    to avoid the interference between stabilizing for release and the ongoing development
    work. The rule is that all the stabilization work goes on the release branch,
    while all the ongoing development goes to the trunk. **Release candidates** are
    cut (tagged) from the release branch, as is the final version of a **major release**.
    The release branch for a given version can be later used to gather bug fixes and
    to cut **minor releases** from it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果发布过程更为复杂，这种工作流可以与每个版本的分支一起使用。在这种情况下，当我们决定进行新版本发布时，我们会从主干创建新的发布分支。这样做是为了避免发布稳定化与持续开发工作之间的干扰。规则是，所有的稳定化工作都在发布分支上进行，而所有的持续开发都在主干上进行。**候选发布**（Release
    candidates）是从发布分支切出的（打标签），就像**主要版本**的最终版本一样。给定版本的发布分支可以随后用于收集 bug 修复，并从中切出**小版本发布**。
- en: The disadvantage of such a simple workflow is that it requires maintaining a
    healthy branch. Otherwise, if we get in an unstable state during development,
    it can be hard to come up with a good starting point for a new release. An alternative
    solution is to create revert commits on the release branch, undoing the work that
    isn’t ready. However, this can be a lot of work, and it would make the history
    of a project hard to follow.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单工作流的缺点是它要求维持一个健康的分支。否则，如果在开发过程中进入不稳定状态，那么很难为新版本提供一个好的起点。一种替代方案是，在发布分支上创建还原提交，撤销尚未准备好的工作。然而，这可能需要大量的工作，并且会使项目的历史变得难以跟踪。
- en: Another difficulty with this workflow is that a feature that looks good at first
    glance might cause problems later. This is something this workflow has trouble
    dealing with. If it turns out during development that some feature created with
    multiple commits feature is not a good idea, reverting it can be difficult. This
    is true especially if its commits are spread across the timeline (across the history).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作流的另一个难点是，一个看起来不错的功能可能在后期会引发问题。这是这个工作流难以应对的情况。如果在开发过程中发现某个通过多个提交实现的功能不是一个好主意，回滚它可能会很困难。特别是当这些提交分布在时间线（历史）中时，这种情况尤为突出。
- en: Despite these problems, this simple workflow can be a good fit for a small or
    well-disciplined team.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些问题，这种简单的工作流对于小型或自律性强的团队来说是一个不错的选择。
- en: The graduation branches workflow
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 毕业分支工作流
- en: To be able to provide a stable line of the product, and to be able to test it
    in practice as a kind of floating beta version, you need to separate work that
    is stable from the work that is ongoing and might destabilize code. That’s what
    **graduation branches** are for – to integrate revisions with different degrees
    of maturation and stability (this type of long-running branch is also called an
    **integration** branch or **progressive-stability** branch). See *Figure 8**.1*
    in the *Maturity or progressive-stability branches* section, which shows a graph
    view and a silo view of a simple case with progressive-stability branches and
    linear history. Let’s call the technique that utilizes mainly (or only) this type
    of branch the **graduation** **branches workflow**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够提供产品的稳定版本，并能够将其作为一种浮动的 beta 版本进行实际测试，你需要将稳定的工作和正在进行且可能破坏代码的工作分开。这就是**毕业分支**的作用——用于集成不同成熟度和稳定性的修订（这种长期运行的分支也被称为**集成**分支或**渐进稳定性**分支）。请参见*图
    8.1*，位于*成熟度或渐进稳定性分支*部分，展示了渐进稳定性分支和线性历史的简单案例的图形视图和筒仓视图。我们将这种主要（或仅）使用这种类型分支的技术称为**毕业分支工作流**。
- en: Besides keeping stable and unstable development separate, there is also a need
    for ongoing maintenance. If there is only one version of the product to support,
    and the process of creating a new release is simple enough, you can also use the
    graduation-type branch for this.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保持稳定和不稳定开发分开的需求外，还需要持续的维护。如果只需要支持一个版本的产品，并且创建新版本的过程足够简单，那么你也可以为此使用毕业类型的分支。
- en: Here, simple enough means that you can just create the next major release out
    of the stable branch.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，“足够简单”意味着你可以仅从稳定分支中创建下一个主要版本。
- en: 'In such a situation, you would have at least three integration branches. There
    would be one branch for the ongoing maintenance work (containing only bug fixes
    to the last version), to create minor releases, another branch for stable work
    to create major releases (this branch can also be used for nightly stable builds),
    and another branch for ongoing development, possibly unstable:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你至少会有三个集成分支。一个分支用于持续的维护工作（只包含对最后版本的 bug 修复），用于创建小版本更新；另一个分支用于稳定工作，创建主要版本发布（此分支也可用于每夜构建的稳定版本）；还有一个分支用于持续开发，可能是不稳定的：
- en: '![Figure 8.3  – The graduation or progressive-stability branches workflow.
    You should never merge a less stable branch into a more stable one as it would
    bring all the unstable history](img/B21194_08_03.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 毕业或渐进稳定分支工作流。你绝不应将一个不太稳定的分支合并到更稳定的分支中，因为那样会带入所有不稳定的历史](img/B21194_08_03.jpg)'
- en: Figure 8.3 – The graduation or progressive-stability branches workflow. You
    should never merge a less stable branch into a more stable one as it would bring
    all the unstable history
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 毕业或渐进稳定分支工作流。你绝不应将一个不太稳定的分支合并到更稳定的分支中，因为那样会带入所有不稳定的历史。
- en: 'You can use this workflow as-is, with only graduation branches, and no other
    types of branches:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按原样使用这个工作流，只包含毕业分支，而不包含其他类型的分支：
- en: You commit bug fixes on the maintenance branch and merge it into the stable
    branch and development branch, if necessary
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在维护分支上提交 bug 修复，并在必要时将其合并到稳定分支和开发分支中。
- en: You create revisions with the well-tested work on the stable branch, merging
    it into the development branch when needed (for example, if the new work depends
    on them)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在稳定分支上创建经过充分测试的修订版，并在需要时将其合并到开发分支中（例如，如果新工作依赖于它们）。
- en: You put the work in progress, which might be unstable, on the development branch
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将进行中的工作（可能是不稳定的）放在开发分支上。
- en: During normal development, you should never merge less stable branches into
    more stable ones as this decreases their stability. This simple version of this
    workflow is shown in *Figure 8**.3*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常开发过程中，绝不应将不太稳定的分支合并到更稳定的分支中，因为这会降低它们的稳定性。这个工作流的简化版本展示在*图 8.3*中。
- en: This, of course, requires that you know upfront whether the feature that you
    are working on should be considered stable or unstable. There is also an underlying
    assumption that different features work well together from the start. In practice,
    however, you would expect that each piece of the development matures from the
    proof of concept, through being a work in progress during possibly several iterations,
    before it stabilizes. This problem can be solved by using topic branches, as described
    next.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这要求你在开始工作之前就知道你正在处理的功能应该被视为稳定还是不稳定。另有一个前提假设是，从一开始不同的功能就能很好地协同工作。然而，在实际操作中，你会期望每个开发环节都从概念验证开始，经过可能多次迭代的进行中的工作，最终稳定下来。这个问题可以通过使用主题分支来解决，接下来会进行说明。
- en: In the pure graduation branches workflow, you would create minor releases (with
    bug fixes) out of the maintenance branch. Major releases (with new features) are
    created out of the stable-work branch. After a major release, the stable-work
    branch is merged into the maintenance branch to begin supporting the new release
    that was just created. At this point, an unstable (development) branch can be
    merged into a stable one. This is the only time when merging upstream – that is,
    merging fewer stable branches into more stable branches – should be done.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯粹的毕业分支工作流中，你会从维护分支创建小版本发布（包含 bug 修复）。主要版本发布（包含新功能）则从稳定工作分支创建。在主要版本发布后，稳定工作分支会合并到维护分支中，以开始支持刚刚创建的新版。此时，可以将一个不稳定的（开发）分支合并到稳定分支中。这是唯一允许进行向上合并——即将不太稳定的分支合并到更稳定的分支中的时候。
- en: The topic branches workflow
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主题分支工作流
- en: 'The idea behind the topic branches workflow is to create a separate short-lived
    branch for each topic or feature so that all the commits belonging to a given
    topic (all the steps in its development) are kept together. The purpose of each
    **topic branch** is to develop a new feature or create a bug fix:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 主题分支工作流的核心思想是为每个主题或功能创建一个独立的短期分支，这样所有属于某一主题的提交（即其开发过程的所有步骤）都被保留下来。每个**主题分支**的目的是开发一个新功能或修复一个
    bug：
- en: '![Figure 8.4 – The topic branches workflow with one integration branch (master)
    and three topic or feature branches. One of the topic branches is merged into
    the integration branch and deleted](img/B21194_08_04.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 具有一个集成分支（master）和三个主题或功能分支的主题分支工作流。一个主题分支被合并到集成分支并删除](img/B21194_08_04.jpg)'
- en: Figure 8.4 – The topic branches workflow with one integration branch (master)
    and three topic or feature branches. One of the topic branches is merged into
    the integration branch and deleted
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 具有一个集成分支（master）和三个主题或功能分支的主题分支工作流。一个主题分支被合并到集成分支并删除
- en: In the **topic branches workflow** (also called the **feature branches workflow**),
    you have at least two different types of branches. First, there needs to be at
    least one permanent (or just long-lived) *integration branch*. This type of branch
    is used purely for merging. Integration branches are public.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在**主题分支工作流**（也称为**功能分支工作流**）中，至少有两种不同类型的分支。首先，至少需要有一个长期存在的*集成分支*。这种类型的分支纯粹用于合并。集成分支是公开的。
- en: Second, there are separate short-lived temporary *feature branches*, each intended
    for the development of a topic or the creation of a bug fix. They are used to
    carry all the steps, and only the steps required in the development of a feature
    or a fix – this is a unit of work for a developer. These branches can be deleted
    after the feature or the bug fix is merged. Topic branches are usually private
    and are often not present in public repositories.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，还有单独的短期临时*功能分支*，每个分支旨在开发某个主题或创建一个Bug修复。它们用于执行开发功能或修复所需的所有步骤——这是开发者的一个工作单元。这些分支可以在功能或Bug修复合并后删除。主题分支通常是私有的，且往往不出现在公共仓库中。
- en: When a feature is ready for review, its topic branch is often rebased to make
    integration easier, and optionally to make the history clearer. It is then sent
    for review as a whole. The topic branch can be used in a `git format-patch` and
    `git send-email`). It is then often saved as a separate topic branch in a maintainer’s
    working repository (for example, using `git am --3way` if it was sent as patches)
    to help in examining and managing it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个功能准备好进行审查时，它的主题分支通常会被重新基准化，以便于集成，并可选择性地使历史记录更加清晰。然后，整个分支会被发送进行审查。主题分支可以用于`git
    format-patch`和`git send-email`。它通常会被作为一个独立的主题分支保存在维护者的工作仓库中（例如，如果作为补丁发送，可以使用`git
    am --3way`），以帮助检查和管理它。
- en: Then, the integration manager (the maintainer in the blessed repository workflow,
    or simply another developer in the central repository workflow) reviews each topic
    branch and decides whether it is ready for inclusion in the selected integration
    branch. If it is, then it will be merged (perhaps with the `--``no-ff` option).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，集成管理者（在受信任的仓库工作流中是维护者，或者在中央仓库工作流中是其他开发者）会审查每个主题分支，并决定它是否准备好合并到选定的集成分支。如果准备好了，就会进行合并（可能使用`--no-ff`选项）。
- en: Graduation branches in a topic branch workflow
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主题分支工作流中的毕业分支
- en: The simplest variant of the topic branches workflow uses only one integration
    branch. Usually, however, you would combine the graduation branches workflow with
    topic branches.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 主题分支工作流的最简单变体只使用一个集成分支。然而，通常情况下，你会将毕业分支工作流与主题分支结合使用。
- en: '![Figure 8.5 – The topic branches workflow with two graduation branches. Among
    topic branches, there is one that is stable enough to be merged into both graduation
    branches](img/B21194_08_05.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 具有两个毕业分支的主题分支工作流。在主题分支中，有一个足够稳定的分支，可以合并到两个毕业分支](img/B21194_08_05.jpg)'
- en: Figure 8.5 – The topic branches workflow with two graduation branches. Among
    topic branches, there is one that is stable enough to be merged into both graduation
    branches
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 具有两个毕业分支的主题分支工作流。在主题分支中，有一个足够稳定的分支，可以合并到两个毕业分支
- en: In this often-used variant, the feature branch is started from the tip of a
    given stable branch (usually) or the last major release, unless the branch requires
    some other feature. In the latter case, the branch needs to be forked from (created
    from) the topic branch it depends on, such as the `feat` branch in *Figure 8**.5*.
    Bugfix topic branches are created on top of the maintenance branch.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个常用的变体中，功能分支通常是从给定稳定分支的最新状态（通常是）或最后一个主要发布版本开始，除非该分支需要某个其他功能。在后者的情况下，该分支需要从其依赖的主题分支中分叉（即从该主题分支创建），例如*图
    8.5*中的`feat`分支。Bugfix主题分支是在维护分支之上创建的。
- en: When the topic is considered done, it is merged into the development-work integration
    branch (for example, `next`) to be tested. For example, in *Figure 8**.5*, topic
    branches `idea` and `iss92` are both merged into `next`, while `feat` is not considered
    ready yet. Adventurous users can use builds from a given unstable branch to exercise
    the feature, though must take into account the possibility of crashes and data
    loss.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当该主题被认为完成时，它会被合并到开发工作集成分支（例如，`next`）进行测试。例如，在*图8.5*中，主题分支 `idea` 和 `iss92` 都已合并到
    `next`，而 `feat` 还未准备好。冒险的用户可以使用来自不稳定分支的构建来体验该功能，但必须考虑到崩溃和数据丢失的可能性。
- en: 'After this examination, when the feature is considered to be ready to be included
    in the next release, it is merged into the stable-work integration branch (for
    example, `master`). *Figure 8**.5* includes one such branch: `iss92`. At this
    point, after merging it into the stable integration branch, the topic branch can
    be deleted.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在经过这一步检查后，当功能被认为已准备好被包含在下一个版本中时，它会被合并到稳定工作集成分支（例如，`master`）。*图8.5* 包含了这样一个分支：`iss92`。此时，在将它合并到稳定集成分支后，主题分支可以被删除。
- en: Using a feature branch allows topical revision to be kept together and not mixed
    with other commits. The topic branch workflow allows you to easily undo topics
    as a whole and remove all bad commits together (removing a series of commits as
    a whole unit), instead of using a series of reverts.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用功能分支可以将专题修订保持在一起，而不会与其他提交混合。主题分支工作流使你可以轻松地整体撤销主题并一起删除所有错误提交（以整体单元移除一系列提交），而不是通过一系列回滚操作。
- en: If the feature turns out not to be ready, it is simply not merged into the stable
    branch, and it remains present only in the development-work branch. However, if
    we realize that it wasn’t ready too late, after the topic was merged into the
    stable branch, we would need to revert the merge. This is a slightly more advanced
    operation than reverting a single commit, but it is less troublesome than reverting
    commits one by one, while ensuring that all the commits get correctly reverted.
    Problems with reverting merges will be covered in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping* *History Clean*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该功能最终被认为还未准备好，它就不会被合并到稳定分支，而只会保留在开发工作分支中。然而，如果我们意识到它未准备好已经太晚，主题已经被合并到稳定分支后，我们就需要回滚合并。这比回滚单个提交稍微复杂一些，但比一个个回滚提交要更简单，同时能确保所有提交都被正确回滚。有关回滚合并的更多问题，请参阅[*第10章*](B21194_10_split_000.xhtml#_idTextAnchor247)，*保持*
    *历史* *清晰*。
- en: The workflow for topic branches containing bug fixes is similar. The only difference
    is that you need to consider which of the integration branches the bugfix branch
    is to be merged into. This, of course, depends on the situation. Perhaps the bugfix
    applies only to the maintenance branch, because it was accidentally fixed by a
    new feature in the stable-work and development-work branches; then, it is merged
    only to this branch. Perhaps the bug only applies to the stable-work and development-work
    branches because it is about the feature that was not present in the previous
    version, thus the maintenance branch is excluded from being merged into.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 bug 修复的主题分支工作流类似。唯一的不同是，你需要考虑该 bugfix 分支将合并到哪个集成分支。这当然取决于具体情况。也许该 bug 修复仅适用于维护分支，因为它是通过稳定工作分支和开发工作分支中的新功能意外修复的；那么，它就只会合并到该分支。也许该
    bug 仅适用于稳定工作和开发工作分支，因为它涉及一个在先前版本中不存在的功能，因此维护分支不会被合并进来。
- en: 'Using a separate topic branch for bug fixing, instead of committing a bugfix
    directly, has an additional advantage: it allows us to easily correct the misstep
    if it turns out after the fact that the fix applies to more branches than we thought.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单独的主题分支来修复 bug，而不是直接提交修复，有一个额外的优势：如果事后发现修复涉及的分支比预期的更多，这样可以轻松纠正错误。
- en: For example, if it turns out that the fix needs to also be applied to the maintained
    version and not only to the current work, with the topic branch you can simply
    merge the fix into additional branches. This is not the case if we were to commit
    the fix directly to the stable branch. In the latter situation, you cannot use
    merging as it would destabilize the maintenance branch. You would need to copy
    the revision with the fix by **cherry-picking** it from the branch it was committed
    to into the maintenance branch (see [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229),
    *Merging Changes Together*, for a detailed description of this operation). But
    it means that duplicated commits are present in the history of the project, and
    cherry-picked commits can sometimes interact wrongly with the act of merging.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果发现修复也需要应用到维护版本，而不仅仅是当前的工作版本，使用主题分支时，你可以简单地将修复合并到其他分支中。如果直接将修复提交到稳定分支，则不能这样操作。在后一种情况下，你不能使用合并，因为这会破坏维护分支的稳定性。你需要通过**挑选提交**（**cherry-picking**）将修复从其原始提交分支复制到维护分支中（有关此操作的详细描述，请参见[*第9章*](B21194_09.xhtml#_idTextAnchor229)，*合并更改*）。但是，这意味着在项目历史中会出现重复的提交，而挑选的提交有时可能与合并操作发生冲突。
- en: The topic branches workflow also allows us to check whether the features conflict
    with each other, and then fix them as necessary. You can simply create a throw-away
    integration branch and merge into it topic branches containing these features,
    to test the interaction between them. You can even publish such branches meant
    for integration testing (named `proposed-updates` or just `pu`, for example) to
    allow other developers to examine the works in progress. However, you should state
    explicitly in the developer documentation that said branch should not be used
    as a basis to work on, as it is recreated each time from scratch.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 主题分支工作流还允许我们检查功能是否相互冲突，并在必要时进行修复。你可以简单地创建一个临时的集成分支，将包含这些功能的主题分支合并到该分支中，以测试它们之间的相互作用。你甚至可以发布这样的集成测试分支（例如命名为`proposed-updates`或简称`pu`），让其他开发者查看正在进行的工作。然而，你应该在开发者文档中明确声明，不应以该分支为基础进行工作，因为它每次都会从头创建。
- en: Branch management for a release in a topic branch workflow
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主题分支工作流中的发布分支管理
- en: 'Let’s assume that we’re using three graduation (integration) branches: `maint`
    for maintenance work on the last release, `master` for stable work, and `next`
    for development.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用三个毕业（集成）分支：`maint`用于上一个版本的维护工作，`master`用于稳定工作，`next`用于开发。
- en: 'The first thing that the maintainer (the release manager) needs to do before
    creating a new release is to verify that `master` is a superset of `maint` – that
    is, all the bugs are also fixed in the version being considered for the next release.
    You can do this by checking whether the following command gives an empty output
    (see [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083), *Exploring* *Project History*):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新版本之前，维护者（发布经理）需要做的第一件事是验证`master`是否包含`maint`的所有内容——也就是说，所有的错误修复是否也已应用于正在考虑发布的下一个版本。你可以通过检查以下命令是否输出空结果来验证这一点（见[*第4章*](B21194_04.xhtml#_idTextAnchor083)，*探索*
    *项目历史*）：
- en: '[PRE1]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the preceding command shows some unmerged commits, the maintainer needs to
    decide what to do with them. If these bug fixes don’t break anything, they can
    simply merge `maint` into `master` (as it’s merging the more stable branch into
    the less stable one).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述命令显示有未合并的提交，维护者需要决定如何处理这些提交。如果这些错误修复没有破坏任何内容，可以直接将`maint`合并到`master`中（因为这相当于将更稳定的分支合并到较不稳定的分支）。
- en: 'Now that the maintainer knows that `master` is a superset of `maint`, they
    can create the new release from the remote `master` branch by tagging it and push
    the just-created tag to the distribution point (to the public repository) with
    the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，维护者知道`master`是`maint`的超集后，可以通过为远程`master`分支打标签来创建新版本，并将新创建的标签推送到分发点（即公共仓库），可以使用以下命令：
- en: '[PRE2]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding command assumed that the public repository of the Foo project
    is the one described by `origin` and that we use the double-digit version for
    major releases (following the semantic versioning specification).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令假设Foo项目的公共仓库是由`origin`描述的，并且我们采用双位数字版本号来表示主要版本（遵循语义版本控制规范）。
- en: Tip
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If the maintainer wants to support more than one older version, they would
    need to copy an old maintenance branch, as the next step would be to prepare it
    for maintaining the just-released revision: **git branch** **maint-1.3.x maint**.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果维护者想要支持多个旧版本，他们需要复制一个旧的维护分支，因为接下来的步骤是准备它以维护刚刚发布的版本：**git branch** **maint-1.3.x
    maint**。
- en: 'Then, the maintainer updates `maint` to the new release, advancing the branch
    (note that step one ensured that `maint` was a subset of `master`):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，维护者将`maint`更新到新发布版本，推进该分支（注意，第一步确保了`maint`是`master`的子集）：
- en: '[PRE3]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the second command fails, it means that some commits on the `maint` branch
    are not present in `master`, or to be more exact that `master` is not a strict
    descendant of `maint`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个命令失败，意味着`maint`分支上的一些提交没有出现在`master`中，或者更准确地说，`master`不是`maint`的严格后代。
- en: Because we usually consider features for inclusion in `master` one by one, there
    might be some topic branches that are merged into `next`, but they were abandoned
    before they were merged into `master` (or they are not merged because they were
    not ready). This means that though the `next` branch contains a superset of topic
    branches that compose the `master` branch, `master` is not necessarily the ancestor
    of `next`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们通常会逐个考虑将特性合并到`master`中，所以可能有一些主题分支被合并到了`next`中，但它们在合并到`master`之前被放弃了（或者由于未准备好而未合并）。这意味着，虽然`next`分支包含了构成`master`分支的主题分支的超集，但`master`不一定是`next`的祖先。
- en: 'That’s why advancing the `next` branch after a release can be more complicated
    than advancing the `maint` branch. One solution is to rewind and rebuild the `next`
    branch:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在发布后推进`next`分支比推进`maint`分支更复杂的原因。一个解决方案是回退并重建`next`分支：
- en: '[PRE4]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can find unmerged topics to be merged to rebuild `next` by running the
    following command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令找到未合并的主题分支，以便合并并重建`next`：
- en: '[PRE5]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After creating the release after rebuilding `next`, other developers would
    have to force fetch the `next` branch (see the next section) as it would not fast-forward
    if it were not already configured to force fetch:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在重建`next`分支并创建发布版本后，其他开发者需要强制获取`next`分支（见下一节），因为如果没有配置为强制获取，它是无法快速前进的：
- en: '[PRE6]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice the forced update for the `next` branch here.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里对`next`分支的强制更新。
- en: git-flow – a successful Git branching model
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: git-flow——一个成功的Git分支模型
- en: 'The more advanced version of the topic branching workflow builds on top of
    the graduation branch’s one. In some cases, an even more involved branching model
    might be necessary, utilizing more types of branches: graduation branches, release
    branches, hotfix branches, and topic branches. One such model is `git-flow`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的主题分支工作流版本是在毕业分支模型的基础上构建的。在某些情况下，可能需要一个更复杂的分支模型，使用更多类型的分支：毕业分支、发布分支、热修复分支和主题分支。其中一种模型是`git-flow`。
- en: This development model uses two main long-running `master` (stable work) and
    `develop` (gathers changes for the next release). The latter can be used for nightly
    builds. These two integration branches have an infinite lifetime.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个开发模型使用两个主要的长期运行分支`master`（稳定工作）和`develop`（收集下一个发布的更改）。后者可以用于夜间构建。这两个集成分支有无限的生命周期。
- en: These branches are accompanied by **supporting branches** – that is, *feature
    branches*, *release branches*, and *hotfix branches*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分支伴随有**支持分支**——也就是*特性分支*、*发布分支*和*热修复分支*。
- en: Each new feature is developed on a `devel` or `master` branch, depending on
    the requirements of the feature in question. When work on a feature is finished,
    its topic branch is merged with the `--no-ff` option (so that there is always
    a merge commit where a feature can be described) into `devel` for integration
    testing. When they are ready for the next release, they are merged into the `master`
    branch. A topic branch exists only as long as a feature is in development and
    is deleted when merged (or when abandoned).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新特性都在`devel`或`master`分支上开发，具体取决于特性的需求。当特性开发完成后，其主题分支会使用`--no-ff`选项进行合并（这样就会总是创建一个合并提交，用来描述特性）到`devel`进行集成测试。当它们准备好进行下一次发布时，它们会被合并到`master`分支。主题分支只在特性开发期间存在，并在合并后被删除（或在放弃时删除）。
- en: The purpose of a **release branch** is twofold. When created, the goal is to
    prepare a new production release. This means doing last-minute cleanup, applying
    minor bug fixes, and preparing metadata for a release (for example, version numbers,
    release names, and so on). All but the last should be done using topic branches;
    metadata can be prepared directly on the release branch. This use of the release
    branch allows us to separate the quality assurance for the upcoming release from
    the work developing features for the next big release.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布分支**的目的有两个。当创建时，目标是准备新的生产版本发布。这意味着进行最后的清理、应用小的bug修复，并准备发布的元数据（例如，版本号、发布名称等）。除了最后一步之外，所有工作都应该通过主题分支完成；元数据可以直接在发布分支上准备。发布分支的使用使我们能够将即将发布版本的质量保证与为下一个大版本开发功能的工作分开。'
- en: Such release branches are forked off when the stable state reflects, or is close
    to, the desired state planned for the new release. Each such branch is named after
    a release, usually something such as `release-1.4` or `release-v1.4.x`. You would
    usually create a few release candidates from this branch (tagging them `v1.4-rc1`
    and so on) before tagging the final state of the new release (for example, `v1.4`).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此类发布分支是在稳定状态反映或接近新发布所规划的理想状态时分叉出来的。每个这样的分支都以发布命名，通常是类似`release-1.4`或`release-v1.4.x`的名称。通常，你会从这个分支创建几个发布候选版本（将它们标记为`v1.4-rc1`等），然后再标记新发布的最终版本（例如，`v1.4`）。
- en: 'The release branch might exist only until the time the project release it was
    created for is rolled out, or it might be left to gather maintenance work: bug
    fixes for the given. In the latter situation, it replaces the `maint` branch of
    other workflows.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 发布分支可能只会存在到项目发布它所创建的版本为止，或者它可能会被保留以进行维护工作：为给定版本修复bug。在后一种情况下，它会替代其他工作流中的`maint`分支。
- en: '`hotfix-1.4.1` or something similar. A hotfix branch is created out of an old
    release tag if the respective release (maintenance) branch does not exist. The
    purpose of this type of branch is to resolve critical bugs found in a production
    version. After putting a fix on such branches, the minor release is cut (for each
    such branch).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`hotfix-1.4.1`或类似名称。如果相应的发布（维护）分支不存在，则从旧的发布标签创建一个热修复分支。这种分支的目的是解决生产版本中发现的关键bug。在这些分支上进行修复后，会发布小版本（为每个这样的分支）。'
- en: Ship/Show/Ask – a modern branching strategy
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ship/Show/Ask —— 现代分支策略
- en: This approach tries to provide a balance between the advantages of doing pre-integration
    code reviews with pull requests and feature branches, and high-frequency integration
    and release-ready mainline that scaled trunk-based development provides.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法尝试在进行预集成代码审查的拉取请求和特性分支与基于主干开发所提供的高频集成和发布就绪主线之间找到一个平衡。
- en: In this workflow, you choose one of the three options – *Ship*, *Show*, or *Ask*
    – every time you make a change. With **Ship**, you add a change directly into
    the mainline (like in trunk-based development). This is useful if you want fast
    integration while being sure that the change is healthy – for example, if you
    add a feature using an established pattern, fix a simple bug, or update documentation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个工作流中，每次做出修改时，你需要选择三个选项之一——*Ship*、*Show* 或 *Ask*。选择**Ship**时，你会将更改直接合并到主线（类似于基于主干的开发）。如果你想要快速集成并确保更改是健康的，这种方法非常有用——例如，当你使用已建立的模式添加一个功能、修复一个简单的bug，或者更新文档时。
- en: With **Show**, you open a pull request but merge it straight away (if the automated
    checks pass). This allows for easy post-integration review while not making the
    feature wait.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**Show**时，你会打开一个拉取请求，但如果自动检查通过，则立即合并它。这允许在不让特性等待的情况下进行轻松的集成后审查。
- en: Finally, with **Ask**, you follow the topic branch workflow and wait for the
    code review before integration.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，选择**Ask**时，你会遵循主题分支工作流，并在集成前等待代码审查。
- en: Fixing a security issue
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复安全问题
- en: 'Let’s examine another situation: how we can use branches to fix a bug, such
    as a security issue. This requires a slightly different technique than in ordinary
    development.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看另一种情况：如何使用分支来修复bug，比如安全问题。这需要比普通开发稍微不同的技巧。
- en: As explained in the *The topic branches workflow* section, while it is possible
    to create a bugfix commit directly on the most stable of the integration branches
    that is affected by the bug, it is usually better to create a separate bugfix
    branch.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如*主题分支工作流*部分所解释的那样，虽然可以在最稳定的集成分支上直接创建bug修复提交，但通常最好创建一个单独的bug修复分支。
- en: You start by forking from the oldest (most stable) integration branch the fix
    needs to be applied to, perhaps even at the branching point of all the branches
    it would apply to. You put the fix (perhaps consisting of multiple commits) on
    the branch that you have just created. After testing it, you simply merge the
    bugfix branch into each of the integration branches that need the fix.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先从需要应用修复的最旧（最稳定）的集成分支上进行分叉，可能甚至是在所有相关分支的分叉点。你将修复（可能包含多个提交）放到你刚刚创建的分支上。测试完成后，你只需要将
    bug 修复分支合并到每个需要修复的集成分支中。
- en: This model can be also used to resolve conflicts (dependencies) between branches
    at an early stage. Let’s assume that you are working on some new feature (on a
    topic branch) that is not ready yet. While writing it, you noticed some bugs in
    the development version and you know how to fix them. You want to work on top
    of the fixed state, but you realize that other developers would also want the
    bugfix. Committing the fix on top of the feature branch takes the bugfix hostage.
    Fixing the bug directly on an integration branch has a risk of forgetting to merge
    the bugfix into the feature in progress.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型也可以用于在早期阶段解决分支之间的冲突（依赖关系）。假设你正在开发某个尚未完成的新特性（在一个主题分支上）。在编写过程中，你发现开发版本中存在一些
    bug，并且知道如何修复它们。你希望在修复后的状态上进行开发，但你意识到其他开发人员也会需要这个 bug 修复。将修复提交到特性分支上会让 bug 修复“被绑架”。直接在集成分支上修复
    bug，则有可能忘记将修复合并到正在进行中的特性分支中。
- en: The solution is to create a fix on a separate topic branch and merge it into
    both the topic branch for the feature being developed and into the test integration
    branch (and possibly the graduation branches).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是：在一个单独的主题分支上创建修复，并将其合并到正在开发的特性主题分支以及测试集成分支中（并可能合并到发布分支）。
- en: Tip
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can use similar techniques to create and manage some features that are requested
    by a subset of customers. You need to simply create a separate topic branch for
    each such feature and merge it into the individual, per-customer branches.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类似的技术来创建和管理一些客户群体要求的特性。你只需要为每个这样的特性创建一个单独的主题分支，并将其合并到每个客户的单独分支中。
- en: The matter is a bit more complicated if there is security involved. In the case
    of a severe security bug, you would want to fix it not only in the current version
    but also in all the widely used versions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果涉及安全问题，事情就会变得更加复杂。在严重的安全漏洞情况下，你不仅需要在当前版本中修复它，还需要在所有广泛使用的版本中修复它。
- en: 'To do this, you need to create a hotfix branch for various maintenance tracks
    (forking it from the specified version):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你需要为各种维护轨道创建一个热修复分支（从指定版本分叉）。
- en: '[PRE7]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, you need to merge the topic branch with the fix in question into the
    just created hotfix branch, to finally create the bugfix release:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要将包含修复的主题分支合并到新创建的热修复分支中，最终创建 bug 修复发布版本：
- en: '[PRE8]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Interacting with branches in remote repositories
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与远程仓库中的分支交互
- en: As we’ve seen, having many branches in a single repository is very useful. Easy
    branching and merging allow for powerful development models that utilize advanced
    branching techniques, such as topic branches. This means that remote repositories
    will also contain many branches. Therefore, we have to go beyond just the repository
    to the repository interaction, as described in [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140),
    *Collaborative Development with Git*. We have to consider how to interact with
    multiple branches in the remote repositories.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在单个仓库中拥有多个分支非常有用。简便的分支和合并使得利用高级分支技术（如主题分支）的强大开发模型成为可能。这意味着远程仓库也将包含许多分支。因此，我们必须超越仅仅关注仓库间的交互，正如[*第6章*](B21194_06.xhtml#_idTextAnchor140)《*使用
    Git 进行协同开发*》中所描述的那样，我们必须考虑如何与远程仓库中的多个分支进行交互。
- en: We also need to think about how many local branches in our repository relate
    to the branches in the remote repositories (or, in general, other refs). The other
    important knowledge is how the tags in the local repository relate to the tags
    in other repositories.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑仓库中的本地分支与远程仓库中的分支（或一般的其他引用）之间的关系。另一个重要的知识点是本地仓库中的标签与其他仓库中的标签之间的关系。
- en: Understanding the interaction between repositories, the branches in these repositories,
    and how to merge changes (as described in [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229),
    *Merging Changes Together*) is required to truly master collaboration with Git.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 理解仓库之间、这些仓库中的分支之间的交互，以及如何合并变更（如[*第9章*](B21194_09.xhtml#_idTextAnchor229)，*合并变更*所述），对于真正掌握与Git的协作至关重要。
- en: Upstream and downstream
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上游与下游
- en: In software development, **upstream** refers to a direction toward the original
    authors or the maintainers of the project. We can say that the *repository* is
    upstream from us if it is closer (in the repository-to-repository steps) to the
    blessed repository – the canonical source of the software. If a change (a patch
    or a commit) is accepted upstream, it will be included either immediately or in
    a future release of an application, and all the people **downstream** will receive
    it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，**上游**指的是指向项目原作者或维护者的方向。如果一个*仓库*距离我们更近（在仓库与仓库之间的步骤上），那么我们可以说它是上游的，即指向那个被认定为软件源代码的仓库。如果一个变更（补丁或提交）被上游接受，它将立即或在未来的应用发布中包含，并且所有**下游**的人都将接收到这个变更。
- en: Similarly, we can say that a given *branch* in a remote repository (the maintainer
    repository) is an **upstream branch** for a given local branch if changes in that
    local branch are to be ultimately merged and included in the remote branch.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以说远程仓库中的某个给定*分支*（维护者仓库）是某个本地分支的**上游分支**，如果该本地分支中的变更最终将被合并并包含到远程分支中。
- en: Configuring what is considered upstream
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 配置上游的定义
- en: 'A quick reminder: the upstream repository and the upstream branch in the said
    remote repository for a given branch are defined by the **branch.<branchname>.remote**
    and **branch.<branchname>.merge** configuration variables, respectively. The upstream
    branch can be referred to with the **@{upstream}** or **@{****u}** shortcut.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 快速提醒：给定分支的上游仓库和上游分支在该远程仓库中的定义分别由**branch.<branchname>.remote**和**branch.<branchname>.merge**配置变量确定。上游分支可以通过**@{upstream}**或**@{****u}**快捷方式进行引用。
- en: The upstream branch is usually set while creating a branch out of the remote-tracking
    branch, and it can be modified using either **git branch --set-upstream-to** or
    **git** **push --set-upstream**.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 上游分支通常是在从远程跟踪分支创建一个新分支时设置的，且可以通过**git branch --set-upstream-to**或**git push
    --set-upstream**进行修改。
- en: The upstream branch does not need to be a branch in the remote repository. It
    can be a local branch, though we usually say that it is a **tracked branch** rather
    than saying that it is an upstream one. This feature can be useful when one local
    branch is based on another local branch, such as when a topic branch is forked
    from another topic branch (because it contains the feature that is a prerequisite
    for the latter work).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 上游分支不一定是远程仓库中的分支。它也可以是本地分支，尽管我们通常称其为**跟踪分支**，而不是称其为上游分支。当一个本地分支基于另一个本地分支时，这一功能特别有用，比如当一个主题分支是从另一个主题分支派生出来时（因为它包含了后续工作所需的功能）。
- en: Remote-tracking branches and refspec
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程跟踪分支与引用规范
- en: While collaborating on a project, you will be interacting with many repositories
    (see [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140), *Collaborative Development
    with Git*). Each of these remote repositories you are interacting with will have
    a notion of the position of the branches. For example, the `master` branch in
    the remote repository, `origin`, doesn’t need to be at the same place as your
    local `master` branch in your clone of the repository. In other words, they don’t
    need to point to the same commit in the graph of revisions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在协作项目中，你会与许多仓库进行交互（见[*第6章*](B21194_06.xhtml#_idTextAnchor140)，*与Git的协作开发*）。你交互的每一个远程仓库都会有关于分支位置的概念。例如，远程仓库`origin`中的`master`分支不需要与你克隆仓库中的本地`master`分支在同一个位置。换句话说，它们不需要指向修订图中的同一个提交。
- en: Remote-tracking branches
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 远程跟踪分支
- en: 'To be able to check the integration status to see what changes there are in
    the `origin` remote repository that are not yet in yours, or what changes you
    made in your working repository that you have not published yet, you need to know
    where the branches in the remote repositories are (well, where they were the last
    time you contacted these repositories). This is the task of **remote-tracking
    branches** – the references that track where the branch was in the remote repository:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够检查集成状态，查看`origin`远程仓库中有哪些尚未同步到本地的更改，或查看你在本地仓库中所做的更改且尚未发布的内容，你需要知道远程仓库中分支的位置（嗯，也就是它们上次与这些仓库通信时的位置）。这是**远程跟踪分支**的任务——这些引用用于追踪远程仓库中分支的位置：
- en: "![Figure 8.6 – Remote repository and local repository with local branches and\
    \ remote-tracking branches. The grayed-out text in the fetch command denotes the\
    \ default implicit parameters\uFEFF.](img/B21194_08_06.jpg)"
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: "![图 8.6 – 远程仓库和本地仓库，包含本地分支和远程跟踪分支。fetch 命令中灰色文本表示默认的隐式参数\uFEFF。](img/B21194_08_06.jpg)"
- en: Figure 8.6 – Remote repository and local repository with local branches and
    remote-tracking branches. The grayed-out text in the fetch command denotes the
    default implicit parameters.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 远程仓库和本地仓库，包含本地分支和远程跟踪分支。fetch 命令中灰色文本表示默认的隐式参数。
- en: To track what happens in the remote repository, remote-tracking branches are
    updated automatically; this means that you cannot create new local commits on
    top of them (as you would lose these commits during updates). You need to create
    a local branch for it. This can be done, for example, by running `git checkout
    <branchname>`, assuming that the local branch with the given name does not already
    exist. This command creates a new local branch out of the remote branch’s `<branchname>`
    and sets the upstream information for it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪远程仓库中的变化，远程跟踪分支会自动更新；这意味着你无法在其上创建新的本地提交（因为在更新过程中这些提交会丢失）。你需要为此创建一个本地分支。例如，你可以通过运行`git
    checkout <branchname>`来实现，前提是具有给定名称的本地分支尚未存在。此命令会从远程分支的`<branchname>`创建一个新的本地分支，并为其设置上游信息。
- en: Refspec – remote to local branch mapping specification
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Refspec – 远程到本地分支的映射规范
- en: As described in [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083), *Exploring
    Project History*, local branches are in the `refs/heads/` namespace, while remote-tracking
    branches for a given remote are in the `refs/remotes/<remote name>/` namespace.
    But that’s just the default. The `fetch` (and `push`) lines in the `remote.<remote
    name>` configuration describe the mapping between branches (or refs in general)
    in the remote repository and the remote-tracking branches (or other refs) in the
    local repository.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[*第 4 章*](B21194_04.xhtml#_idTextAnchor083)《探索项目历史》中所述，本地分支位于`refs/heads/`命名空间中，而针对某个远程仓库的远程跟踪分支位于`refs/remotes/<远程名称>/`命名空间中。但这仅仅是默认设置。`fetch`（和`push`）命令中的`remote.<远程名称>`配置描述了远程仓库中的分支（或其他引用）与本地仓库中的远程跟踪分支（或其他引用）之间的映射关系。
- en: This mapping is called **refspec**; it can be either explicit, mapping branches
    one by one, or globbing, describing a mapping pattern.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射称为**refspec**；它可以是显式的，逐一映射分支，也可以是通配符的，描述映射模式。
- en: 'For example, the default mapping for the `origin` repository is as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`origin`仓库的默认映射如下所示：
- en: '[PRE9]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This says that, for example, the content of the `master` branch (whose full
    name is `refs/heads/master`) in the remote repository, `origin`, is to be stored
    in the local clone of a repository in the remote-tracking branch, `origin/master`
    (whose full name is `refs/remotes/origin/master`). The plus (`+`) sign at the
    beginning of the pattern tells Git to accept the updates to the remote-tracking
    branch that are not fast-forwarded – that is, they are not descendants of the
    previous value.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示，例如，远程仓库`origin`中的`master`分支（完整名称为`refs/heads/master`）的内容将存储在本地仓库的远程跟踪分支`origin/master`（完整名称为`refs/remotes/origin/master`）中。模式开头的加号（`+`）告诉
    Git 接受那些非快进更新的远程跟踪分支——也就是说，它们不是前一个值的后代。
- en: The mapping can be given using the fetch lines in the configuration for the
    remote, as shown previously, or can be also passed as arguments to a command (it
    is often enough to specify just the short name of the reference instead of the
    full refspec). The configuration is only taken into account if there are no refspecs
    on the command line.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 映射可以通过远程配置中的 fetch 行给出，如前所示，或者也可以作为命令的参数传递（通常只需要指定引用的短名称，而不需要完整的 refspec）。只有在命令行没有
    refspec 时，配置才会被考虑。
- en: Fetching and pulling versus pushing
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和拉取与推送的区别
- en: Sending changes (publishing) to the remote repository can be done with `git
    push`, while getting changes from it can be done with `git fetch`. These commands
    send changes in the opposite direction. However, note that your local repository
    has a very important difference – it has you sitting next to you’re keyboard so
    that you’re available to run other Git commands.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 向远程仓库发送更改（发布）可以通过`git push`完成，而从远程获取更改可以通过`git fetch`完成。这些命令会将更改发送到相反的方向。然而，请注意，你的本地仓库有一个非常重要的区别—它有你坐在键盘旁边，这样你可以随时运行其他
    Git 命令。
- en: That’s why there is no equivalent in the local-to-remote direction to `git pull`,
    which combines getting and integrating changes (see the next section). There is
    simply nobody there to resolve possible conflicts (problems occurring during doing
    automated integration).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在本地到远程的方向上没有与`git pull`等效的命令，因为`git pull`结合了获取和集成更改（请参阅下一节）。只是没有人能够解决可能发生的冲突（在进行自动化集成时发生的问题）。
- en: In particular, there is a difference between how branches and tags are fetched
    and how they are pushed. This will be explained in detail later.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，分支和标签的获取方式与推送方式有所不同。这个问题将在后面详细解释。
- en: Pull – fetching and updating the current branch
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pull – 获取并更新当前分支
- en: Many times, you want to incorporate changes from a specific branch of a remote
    repository into the current branch. The `git fetch` with the parameters given);
    then, it automatically integrates the retrieved branch head into the current branch.
    Depending on the configuration, it either calls `git merge` or `git rebase` to
    do that. You can use the `--rebase=false` or `--rebase` option to override the
    default, something that can be configured globally with the `pull.rebase` configuration
    option or `branch.<branch name>.rebase` per-branch configuration option.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，你可能想将远程仓库特定分支的变更合并到当前分支中。`git fetch` 会根据给定的参数来执行操作；然后，它会自动将检索到的分支头合并到当前分支。根据配置，它会调用`git
    merge`或`git rebase`来完成这个操作。你可以使用`--rebase=false`或`--rebase`选项来覆盖默认设置，这些设置可以通过`pull.rebase`配置选项或每个分支的`branch.<branch
    name>.rebase`配置选项进行全局配置。
- en: Note that if there is no configuration for the remote (you are doing the pull
    by URL), Git uses the `FETCH_HEAD` ref to store tips of the fetched branches.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果远程没有配置（你是通过 URL 执行 pull 操作），Git 会使用`FETCH_HEAD`引用来存储已获取分支的提示。
- en: There is also the `git request-pull` command to create information about published
    or pending changes for the pull-based workflows – for example, for a variant of
    the blessed repository workflow. It creates a plain text equivalent of the GitHub
    merge requests, one that is particularly suitable to send by email.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`git request-pull`命令，用于创建有关已发布或待处理更改的信息，适用于基于拉取的工作流—例如，适用于变体的受祝福的仓库工作流。它会创建一个简单文本格式的
    GitHub 合并请求，特别适合通过电子邮件发送。
- en: Pushing to the current branch in a non-bare remote repository
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向非裸远程仓库的当前分支推送
- en: Usually, the repositories you push to are created for synchronization and are
    `HEAD`) – there is no worktree, so there is no checked-out branch.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你推送的仓库是为了同步而创建的，并且是`HEAD`）– 这里没有工作树，因此没有被检出的分支。
- en: Sometimes, however, you might want to push to the non-bare repository. This
    may happen, for example, as a way of synchronizing two repositories, or as a mechanism
    for deployment (for example, of a web page or a web application). By default,
    Git on the server will deny the ref update to the currently checked-out branch.
    This is because it brings `HEAD` out of sync with the worktree and the staging
    area, which is very confusing if you don’t expect it. You can, however, enable
    such a push by setting `receive.denyCurrentBranch` to `warn` or `ignore` (changing
    it from the default value of `refuse`). You can even make Git update the working
    directory (which must be clean – that is, without any uncommitted changes) by
    setting the said configuration variable to `updateInstead`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能想要推送到非裸仓库。例如，这种情况可能发生在同步两个仓库，或者作为部署机制（例如，网页或 Web 应用程序的部署）。默认情况下，Git
    服务器会拒绝对当前检出的分支进行 ref 更新。这是因为它会使 `HEAD` 与工作树和暂存区不同步，如果你没有预料到这一点，会非常混淆。然而，你可以通过将
    `receive.denyCurrentBranch` 设置为 `warn` 或 `ignore`（将其从默认的 `refuse` 更改）来启用这种推送。你甚至可以通过将此配置变量设置为
    `updateInstead` 来使 Git 更新工作目录（必须是干净的，即没有未提交的更改）。
- en: An alternative and a more flexible solution to using `git push` for deployment
    is to configure appropriate hooks on the receiving side – see [*Chapter 13*](B21194_13_split_000.xhtml#_idTextAnchor320),
    *Customizing and Extending Git*, for information on hooks in general, and [*Chapter
    14*](B21194_14.xhtml#_idTextAnchor349), *Git Administration*, for details on their
    use on the server.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `git push` 部署的一个替代方案和更灵活的解决方案是配置接收方的适当钩子 – 有关钩子的详细信息，请参见 [*第13章*](B21194_13_split_000.xhtml#_idTextAnchor320)，*自定义和扩展
    Git*，以及 [*第14章*](B21194_14.xhtml#_idTextAnchor349)，*Git 管理*，了解它们在服务器上的使用情况。
- en: The default fetch refspec and push modes
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认的 fetch refspec 和 push 模式
- en: We usually fetch from public repositories with all the branches made public.
    Often, we want to get a full update of all the branches. That’s why `git clone`
    sets up the default `git pull <``URL> <branch>`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常从公开仓库获取所有公开的分支。通常，我们希望更新所有分支的最新状态。这就是为什么 `git clone` 设置了默认的 `git pull <``URL>
    <branch>`。
- en: 'On the other side, in the private working repository, there are usually many
    branches that we don’t want to publish or, at least, we don’t want to publish
    them yet. In most cases, we would want to publish a single branch: the one we
    were working on and the one we know is ready. However, if you are the integration
    manager, you would want to publish a carefully selected subset of the branches
    instead of just one single branch.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在私有工作仓库中，通常会有许多我们不希望发布的分支，或者至少是我们暂时不想发布的分支。在大多数情况下，我们希望发布一个单一的分支：我们正在处理的分支，而且我们知道它已经准备好。然而，如果你是集成经理，你会希望发布一个精心挑选的分支子集，而不是仅仅发布一个单独的分支。
- en: This is yet another difference between fetching and pushing. That’s why Git
    doesn’t set up push refspec by default (you can configure it manually nonetheless),
    but instead relies on the so-called `push.default` configuration variable used
    to configure this applies only while running the `git push` command without branches
    to push stated explicitly.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是 fetch 和 push 之间的另一个区别。这也是为什么 Git 默认不设置推送 refspec（尽管你可以手动配置），而是依赖于所谓的 `push.default`
    配置变量，该变量仅在运行 `git push` 命令时使用，当没有明确指定要推送的分支时适用。
- en: Using git push to sync out of a host that one cannot pull from
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 git push 从无法拉取的主机同步
- en: When you work on two machines, **machineA** and **machineB**, each with its
    own worktree, a typical way to synchronize between them is to run **git pull**
    from each other. However, in certain situations, you may only be able to make
    the connection in one direction (for example, because of a firewall or intermittent
    connectivity). Let’s assume that you can fetch and push from **machineB**, but
    you cannot fetch from **machineA**.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在两台机器上工作，**machineA** 和 **machineB**，每台机器都有自己的工作树时，一个典型的同步方式是相互运行 **git pull**。然而，在某些情况下，你可能只能在一个方向上建立连接（例如，由于防火墙或间歇性的连接问题）。假设你可以从
    **machineB** 拉取和推送，但无法从 **machineA** 拉取。
- en: 'You want to perform a push from **machineB** to **machineA** in such a way
    that the result of the operation is practically indistinguishable from doing a
    fetch while being on **machineA**. For this, you need to specify, via refspec,
    that you want to push the local branch into its remote-tracking branch:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望从 **machineB** 向 **machineA** 执行推送操作，使得操作的结果与在 **machineA** 上执行 `fetch` 几乎没有区别。为此，你需要通过
    refspec 指定你希望将本地分支推送到其远程追踪分支：
- en: '**machineB$ git push** **machineA:repo.git \**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**machineB$ git push** **machineA:repo.git \**'
- en: '**refs/heads/master:refs/remotes/machineB/master**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**refs/heads/master:refs/remotes/machineB/master**'
- en: The first parameter is the URL in the **scp**-like syntax, while the second
    parameter is refspec. You can set this in the config file, in case you need to
    do something like this more often.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是类似**scp**语法的URL，而第二个参数是refspec。你可以在配置文件中设置它，以防你经常需要执行类似操作。
- en: Fetching and pushing branches and tags
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和推送分支与标签
- en: The next section will describe which push modes are available, and when to use
    them (for which collaboration workflows). But first, we need to know how Git behaves
    concerning tags and branches while interacting with remote repositories.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将描述可用的推送模式，以及何时使用它们（适用于哪些协作工作流）。但首先，我们需要了解Git在与远程仓库交互时如何处理标签和分支。
- en: Because pushing is not the exact opposite of fetching, and because branches
    and tags have different objectives (branches point to the lines of development,
    and tags point to name-specific revisions), their behavior is subtly different.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因为推送并不是获取的完全反面操作，而且分支和标签的目标不同（分支指向开发线路，而标签指向特定的修订版本），所以它们的行为有细微的不同。
- en: Fetching branches
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取分支
- en: Fetching branches is quite simple. With the default configuration, the `git
    fetch` command downloads changes and updates remote-tracking branches (if possible).
    The latter is done according to the fetch refspec for the remote.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 获取分支非常简单。在默认配置下，`git fetch`命令会下载更改并更新远程跟踪分支（如果可能）。后者是根据远程的获取refspec完成的。
- en: 'There are, of course, exceptions to this rule. One such exception is `git clone
    --mirror` would generate the following configuration for `origin`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这条规则也有例外。其中一个例外是`git clone --mirror`会为`origin`生成以下配置：
- en: '[PRE10]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The names of refs that are fetched, together with the object names they point
    at, are written to the `.git/FETCH_HEAD` file. This information is used, for example,
    by `git pull`; this is necessary if we are fetching via URL and not via a remote
    name. This is done because, when we fetch by the URL, there are simply no remote-tracking
    branches to store the information about the fetched branch to be integrated.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 获取的ref名称及其指向的对象名称会写入`.git/FETCH_HEAD`文件中。例如，`git pull`会使用这些信息；如果我们通过URL获取而不是通过远程名称获取，这就很有必要。这样做的原因是，当我们通过URL获取时，根本没有远程跟踪分支来存储关于被获取分支的信息。
- en: You can delete remote-tracking branches on a case-by-case basis with `git branch
    -r -d`; you can also remove them on a case-by-case basis for which the corresponding
    branch in the remote repository no longer exists with `git remote prune` (or with
    `git fetch -- prune` in modern Git).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要通过`git branch -r -d`删除远程跟踪分支；如果远程仓库中相应的分支不再存在，你也可以通过`git remote prune`（或者在现代Git中使用`git
    fetch --prune`）逐个删除它们。
- en: Fetching tags and automatic tag following
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取标签和自动跟踪标签
- en: The situation with tags is a bit different. While we would want to make it possible
    for different developers to work independently on the same branch (for example,
    an integration branch such as `master`), in different repositories, we would need
    for all developers to have one specific tag to always refer to the same specific
    revision. That’s why the position of branches in remote repositories is stored
    using a separate per-remote namespace, `refs/remotes/<remote name>/*`, in remote-tracking
    branches, but tags are mirrored – each tag is stored with the same name in the
    `refs/tags/*` namespace.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 标签的情况有些不同。虽然我们希望不同的开发者能够在同一个分支上独立工作（例如，`master`这样的集成分支），但在不同的仓库中，我们需要所有开发者都有一个特定的标签来始终指向相同的特定修订版本。这就是为什么远程仓库中的分支位置使用一个独立的每远程仓库命名空间`refs/remotes/<remote
    name>/*`存储在远程跟踪分支中，而标签则是镜像的——每个标签都以相同的名称存储在`refs/tags/*`命名空间中。
- en: Tip
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Note that the positions of tags in the remote repository can be configured with
    the appropriate fetch refspec; Git is that flexible. One example where it might
    be necessary is fetching a subproject, where we want to store its tags in a separate
    namespace (more information on this issue in [*Chapter 11*](B21194_11.xhtml#_idTextAnchor270),
    *Managing Subprojects*).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，远程仓库中标签的位置可以通过适当的获取refspec进行配置；Git是如此灵活。一个可能需要这样操作的例子是获取子项目，我们希望将其标签存储在一个独立的命名空间中（有关此问题的更多信息，请参见[*第11章*](B21194_11.xhtml#_idTextAnchor270)，*管理子项目*）。
- en: This is also why, by default, while downloading changes, Git will also fetch
    and store all the tags that point to the downloaded objects locally. You can disable
    this `--no-tags` option. This option can be set on the command line as a parameter,
    or it can be configured with the `remote.<remote` `name>.tagopt` setting.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么默认情况下，在下载更改时，Git 会同时拉取并存储所有指向下载对象的标签。你可以使用`--no-tags`选项禁用此行为。此选项可以作为命令行参数设置，或者可以通过`remote.<remote`
    `name>.tagopt`设置进行配置。
- en: 'You can also make Git download all the tags with the `--tags` option, or by
    adding the appropriate fetch refspec value for tags:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`--tags`选项使 Git 下载所有标签，或者通过为标签添加适当的拉取 refspec 值：
- en: '[PRE11]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Pushing branches and tags
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推送分支和标签
- en: 'Pushing is different. Pushing branches is (usually) governed by the selected
    push mode. You push a local branch (usually just a single current branch) to update
    a specific branch in the remote repository, from `refs/heads/` locally to `refs/heads/`
    in remote. It is usually a branch with the same name, but it might be a differently
    named branch configured as upstream – details will be provided later. You don’t
    need to specify the full refspec: using the ref name (for example, the name of
    a branch) means pushing to the ref with the same name in the remote repository,
    creating it if it doesn’t exist. Pushing `HEAD` means pushing the current branch
    into the branch with the same name (not to `HEAD` in remote – it usually doesn’t
    exist).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 推送是不同的。推送分支（通常）由所选的推送模式控制。你将本地分支（通常只有一个当前分支）推送到远程仓库中的特定分支，从本地的`refs/heads/`推送到远程的`refs/heads/`。通常是同名的分支，但它也可能是配置为上游的不同名称的分支——详细信息稍后会提供。你不需要指定完整的
    refspec：使用 ref 名称（例如，分支名称）意味着将其推送到远程仓库中同名的 ref，如果它不存在则会创建它。推送`HEAD`意味着将当前分支推送到同名的分支（而不是远程的`HEAD`——它通常不存在）。
- en: Usually, you push tags explicitly with `git push <remote repository> <tag>`
    (or `tag <tag>` if there is both a tag and branch with the same name – both mean
    the `+refs/tags/<tag>:refs/tags/<tag>` refspec). You can push all the tags with
    `--tags` (and with appropriate refspec) and turn on the automatic tag with `--follow-tags`
    (it is not turned on by default as it is for fetch).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你通过`git push <远程仓库> <标签>`显式推送标签（或者如果有同名的标签和分支，使用`tag <标签>`——两者都表示`+refs/tags/<标签>:refs/tags/<标签>`
    refspec）。你也可以使用`--tags`推送所有标签（并带有适当的 refspec），并使用`--follow-tags`开启自动标签（默认情况下没有开启，像拉取时一样）。
- en: 'As a special case of refspec, pushing an “empty” source into some ref in remote
    deletes it. The `--delete` option to `git push` is just a shortcut for using this
    type of refspec. For example, to delete a ref matching `experimental` in the remote
    repository, you can run the following command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 refspec 的一种特殊情况，将“空”源推送到远程的某个 ref 会删除它。`git push`的`--delete`选项只是使用这种类型的 refspec
    的快捷方式。例如，要删除远程仓库中与`experimental`匹配的 ref，可以运行以下命令：
- en: '[PRE12]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that the remote server might forbid the deletion of refs with `receive.denyDeletes`
    configuration option or with hooks.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，远程服务器可能会通过`receive.denyDeletes`配置选项或钩子禁止删除 refs。
- en: Push modes and their use
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送模式及其使用
- en: The behavior of `git push`, in the absence of the parameters specifying what
    to push, and in the absence of the configured push refspec, is specified by the
    **push mode**.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定推送内容的参数，并且没有配置推送的 refspec，`git push`的行为由**推送模式**决定。
- en: Different modes are available, each suitable for different collaborative workflows,
    which was shown in [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140), *Collaborative
    Development* *with Git*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的模式可供选择，每种模式适用于不同的协作工作流，详情见[*第 6 章*](B21194_06.xhtml#_idTextAnchor140)，*使用
    Git 进行协作开发*。
- en: The “simple” push mode – the default
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “简单”推送模式——默认模式
- en: 'The default push mode in Git 2.0 and later is the so-called `simple` mode.
    It was designed with the idea of *minimum surprise*: the idea that it is better
    to prevent publishing a branch than to make some private changes accidentally
    public.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Git 2.0 及更高版本的默认推送模式是所谓的`简单`模式。它的设计理念是*最小惊讶*：即防止意外将某个私有分支发布出去要比让私有更改意外公开更好。
- en: With this mode, you always push the current local branch into the same named
    branch in the remote repository. If you push into the same repository you fetch
    from (the centralized workflow), it requires the upstream to be set for the current
    branch. The upstream is named the same as the branch.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式下，你始终将当前本地分支推送到远程仓库中同名的分支。如果你将更改推送到与拉取的同一仓库（集中式工作流），则需要为当前分支设置上游。上游与分支同名。
- en: This means that in the centralized workflow (push into the same repository you
    fetch from), it works like `upstream` with the additional safety that the upstream
    must have the same name as the current (pushed) branch. With a triangular workflow,
    while pushing to a remote that is different from the remote you normally pull
    from, it works like `current`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在集中式工作流中（推送到你拉取的同一仓库），它像`upstream`一样工作，额外的安全性是上游必须与当前（推送的）分支具有相同的名称。在三角形工作流中，当推送到与通常拉取的远程仓库不同的远程仓库时，它像`current`一样工作。
- en: This is the safest option; it is well-suited for beginners, which is why it
    is the default mode. You can turn it on explicitly with `git config` `push.default
    simple`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最安全的选项，非常适合初学者，因此它是默认模式。你可以通过`git config` `push.default simple`显式启用此模式。
- en: The “matching” push mode for maintainers
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维护者的“匹配”推送模式
- en: Before version 2.0 of Git, the default push mode was `matching`. This mode is
    most useful for the maintainer (also known as the integration manager) in a blessed
    repository workflow. But most Git users are not maintainers; that’s why the default
    push mode was changed to `simple`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在Git 2.0版本之前，默认的推送模式是`matching`。这种模式对于维护者（也称为集成经理）在受信任的仓库工作流中非常有用。但大多数Git用户并不是维护者；这就是默认推送模式被更改为`simple`的原因。
- en: The maintainer would get contributions from other developers, be it via pull
    requests or patches sent in an email, and put them into topic branches. They could
    also create topic branches for their own contributions. Then, the topic branches
    considered to be suitable were merged into the appropriate integration branches
    (for example, `maint`, `master`, and `next`) – merging will be covered in [*Chapter
    9*](B21194_09.xhtml#_idTextAnchor229), *Merging Changes Together*. All this is
    done in the maintainer’s private repository.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 维护者将从其他开发者那里获取贡献，无论是通过拉取请求还是通过电子邮件发送的补丁，并将它们放入主题分支中。他们还可以为自己的贡献创建主题分支。然后，被认为适合的主题分支会被合并到适当的集成分支中（例如，`maint`、`master`和`next`）——合并将在[*第9章*](B21194_09.xhtml#_idTextAnchor229)中讨论，*合并变更*。所有这些操作都在维护者的私人仓库中完成。
- en: The public blessed repository (one that everyone fetches from, as described
    in [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140), *Collaborative Development
    with Git*) should only contain long-running branches (otherwise, other developers
    could start basing their work on a branch that suddenly vanishes). Git cannot
    know by itself which branches are long-lived and which are short-lived.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 公共受信仓库（每个人都会从中拉取的仓库，如[*第6章*](B21194_06.xhtml#_idTextAnchor140)中所述，*与Git的协作开发*）应只包含长期存在的分支（否则，其他开发者可能会开始基于一个突然消失的分支进行工作）。Git无法自行判断哪些分支是长期存在的，哪些是短期存在的。
- en: 'With the matching mode, Git will push all the local branches that have their
    equivalent with the same name in the remote repository. This means that only the
    branches that are already published will be pushed to the remote repository. To
    make a new branch public, you need to push it explicitly the first time, like
    so:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配模式下，Git将推送所有本地分支，这些分支在远程仓库中有相同名称的对应分支。这意味着只有已经发布的分支才会被推送到远程仓库。要使新分支公开，你需要第一次显式推送它，像这样：
- en: '[PRE13]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Important note
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that with this mode, unlike with other modes, using the **git push** command
    without providing a list of branches to push can publish multiple branches at
    once, and may not publish the current branch.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此模式下，与其他模式不同，使用**git push**命令而不提供要推送的分支列表时，可以一次性推送多个分支，并且可能不会推送当前分支。
- en: 'To turn on the matching mode globally, you can run the following command:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要全局启用匹配模式，你可以运行以下命令：
- en: '[PRE14]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you want to turn it on for a specific repository, you need to use a special
    refspec composed of a sole colon. Assuming that the said repository is named `origin`
    and that we want a not forced push, it can be done with the following command:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为特定仓库启用匹配模式，你需要使用由单个冒号组成的特殊refspec。假设该仓库名为`origin`，并且我们希望进行非强制推送，可以使用以下命令：
- en: '[PRE15]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can, of course, push matching branches by using the following refspec on
    the command line:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以通过在命令行中使用以下refspec来推送匹配的分支：
- en: '[PRE16]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The “upstream” push mode for the centralized workflow
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集中式工作流的“upstream”推送模式
- en: In the centralized workflow, there is a single shared central repository that
    every developer with commit access pushes to. This shared repository will only
    have long-lived integration branches, usually only `maint` and `master`, and sometimes
    only `master`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在集中式工作流中，所有开发者都有提交权限，向一个单一的共享中央仓库推送代码。这个共享仓库通常只会有长期存在的集成分支，通常是`maint`和`master`，有时只有`master`。
- en: 'You should rather never work directly on `master` (perhaps except for simple
    single-commit topics), but rather fork a topic branch for each separate feature
    out of the remote-tracking branch:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你最好永远不要直接在`master`上工作（也许只有在简单的单提交主题的情况下除外），而是应该从远程跟踪分支中为每个独立功能派生一个主题分支：
- en: '[PRE17]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the centralized workflow, the integration is distributed: each developer
    is responsible for merging changes (in their topic branches), and publishing the
    result to the `master` branch in the central repository. You would need to update
    the local `master` branch, merge the topic branch to it, and push it:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在集中式工作流中，集成是分布式的：每个开发者负责合并其主题分支中的更改，并将结果发布到中央仓库的`master`分支。你需要更新本地的`master`分支，将主题分支合并到其中，然后推送：
- en: '[PRE18]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'An alternate solution is to rebase the topic branch on the top of the remote-tracking
    branch rather than merging it. After rebasing, the topic branch should be an ancestor
    of `master` in the remote repository, so we can simply push it into `master`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是将主题分支重新基于远程跟踪分支，而不是将其合并。重新基准化后，主题分支应成为远程仓库中`master`的祖先，因此我们可以直接将其推送到`master`：
- en: '[PRE19]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In both cases, you are pushing the local branch (`master` in the merge-based
    workflow and the feature branch in the rebase-based workflow) into the branch
    it tracks in the remote repository – in this case, origin’s `master`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你都是将本地分支（在基于合并的工作流中是`master`，在基于重新基准化的工作流中是功能分支）推送到它在远程仓库中跟踪的分支——在这种情况下是
    origin 的`master`。
- en: 'That is what the `upstream` push mode was created for:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是创建`upstream`推送模式的原因：
- en: '[PRE20]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This mode makes Git push the current branch to the specific branch in the remote
    repository – the branch whose changes are usually integrated into the current
    branch. This branch in the remote repository is the upstream branch (and can be
    referenced as `@{upstream}`). Turning this mode on makes it possible to simplify
    the last command in both examples to the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式使 Git 将当前分支推送到远程仓库中的特定分支——该分支通常是将更改集成到当前分支的目标分支。远程仓库中的这个分支就是上游分支（可以用`@{upstream}`引用）。启用此模式后，可以将两个示例中的最后一条命令简化为以下内容：
- en: '[PRE21]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The information about the upstream is created either automatically (while forking
    off the remote-tracking branch), or explicitly with the `--track` option. It is
    stored in the configuration file and it can be edited with ordinary configuration
    tools.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 上游信息是通过自动方式（当从远程跟踪分支分支时）或通过`--track`选项显式创建的。它存储在配置文件中，可以使用普通的配置工具进行编辑。
- en: 'Alternatively, it can be changed later with the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，稍后可以通过以下方式更改：
- en: '[PRE22]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The “current” push mode for the blessed repository workflow
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 受托仓库工作流的“当前”推送模式
- en: In the blessed repository workflow, each developer has a private and public
    repository. In this model, you fetch from the blessed repository and push it to
    your public repository.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在受托仓库工作流中，每个开发者都有一个私有仓库和一个公共仓库。在这种模型中，你从受托仓库拉取代码并推送到你的公共仓库。
- en: 'In this workflow, you start working on a feature by creating a new topic branch
    for it:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种工作流中，你通过为每个功能创建一个新的主题分支来开始工作：
- en: '[PRE23]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the features are ready, you push it into your public repository, perhaps
    rebasing it first to make it easier for the maintainer to merge it:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当功能准备好时，你将其推送到公共仓库，可能先进行重新基准化，以便让维护者更容易合并：
- en: '[PRE24]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, it is assumed that you used `pushurl` to configure the triangular workflow,
    and the push remote is `origin`. You would need to replace `origin` here with
    the appropriate name of the publishing remote if you are using a separate remote
    for your public repository (using a separate repository makes it possible to use
    it not only for publishing but also for synchronization between different machines).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里假设你已经使用`pushurl`配置了三角工作流，推送远程是`origin`。如果你使用的是一个单独的远程仓库来作为公共仓库（使用不同的仓库不仅可以用于发布，还可以用于不同机器之间的同步），你需要将此处的`origin`替换为公共仓库的正确远程名称。
- en: 'You can configure Git in such a way that when you’re on the `fix-tty-bug` branch,
    it is enough to just run `git push`. To do this, you need to set up Git to use
    the `current` push mode, like so:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以配置 Git，使得当你处于`fix-tty-bug`分支时，只需运行`git push`即可。为此，你需要设置 Git 使用`current`推送模式，像这样：
- en: '[PRE25]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This mode will push the current branch to the branch with the same name at the
    receiving end.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式将把当前分支推送到接收端同名的分支。
- en: Note that if you’re using a separate remote for the publishing repository, you
    would need to set up the `remote.pushDefault` configuration option to be able
    to use just `git push` for publishing.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你使用的是单独的远程发布仓库，则需要设置`remote.pushDefault`配置选项，以便只使用`git push`进行发布。
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has shown how to effectively use branches for development and collaboration.
    You also got to know a few useful tricks.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何有效地使用分支进行开发和协作。你还学到了一些实用的技巧。
- en: First, we learned about the various uses of branches, from integration, through
    release management and the parallel development of features, to fixing bugs. You
    learned about different branching patterns and branching workflows. This knowledge
    should help you branch and customize workflows so that they fit the needs of the
    project and your team’s preferences.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们了解了分支的各种用途，从集成、发布管理、特性并行开发到修复 bug。你学习了不同的分支模式和分支工作流。这些知识应该能帮助你根据项目的需求和团队的偏好，灵活地创建和定制工作流。
- en: 'You also learned how to deal with multiple branches per repository while downloading
    or publishing changes. Git provides flexibility in how the information on branches
    and other refs in the remote repository is managed using the so-called refspecs
    to define a mapping to local refs: remote-tracking branches, local branches, and
    tags. Usually, fetching is governed by fetch refspec, but pushing is managed by
    the configured push mode. Various collaborative workflows require branch publishing
    to be handled differently; this chapter described which push mode to use with
    which workflow and explains why.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了如何在下载或发布变更时处理每个仓库的多个分支。Git 提供了灵活性来管理远程仓库中分支和其他引用的相关信息，使用所谓的 refspec 来定义本地引用的映射：远程追踪分支、本地分支和标签。通常，获取操作由获取
    refspec 管理，但推送则由配置的推送模式管理。各种协作工作流要求对分支发布的处理方式不同；本章描述了哪种推送模式适用于哪种工作流，并解释了原因。
- en: The next chapter, [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229), *Merging
    Changes Together*, will explain how to integrate changes from other branches and
    other developers. You will learn about merging and rebasing, and how to deal with
    situations where Git can’t do this automatically (how to handle various types
    of merge conflicts). You will also learn about cherry-picking and reverting commits.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，[*第9章*](B21194_09.xhtml#_idTextAnchor229)，*合并变更*，将解释如何集成来自其他分支和开发者的变更。你将学习合并和变基，以及如何处理
    Git 无法自动执行这些操作的情况（如何处理各种类型的合并冲突）。你还将学习如何使用樱桃挑选（cherry-picking）和回滚提交。
- en: Questions
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章内容的理解：
- en: What are the advantages of frequent integration?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经常集成有哪些优点？
- en: What are the advantages of topic branches?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主题分支有哪些优点？
- en: How can you store a project web page or its GitOps configuration in the same
    repository as the code, while keeping their histories and files separate?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将一个项目网页或其 GitOps 配置与代码一起存储在同一个仓库中，同时保持它们的历史记录和文件分开？
- en: How can you synchronize the working directory of the Git repository hosted on
    other computers?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何同步托管在其他计算机上的 Git 仓库的工作目录？
- en: Answers
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的答案：
- en: More frequent integration leads to easier integration because with smaller differences,
    there is less chance of conflict, and because conflicts are discovered earlier.
    It also makes it easier to maintain a production-ready mainline, decreasing the
    time it takes to put the feature into the production environment.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更频繁的集成可以带来更容易的集成，因为差异较小，冲突的可能性较低，而且冲突能更早发现。它还使得维护一个随时可以投入生产的主分支变得更加容易，缩短了将特性投入生产环境的时间。
- en: Using topic branches makes it easier to review and examine the steps it took
    to create a feature and remove it if needed. The use of topic branches also plays
    nicely with the requirement of pre-integration code review.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用主题分支可以更容易地回顾和检查创建一个特性所需的步骤，并在必要时移除它。主题分支的使用也与集成前的代码审查要求相得益彰。
- en: You can use the “orphan” branch trick – for example, with **git checkout --
    orphan** – to have two or more unrelated histories in a single repository.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用“孤儿”分支技巧——例如，使用 **git checkout -- orphan**——在一个仓库中拥有两个或更多不相关的历史记录。
- en: Log in to the other computer and use **git pull**; if this is not possible,
    you can **git push** into a non-bare repository (configuring what should happen
    to checked-out branches).
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到另一台计算机并使用 **git pull**；如果无法这样做，可以将更改 **git push** 到非裸仓库中（配置已检出分支的处理方式）。
- en: Further reading
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多本章讨论的主题，请查看以下资源：
- en: 'Martin Fowler, *Patterns for Managing Source Code Branches* (2020): [https://martinfowler.com/articles/branching-patterns.html](https://martinfowler.com/articles/branching-patterns.html)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Martin Fowler，*管理源代码分支的模式*（2020年）： [https://martinfowler.com/articles/branching-patterns.html](https://martinfowler.com/articles/branching-patterns.html)
- en: 'Rouan Wilsenach, *Ship / Show / Ask: A modern branching strategy* (2021): [https://martinfowler.com/articles/ship-show-ask.html](https://martinfowler.com/articles/ship-show-ask.html)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Rouan Wilsenach，*Ship / Show / Ask: 一种现代分支策略*（2021年）： [https://martinfowler.com/articles/ship-show-ask.html](https://martinfowler.com/articles/ship-show-ask.html)'
- en: 'Vincent Driessen, *git-flow - A successful Git branching model* (2010): [https://nvie.com/posts/a-successful-git-branching-model/](https://nvie.com/posts/a-successful-git-branching-model/)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vincent Driessen，*git-flow - 一种成功的 Git 分支模型*（2010年）： [https://nvie.com/posts/a-successful-git-branching-model/](https://nvie.com/posts/a-successful-git-branching-model/)
- en: '*gitworkflows - An overview of recommended workflows with* *Git*: [https://git-scm.com/docs/gitworkflows](https://git-scm.com/docs/gitworkflows)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*gitworkflows - Git 推荐工作流概览*： [https://git-scm.com/docs/gitworkflows](https://git-scm.com/docs/gitworkflows)'
- en: 'Paul Hammant and others, *Trunk Based* *Development*: [https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paul Hammant 和其他人，*基于主干的* *开发*： [https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/)
- en: 'Junio C Hamano: *Resolving conflicts/dependencies between topic branches early*
    (2009): [https://gitster.livejournal.com/27297.html](https://gitster.livejournal.com/27297.html)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Junio C Hamano: *提前解决主题分支之间的冲突/依赖关系*（2009年）： [https://gitster.livejournal.com/27297.html](https://gitster.livejournal.com/27297.html)'
- en: 'Junio C Hamano, *Fun with various workflows 1* and *2* (2013): [https://git-blame.blogspot.com/2013/06/fun-with-various-workflows-1.html](https://git-blame.blogspot.com/2013/06/fun-with-various-workflows-1.html)
    and [https://git-blame.blogspot.com/2013/06/fun-with-various-workflows-2.html](https://git-blame.blogspot.com/2013/06/fun-with-various-workflows-2.html)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Junio C Hamano，*各种工作流的乐趣 1* 和 *2*（2013年）： [https://git-blame.blogspot.com/2013/06/fun-with-various-workflows-1.html](https://git-blame.blogspot.com/2013/06/fun-with-various-workflows-1.html)
    和 [https://git-blame.blogspot.com/2013/06/fun-with-various-workflows-2.html](https://git-blame.blogspot.com/2013/06/fun-with-various-workflows-2.html)
