# 14

# Git 管理

前一章，*自定义和扩展 Git*，其中解释了如何使用 Git 钩子进行自动化。客户端钩子进行了详细描述，而服务器端钩子仅做了简要介绍。在本章中，我们将全面介绍服务器端钩子，并讨论客户端钩子作为助手的使用。

前面的章节帮助你作为开发者、团队成员和维护者掌握了 Git 的使用。当书中讨论设置仓库和分支结构时，是从 Git 用户的角度出发的。

本章旨在帮助那些处理 Git 管理方面工作的读者。这包括设置远程 Git 仓库和配置其访问权限。本章涵盖了让 Git 顺利运行所需的工作（即 Git 维护），以及如何发现并从仓库错误中恢复。同时还介绍了如何使用服务器端钩子来实施和强制执行开发政策。此外，你还会找到关于用于管理远程仓库的各种工具的简短描述，帮助你从中进行选择。

本章将涵盖以下内容：

+   服务器端钩子 – 实施政策和通知

+   如何在服务器上设置 Git

+   使用第三方工具管理远程仓库

+   签名推送以确保更新引用并启用审计

+   使用替代和命名空间减少托管仓库的大小

+   改进服务器性能并帮助初始化克隆

+   检查仓库是否损坏并修复仓库

+   在 reflog 的帮助下恢复错误并使用 **git fsck**

+   Git 仓库维护和重新打包

+   用 Git 增强开发工作流

# 仓库维护

偶尔，你可能需要清理一个仓库，通常是为了让它变得更紧凑。这种清理在从其他版本控制系统迁移仓库后也是一个非常重要的步骤。

## 使用 git-gc 自动化清理工作

现代 Git（或者说，几乎所有版本的 Git）会不时在每个仓库中运行`git gc --auto`命令。这个命令检查是否有太多松散对象（对象作为单独的文件存储，每个对象一个文件，而不是存储在打包文件中；对象几乎总是以松散形式创建的），如果有，便会启动垃圾回收操作。垃圾回收意味着将所有松散对象收集起来并放入打包文件中，还会将多个小打包文件合并为一个大打包文件。此外，它还会将引用打包到`packed-refs`文件中。那些即使通过 reflog 也无法访问且已经足够旧的对象，默认情况下会单独打包到一个垃圾打包文件中。然后，Git 会删除松散对象、垃圾打包文件和重新打包过的打包文件（保留松散对象文件的年龄安全边际），从而修剪掉旧的不可访问对象。`gc.*`命名空间中有多个配置选项可以控制垃圾回收操作。

你可以手动运行`auto gc`，使用`git gc --auto`，或者通过`git gc`强制垃圾回收。`git count-objects`命令（有时配合`-v`参数）可用于检查是否有需要重新打包的迹象。你甚至可以通过`git repack`、`git pack-refs`、`git prune`和`git prune-packed`分别运行垃圾回收的单个步骤。

默认情况下，Git 会尽量重用早期打包的结果，以减少重新打包时的 CPU 时间，同时仍能提供良好的磁盘空间利用率。在某些情况下，你可能希望通过更多的时间成本来更积极地优化仓库的大小；这可以通过`git gc --aggressive`实现（或者通过手动使用`git repack`并使用适当的参数重新打包仓库）。建议在从其他版本控制系统导入数据后执行此操作，因为 Git 用于导入的机制（即`fast-import`流）是为了操作的速度优化的，而不是为了最终仓库的大小。

有一些维护问题是`git gc`无法覆盖的，因为它们的性质。其中之一是修剪（删除）已经在远程仓库中删除的远程跟踪分支。可以使用`git fetch --prune`或`git remote prune`，或者通过`git branch --delete --remotes <remote-tracking branch>`按分支逐个操作。这一操作由用户执行，而不是由`git gc`运行，因为 Git 无法知道你是否基于将要被修剪的远程跟踪分支来进行自己的工作。

## 使用 git-maintenance 进行定期维护

像 `git add` 或 `git fetch` 这样将数据添加到仓库的 Git 命令，会触发自动垃圾回收并进行一些仓库优化。然而，由于这些命令需要提供响应式的用户界面，它们不会触发更昂贵的仓库优化任务。这些任务包括更新提交图数据、从远程仓库预取数据（这样 `git fetch` 就可以下载更少的对象）、清理松散对象以及进行增量重新打包。这些优化任务通常会随着仓库的整体大小增长而增加。

更好的解决方案是将耗费资源的维护任务定期地在后台运行——每小时、每天或每周运行一次。借助现代 Git，你可以通过 `git maintenance` 命令来调度这些任务。它会根据操作系统的不同，安排这些任务的运行方式。

你可以配置给定任务的运行频率。请注意，`git maintenance run` 这个执行调度任务的过程，会对仓库的对象数据库加锁，防止竞争进程导致仓库处于无法预测的状态。`git gc` 则不会这样做；因此，如果你进行定期维护，应该使用 `git maintenance run --task=gc` 而不是直接使用 `git` 的 `gc` 命令。

# 数据恢复与故障排除

几乎不可能做到从不犯错。这同样适用于使用 Git。书中呈现的知识，以及你使用 Git 的经验，应该有助于减少错误的发生。请注意，Git 会尽力避免帮助你丢失工作；很多错误是可以恢复的。下一节将解释如何尝试从错误中恢复。

## 恢复丢失的提交

可能会发生你不小心丢失了一个提交。也许你强制删除了一个错误的分支，或者你将分支回退到了错误的位置，或者在开始操作时，你所在的分支是错误的。如果发生了类似的情况，有没有办法找回你的提交并撤销这个错误呢？

因为 Git 并不会立即删除对象，而是将其保留一段时间，只有在垃圾回收阶段发现对象不可达时才会删除，所以你丢失的提交仍然存在；你只需要找到它。正如前面所提到的，垃圾回收操作有自己的安全边界；不过，如果你发现需要进行故障排除，最好暂时关闭自动垃圾回收功能，可以通过 `git config gc.auto never` 来关闭（并且如果 `git maintenance` 被调度定期运行，可以通过将 `maintenance.gc.enabled` 设置为 false 或通过 `git maintenance unregister` 关闭维护，来关闭 `gc` 任务）。

通常，找回丢失提交的最简单方法是使用`git reflog`工具。对于每个分支，以及单独的`HEAD`，Git 会悄悄记录（日志）分支的顶部在本地仓库中的位置、何时到达以及如何到达。这个记录被称为**reflog**。每次提交或回滚分支时，分支和 HEAD 的 reflog 都会更新。每次切换分支时，HEAD 的 reflog 也会更新，依此类推。

你可以通过运行`git reflog`或`git reflog <branch>`查看分支顶部曾经的位置。你也可以运行`git log -g`，其中`-g`是`--walk-reflog`的简写；这将显示一个正常的可配置日志输出。还有`--grep-reflog=<pattern>`可以用来搜索 reflog：

```
$ git reflog
6c89dee HEAD@{0}: commit: Ping asynchronously
d996b71 HEAD@{1}: rebase -i (finish): returning to refs/heads/ajax
d996b71 HEAD@{2}: rebase -i (continue): Ping asynchronously WIP
89579c9 HEAD@{3}: rebase -i (pick): Use Ajax mode
7c6d322 HEAD@{4}: commit (amend): Simplify index()
e1e6f65 HEAD@{5}: cherry-pick: fast-forward
eea7a7c HEAD@{6}: checkout: moving from ssh-check to ajax
c3e77bf HEAD@{7}: reset: moving to ajax@{1}
```

你应该记得*第四章*中的`<ref>@{<n>}`语法，*探索项目历史*。通过 reflog 中的信息，你可以将相关分支回滚到操作之前的版本，或者可以从列表中的任何提交开始创建一个新分支。

假设你的丢失是因为删除了错误的分支。由于 reflog 的实现方式（例如，`foo`分支的日志——即`refs/heads/foo`的日志——被保存在`.git/logs/refs/heads/foo`文件中），给定分支的 reflog 会在删除分支时一并删除。除非你没有涉及工作区，单纯操作了分支顶部，否则你可能仍然可以在`HEAD`的 reflog 中找到必要的信息，但这可能不容易找到。

如果 reflog 中没有相关信息，可以使用`git fsck`工具来查找恢复丢失对象所需的信息，它可以检查你的仓库是否完整。使用`--full`选项，你可以用此命令显示所有未引用的对象：

```
$ git fsck --full
Checking object directories: 100% (256/256), done.
Checking objects: 100% (58/58), done.
dangling commit 50b836cb93af955ca99f2ccd4a1cc4014dc01a58
dangling blob 59fc7435baf79180a3835dddc52752f6044bab99
dangling blob fd64375c1f2b17b735f3145446d267822ae3ddd5
[...]
```

你可以在`git fsck`输出的行中看到未引用（丢失）提交的 SHA1 标识符，通过`grep "commit"`查找提交，使用`cut -d' ' -f3`提取 SHA1 标识符，然后将这些修订输入`git log --stdin --no-walk`，如下所示：

```
$ git fsck --full | grep "commit" | cut -d' ' -f3 | git log --stdin --no- walk
```

提示

同样的技术，但使用**blob**命令，可以用来恢复意外删除的文件——前提是你在想要恢复的文件版本上使用了**git add**。

## 故障排除 Git

`git fsck`的主要目的是检查仓库是否损坏。除了可以找到悬挂对象外，这个命令还会对每个对象进行完整性检查，并跟踪对象的可达性。它可以发现损坏和丢失的对象；如果损坏仅限于你的克隆，且正确版本可以在其他仓库（备份和其他存档）中找到，你可以尝试从未损坏的源中恢复这些对象。

然而，有时错误可能更难恢复。你可以尝试寻找团队外的 Git 专家，但通常，仓库中的数据是专有的，无法创建问题的最小化重现。对于现代 Git，如果问题是结构性问题，你可以尝试使用`git fast-export --anonymize`来去除仓库中的数据，同时确保匿名化后的仓库能够重现该问题。重现某些 bug 可能需要引用特定的提交或路径；对于现代 Git，你可以请求某个特定标记保持原样，或者通过一组`--anonymize-map`选项将其映射到新值。

如果仓库本身没问题，但问题出在 Git 操作上，你可以尝试使用 Git 内置的各种追踪和调试机制，或者尝试增加命令的详细程度。你可以通过适当的环境变量来启用追踪功能（稍后我们会展示）。通过将相应环境变量的值设置为**1**、**2**或**true**，追踪输出可以被写入标准错误流。**0**或**false**值则会禁用追踪。介于 2 和 10 之间的其他整数值会被解释为用于追踪输出的打开文件描述符。你也可以将这些环境变量设置为文件的绝对路径，以便将追踪信息写入该文件。

这些与追踪相关的变量包括以下内容（请参阅`git`包装器的手册页以获取完整列表）：

+   **GIT_TRACE**：启用一般的追踪消息，适用于任何不属于特定类别的消息。这包括 Git 别名的扩展（参见*第十三章*，*定制和扩展 Git*）、内置命令执行和外部命令执行（例如分页器、编辑器或助手）。

+   **GIT_TRACE_PACKET**：启用对“智能”传输协议的网络操作进行数据包级别的追踪。这有助于调试协议问题或你设置的远程服务器上的任何问题。要调试并从浅层仓库获取数据，可以使用**GIT_TRACE_SHALLOW**。

+   **GIT_TRACE_CURL**（可能与**GIT_TRACE_CURL_NO_DATA**一起使用）：启用对 HTTP(S) 传输协议的**curl**完整追踪，类似于运行**curl --trace-ascii**选项。

+   **GIT_TRACE_SETUP**：启用追踪消息，打印有关仓库管理区域、工作区、当前工作目录和前缀（最后一个是仓库目录结构中的子目录）的位置。

+   **GIT_TRACE_PERFORMANCE**：显示每个 Git 命令的总执行时间。

使用现代 Git，你可以启用来自`trace2`库的更详细的跟踪信息，格式可以是简单的文本格式（供人类使用）通过`GIT_TRACE2`，也可以是用于机器解析的 JSON 格式通过`GIT_TRACE2_EVENT`。除了将输出重定向到标准错误、指定的文件描述符或指定的文件，你还可以要求将输出文件写入指定目录（每个进程一个文件），甚至可以请求将路径打开为 Unix 域套接字。`GIT_TRACE_PERFORMANCE`的 Trace2 API 替代方案是`GIT_TRACE2_PERF`。除了环境变量，你还可以分别使用`trace2.normalTarget`、`trace2.eventTarget`和`trace2.perfTarget`配置变量。

还有`GIT_CURL_VERBOSE`，它会输出由 curl 库生成的所有 HTTP 网络操作的消息，以及`GIT_MERGE_VERBOSITY`，它用来控制递归合并策略显示的输出量。

# 服务器上的 Git

前几章应该已经为你提供了足够的知识，帮助你掌握大多数日常的 Git 版本控制任务。*第六章*，*使用 Git 进行协作开发*，解释了如何布局仓库以进行协作。在这里，我们将讲解如何设置 Git 仓库，以便在服务器上启用远程访问，允许你从中获取和推送数据。

Git 仓库的管理是一个庞大的话题。关于特定仓库管理解决方案（如 Gitolite、Gerrit、GitHub 或 GitLab）的书籍也已出版。在这里，希望你能找到足够的信息，帮助你选择解决方案或自行开发。

让我们从管理远程仓库的工具和机制开始，然后再讲解如何提供 Git 仓库服务（即将 Git 部署在服务器上）。

## 服务器端钩子

在服务器上调用的钩子可用于服务器管理；其中，钩子可以通过执行授权步骤来控制对远程仓库的访问，并且它们可以确保提交进入仓库时符合某些最基本的标准。后者最好通过客户端钩子的额外帮助来完成，这些钩子在*第十三章*，*定制和扩展 Git*中已有讨论。这样，用户在提交时才不会被通知提交未通过验证。相反，实现验证的客户端钩子很容易通过`--no-verify`选项跳过（因此，服务器端验证是必要的），并且需要记得安装它们。

重要提示

但请注意，服务器端钩子仅在推送操作期间被触发；对于获取（和克隆）操作，你需要其他的访问控制解决方案。

显然，在使用“笨”协议时，钩子也不会被触发——此时服务器上不会调用 Git。

在编写钩子以实现某些 Git 强制的策略时，您需要记住该钩子在哪个阶段运行以及当时可用的信息。了解相关信息是如何传递给钩子的也很重要；然而，您可以通过查阅 Git 文档中的`githooks`手册页轻松找到最后一点。上一章简要总结了服务器端钩子的内容。在这里，我们将对此主题做一些扩展。

所有服务器端钩子都是由`git receive-pack`调用的，`git receive-pack`负责接收已发布的提交（以 packfile 的形式接收，因此命令名称如此）。如果一个钩子（除了`post-*`类型的钩子）以非零状态退出，则操作会中断，并且不会执行进一步的阶段。post 钩子在操作完成后运行，因此没有任何事情可以中断它。

标准输出和标准错误输出都会被转发到客户端的`git send-pack`，因此钩子可以通过打印消息来简单地向用户传递信息（例如，如果钩子是作为 shell 脚本编写的，可以使用`echo`）。请注意，客户端在所有钩子完成操作之前不会断开连接，因此，如果您尝试执行可能需要很长时间的操作（例如自动化测试），请小心。最好让钩子简单地启动这些长时间的操作并异步退出，以允许客户端完成。

您需要记住，在 pre 钩子中，引用尚未更新，而 post 钩子不能影响操作结果。您可以使用 pre 钩子进行访问控制（权限检查），并使用 post 钩子进行通知、更新侧数据和日志记录。钩子的列出顺序是按照操作的顺序。

### pre-receive 钩子

第一个运行的钩子是`git push`操作，Git 调用此钩子之前，操作将会失败。

该钩子不接收任何参数；所有信息都通过脚本的标准输入接收。对于每个要更新的引用，它会接收到一行，格式如下：

```
<old-SHA1-value> <new-SHA1-value> <full-ref-name>
```

需要创建的引用将具有 40 个零的旧 SHA1 值，而需要删除的引用将具有相同的新 SHA1 值。所有其他地方也使用相同的约定，其中钩子接收更新的引用的旧状态和新状态。

推送选项

您可以通过**git push --push-option=<option>**或**push.pushOption**配置变量向服务器传递附加数据。两者都可以多次使用。然后，这些数据通过环境变量**GIT_PUSH_OPTION_COUNT**以及**GIT_PUSH_OPTION_0**、**GIT_PUSH_OPTION_1**等，传递给 pre-receive 和 post-receive 钩子。

如果更新无法接受，则可以使用此钩子快速中止操作——例如，如果接收到的提交不符合指定的策略，或者签名推送（稍后会讲到）无效。请注意，要将其用于访问控制（即授权），你需要以某种方式获取身份验证令牌，可以通过`getpwuid`命令或使用环境变量如`USER`。然而，这取决于服务器的设置和配置。

### 用于推送到非裸仓库的推送钩子

当推送到非裸仓库时，如果推送操作试图更新当前已检出的分支，则`receive.denyCurrentBranch`配置变量会被设置为`updateInstead`值（而不是`true`、`refuse`、`warn`、`false`或`ignore`等值）。此钩子接收将成为即将更新的当前分支的提交的 SHA1 标识符。

该机制旨在同步工作目录，当一方不能方便地通过交互式方式访问时（例如，通过交互式`ssh`访问），或作为一个简单的部署方案。它可以用于部署到实时网站，或在不同操作系统上运行代码测试。

如果此钩子不存在，Git 将在工作树或索引（暂存区）与`HEAD`不同的情况下拒绝更新引用——也就是说，如果状态为“未清理”。此钩子应当用于覆盖此默认行为。

你可以编写这个钩子，使其对工作树和索引进行必要的修改，以使它们达到所需的状态。例如，钩子可以简单地运行`git read-tree -u -m HEAD "$1"`来切换到新的分支尖端（`-u`选项更新工作树中的文件），同时保留本地更改（`-m`选项使其执行快速合并，处理两个提交/树）。如果此钩子以非零状态退出，那么 Git 将拒绝推送到当前已检出的分支。

### 更新钩子

接下来运行的是`receive.denyDeletes`、`receive.denyDeleteCurrent`、`receive.denyCurrentBranch`和`receive.denyNonFastForwards`。

请注意，退出时如果返回非零状态，则会拒绝更新引用；如果推送是*原子性*的（`git push --atomic`），那么拒绝更新任何引用将放弃整个推送操作。对于普通推送，仅拒绝更新单个引用；其他引用的推送将正常进行。

此钩子接收有关要更新的引用的信息，按顺序提供：

+   被更新的引用的完整名称，

+   推送操作前存储在引用中的旧 SHA1 对象名称

+   推送操作后要存储在引用中的新 SHA1 对象名称

`update.sample` 钩子示例可用于阻止未注释的标签进入代码库，也可以允许或拒绝删除和修改标签、删除和创建分支。这个示例钩子的所有配置都通过适当的 `hooks.*` 配置变量完成，而不是硬编码的。此外，在 `contrib/hooks/` 目录中还有 `update-paranoid` Perl 脚本，可以作为如何使用此钩子进行访问控制的示例。这个钩子通过外部配置文件进行配置，其中你可以设置访问控制，确保只有来自指定作者的提交和标签被允许，并且要求作者具有正确的访问权限。

许多代码库管理工具，如 Gitolite，会设置并使用这个钩子来完成它们的工作。如果你出于某种原因希望同时运行你自己的 `update` 钩子和这些工具提供的钩子，可能需要借助一些钩子管理工具（例如，查看 [`githooks.com/`](https://githooks.com/) 上的工具列表），你需要查阅工具的文档。

### `post-receive` 钩子

然后，在所有引用更新后，`pre-receive` 钩子会执行。只有现在，所有引用才会指向新的 SHA1 值。可能会发生在钩子评估引用之前，另一个用户已经修改了引用。这种钩子可以用于更新其他服务（例如，通知持续集成服务器），通知用户（通过电子邮件或邮件列表、聊天频道或问题跟踪系统），或记录关于推送的信息以便审计（例如，关于已签名的推送）。它取代了 `post-update` 钩子，应当使用这个钩子。

没有默认的 `post-receive` 钩子，但你可以在 `contrib/hooks/` 目录中找到简单的 `post-receive-email` 脚本及其替代品 `git-multimail`。

这两个示例钩子实际上是独立于 Git 本身开发的，但为了方便，它们与 Git 源代码一起提供。`git-multimail` 会发送一封总结每个更改引用的电子邮件，每个新提交更改的电子邮件（作为回复进行线程化），以及每个新标注标签的公告邮件。每个邮件在使用的电子邮件地址以及包含的信息方面都可以单独配置。

举个第三方工具的例子，`irker` 包含一个脚本，作为 Git 的 `post-receive` 钩子，用于将新更改的通知发送到适当的 IRC 频道，使用 irker 守护进程（需要单独设置）。

### `post-update` 钩子（一个遗留机制）

然后，`post-receive` 钩子是一个更好的解决方案。

示例钩子运行`git update-server-info`，以准备一个仓库，用于通过简易传输（在*第七章*的*传统（简易）传输*部分、*发布更改*部分以及本章稍后的*简易协议*部分中描述）进行使用，通过创建和保存一些额外的信息。如果仓库所在的目录要通过普通的 HTTP 或其他基于步行器的传输方式（如 FTP）访问，您可以考虑启用此功能。然而，在现代 Git 中，只需将`receive.updateServerInfo`设置为`true`，就足够了，因此不再需要钩子。

## 使用钩子实现 Git 强制策略

强制执行策略的唯一真正方法是使用服务器端钩子来实现，使用`pre-receive`或`update`钩子；如果您需要按引用进行决策，则需要使用后者。客户端钩子可以帮助开发人员关注策略，但这些钩子可以被禁用、跳过或未启用。

### 使用服务器端钩子强制执行策略

开发政策的一部分可能是要求每个提交信息遵循指定的模板。例如，您可以要求每个非合并的提交信息包含**Signed-off-by:**行，作为*数字来源证书*，或者要求每个提交都引用问题追踪器的票据，格式类似于**ref: 2387**。可能性无穷无尽。

为了实现这样的钩子，您首先需要将引用的旧值和新值（您可以通过在`pre-receive`中逐行读取标准输入，或者作为`update`钩子的参数获取这些值）转化为正在推送的所有提交的列表。您需要处理一些特殊情况——删除引用（没有提交被推送）、创建新引用、以及非快进推送的可能性（您需要使用合并基准作为修订范围的下限——例如，使用`git merge-base`命令），推送到标签、推送到注释以及其他非分支推送。将修订范围转换为提交列表的操作可以通过`git rev-list`命令完成，这是`git log`命令的低级等效命令（也叫做*plumbing*）；默认情况下，此命令仅输出指定修订范围内每个提交的 SHA1 值，每行一个，并且没有其他信息。

然后，对于每个修订版，您需要获取提交信息并检查它是否符合政策中指定的模板。您可以使用另一个低级命令，`git cat-file`，然后从此命令的输出中提取提交信息，跳过所有在第一个空行之前的内容。这个空行将提交元数据和提交主体分开：

```
$ git cat-file commit a7b1a955
tree 171626fc3b628182703c3b3c5da6a8c65b187b52
parent 5d2584867fe4e94ab7d211a206bc0bc3804d37a9
author Alice Developer  1440011825 +0200
committer Alice Developer  1440011825 +0200
Added COPYRIGHT file
```

或者，您可以使用`git show -s`或`git log -1`，这两个都是简单命令，代替`git cat-file`。但是，您需要指定确切的输出格式——例如，`git show -s --format=%B <SHA1>`。

当你拥有这些提交信息时，你可以使用正则表达式匹配或其他工具检查每个提交信息，以确认它们是否符合政策。

政策的另一个部分可能是关于分支管理的限制。例如，你可能希望防止删除长期存在的开发阶段分支（参见*第八章*，*高级分支技术*），同时允许删除主题分支。为了区分它们——也就是说，找出被删除的分支是否为主题分支——你可以选择包含一个可配置的分支列表来严格管理，或者假设主题分支总是使用`<user>/<topic>`命名规范。后一种解决方案可以通过要求新创建的分支（应该只为主题分支）匹配这一命名规范来强制执行。

理论上，你可以制定一个政策，要求主题分支只能在没有合并的情况下进行快进合并，尽管实现这一政策的检查并非易事。

通常，只有特定的人有权限推送到项目的官方仓库（持有所谓的提交权限）。通过服务器端钩子，你可以配置仓库，使其允许任何人推送，但仅限于特殊的群体分支；所有其他推送访问将受到限制。

你还可以使用服务器端钩子来要求仓库中只允许注解标签，标签必须使用在指定密钥服务器中存在的公钥进行签名（因此，其他开发者可以验证），并且标签不能被删除或更新。如有需要，你可以将签名标签限制为来自已选择（并配置）的用户集——例如，执行一个政策，要求只有一位维护者可以标记项目为发布版本（通过创建一个适当命名的标签——例如`v0.9`）。

### 使用客户端钩子提前通知关于政策违规的情况

严格执行开发政策而不给用户提供帮助监视和遵守这些政策的方式并不是一个好的解决方案。在推送过程中工作被拒绝可能会令人沮丧；为了修复阻止提交发布的问题，你需要编辑本地项目历史（也就是重写你的更改）。详细了解如何操作，请参见*第十章*，*保持历史清洁*。

解决这个问题的方法是提供一些客户端钩子，用户可以安装这些钩子，并让 Git 在他们违反政策时立即通知他们，这将导致他们的更改被服务器拒绝。其目的是尽可能快速地帮助纠正问题，通常是在提交更改之前。这些客户端钩子必须以某种方式分发，因为克隆仓库时不会复制钩子。各种分发这些钩子的方法在 *第十三章*，*自定义和扩展 Git* 中进行了描述。

如果对变更内容有任何限制（例如，某些文件可能仅由指定的开发者修改），可以使用 `pre-commit` 钩子创建警告信息。`prepare-commit-msg` 钩子（和 `commit.template` 配置变量）可以为开发者提供一个自定义的模板，开发者在提交消息时填写。你还可以让 Git 在提交记录之前，通过 `commit-msg` 钩子检查提交消息。此钩子会检查并通知你是否正确格式化了提交消息，是否包含了政策要求的所有信息。此钩子也可以替代或与 `pre-commit` 一起使用，检查你是否修改了不允许修改的文件。

`pre-rebase` 钩子可用于验证你是否试图以会导致非快进推送的方式重写历史（如果服务器启用了 `receive.``denyNonFastForwards`，强制推送也无法生效）。

作为最后的手段，还有一个 `pre-push` 钩子，可以在尝试连接到远程仓库之前检查是否正确。

## 签名推送

*第六章*，*使用 Git 进行协作开发*，包括开发者可以用来确保自己工作完整性和真实性的各种机制描述——签名标签、签名提交和签名合并（合并签名标签）。所有这些机制都声明对象（及其包含的更改）来自签名者。

然而，签名标签和提交并不能证明开发者希望在某个特定分支的顶端有某个特定的修订版本。托管网站进行的身份验证无法轻松审计，且这要求你信任托管网站及其身份验证机制。现代 Git（版本 2.2 或更新版本）允许你为此目的**签名推送**。

签名推送要求服务器设置 `receive.certNonceSeed`，客户端使用 `git push --signed`。签名推送的处理通过服务器端钩子完成。目前，包括 GitHub、GitLab、Bitbucket 和 Gitea 在内的 Git 仓库平台都不支持签名推送；有一些工具如**gittuf**或**Kernel.org Transparency Log Monitor**提供推送操作的透明日志。

客户端发送的签名推送证书作为 blob 对象存储在仓库中，并通过 `pre-receive` 钩子进行验证，该钩子可以检查各种 `GIT_PUSH_CERT_*` 环境变量（有关详细信息，请参阅 `git-receive-pack` 手册页面），以决定是否接受或拒绝给定的签名推送。

可以通过 `post-receive` 钩子来记录签名推送的审计日志。您可以让此钩子发送关于签名推送的电子邮件通知，或者将推送信息附加到日志文件中。`pre-receive` 和 `post-receive` 输入。

## 提供 Git 仓库服务

在 *第六章*，《使用 Git 进行协作开发》中，我们探讨了 Git 用于连接远程仓库的四种主要协议——本地协议、HTTP 协议、**SSH**（**安全** **外壳**）协议和 Git 协议（原生协议）。从客户端连接到仓库的角度进行讨论，解释了这些协议是什么，以及在远程仓库提供多种协议时应使用哪个协议。

本章将提供管理员的视角，解释如何设置并随后迁移改写后的 Git 仓库，以通过不同的传输协议提供服务。在这里，我们还将逐一检查每种协议的身份验证和授权方式。

### 本地协议

这是最基本的协议，客户端使用指向仓库的路径或 `file://` URL 来访问远程仓库。您只需要拥有一个共享的文件系统，例如 NFS 或 SMB/CIFS 挂载，其中包含 Git 仓库。这是一个不错的选择，如果您已经有网络文件系统的访问权限，因为您不需要设置任何服务器。

使用基于文件的传输协议访问仓库由现有的文件权限和网络访问权限控制。您需要读取权限来获取和克隆，写入权限来推送。

在后一种情况下，如果您希望启用推送，最好以一种不会破坏权限的方式设置仓库。这可以通过使用 `git init`（或 `git clone`）时创建带有 `--shared` 选项的仓库来实现。此选项允许属于同一组的用户通过使用粘滞组 ID 推送到仓库，从而确保仓库对所有组成员可用。

这种方法的缺点在于，与基本的网络访问和设置适当的服务器相比，共享网络文件系统的访问通常更难设置并从多个远程位置安全地访问。通过互联网挂载远程磁盘可能困难且速度较慢。

此协议不能防止仓库遭受意外损坏。每个用户对仓库的内部文件都有完全访问权限，并且没有任何措施阻止他们意外破坏仓库。

### SSH 协议

SSH 是一种常见的传输协议（Linux 用户常用）来自托管 Git 仓库。SSH 对服务器的访问在许多情况下已经设置好，通常是作为安全登录远程机器的一种方式；如果没有设置，通常也很容易设置和使用。SSH 是一种经过身份验证和加密的网络协议。

相反，你不能通过 SSH 为 Git 仓库提供匿名访问。用户必须至少具有对你的机器的有限 SSH 访问权限；该协议不允许对已发布的仓库进行匿名的只读访问。

通常，有两种方式可以通过 SSH 访问 Git 仓库。第一种是为每个尝试访问仓库的客户端在服务器上创建一个单独的账户（尽管这样的账户可以被限制，并且不需要完全的 shell 访问权限，在这种情况下，你可以为 Git 专用账户使用`git-shell`作为登录 shell）。这种方式可以与普通的 SSH 访问一起使用，你提供密码，或者使用公钥登录。在每个用户一个账户的情况下，访问控制与本地协议类似——即通过文件系统权限控制访问。

第二种方法是创建一个单一的 shell 账户，通常是`git`用户，专门用于访问 Git 仓库，并使用公钥登录来验证用户。每个需要访问仓库的用户需要将他们的 SSH 公钥发送给管理员，管理员将此公钥添加到授权密钥列表中。实际用户通过他们用于连接服务器的密钥来识别。

另一种选择是通过 LDAP 服务器或其他集中式身份验证方案对 SSH 服务器进行身份验证（通常用于实现单点登录）。只要客户端能够获得（有限的）shell 访问权限，就可以使用任何 SSH 身份验证机制。

### 匿名 Git 协议

接下来是 Git 协议。这是由一个特殊且非常简单的 TCP 守护进程提供的，它在一个专用端口上监听（默认情况下是端口`9418`）。这是（或曾经是）快速、匿名、未经身份验证的只读访问 Git 仓库的常见选择。

Git 协议服务器`git daemon`相对容易设置。基本上，你只需要运行此命令，通常以守护进程方式运行。如何运行守护进程（服务器）取决于你使用的操作系统。它可以是`systemd`单元文件、Upstart 脚本或`sysvinit`脚本。常见的解决方案是使用`inetd`或`xinetd`。

你可以通过`--base-path=<directory>`重映射所有相对于给定路径（Git 仓库的项目根目录）的仓库请求。也支持虚拟主机；更多细节请参见`git-daemon`文档。默认情况下，`git daemon`只会导出在`gitdir`内具有`git-daemon-export-ok`文件的仓库，除非使用`--export-all`选项。通常，你还会希望开启`--reuseaddr`，允许服务器在不等待连接超时的情况下重新启动。

Git 协议的缺点是缺乏认证，并且运行时使用的端口较为隐蔽（可能需要你在防火墙中打孔）。缺乏认证的原因是，默认情况下它仅用于读取访问——即用于拉取和克隆仓库。通常，它与 SSH（始终经过认证且绝不匿名）或 HTTPS 一起用于推送。

你可以配置它以允许推送（通过使用`--enable=<service>`命令行选项启动`receive-pack`服务，或者在每个仓库的基础上，通过将`daemon.receivePack`配置设置为`true`），但通常不推荐这么做。钩子实现访问控制时可以获得的唯一信息是客户端地址，除非你要求所有推送都进行签名。你可以在访问钩子中运行外部命令，但这并不能提供更多关于客户端的信息。

提示

你可能考虑启用的一个服务是**upload-archive**，它提供**git** **archive --remote**服务。

这种缺乏认证意味着，Git 服务器不仅不知道是谁访问了仓库，而且客户端也必须信任网络，确保在访问服务器时地址不会被伪造。这种传输没有加密。

### 智能 HTTP(S)协议

设置所谓的“智能”HTTP(S)协议，基本上是启用一个服务器脚本，该脚本会在服务器上调用`git receive-pack`和`git upload-pack`。Git 为此任务提供了一个名为`git-http-backend`的 CGI 脚本。这个 CGI 脚本可以检测客户端是否理解智能 HTTP 协议；如果不理解，它将回退到“笨重”模式（这是一种向后兼容的功能）。

要使用此协议，你需要一个 CGI 服务器——例如 Apache（使用此服务器时，你还需要`mod_cgi`模块或其等效模块，以及`mod_env`和`mod_alias`模块）。参数通过环境变量传递（因此在使用 Apache 时需要`mod_env`）——`GIT_PROJECT_ROOT`用于指定仓库的位置，且如果你希望导出所有仓库而不仅仅是那些包含`git-daemon-export-ok`文件的仓库，还可以选择使用`GIT_HTTP_EXPORT_ALL`。

认证由 Web 服务器完成。特别是，你可以设置它允许未经认证的匿名只读访问，同时要求推送时进行认证。使用 HTTPS 可以提供加密和服务器认证，类似于 SSH 协议。使用 HTTP(S)时，拉取和推送的 URL 是相同的；你还可以配置，使得用于浏览 Git 仓库的 Web 界面也使用相同的 URL 进行拉取。

注意

**git-http-backend**的文档包括了不同情况下的 Apache 设置，包括未认证的读取和认证的写入。那里展示的设置有些复杂，因为最初的引用广告使用查询字符串，而**receive-pack**服务的调用使用路径信息。

相反，要求任何有效账户进行身份验证以进行读取和写入，并将写入的限制留给服务器端钩子，这是一个更简单且通常可接受的解决方案。

如果你尝试推送到需要身份验证的仓库，服务器可能会提示输入凭证。由于 HTTP 协议是无状态的，并且有时涉及多个连接，因此使用凭证助手（请参见 *第十三章*，*自定义和扩展 Git*）是有用的，这样就可以避免在单次操作中多次输入密码，或者将密码保存在磁盘上的某个地方（例如，在远程 URL 中）。

Gitolite 用于智能 HTTPS 访问控制

虽然 Gitolite ([`gitolite.com/`](https://gitolite.com/)) 为通过 SSH 访问的 Git 提供了访问控制层，但它也可以配置为对智能 HTTP 模式进行授权。

### 傻瓜协议

如果你无法在服务器上运行 Git，你仍然可以使用傻瓜协议，因为它不需要 Git。在这种传输协议下，Git 仓库被期望像普通静态文件一样由 Web 服务器提供服务。然而，为了能够使用这种协议，Git 需要额外的 `objects/info/packs` 和 `info/refs` 文件，并且这些文件必须通过 `git update-server-info` 保持最新。通常，这个命令是在通过前面提到的某个智能协议进行推送时运行的（默认的 `post-update` 钩子会执行此操作，如果 `receive.updateServerInfo` 设置为 `true`，`git-receive-pack` 也会执行此操作）。

可以使用傻瓜协议进行推送，但这需要一种设置，允许你使用指定的传输更新文件；对于傻瓜 HTTP(S) 传输协议，这意味着配置 WebDAV。

在这种情况下，身份验证是由 Web 服务器为静态文件完成的。显然，对于这种传输方式，Git 的服务器端钩子不会被调用，因此不能用来进一步限制访问。

历史说明

请注意，对于现代 Git，傻瓜传输是通过 curl 系列的远程助手实现的，而这些助手可能不是默认安装的。

这种传输方式（用于获取）通过下载请求的引用（作为普通文件），检查在哪儿可以找到包含引用提交对象的文件（因此需要服务器信息文件，至少对于包文件中的对象），获取它们，然后遍历修订链，检查每个所需的对象，如果对象尚未存在于本地仓库，则下载新文件。如果仓库在请求的修订范围内没有良好打包，这种遍历方法可能会非常低效。它需要大量连接，并且即使只需要其中一个对象，也总是会下载整个包。

使用智能协议时，客户端和服务器端的 Git 会协商哪些对象需要发送（即“需要/已有”协商）。然后 Git 创建一个定制的打包文件，利用已知的对方已有的对象，通常只包括增量——也就是与对方所拥有的不同部分（即瘦打包文件）。对方会将接收到的打包文件重写为自包含的格式。

### 远程助手

Git 允许我们通过编写远程助手程序来创建对新传输协议的支持。这个机制也可以用于支持外部仓库。Git 通过将远程助手作为独立的子进程启动，并通过标准输入和输出与这个进程通信，执行一组命令来与需要远程助手的仓库交互。远程传输助手的使用在*第六章*，*使用 Git 进行协作开发*中有描述。

你可以找到第三方远程助手来支持新的访问仓库方式——例如，有`git-remote-dropbox`可以使用 Dropbox 来存储远程 Git 仓库。不过，注意的是，与内建传输支持相比，远程助手的功能可能（仍然）有所限制。

## 用于管理 Git 仓库的工具

现在，你不需要自己编写 Git 仓库管理解决方案。有许多各种各样的第三方解决方案可以使用。列出所有的解决方案是不可能的，甚至给出推荐也是有风险的。Git 生态系统正在积极开发中；哪个工具最好可能会随着时间的推移而改变。

我在这里仅想集中讨论管理员工具的类型，就像我在*第十三章*，*Git 的定制与扩展*中讨论 GUI 工具一样。

首先，在 `contrib/` 目录下有 `update-paranoid` 脚本。这些工具侧重于访问控制，通常是授权部分，使得添加仓库和管理其权限变得简单。一个这样的工具的例子是*Gitolite*。

它们通常支持某些机制，以添加你自己的额外访问限制。

然后是 `git log` 和 `git show` 命令，以及显示仓库中文件列表的视图。一个这样的工具的例子是与 Git 一起分发的 Perl 脚本 `gitweb`；另一个是由 [git.kernel.org](http://git.kernel.org) 使用的 `cgit`。

同样有用的是**代码审查**（**代码协作**）工具。这些工具使得团队中的开发人员可以通过网页界面审查彼此提出的修改。这些工具通常允许创建新项目并处理访问管理。一个这样的工具的例子是 Gerrit 代码审查。

最后，有**Git 托管**解决方案，也称为**软件 Forge**，通常具有用于管理仓库的网页界面，使我们能够添加用户、创建仓库、管理访问权限，并且通常可以在浏览器中操作 Git 仓库。此类工具的示例有 GitLab 和 Gitea。也有类似的**源代码管理**系统，它们提供（除了其他基于网页的界面）仓库托管服务，以及协作和开发管理功能。这样的系统示例有 Kallithea；然而，现如今，许多软件 Forge 也包括一些源代码管理功能，如问题追踪，以及**CI/CD**（**持续集成/持续交付**）管道。

当然，你不需要自己托管代码。市面上有大量第三方托管选项——如 GitHub、Bitbucket 等。甚至还有使用开源托管管理工具的托管解决方案，如 GitLab 和 Codeberg。

## 托管仓库的小技巧

如果你想自托管 Git 仓库，有一些事情可能有助于提升服务器性能和用户满意度。

### 减少仓库占用的空间

如果你托管了许多同一仓库的分支（克隆），你可能希望通过某种方式共享公共对象以减少磁盘使用。一个解决方案是在创建分支时使用`git clone --reference`。在这种情况下，衍生仓库会在其自身找不到对象时查找其父仓库的对象存储。

然而，这种方法有两个问题。首先，你需要确保借用仓库依赖的对象不会从作为备用对象存储的仓库集合中消失（即你借用的仓库）。例如，你可以通过在借用对象的仓库中链接借用仓库的 refs（例如，在`refs/borrowed/`命名空间中）来完成此操作。第二，进入借用仓库的对象不会自动去重；你需要运行`git repack -a -d -l`，它内部会将`--local`选项传递给`git pack-objects`。

另一种解决方案是将所有的分支放在同一个仓库中，并使用`git-http-backend`手册页中包含的示例配置，从单个仓库为不同的命名空间提供多个仓库。Gitolite 也对命名空间提供了一些支持，形式为逻辑仓库和后端仓库，以及`option namespace.pattern`，尽管并不是所有功能都适用于逻辑仓库。

将多个仓库作为单一仓库的命名空间来存储，可以避免存储相同对象的重复副本。它自动防止了新对象之间的重复，而不需要进行持续的维护，这与替代方案不同。相反，安全性较弱；你需要将对单一命名空间（位于仓库内）有访问权限的人视为对所有其他命名空间都有访问权限（尽管这可能对你的情况来说不是问题）。

### 通过 pack 位图加速智能协议

另一个在自托管仓库时可能遇到的问题是智能协议的性能。对于你的服务器客户端而言，操作需要快速完成；作为管理员，你不希望因为提供 Git 仓库服务而在服务器上产生高 CPU 负载。

一项从 JGit 移植过来的特性应该显著提高计数对象阶段的性能，同时为使用该特性的仓库提供对象服务。这个特性是**位图索引文件**，自 Git 2.0 起可用。

位图索引文件

**位图索引**文件的主要功能是为选定的提交子集（包括最近的提交）提供位向量（位图），这些位向量存储了在 packfile 或多 pack 索引中的一组对象的可达性信息。在每个位向量中，索引 **i** 处的 1 表示第 **i** 个对象（按 packfile 或多 pack 索引文件定义的顺序）可以从该位向量所属的提交中访问。

该文件与 packfile 及其索引一起存储。可以通过运行`git repack -A -d --write-bitmap-index`手动生成，或者通过将`repack.writeBitmaps`配置变量设置为`true`，与 packfile 一起自动生成。该方案的缺点是位图会占用额外的磁盘空间，而且初次 repack 需要额外时间来创建位图索引。随着现代 Git 的发展，得益于多 pack 索引，你不再需要将所有内容重新打包成单一的 packfile 就能使用位图文件。这个特性还加快了位图更新的速度。

如今，这个特性默认在裸仓库中启用。

### 解决大型不可恢复初始克隆问题

拥有大型代码库和悠久历史的仓库可能会变得相当庞大。问题在于，初始克隆需要从一个可能很大的仓库中获取所有内容，这是一个全有或全无的操作，至少对于现代（安全且有效的）智能传输协议——SSH、`git://`和智能 HTTP(S) 来说是这样。如果网络连接不太可靠，这可能会成为问题。目前不支持可恢复克隆，遗憾的是，这似乎是 Git 开发者面临的一个根本难题。然而，这并不意味着你作为托管管理员无能为力，无法帮助用户完成初始克隆。

一个解决方案是使用`git bundle`命令创建一个静态文件，该文件可以用于初始克隆，或者作为初始克隆的参考仓库（后者可以在下载 bundle 后使用`git clone --reference=<bundle> --dissociate`命令完成）。这个 bundle 文件可以通过任何传输方式进行分发——特别是能够在中断时恢复的方式， 无论是 HTTP(S)、FTP、rsync 还是 BitTorrent。人们通常使用的约定是，在开发者文档中解释如何获取这样的 bundle 时，使用与仓库相同的 URL，但文件扩展名是`.bundle`（而不是空扩展名或`.git`后缀）。如果 bundle 可以通过 HTTP(S)或 SSH 协议访问，则可以在没有显式下载的情况下直接使用`git clone --bundle-uri=<bundle uri>`。

Git 还有**bundle-uri**功能，服务器可以向客户端建议从哪里下载这样的 bundle，客户端可以使用该 bundle 来加速初始克隆。在[写这篇文档时，没有软件托管平台支持此功能，](https://github.com/git-ecosystem/git-bundle-server)但有一个**git bundle-server**（[`github.com/git-ecosystem/git-bundle-server`](https://github.com/git-ecosystem/git-bundle-server)）的 Web 服务器和管理界面可以配合此功能使用。

还有一些更为复杂的方法可以解决初始克隆成本的问题，例如逐步加深一个浅克隆（或者也许只需要使用`git clone --depth`进行浅克隆），从部分克隆开始，或者使用像 GitTorrent 这样的方式。

# 增强开发工作流程

版本控制只是开发工作流程的一部分。还有工作管理、代码审查与审核、自动化测试执行以及构建生成等任务。

许多这些步骤可以通过专门的工具来辅助。许多工具提供 Git 集成。例如，可以使用 Gerrit 来管理代码审查，要求每个变更在公开之前都通过审查。另一个例子是设置开发环境，以便将更改推送到公共仓库时，可以根据提交信息中的模式自动关闭问题跟踪器中的工单。可以通过服务器端钩子或托管服务的 Webhooks 来实现这一点。

一个仓库可以作为一个网关，运行自动化测试（例如，借助 Jenkins 或 Hudson 的持续集成服务）并在所有测试通过后仅部署更改以确保质量环境。另一个仓库可以配置为触发不同支持的系统的构建。许多工具和服务支持推送部署机制（例如，Heroku 或 Google 的 App Engine）。

Git 可以自动通知用户和开发者有关已发布更改的信息。这可以通过电子邮件、邮件列表、IRC/Discord/Slack 频道或基于 Web 的仪表盘应用程序来实现。可能性很多；你只需要找到它们。

## 在仓库中定义开发工作流

许多软件开发平台允许你直接从仓库自动化、定制和执行软件开发工作流。这些解决方案，如*GitHub Actions* 和 *GitLab CI/CD*，允许你在仓库中发生其他事件时运行各种工作流（例如，运行测试或部署应用程序）。这些工作流是通过运行器来执行的，运行器可以是虚拟机或容器。它们通常由一个 YAML 文件定义并检查到你的仓库中。

虽然 YAML 标记语言的具体方言、文件路径名以及可用的预定义操作因服务而异，但它们足够相似，你应该能够从一个解决方案迁移到另一个解决方案。

## GitOps —— 使用 Git 进行操作程序

在 Git 仓库中定义软件开发工作流的自然扩展是使用 Git 来自动管理部署基础设施，特别是对于云原生应用程序。这被称为**GitOps**——一种操作框架，使用 Git 仓库存储**基础设施即代码**（**IoC**）文件和应用程序配置文件。这些数据可以与应用程序代码存储在同一个仓库中，或存储在单独的仓库中。

GitOps 确保基础设施（包括开发、测试和部署环境）基于 Git 仓库的状态能够立即重现。这为操作提供了版本控制，以便在需要回滚时使用。

通常，基础设施配置是声明式定义的，专门的软件代理（例如 Argo CD、Flux 或 Gitkube）在云端定期从 Git 仓库拉取并检查配置与实时状态的匹配情况，根据需要调整状态。

# 总结

本章涵盖了与 Git 使用相关的管理方面的各种问题。你学习了维护、数据恢复和仓库故障排除的基础知识。你还学习了如何在服务器上设置 Git，如何使用服务器端钩子以及如何管理远程仓库。本章还介绍了提高远程性能的技巧和窍门，并描述了如何在第三方工具的帮助下使用 Git 来增强开发工作流。本章中的信息应该帮助你选择 Git 仓库管理解决方案，甚至自己编写一个。

下一章将包含一套建议和最佳实践，既包括特定于 Git 的，也包括那些与版本控制无关的。可以通过本章中探索的工具来执行和鼓励基于这些建议的政策。

# 问题

回答以下问题，测试你对本章内容的理解：

1.  如何设置自动化的仓库维护，确保 Git 操作不会变慢？

1.  如何尝试恢复丢失的提交？

1.  如何找出某些 Git 命令开始表现不佳且执行时间过长的原因？

1.  如何确保开发过程遵循既定的定义政策？

1.  分享仓库的最简单私密方法是什么，其中所有开发者都在单台计算机上工作（在一台机器上）？

# 答案

以下是对上述问题的答案：

1.  使用**git** **maintenance**命令。

1.  首先，如果无法从分支和 HEAD 的 reflog 中找到丢失的提交，检查它们。如果此方法无效，你可以尝试使用**git fsck**浏览不可达的提交。

1.  你可以使用“**Git trace**”机制——例如，通过设置**GIT_TRACE2_PERF**或**GIT_TRACE_PERFORMANCE**环境变量。

1.  如果可能，使用你的软件平台功能（例如，保护分支免受更改或删除）或使用服务器端钩子。客户端钩子可以帮助但不能确保强制执行政策。

1.  只需使用**git init --bare --shared**创建裸仓库，同时确保所有需要访问仓库的开发者拥有适当的文件系统权限。如果需要，可以向该仓库推送。

# 深入阅读

要了解更多关于本章所涵盖的主题，请参考以下资源：

+   Scott Chacon, Ben Straub: *Pro Git, 第 2 版*，Apress（2014）*第四章*，*Git 在服务器上* [`git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols`](https://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols)

+   Scott Chacon: *Git 技巧 2：Git 中的新特性*（2024）[`blog.gitbutler.com/git-tips-2-new-stuff-in-git/#git-maintenance`](https://blog.gitbutler.com/git-tips-2-new-stuff-in-git/#git-maintenance)

+   Konstantin Ryabitsev: *签名的 Git 推送*（2020）[`people.kernel.org/monsieuricon/signed-git-pushes`](https://people.kernel.org/monsieuricon/signed-git-pushes)

+   Vicent Martí: *计数对象*（2015）[`github.blog/2015-09-22-counting-objects/`](https://github.blog/2015-09-22-counting-objects/)

+   Sitaram Chamarty: *Gitolite 基础*，Packt（2014）[`subscription.packtpub.com/book/programming/9781783282371`](https://subscription.packtpub.com/book/programming/9781783282371)

+   Derrick Stolee: *探索 Git 推送性能的新前沿*（2019）[`devblogs.microsoft.com/devops/exploring-new-frontiers-for-git-push-performance/`](https://devblogs.microsoft.com/devops/exploring-new-frontiers-for-git-push-performance/)

+   Taylor Blau: *扩展单一仓库的维护*（2021）[`github.blog/2021-04-29-scaling-monorepo-maintenance/`](https://github.blog/2021-04-29-scaling-monorepo-maintenance/)
