

# 第十五章：Git 最佳实践

《*Git 入门*》的最后一章展示了一系列通用和特定于 Git 的版本控制建议和最佳实践。你在前面的章节中已经接触到其中很多建议；这里将它们作为总结和提醒。有关每个最佳实践的详细信息和背后的原因，请参考具体章节。

本章将涵盖管理工作目录、创建提交和提交系列（拉取请求）、提交更改以供包含以及同行评审变更的问题。

本章将涵盖以下主题：

+   如何将项目拆分为仓库

+   在仓库中存储哪些类型的数据，以及 Git 应该忽略哪些文件

+   在创建新提交之前需要检查什么

+   如何创建良好的提交和良好的提交系列（换句话说，如何创建良好的拉取请求）

+   如何选择有效的分支策略，以及如何命名分支和标签

+   如何审查变更以及如何回应审查

# 启动一个项目

在启动项目时，你应该选择并明确项目治理模型（谁管理工作，谁整合更改，谁负责什么）。你还需要决定代码的许可证和版权：它是否是外包工作，贡献是否需要版权转让、贡献者协议、贡献者许可证协议，或者仅仅是数字原产地证书。

## 将工作分配到仓库中

在集中式版本控制系统中，通常所有内容都放在同一个项目树下。而在分布式版本控制系统（如 Git）中，这在很大程度上取决于项目的性质。通常，最好将不同的项目拆分到不同的仓库中，但如果这些项目紧密耦合在一起，那么使用**单一仓库（monorepo）**可能更好——将所有项目放在一个大的仓库中。

如果某部分代码被多个独立项目需要，考虑将其提取为一个独立的项目，并将其作为子模块或子树引入，按概念将其组织成一个超级项目。有关详细信息，请参见 *第十一章*，*管理子项目*。

## 选择协作工作流

你需要做出关于协作结构的决策，决定你的项目将采用分散贡献者模型、"受信任"仓库模型、还是中央仓库等（具体内容请见 *第六章*，*使用 Git 进行协作开发*）。

这通常需要设置访问控制机制并决定权限结构；有关如何设置这些内容的详细信息，请参见 *第十四章**，Git 管理*。

你还需要决定使用的分支模式。参见*第八章*，*高级分支技术*，其中包含了最常见模式的示例。你需要决定如何集成变更，以及如何隔离独立的工作。这些分支模式通常会组合成一个单独的命名分支工作流。

关于分支的决策不需要一成不变。随着项目和团队经验的增长，你可能希望考虑改变分支模型，例如，从基于主干的工作流改为每个功能独立分支模型、GitHub 流，或其他衍生模型。

有关许可、协作结构和分支模型的决策应该在开发者文档中明确说明（至少在`README`和`LICENSE`/`COPYRIGHT`文件中，可能还包括在`CodingGuidelines`和`CodeOfConduct`中）。你需要记住，如果项目的开发方式发生变化，这些文档需要更新以反映这些变化。例如，因为项目已超出最初阶段，可能会发生这种情况。

## 选择要保留在版本控制中的文件

在大多数情况下，你不应该将任何**生成的文件**包含在版本控制系统中（尽管有一些非常罕见的例外）。你应该只跟踪源文件（即原始资源）；Git 在处理这些源文件时表现最好，尽管它也能很好地处理二进制文件。

为了避免不小心将不需要的文件包含在代码库中，你应该在项目树中使用`.gitignore`文件；开发者特定的文件（例如，由编辑器或操作系统创建的备份文件）应放入他们各自的`core.excludesFile`（在现代 Git 中是`~/.config/git/ignore`文件），或者放入特定克隆版本库的本地配置中，即`.git/info/excludes`。有关详细信息，请参见*第三章*，*管理你的工作树*。

忽略模式的一个良好起点是[`gitignore.io`](https://gitignore.io)网站，它提供了各种操作系统、IDE 和编程语言的`.gitignore`模板。

另一个建议是，不要将可能因环境而变化的配置文件添加到 Git 中（例如，MS Windows 和 Linux 之间不同的配置文件）。

# 在项目中工作

以下是有关如何创建变更和开发新版本的一些指导方针。这些方针可以用于你自己项目的工作，或者帮助你向由他人维护的项目贡献代码。

不同的项目可能使用不同的开发工作流；因此，根据使用的工作流，本文提供的一些建议可能没有意义。

## 在主题分支上工作

Git 中的分支有两个功能（*第八章*，*高级分支技巧*）：作为开发者提交的代码在**指定的代码稳定性和成熟度级别**下的中介（长期存在的公共分支），提供集成和部署的路径，以及作为**新想法开发的沙盒**（短期存在的私人分支）。

沙盒化变更的能力是为什么创建一个单独的分支来处理每个新任务被认为是一个好习惯。这样的分支被称为主题分支或功能分支。使用独立的分支使得在任务之间轻松切换成为可能，并且可以防止不同的工作进度互相干扰。另一方面，如果这些分支存在很长时间，这会违反**持续集成**（**CI**）的实践，减少变更集的可见性，并因为更大的分歧导致更困难的集成。

你应该为分支选择简短且具有描述性的名称。主题分支有不同的命名约定，你的项目使用的约定应在开发文档中说明。通常，分支名称会总结它们所托管的主题，通常是全小写字母，单词之间的空格用连字符或下划线替代（查看`git-check-ref-format`的手册页以了解分支名称中禁止使用的字符）。分支名称可以包含斜杠（成为层次化结构）。

如果你正在使用问题追踪器，那么修复 bug 或实现某个问题的分支可以在其名称前加上描述该问题的票据编号，例如`1234-doc_spellcheck`。另一方面，维护者在收集其他开发者的提交时，可以将这些提交放入以开发者的首字母和主题名称命名的主题分支中，例如`ad/whitespace-cleanup`（这是一个**层次化的** **分支名称**示例）。

在完成相关分支的工作后，从本地仓库以及上游仓库删除你的主题分支被认为是一个好习惯，以减少杂乱。

## 决定基于什么来开展你的工作

作为开发者，你通常会在某个特定问题上进行工作，无论是 bug 修复、功能增强、某个主题的修正，还是新特性的开发。

在给定主题上开始工作的地方，以及基于哪个分支开始工作，都取决于项目所选的分支工作流（参见*第八章*，*高级分支技巧*，了解不同的分支工作流）。这个决定也取决于你所做工作的类型。

对于主题分支工作流（或每个功能一个分支工作流），你应该选择基于与你的更改相关的、最老且最稳定的长期运行分支，并计划将更改合并到该分支。这是因为，正如在*第八章*《*高级分支技巧*》中所描述的，你**绝不应该将**一个**不太稳定的分支合并到**一个**更稳定的分支**。这一最佳实践的背后原因是为了避免使分支不稳定，因为合并会带入所有更改。

不同类型的更改需要不同的长期存在的分支作为主题分支的基础，或者将这些更改放置到该分支上。一般来说，为了帮助开发者理解项目的工作流程，这些信息应当在开发文档中进行描述；并不是每个人都需要了解项目使用的分支工作流。

以下内容描述了根据更改的目的，通常作为基础分支使用的内容：

+   **Bug 修复**：在这种情况下，主题分支（bugfix 分支）应基于存在该 bug 的最老且最稳定的分支。通常来说，从维护分支开始。如果在维护分支中没有该 bug，则应基于稳定分支创建 bugfix 分支。对于在稳定分支中不存在的 bug，找到引入该 bug 的主题分支，并基于该主题分支进行工作。

+   **新功能**：在这种情况下，主题分支（功能分支）应尽可能基于稳定分支。如果新功能依赖于某个尚未准备好进入稳定分支的主题，则应基于该主题（从主题分支）。

+   对于未合并到稳定分支中的主题的修正和增强，应基于正在修正的主题分支的最新版本。如果相关主题尚未发布，可以对该主题的步骤进行更改，将小的修正合并到系列中（详见*第十章*《*保持* *历史清晰*》中的历史重写部分）。

如果你所参与的项目足够大，拥有专门的维护者来管理系统的某些部分（子系统），你首先需要决定将基于哪个代码库和分支（有时称为“树”）进行工作。

## 将更改拆分为逻辑上独立的步骤

除非你的工作非常简单并且可以在一个步骤内完成（一个提交）——就像许多 bug 修复一样——你应该将逻辑上独立的更改拆分为单独的提交，每个提交代表一个步骤。这些提交应按逻辑顺序排列。

遵循提交信息的最佳实践（说明你所做的更改——见下一节）有助于决定何时提交。如果你的描述过长，并且开始看到你有两个独立的更改被混合在一起，那么这意味着你可能需要将提交拆分成更小的部分，并使用更细粒度的步骤。

然而，请记住，这取决于项目约定和所选开发工作流之间的平衡。更改至少应该是自成一体的。在实现某个特性时的每一步（每次提交），代码应该能够编译，程序也能通过测试套件。你应该使用 `git bisect`（这一点在 *第四章*，*探索项目历史* 中有所描述）。

请注意，你不必一开始就制定完美的步骤序列。如果你发现工作目录的状态被混合在一起，可以利用暂存区，通过交互式添加将其解开（这一点在 *第二章**，开发与 Git,* 和 *第三章**，管理工作树* 中有所描述）。你也可以使用交互式变基或类似技术，如 *第十章**，保持历史整洁* 中所示，整理提交，生成易读（且易于二分）的历史，然后再发布。

重要提示

你应该记住，提交是记录你的结果（或朝着结果迈出的特定步骤）的位置，而不是保存工作临时状态的地方。如果你需要在返回之前暂时保存当前状态，可以使用 **git stash**。

## 写一条好的提交信息

一条好的提交信息应该包含对更改的解释，足够详细，以便团队中的其他开发人员（包括审查者和维护者）能够判断是否应该将该更改包含到代码库中。这个是否“好”的决策不应该需要他们阅读实际的更改内容才能判断提交的意图。

提交信息的第一行应简洁明了（大约 50 到 72 个字符），概述所做的更改。如果有其他内容，应该用空行将其与剩余部分分开。这是因为在许多地方，例如 `git log --oneline` 命令输出、图形化历史查看器如 `gitk` 和 `git rebase --interactive` 的指令页中，你只会看到这一行提交信息，并且必须根据这一行来决定对该提交的操作。如果你在总结更改时遇到困难，这可能意味着这些更改需要拆分成更小的步骤。

对于更改的摘要行，有多种约定。一种约定是使用**area:**作为前缀，后面跟随代码修改的领域标识符：如子系统名称、受影响的子目录名，或被修改的文件名。如果开发通过问题跟踪器管理，则此摘要行可以以类似**[#1234]**的前缀开始，其中**1234**是提交中实现的问题或任务的标识符。通常情况下，如果不确定提交信息中应该包含哪些信息，请参考开发文档或回溯到历史提交中使用的当前约定。

提示

如果你使用的是敏捷开发方法，你可以在回顾过程中寻找特别好的提交信息，并将其作为示例添加到未来的开发者文档中。

对于非琐碎的更改，应该有一段更长的有意义的描述，也就是提交信息的正文。这里有些事情是来自其他版本控制系统的人可能需要忘记的：即不写提交信息或将其写在一长行中。注意，Git 不允许创建一个空提交信息的提交，除非通过`--allow-empty`强制允许。

提交信息应该做到以下几点：

+   包括提交的理由，解释提交试图解决的问题——换句话说，*为什么*。它应该包含描述当前代码或项目在没有这个变更时的行为或状态的问题。这部分应当自包含，但可以引用其他来源，包括问题跟踪器（bug 跟踪器）或其他外部文档，如文章、wiki 或**常见漏洞与** **暴露**（**CVE**）。

+   包含简短的摘要。在大多数情况下，它也应该解释*如何*解决问题，并为提交解决方案的方式提供理由。

+   描述为什么你认为变更后的结果更好；这部分描述无需解释代码的作用，因为这通常是代码注释的任务。

+   如果存在多个可能的解决方案，请包含考虑过但最终被弃用的替代解决方案的描述，并提供指向讨论或评审的链接。

确保你的变更说明可以在不访问任何外部资源的情况下理解（也就是说，不访问问题跟踪器、互联网或邮件列表档案）。与其仅仅引用讨论，或在提供 URL 或问题编号的同时，写出相关要点的总结并包含在提交信息中。

写提交信息时的一项可能推荐做法是使用祈使语气描述变更，例如**让 foo 执行 bar**，就好像你在命令代码库改变其行为，而不是写**这个提交使得...**或**[我]** **更改了...**。

在这里，`commit.template` 和提交消息钩子可以帮助遵循这些做法。详细信息请见*第十三章*，*定制和扩展 Git*（以及*第十四章*，*Git 管理*，描述了强制执行这一建议的方法）。

## 准备变更以供提交

如果话题分支是很久之前开始的，考虑将该分支基于当前基础分支的最新提交进行 rebase。这应该会使未来的变更集成变得更容易。如果你的话题分支是基于开发版本，或者是基于其他正在进行中的话题分支（可能是因为它依赖某些特定功能），并且它所基于的分支已经合并到稳定的开发线路中，那么你应该将你的变更 rebase 到稳定的集成分支之上。

Rebase 也是最后清理历史的机会；这是使提交的变更更容易审查的机会。只需运行 `git rebase --interactive` 进行交互式 rebase，或者如果你喜欢，可以使用补丁管理工具（详见*第十章*，*保持历史干净*）。有一个注意事项：**不要重写已发布的历史**。

考虑测试你的变更是否能够顺利合并，如果不能，尽量修复它（如果可能）。确保它们能够顺利地应用或合并到适当的集成分支中。

最后检查一下即将提交的提交记录。确保你的变更没有添加注释掉的代码（或是 `ifdef` 注释掉的代码），也没有包含任何与补丁目的无关的额外文件（例如，未来功能的变更）。在提交之前，审查你的提交系列，确保准确无误。

# 集成变更

提交变更以进行合并的具体细节，当然取决于项目使用的开发工作流。关于各种可能的工作流类，详情请见*第六章*，*使用 Git 进行协作开发*。

## 提交并描述变更

如果项目有专门的维护者，或者至少有负责将提交的变更合并到官方版本的人，那么你还需要对提交的变更进行整体描述（除了描述每个提交之外）。这可以通过邮件发送补丁时的补丁系列封面信形式来完成。也可以通过使用协作贡献者仓库模型时，在 pull 请求中的评论中进行描述，或者可以通过已包含 URL 和你公共仓库中更改分支的邮件描述来完成（该 URL 是通过 `git request-pull` 生成的）。

这封封面信件或拉取请求应该包括补丁系列或拉取请求的目的描述。考虑提供为什么进行此项工作的概述（包括任何相关链接和讨论摘要）。在更改描述中明确表示这是一项进行中的工作。

在分散的贡献者模型中，变更作为补丁或补丁系列提交以供审查，通常是提交到邮件列表，你应该使用基于 Git 的工具，如`git format-patch`，如果可能，使用`git send-email`。多个相关的补丁应该被归为一组，例如放在同一个邮件线程中。约定是将它们作为对附加封面信件的回复发送，封面信件应该描述整个特性。

如果更改被发送到邮件列表，通常的约定是将主题行前缀加上`[PATCH]`或`[PATCH m/n]`（其中`m`是补丁系列中的补丁编号，`n`是总补丁数）。这样可以让人们轻松区分补丁提交和其他邮件。这个部分可以通过`git format-patch`来完成。你需要自己决定是否在`PATCH`后使用额外的标记来标记系列的性质，例如，`PATCH/RFC`。（**RFC**在这里指的是**征求意见**，即提出一个特性的想法，并附上其实现的示例。这种补丁系列只有在想法有价值时才应被审查；它还不准备应用/合并，只是为了开发者之间的讨论。）

在共同位置的贡献者仓库模型中，所有开发者使用相同的 Git 托管网站或软件（例如 GitHub、Bitbucket、GitLab 或其私有实例），你会将更改推送到你自己的公开仓库，即官方版本的一个分支。然后，你会创建一个合并请求或拉取请求，通常通过托管服务的网页界面进行，在那里再次描述更改的整体内容。

在使用中央仓库的情况下（可能是在共享维护模型中），你会将更改推送到集成仓库中的一个单独且可能是新的分支，然后向维护者发送公告，以便他们能够找到这些更改进行合并。此步骤的详细信息取决于具体的设置；发送公告可能通过电子邮件、某种内部消息机制，甚至通过工单（或工单中的评论）进行。

开发文档可能包括规则，指定在哪里发送公告和/或更改。通知涉及到你所修改的代码区域的人员是出于礼貌的行为（你可以使用`git blame`和`git shortlog`来识别这些人）。

人员；请参见*第四章*，*探索项目历史*）。这些人很重要；他们可以写评论并帮助审查变更。

署名和致谢

一些开源项目为了改进代码的来源追踪，使用了借鉴自 Linux 内核的签名程序，称为**数字来源证书**。签名是一行简单的内容，位于提交信息的末尾，如以下示例：

**Signed-off-by: Random** **Developer <rdeveloper@company.com>**

通过添加这一行，你证明该贡献要么完全由你创建，要么部分由你创建，或基于之前的工作，或直接提供给你，并且链中的每个人都有权在适当的许可证下提交它。如果你的工作是基于其他人的工作，或者你只是转交别人的工作，那么可能会有多条签名行，形成一条来源链。

为了表彰帮助创建提交的人，你可以在提交信息中附加其他尾注，例如**Reported-by:**、**Reviewed-by:**、**Acked-by:**（此项表示该更改得到了负责该区域的人的认可）或**Tested-by:**。

## 更改审查的艺术

完成同行评审更改是非常耗时的（尽管使用版本控制也同样耗时），但其好处巨大：更好的代码质量、减少质量保证测试所需的时间、知识转移等等。更改可以由同行开发人员进行评审，也可以由社区评审（需要达成共识），或者由维护者或他们的副手进行评审。

在开始代码审查过程之前，你应该阅读拟议更改的描述，以了解为什么提出这个更改，并决定你是否是执行审查的合适人选（这也是为什么好的提交信息如此重要的原因之一）。你需要理解该更改尝试解决的问题。你应该熟悉问题的背景，并了解更改涉及的代码部分。

第一步是重现更改前的状态，检查程序是否按描述工作（例如，检查一个 bug 修复是否能够重现该 bug）。然后，你需要检查包含拟议更改的主题分支，并验证结果是否正确。如果有效，审查这些更改，列出所有错误的地方（尽管如果在流程早期就发现错误，可能无需深入下去），如下所示：

+   提交信息是否足够描述性？代码是否易于理解？

+   贡献的架构是否正确？它在架构上是否稳健？

+   代码是否符合项目的编码标准和约定的编码规范？

+   更改是否仅限于提交信息中描述的范围？

+   代码是否遵循行业最佳实践？它是否安全且高效？

+   是否有冗余或重复的代码？代码是否尽可能模块化？

+   代码是否在测试套件中引入了任何回归？如果是新功能，变更是否包括该新功能的测试，包括正向和负向测试？

+   新代码的表现是否和变更前一样（在项目的容忍范围内）？

+   所有单词拼写是否正确，新版本是否遵循内容的格式化指南？

这只是一个可能的代码审查检查清单提案。根据项目的具体情况，可能还会有其他需要在审查中提出的问题；让团队编写自己的检查清单。你可以在网上找到很好的例子。

将在审查过程中发现的问题分为以下几类：

+   **错误问题**：该功能不在项目范围内。有时用于无法复现的 bug。贡献背后的想法是否合理？如果合理，则可以带有或不带有偏见地弹出变更，并且不再继续分析审查。

+   **无法正常工作**：这无法编译，导致回归，未通过测试套件，未修复 bug 等。这些问题必须彻底修复。

+   **不符合最佳实践**：这不符合行业指导原则或项目的编码规范。贡献是否经过打磨？这些问题是相当重要的，但可能存在一些写法上的细微差别。

+   **不符合** **审查者偏好**。在这种情况下，你应该建议修改，或者请求进一步澄清。

小问题，例如拼写错误或打字错误，可以由审查者立即修复。然而，如果相同的问题重复出现，考虑请求原作者进行修复并重新提交；这样做是为了传播知识。在审查过程中，你不应该做任何实质性的编辑（除非有特殊情况）。

提问，而不是直接告诉。解释为什么代码需要修改。提供改进代码的建议。区分事实和意见。

## 回应审查和评论

变更并不总是会在第一次尝试时被接受。你可以并且会收到来自维护者、代码审查员和其他开发人员的改进建议（以及其他评论）。你甚至可能会收到补丁形式或修复提交形式的评论。

首先，可以考虑在回应中表达对评论者花时间进行审查的感激。如果审查中的任何内容不清楚，可以请求澄清；如果你和审查者之间存在理解上的差距，提供澄清。

下一步通常是打磨和完善变更。然后，你应该重新提交它们（也许标记为**v2**）。你应该针对每次提交和整个系列的审查作出回应。

如果你在回应 pull request 中的评论，按照相同的方式回复。如果是通过电子邮件提交补丁，你可以将新版本的评论（包括对审查的回应或与上次尝试的不同之处）放在三条破折号 `diffstat` 中间，或者放在电子邮件顶部，用“剪刀”线将其与提交信息分开，例如，使用 `git` `format-patch --notes`。

根据项目的治理结构，你可能需要等待更改被认为是合适的并准备好合并。这可能是开源项目中由终身仁慈的独裁者做出的决定，或者是团队领导、委员会或共识的决定。在提交功能的最终版本时，总结讨论结果被视为一种良好的做法。

请注意，已经接受的更改仍可能会经过几个阶段，才最终进入稳定分支并出现在项目中。

# 其他建议

在本节中，你将找到那些不完全符合前面描述的项目启动、项目工作和集成更改领域的最佳实践和建议。

## 不要慌张，恢复几乎总是可能的。

只要你已经提交了工作并将更改存储在版本库中，它们就不会丢失。它们可能会被误放置。Git 也会尽力保存你当前未提交（未保存）的工作，但它无法区分例如通过 `git reset --hard` 意外或故意删除所有工作目录中的更改。因此，在尝试恢复丢失的提交之前，确保先提交或暂存当前的工作。

多亏了 reflog（无论是特定分支还是 `HEAD` 引用），大多数操作都很容易撤销。然后是暂存更改的列表（见 *第三章*，*管理你的工作树*），你的更改可能隐藏在其中。还有 `git fsck`，作为最后的手段。有关数据恢复的更多信息，请参见 *第十四章*，*Git 管理*。

如果问题是你弄乱了工作目录，停下来思考一下。不要无谓地丢弃你的更改。在交互式添加、交互式重置（`--patch` 选项）和交互式检出（相同的方式）帮助下，你通常可以解开这个困局。

运行 `git status` 并仔细阅读其输出，有助于你在执行某些鲜为人知的 `git` 操作后卡住时找到解决方法。

如果你遇到了 rebase 或 merge 问题，且无法将责任推给其他开发者，总有第三方 `git-imerge` 工具可以帮助你。

## 不要更改已发布的历史

一旦你将修改公开，理想情况下应认为这些修订是不可更改、不可改变的。如果你发现提交存在问题，应创建修复（可能通过使用`git revert`撤销修改的效果）。这一切都在*第十章*，*保持历史清洁*中描述：也就是说，除非在开发文档中明确说明这些特定的分支可以被重写或重做，否则最好避免创建此类分支。

在一些少见的情况下，你可能确实需要更改历史记录：例如删除文件、清理未加密的存储密码、删除意外添加的大文件等。如果你需要这么做，请通知所有开发人员这一事实。

## 发布版本的编号和标签

在发布新版本之前，请使用签名标签标记将要发布的版本。这可以确保刚创建的修订版的完整性。

命名发布标签和使用发布编号有各种约定。常见的一种约定是通过使用例如`1.0.2`或`v1.0.2`作为标签名称来标记发布版本。

提示

如果项目的完整性很重要，考虑使用签名合并进行集成（即合并已签名的标签）。详见*第六章*，*使用 Git 进行协作开发*，签名推送的内容请见*第十四章*，*Git 管理*。

命名发布版本有不同的约定。例如，时间驱动的发布版本通常使用日期命名，如`2015.04`（或`15.04`）。然后，有一种常见的`MAJOR.MINOR.PATCH`编号约定，其中`PATCH`在进行向后兼容的错误修复时增加，`MINOR`在添加向后兼容的功能时增加，而`MAJOR`版本在进行不兼容的 API 更改时增加。即使不使用完整的语义版本控制，通常也会为维护版本添加第三个数字，例如`v1.0`和`v1.0.3`。

## 尽可能实现自动化

你不仅应该在开发文档中写下编码标准，还需要强制执行这些标准。通过客户端钩子（*第十三章*，*定制和扩展 Git*）可以方便地遵循这些标准，而通过服务器端钩子（*第十四章*，*Git 管理*）可以强制执行。

钩子还可以通过自动管理问题跟踪器中的工单，并根据提交消息中的触发模式（模式）选择操作。钩子还可用于防止重写历史记录。

考虑使用第三方解决方案，如 Gitolite 或 GitLab，来强制执行访问控制规则。如果你需要进行代码审查，使用适当的工具，如 Gerrit 或 GitHub、Bitbucket 或 GitLab 的拉取请求。

# 总结

这些建议基于使用 Git 作为版本控制系统的最佳实践，能够真正帮助你的开发工作和团队。你已经学会了沿着这条道路的步骤，从一个想法开始，一直到最后的更改被集成到项目中。这些清单应该帮助你开发更好的代码。

# 深入阅读

要了解更多本章所涵盖的主题，请查看以下资源：

+   Emma Jane Hogbin Westby: *Git for Teams* (2015)，O'Reilly Media

+   *学习 Git* *分支管理* [`learngitbranching.js.org/`](https://learngitbranching.js.org/)

+   *Conventional Commits：为提交* *信息* 添加人类和机器可读意义的规范 [`www.conventionalcommits.org/`](https://www.conventionalcommits.org/)

+   *Commitizen - 旨在为* *团队* 设计的发布管理工具 [`commitizen-tools.github.io/commitizen/`](https://commitizen-tools.github.io/commitizen/)

+   Sage Sharp: *补丁审查的温和艺术* (2014) [`sage.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/`](https://sage.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/)

+   *该死的，* *Git!?!* [`dangitgit.com/en`](https://dangitgit.com/en)

+   Julia Evans: *天哪，git!* 小册子 [`wizardzines.com/zines/oh-shit-git/`](https://wizardzines.com/zines/oh-shit-git/)

+   *语义化版本控制* *2.0.0* [`semver.org/`](https://semver.org/)
