

# 第十三章：自定义和扩展 Git

前面的章节旨在帮助你理解 Git 的工作原理，并掌握 Git 作为版本控制系统的使用。接下来的两章将帮助你设置和配置 Git，使你能够更加高效地使用它（本章）以及帮助其他开发人员使用它（下一章）。

本章将介绍如何配置和扩展 Git 以满足个人需求。首先，它将展示如何设置 Git 命令行以使其更易于使用。对于某些任务，使用视觉工具会更容易；本章对图形界面的简要介绍将帮助你做出选择。接下来，将解释如何通过配置文件（并描述所选配置选项）到每个文件的配置（使用 `.gitattributes` 文件）来更改和配置 Git 的行为。

接下来，本章将介绍如何使用钩子自动化 Git，例如如何让 Git 检查正在创建的提交是否符合项目的编码规范。本部分将重点讨论客户端钩子，并仅简要涉及服务器端钩子——这些内容会留给 *第十四章*，*Git 管理*。本章的最后部分将描述如何扩展 Git，从 Git 命令别名，到集成新的用户可见命令，再到助手和驱动程序（新的后台功能）。

许多问题，如 gitattributes、远程和凭证助手以及 Git 配置的基础知识，应该已经在前面的章节中了解。本章将把这些信息集中到一个地方，并稍作扩展。

本章将涵盖以下主题：

+   设置 shell 提示符和命令行的 Tab 补全功能

+   图形用户界面的类型和示例

+   配置文件和基本配置选项

+   安装和使用各种类型的钩子

+   简单和复杂的别名

+   扩展 Git 以增加新命令和助手

# 命令行中的 Git

使用 Git 版本控制系统的方式有很多种。存在许多不同用途和功能的 **图形用户界面**（**GUIs**），并且还存在允许与 **集成开发环境**（**IDE**）或文件管理器集成的工具和插件。

然而，命令行是你可以运行所有 Git 命令并支持其所有选项的唯一地方。你可能希望使用的新功能，通常首先会为命令行开发。此外，大多数图形用户界面（GUI）仅实现了 Git 功能的一部分。精通命令行总能保证对工具、机制及其功能的深入理解。仅仅知道如何使用图形界面可能不足以获得扎实的知识。

无论你是出于选择、偏好环境，还是因为这是唯一能访问所需功能的方式在命令行中使用 Git，Git 可以利用一些 shell 特性，使你的体验更加友好。

## Git 感知命令提示符

自定义 **shell 提示符** 显示我们所在 Git 仓库的状态信息是很有用的。

定义

**shell 提示符** 是写入终端或控制台输出的简短文本消息，用于通知用户交互式 shell 正在等待输入（通常是 shell 命令）。

这些信息可以根据需要简单或复杂。Git 的提示符可以类似于普通的命令行提示符（以减少不和谐感），也可以显著不同（以便能轻松区分我们是否在 Git 仓库中）。

在 `contrib/` 目录下有 `bash` 和 `zsh` shell 的示例实现。如果你是从源代码安装 Git，只需将 `contrib/completion/git-prompt.sh` 文件复制到主目录；如果你通过包管理器在 Linux 上安装了 Git，那么该文件可能位于 `/etc/bash_completion.d/git-prompt.sh`。此文件提供了 `__git_ps1` shell 函数，用于在 Git 仓库中生成 Git 感知提示符，但你需要先在 `.bashrc` 或 `.zshrc` shell 配置文件中加载此文件：

```
if [ -f /etc/bash_completion.d/git-prompt.sh ]; then
    source /etc/bash_completion.d/git-prompt.sh
fi
```

shell 提示符是通过环境变量配置的。要设置提示符，必须直接或间接地更改 `PS1`（提示字符串一，默认交互提示符）环境变量。因此，创建一个 Git 感知命令提示符的一个解决方案是通过命令替换，将对 `PS1` 环境变量进行调用，加入 `__git_ps1` shell 函数：

```
export PS1='\u@\h:\w$( git_ps1 " (%s)")\$ '
```

注意，对于 `zsh`，你还需要使用 `setopt` `PROMPT_SUBST` 命令打开命令替换功能。

另外，为了获得稍微更快的提示符和支持颜色，你可以使用 `__git_ps1` 来设置 `PS1`。在 `bash` 中通过 `PROMPT_COMMAND` 环境变量完成，在 `zsh` 中则通过 `precmd()` 函数完成。你可以在 `git-prompt.sh` 文件的注释中找到有关此选项的更多信息；对于 `bash`，可能如下所示：

```
PROMPT_COMMAND='__git_ps1 "\\u@\\h:\\w" "\\\$ "'
```

使用此配置（任一解决方案），提示符将如下所示：

```
bob@host.company.org:~/random/src (master)$
```

Git for Windows 中的 Git Bash 命令自带类似的配置（尽管 Git Bash 默认提示符占两行，而非一行）。

`bash` 和 `zsh` 的 shell 提示符可以通过特殊字符进行定制，shell 会扩展这些字符。在这里使用的示例中（你可以在 *Bash 参考手册* 中找到更多示例），我们有如下内容：

+   **\u** 表示当前用户（**bob**）

+   **\h** 表示当前主机名（**host.company.org**）

+   **\w** 表示当前工作目录（**~/random/src**）

+   **\$** 打印提示符中的 **$** 部分（如果以 root 用户身份登录，则为 **#**）

`$(...)` 在 `PS1` 设置中用于调用外部命令和 shell 函数。`__git_ps1 " (%s)"` 在这里调用由 `git-prompt.sh` 提供的 `git_ps1` shell 函数，并带有格式化参数：`%s` 标记是显示的 Git 状态的占位符。请注意，你需要在从命令行设置 `PS1` 变量时使用单引号，如示例所示，或者转义 shell 替换，以便在显示提示符时展开，而不是在定义变量时展开。

如果你使用 `__git_ps1` 函数，Git 还会显示有关当前正在进行的多步骤操作的信息：合并、变基、二分查找等。例如，在 `master` 分支上进行交互式变基（`-i`）时，提示符的相关部分将是 **master|REBASE-i**。如果在操作过程中被中断，将此信息直接显示在命令提示符中非常有用。

还可以在命令提示符中指示工作树、索引等的状态。我们可以通过导出这些环境变量的选定子集来启用这些功能（对于某些功能，你还可以使用提供的布尔值配置变量在每个仓库的基础上单独关闭它们）：

+   **GIT_PS1_SHOWDIRTYSTATE**（对于每个仓库的设置，可使用 **bash.showDirtyState**）显示“*****”表示未暂存更改，显示“**+**”表示已暂存更改，如果设置为非空值。

+   **GIT_PS1_SHOWSTASHSTATE** 如果有内容被暂存，则显示“**$**”。

+   **GIT_PS1_SHOWUNTRACKEDFILES** 和 **bash.showUntrackedFiles** 如果工作目录中存在未跟踪的文件，则显示“**%**”。

+   **GIT_PS1_SHOWUPSTREAM** 和 **bash.showUpstream** 可用于配置上游仓库的 ahead-behind 状态，值为 **auto** 的空格分隔列表将使提示符显示你是否落后于上游“**<**”、已同步“**=**”或领先于上游“**>**”，**name** 显示上游名称，**verbose** 显示你领先/落后的提交数量（带符号；例如，“+1”表示领先 1 次提交）。**git** 比较 HEAD 和 **@{upstream}**，**svn** 比较 SVN 上游。

+   **GIT_PS1_DESCRIBE_STYLE** 可设置为配置如何显示脱离的 HEAD 情况；它可以设置为以下值之一：**contains** 使用更新的注释标签（v1.6.3.2~35），**branch** 使用更新的标签或分支（main~4），**describe** 使用旧的注释标签（v1.6.3.1-13-gdd42c2f），**tag** 使用任何标签，**default** 仅在标签完全匹配当前提交时显示标签。

+   **GIT_PS1_SHOWCONFLICTSTATE** 设置为“**yes**”将通知用户是否存在未解决的冲突，显示“|CONFLICT”。

+   **GIT_PS1_SHOWCOLORHINTS** 可用于配置当前脏状态的彩色提示，即是否存在未提交的更改（类似于 **git status -****sb** 的效果）。

+   **GIT_PS1_HIDE_IF_PWD_IGNORED** 或 **bash.hideIfPwdIgnored** 用于在当前目录被 Git 忽略时，不显示 Git 友好的提示，即使我们处于一个仓库内。

如果你使用的是`zsh` shell，可以查看`zsh-git`脚本集、`zshkit`配置脚本，或可用于`zsh`的`oh-my-zsh`框架，而不是使用`bash`——首先完成来自 Git contrib/ 的提示设置。或者，你也可以使用`zsh`内建的`vcs_info`子系统。

对于`bash`（通常适用于多个不同的 shell），也有一些替代的提示解决方案，例如`git-radar`或`powerline-shell`。

提示

当然，你也可以生成自己的 Git 友好的提示。例如，你可能希望利用**git** **rev-parse** 命令，将当前目录分为仓库路径部分和项目子目录路径部分。

## Git 的命令行补全

另一个让 Git 命令行更易于使用的 shell 特性是可编程的**命令行补全**。此功能可以显著加快 Git 命令的输入速度。命令行补全允许你输入命令或文件名的前几个字符，然后按补全键（通常是*Tab*）来填充剩余部分。启用了 Git 友好的补全后，你还可以填充子命令、命令行参数、远程仓库、分支和标签（引用名称），并且只有在适当的位置才会自动补全（例如，只有在命令期望远程仓库名称的情况下，远程仓库名称才会被补全）。

Git 自带（但并非总是安装）对`bash`和`zsh` shell 的 Git 命令自动补全支持。

对于`bash`，如果没有随 Git 一起安装补全功能（默认情况下在 Linux 中位于`/etc/bash_completion.d/git.sh`），你需要从 Git 源代码中获取`contrib/completion/git-completion.bash`文件的副本。将其复制到一个可访问的位置，例如主目录，并从`.bashrc`或`.bash_profile`中引用它：

```
. ~/git-completion.bash
```

启用 Git 补全后，测试方法是输入一个 Git 命令，然后按*Tab*键。例如，你可以输入`git check`，然后按*Tab*：

```
$ git check<TAB>
```

启用 Git 补全后，`bash`（或`zsh`）shell 会自动补全你输入的部分，直到`git checkout`。

类似地，在模糊情况下，按两次*Tab*键会显示所有可能的补全项（尽管并非所有 shell 都支持此功能；有些 shell 会循环显示不同的补全项）：

```
$ git che<TAB><TAB>
checkout      cherry        cherry-pick
```

补全功能也适用于选项；如果你不记得确切的选项而只记得前缀，这非常有用：

```
$ git config --<TAB><TAB>
--add              --get-regexp       --remove-section   --unset
[…]
```

重要提示

一些 shell 使用（或可以配置为使用）旋转补全功能，而不是显示可能的补全项列表。当有多个可能的补全项时，每按一次*Tab*键会显示一个不同的补全项，循环显示相同前缀的不同补全项。

请注意，命令行补全（也叫 **Tab 补全**）通常仅在交互模式下工作，并且基于明确的前缀，而不是明确的缩写。

## Git 命令的自动更正

一个与 Git 内置工具无关但类似于 Tab 补全的功能是 **自动更正**。默认情况下，如果你输入了看起来像是拼写错误的命令，Git 会尝试帮助你猜测你的意图。即使只有一个候选命令，Git 也不会执行该操作：

```
$ git chekout
git: 'chekout' is not a git command. See 'git --help'.
The most similar command is
        checkout
```

然而，当 `help.autoCorrect` 配置变量设置为正数时，Git 会在等待指定的百分之一秒（0.1 秒）后自动更正并执行拼写错误的命令。你可以使用负值来立即执行，或者使用零来恢复默认行为：

```
$ git chekout
WARNING: You called a Git command named 'chekout', which does not exist.
Continuing in 0.1 seconds, assuming that you meant 'checkout'.
Your branch is up-to-date with 'origin/master'.
```

如果输入的文本可以推导出多个命令，则不会执行任何操作。此机制仅适用于 Git 命令；你不能自动更正子命令、参数和选项（与 Tab 补全不同）。

## 让命令行更美观

Git 完全支持彩色终端输出，这大大有助于视觉上解析命令输出。许多选项可以帮助你根据个人喜好设置颜色。

首先，你可以指定何时使用颜色，比如某些命令的输出。`color.ui` 是一个主开关，用来控制输出的着色，将 Git 的所有彩色终端输出关闭并设置为 `false`。该配置变量的默认设置是 `auto`，这意味着 Git 会在输出直接到终端时着色，但在输出被重定向到文件或管道时会省略颜色控制代码。

你也可以将 `color.ui` 设置为 `always`，尽管你很少会需要这样做：如果你希望在重定向的输出中看到颜色代码，只需将 `--color` 标志传递给 Git 命令；相反，`--no-color` 选项将关闭彩色输出。

如果你想更具体地控制哪些命令以及输出的哪些部分使用颜色，Git 提供了相应的颜色设置：`color.branch`、`color.diff`、`color.interactive`、`color.status` 等。就像 `color.ui` 主开关一样，每个设置都可以设置为 `true`、`false`、`auto` 或 `always`。

此外，这些设置中的每一项都有子设置，可以用来为输出的特定部分设置特定的颜色。例如，`color.diff.meta`（用于配置差异输出中文本的元信息颜色）这样的配置变量的颜色值由前景色、背景色（如果设置）和文本属性的空格分隔的名称组成。

你可以将颜色设置为以下任意值：`normal`、`black`、`red`、`green`、`yellow`、`blue`、`magenta`、`cyan` 或 `white`。至于属性，你可以选择 `bold`、`dim`、`ul`（下划线）、`blink` 和 `reverse`（将前景色与背景色互换）。

`git log` 的漂亮格式也包括设置颜色的选项；有关更多信息，请参阅 `git log` 文档。

外部工具

也有可以与 Git 一起使用的差异语法高亮工具。它们可以通过 **core.pager** 配置变量作为分页器进行设置，或通过别名进行配置。示例包括 **delta** ([`dandavison.github.io/delta`](https://dandavison.github.io/delta)) 和来自 Git 源代码贡献区的 **diff-highlight**。

## 替代命令行

要理解 Git 用户界面的一些粗糙之处，你需要记住 Git 在很大程度上是自底向上开发的。从历史上看，Git 最初是作为一个编写版本控制系统的工具开发的（你可以通过 `git help` `core-tutorial` 命令查看早期 Git 的使用方式，这也是开发者核心教程的一部分）。

Git 的第一个替代“瓷器”（即替代用户界面）是 *Cogito*。如今，Cogito 已不复存在；它的所有功能早已被 Git 纳入（或被更好的解决方案替代）。曾经有人尝试编写包装脚本（替代用户界面），目的是让其更容易学习和使用，例如 `eg`）以及较新的 `jj`）是一个版本控制系统，处于开发的初期阶段，能够使用 Git 仓库存储项目历史，因此也可以看作是 Git 上的一层。

还有一些外部 Git “瓷器”，它们并不打算替代整个用户界面，而是提供对一些额外功能的访问，或将 Git 封装起来提供一些有限的功能集。`gq`)) 被创建的目的是为了方便重写、操作和清理未发布历史的选定部分；这些被提及作为一种替代交互式变基的方式，在*第十章*，“保持历史清洁”中有提到。接下来，是单文件版本控制系统，例如 **Zit**，它将 Git 用作后端。

替代实现

除了替代用户界面外，还有不同的 Git 实现（定义为读取和写入 Git 仓库）。它们在完成度上处于不同的阶段。除了核心的 C 实现外，还有 Java 中的 **JGit**，以及 **libgit2** 项目——它是现代 Git 绑定各种编程语言的基础。

# 图形界面

你已经学会了如何在命令行中使用 Git。上一节告诉你如何定制和配置 Git，使其更高效。但是，终端并不是终点。你还可以使用其他环境来管理 Git 仓库。有时，视觉表示正是你所需要的。

现在，我们将简要看一下各种以用户为中心的 Git 图形工具；Git 管理工具的介绍将在下一章*第十四章*，“Git 管理”中介绍。

## 图形工具的类型

不同的工具和接口针对不同的工作流程进行了定制。一些工具只暴露 Git 功能的一个子集，或者鼓励采用特定的版本控制工作方式。

为了在选择 Git 的图形化工具时做出明智的决策，你需要了解不同类型工具支持哪些操作。请注意，某一个工具可能支持多种类型的使用。

首先，有`git log`。这是用于查找过去发生的事情，或者浏览和可视化项目历史和分支布局的工具。这些工具通常接受修订选择命令行选项，如`--all`。命令行 Git 提供了`git log --graph`，以及较少使用的`git show-branch`，通过 ASCII 艺术来显示历史。

一个类似的工具是`git log -L`）和所谓的镐式搜索（`git log -S`），它们没有很多图形用户界面（GUI）。

接下来，有`git add`、`git reset`等命令，甚至允许你逐个块地暂存和撤销更改。交互式添加的图形化版本在*第三章*，*管理你的工作树*中有所描述，并在*第二章*，*使用 Git 进行开发*中提到。还有一些工具可以根据指定的标准来编写提交信息。

然后，我们有**文件管理器集成**（或**图形化外壳集成**）。这些插件通常通过图标叠加显示文件在 Git 中的状态（已跟踪/未跟踪/忽略）。它们可以为仓库、目录和文件提供右键菜单，通常附带键盘快捷键。它们还可能支持拖放功能。

程序员编辑器和 IDE 通常提供对**IDE 集成**的支持（或者一般的版本控制）。这些工具提供仓库管理（作为团队项目管理的一部分），使得可以直接从 IDE 执行 Git 操作，显示当前文件和仓库的状态，甚至可能在文件视图中标注版本控制信息。它们通常包括提交工具、远程管理、历史查看器和差异查看器。

Git 仓库托管网站通常提供面向工作流的**桌面客户端**。这些客户端主要集中于一组精选的常用功能，这些功能能够很好地协同工作，自动化常见的 Git 任务。它们通常旨在突出其服务，提供额外的功能和集成，但它们也可以与任何托管在任何地方的仓库一起使用。

甚至还有`sequence.editor`配置变量，或者可以设置为默认 Git 分页器的语法高亮工具。

## 图形化的差异比较和合并工具

图形化差异工具和图形化合并工具在某些情况下是特殊的。在这些类别中，Git 包含了与第三方图形工具集成的命令，即`git difftool`和`git mergetool`。这些工具随后从 Git 仓库中调用。请注意，这与外部差异或差异合并驱动程序不同，后者会替代普通的`git diff`或对其进行增强。

尽管 Git 有内部的差异实现和解决合并冲突的机制（见*第九章*，*合并* *更改*），但您仍然可以使用外部图形化差异工具。这些工具通常用于更好地显示差异（通常是并排显示差异，可能带有一些细化），并帮助解决合并（通常使用三窗格界面）。

配置图形化差异或图形化合并工具需要配置一些自定义设置。为了分别指定用于差异和合并的工具，您可以分别设置`diff.tool`和`merge.tool`。如果没有设置，例如，`merge.tool`配置变量，`git mergetool`命令将打印如何配置的相关信息，并尝试运行预定义的工具之一：

```
$ git mergetool
This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
tortoisemerge emerge vimdiff
No files need merging
```

运行`git mergetool --tool-help`将显示所有可用的工具，包括那些未安装的工具。如果您使用的工具不在`$PATH`中，或者该工具的版本错误，您可以使用`mergetool.<tool>.path`设置或覆盖给定工具的路径：

```
$ git mergetool --tool-help
'git mergetool --tool=<tool>' may be set to one of the following:
           vimdiff          Use Vim with a custom layout
[…]
The following tools are valid, but not currently available:
           araxis           Use Araxis Merge
[…]
Some of the tools listed above only work in a windowed
environment. If run in a terminal-only session, they will fail.
```

如果您的工具没有内置支持，您仍然可以使用它；您只需要进行配置。`mergetool.<tool>.cmd`配置变量指定如何运行命令，而`mergetool.<tool>.trustExitCode`告诉 Git 该程序的退出代码是否表示合并解决成功。相关的配置文件片段（对于名为`extMerge`的图形化合并工具）可能如下所示：

```
[merge]
    tool = extMerge
[mergetool "extMerge"]
    cmd = extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"
```

有一些配置选项控制`git mergetool`的行为，可以是全局的，也可以是每个工具单独设置的。其中一个选项是`mergetool.hideResolved`（以及每个工具的`mergetool.<tool>.hideResolved`变体），它使 Git 尽可能自行解决冲突，并仅将未解决的冲突呈现给合并工具。请注意，一些合并工具会自行执行此操作。

一些合并工具，如 vimdiff，是文本界面工具，可以在无需图形会话的情况下工作。如果您想在文本模式下运行一个工具（例如，当通过普通 SSH 访问远程主机时），而在图形模式下运行另一个工具，您可以通过在一个工具中配置`mergetool.tool`，在另一个工具中配置`mergetool.guitool`来实现——并使用`git mergetool --gui`调用图形界面工具。

## 图形界面示例

在本节中，您将看到一些围绕 Git 的工具，您可以使用它们，或者它们可能会激发您进一步研究的兴趣。帮助您开始研究的一种不错方式是列出一些选定的 GUI 客户端。

Git 有两个可视化工具，通常与 Git 一起安装，分别是 `gitk` 和 `git gui`，还有一个 `git gui blame`，一个视觉化的 `git gui` 打开 `gitk`。

可视化工具不一定需要使用图形环境。比如**tig**（即 *Text Interface for Git*）使用基于文本模式的界面（TUI），作为仓库浏览器和提交工具，还可以充当 Git 分页器。

另一个 TUI 示例是**git interactive-rebase-tool**，它可以作为交互式序列编辑器，用于交互式 rebase 指令表。

有一个用 Python 开发的**git cola**，它适用于所有操作系统，包含提交工具和远程管理工具，还提供一个 diff 查看器。然后是一个简单且多彩的**Gitg**工具，适用于 GNOME；你将获得一个图形化的历史查看器、diff 查看器和文件浏览器。

一个较受欢迎的 macOS 开源 GUI 工具是**GitX**。这个工具有很多分支，其中一个比较有趣的分支是**Gitbox**。它提供历史查看器和提交工具。

对于 MS Windows，有**TortoiseGit**和**git-cheetah**，这两款工具都提供与 Windows 上下文菜单的集成，因此你可以在 Windows 资源管理器内执行 Git 命令（文件管理器集成和 Shell 接口）。

GitHub 公司和 Atlassian 都发布了一个桌面 GUI 工具，分别可以轻松与 GitHub 或 Bitbucket 仓库配合使用，但这两个工具不仅限于与单一服务（GitHub 或 Bitbucket）交互。**GitHub Client** 和 **SourceTree** 都具有仓库管理功能，并提供一系列其他常见功能来增强你的开发工作流程。

许多编程编辑器和 IDE 都支持管理 Git 仓库，有时也支持与 Git 托管站点交互。这些功能可以是内置的，或者作为 IDE 插件或扩展提供。例如，**GitLens**（适用于 Visual Studio Code）、**Magit**（适用于 GNU Emacs）和 **Fugitive**（适用于 ViM）。这些工具通常会显示诸如哪些行被添加或更改，或者谁编写了这些行等信息，直接在编辑器窗格中展示。

# 配置 Git

到目前为止，在描述 Git 的工作原理以及如何使用它时，我们已经介绍了多种改变其行为的方法。在本节中，将系统地解释如何临时和永久地配置 Git 操作。我们还将看到如何通过引入和重新引入几个重要的配置设置，使 Git 按照自定义的方式运行。通过这些工具，轻松让 Git 按照你想要的方式工作。

## 命令行选项和环境变量

Git 按照层级结构处理更改其行为的选项，从最不具体到最具体，最具体的选项（且持续时间最短）具有优先权。

最具体的，覆盖其他所有方式的是命令行选项。显然，它们只影响当前的 Git 命令。

重要提示

需要注意的一个问题是，一些命令行选项，例如 **--no-pager** 或 **--no-replace-objects**，是传递给 **git** 外壳程序，而不是 Git 命令本身。例如，查看以下行可以看到这种区别：

**$ git --no-replace-objects log -5 --oneline --****graph --decorate**

你可以在 Git 命令行接口的手册页中找到使用的约定。

改变 Git 命令工作方式的第二种方法是使用环境变量。它们特定于当前的 shell，如果使用替代变量，则需要使用 `export` 内建命令（或其等价物）将变量传播到子进程。有些环境变量适用于所有核心 Git 命令，而有些则仅适用于某个特定的（子）命令。

Git 还使用一些非特定的环境变量。这些变量作为最后的手段使用；它们会被对应的 Git 特定变量覆盖。例如，包括 `PAGER` 和 `EDITOR` 这样的变量。

## Git 配置文件

定制 Git 工作方式的最终方法是通过配置文件。在许多情况下，配置操作的命令行选项、环境变量和配置变量按优先级降序排列。

Git 使用一系列配置文件来确定你可能想要的非默认行为。Git 会按照从最不具体到最具体的顺序读取这些文件，配置设置越靠后越会覆盖早期的设置。你可以使用 `git config` 命令访问这些 Git 配置文件：默认情况下，它会操作所有文件的合并，但你可以通过命令行选项指定要访问的具体文件。你还可以按照配置文件语法访问任何给定的文件（例如 *第十一章* 中提到的 `.gitmodules` 文件，*管理子项目*），方法是使用 `--file=<pathname>` 选项（或 `GIT_CONFIG` 环境变量）。

提示

你也可以从任何具有配置类内容的 blob 中读取值；例如，你可以使用 **git config --blob=master:.gitmodules** 来读取 **master** 分支中的 **.gitmodules** 文件。

Git 查找配置文件的第一个地方是 `/etc/gitconfig`。至少在 Linux 上是如此，`/etc` 目录用于存储主机特定的系统级配置文件；Git for Windows 会将此文件放在其 `Program Files` 文件夹的子目录中。此文件包含系统上每个用户及其所有仓库的配置值。要让 `git config` 专门从这个文件读取和写入（并用 `--edit` 打开它），需要将 `--system` 选项传递给 `git` 的 `config` 命令。

你可以通过设置 `GIT_CONFIG_NOSYSTEM` 环境变量来跳过从此文件读取设置。这可以用于设置可预测的环境或避免使用无法修复的有缺陷的配置。

Git 接下来查找的地方是 `~/.gitconfig`，如果存在，还会回退到 `~/.config/git/config`（默认配置）。此文件特定于每个用户，并影响该用户的所有仓库。如果你向 `git config` 传递 `--global` 选项，它将专门从此文件读取和写入。提示：在此处与其他位置一样，`~`（波浪号字符）表示当前用户的主目录（`$HOME`）。

最后，Git 会在 `.git/config` 中查找配置值。此处设置的值是特定于该本地单个仓库的。你可以通过传递 `--``local` 选项来使 Git 读取和写入此文件。

在现代 Git 中，如果 `extensions.worktreeConfig` 设置为 true（默认值为 false），还可以存在一个 `.git/config.worktree` 文件（参见 `git` `worktree` 命令）。

这些级别（系统级、全局级和本地级）会覆盖前一级的值，因此，例如，`.git/config` 中的值会覆盖 `~/.gitconfig` 中的值；不过，除非配置变量是多值的。

提示

你可以利用本地（每个仓库）配置覆盖全局（每个用户）配置的特点，将默认身份设置在每个用户文件中，并在必要时通过每个仓库的配置文件在仓库级别进行覆盖。

最后，你可以通过 `-c` 选项为单个命令设置配置变量，方法是在 `git` 外壳中使用该选项：

```
$ git -c foo.int=1k config --get --type=int foo.int
1024
```

请参阅以下章节，以获得对此结果的完整解释。

### Git 配置文件的语法

Git 的配置文件是纯文本文件，因此你也可以通过手动编辑选定的文件来自定义 Git 的行为。语法相当灵活和宽松；空格大多被忽略（与 `.gitattributes` 相反）。哈希符号 `#` 和分号 `;` 用于开始注释，注释内容持续到行尾。空白行会被忽略。

该文件由节和变量组成，语法类似于 INI 文件的语法。节名和变量名均不区分大小写。节以方括号中的节名称 **[section]** 开始，并持续到下一个节为止。每个变量必须属于某个节，这意味着在设置变量之前必须有节头。节可以重复，也可以为空。

节可以进一步划分为子节。子节名称区分大小写，并且可以包含除换行符以外的任何字符（双引号 `"` 和反斜杠 `\` 必须分别转义为 `\"` 和 `\\`）。子节的开始如下所示：

```
[section "subsection"]
```

所有其他行（以及节标题后的行其余部分）都被识别为 `name = value` 形式的设置变量。作为一种特例，只有 `name` 是 `name = true`（布尔变量）的简写。这类行可以通过在行尾加上 `\`（反斜杠字符）来续接到下一行，即通过转义行尾字符。前导和尾随的空格会被丢弃；值中的内部空格会原样保留。你可以使用双引号来保留值中的前导或尾随空格。

### 包含与有条件包含

你可以通过设置特殊变量 `include.path` 来包含另一个配置文件，路径指定要包含的文件位置。被包含的文件会立即展开，类似于 C 和 C++ 中的 `#include` 机制。该路径是相对于包含指令所在配置文件的路径。你可以通过 `--no-includes` 选项来关闭此功能。

你也可以通过设置 `includeIf.<condition>.path` 变量来有条件地包含另一个配置文件。条件以一个关键字开始，后跟冒号 `:`，并包含与特定条件相关的数据。

支持的关键字如下：

+   **gitdir**，其后跟随的关键词数据作为全局模式来匹配 **.git** 目录的位置（即仓库本身的目录）。为了方便起见，模式开头的 **~** 和 **~/** 会被替换为主目录的位置，而 **./** 则被替换为包含当前配置文件的目录。还有 **gitdir/i** 变体，它以不区分大小写的方式进行匹配。

+   **onbranch**，可以用于将当前已检出的分支与全局模式进行匹配。

+   **hasconfig:remote.*.url**，该命令检查配置中是否存在至少一个符合全局模式的远程 URL。

例如，若要为主目录中的 `work-repos/` 子目录中的仓库使用不同的配置，你可以使用以下命令：

```
[includeIf "gitdir:~/work-repos/"]
    path = ~/work.inc
```

### 访问 Git 配置

你可以使用 `git config` 命令访问 Git 配置，从列出标准形式的配置条目、检查单个变量，到编辑和添加条目。

你可以使用 `git config --list` 查询现有配置，并根据需要添加适当的参数以限制为单一配置层级。在默认安装的 Linux 系统中，在刚执行 `git init` 后的空 Git 仓库中，本地（每个仓库的）配置大致如下：

```
$ git config --list --local
core.repositoryformatversion=0
core.filemode=false
core.bare=false
core.logallrefupdates=true
```

你也可以使用 `git var -l` 来列出所有影响 Git 的配置和环境变量。

你还可以使用`git config`查询单个键，限制（或不限制）范围到指定的文件，只需将配置变量的名称作为参数（可选地加上`--get`），并且使用点号分隔部分、可选子部分和变量名（键）：

```
$ git config user.email
```

这将返回最后一个值，即具有最高优先级的那个。你可以使用`--get-all`获取所有值，或者使用`--get-regexp=<match>`获取特定的键。这在访问像`refspecs`这样的多值选项时非常有用，尤其是对于远程访问。

配置变量类型及类型说明符

在请求（或写入）配置变量时，你可以通过**--type=<type>**选项提供一个*类型说明符*。类型可以是**bool**，确保返回的值是**true**或**false**；**int**，扩展**k**（1,024 个元素）、**m**（1024k）或**g**（1024m）的可选值后缀；**path**，扩展**~**为**$HOME**的值；**~user**表示给定用户的主目录；以及**expiry-date**，将固定或相对日期字符串转换为时间戳。

还有**bool-or-int**类型，以及与存储颜色和获取颜色转义码相关的一些选项；请参阅**git config**文档。

使用`--get`、`--get-all`和`--get-regexp`时，你还可以将列表（以及多值变量的设置）限制为仅匹配`regexp`值的那些变量（`regexp`作为可选的最后一个参数传递）。例如，要查找所有影响给定主机代理设置的配置，你可以使用以下命令：

```
$ git config --get core.gitproxy 'for kernel\.org$'
```

你还可以使用`git config`命令来设置配置变量的值。如果没有指定其他内容，本地层（每个仓库文件）是默认的写入位置。例如，要设置用户的电子邮件地址，使其适用于大多数仓库，你可以运行以下命令：

```
$ git config --global user.name "Alice Developer"
```

对于多值配置选项（multivar），你可以使用`--add`选项向其添加多行。要更改一个多值配置变量的单个条目，你可以使用如下命令，其中第一个值表示要更改的值，第二个值表示新的值：

```
$ git config core.gitproxy '"ssh" for kernel.org' '"ssh" for kernel\.org$'
```

使用`git config --unset`删除配置条目也非常简单。

与前面示例中在命令行上设置所有配置值不同，你也可以直接通过编辑相关的配置文件来设置或更改它们。只需在你喜欢的编辑器中打开配置文件，或运行`git config --edit`命令。

在 Linux 上，执行`git init`后，新的本地仓库配置文件如下所示：

```
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
```

如果你想通过编辑配置文件来更改配置，最好先找出你要更改的配置变量的来源。

### 查找配置值的来源

在有三层（或四层）配置文件的情况下，可能很难找出给定的配置变量是在哪里设置的，是否在更具体的配置文件中被覆盖或添加过。然后，还需要额外考虑`include`和`includeIf`部分的复杂性。

这时，传递给`git config`命令的`--show-origin`和`--show-source`选项，结合`--list`或`--get/--get-all`选项，可以提供帮助。`git config --list`命令将列出所有在配置文件中设置的变量及其值。`--show-scope`选项会在所有查询的配置选项输出中增加该值的作用域（工作树、局部、全局、系统、命令），而`--show-source`则显示来源类型（文件、标准输入、命令行、blob）及其实际来源（配置文件路径或 blob ID，如果适用）。

调试每个文件的配置

你可以使用**git check-ignore**检查文件为什么被忽略，使用**git check-attr**找出文件所分配的属性以及它们来自哪里。

例如，假设用户身份是在每个用户的配置文件中定义的：`~/.gitconfig`

```
[user]
    name  = Joe Random
    email = joe@company.com
```

还假设使用`git config`命令在项目的顶级目录中创建了`work.inc`文件，并从每个仓库的配置文件中包含它：

```
$ git config --file=conf.inc foo.bar val
$ git config --local include.path ./conf.inc
```

在这种情况下，我们将获得以下查询结果，这里以简化的形式展示：

```
$ git config --show-scope --show-origin --list
global  file:/home/joe/.gitconfig  user.name=Joe Random
global  file:/home/joe/.gitconfig  user.email=joe@company.com
local   file:.git/config        core.repositoryformatversion=0
local   file:.git/config        core.filemode=false
[…]
local   file:.git/config        include.path=./../conf.inc
local   file:.git/./../conf.inc foo.bar=val
```

第一列显示作用域，第二列显示来源，第三列显示完全限定的配置变量及其值。

### 基本的客户端配置

你可以将 Git 识别的配置选项分为两类：客户端和服务器端。大多数选项是关于配置个人工作偏好的，它们属于客户端。服务器端配置将在*第十四章*中详细讲解，*Git 管理*；本节只介绍基本内容。

有许多支持的配置选项，但其中只有一小部分*需要*设置；其中大部分有合理的默认值，显式设置它们仅在某些边缘情况下才有用。可用的选项很多；你可以通过`git config --help`查看所有选项的列表。在这里，我们将只介绍最常见和最有用的选项。

需要真正设置的两个变量是**user.email**和**user.name**。这些配置变量定义了用户的身份（尽管在现代 Git 中，你可以为更改作者和提交者分别设置不同的身份，使用**author.name**和**committer.name**）。另外，如果你正在签名注解标签或提交（如在*第六章*中讨论的那样，*Git 协作开发*），你可能希望设置你的 GPG 签名密钥 ID。可以通过**user.signingKey**配置项来完成。

默认情况下，Git 会使用系统上设置的文本编辑器（通过`VISUAL`或`EDITOR`环境变量定义；`VISUAL`仅用于图形桌面环境）来创建和编辑提交和标签信息。它还会使用你设置的分页器（`PAGER`）来分页和浏览 Git 命令的输出。如果你想将默认编辑器更改为其他编辑器，可以使用`vi`编辑器，或者在`less`分页器上进行更改。

在 Git 中，分页器会自动调用。默认的`less`分页器不仅支持分页功能，还支持增量搜索和其他功能。

重要提示

在默认配置下（即**LESS**环境变量未设置时），Git 调用`less`时的行为与设置了**LESS=FRX**相同。这意味着，如果输出少于一页，它将跳过分页，传递 ANSI 颜色代码，并且退出时不会清屏。

创建提交信息也受到**commit.template**的影响。如果你设置了该配置变量，Git 将在提交时使用该文件作为默认信息。该模板通常不会随仓库一起分发。请注意，除非通过将**commit.status**设置为 false 来禁止，否则 Git 会将状态信息添加到提交信息模板中。

如果你有提交信息政策，这样的模板非常方便，因为它大大增加了遵循该政策的机会。它可以例如包括注释掉的提交信息填写说明。你可以通过适当的钩子进一步扩展此解决方案，检查提交信息是否符合政策（请参见本章后面的*提交过程钩子*部分）。

工作区中文件的状态会受到忽略模式和文件属性的影响（请参见*第三章*，*管理你的工作树*）。你可以将忽略模式放在项目的内置`.gitignore`文件中（通常，`.gitignore`文件用于指定哪些文件不需要跟踪，且该文件本身会被 Git 跟踪），或者将其放在`.git/info/excludes`文件中，用于本地和私有模式，以定义哪些文件不感兴趣。这些是项目特定的；有时，你可能希望编写一个全局（每用户）的`.gitignore`文件。你可以使用`~/.config/git/ignore`。还有一个对应的`.gitattributes`文件，默认位于`~/.config/git/attributes`。

小知识

实际上，它是**$XDG_CONFIG_HOME/git/ignore**；如果未设置**$XDG_CONFIG_HOME**环境变量或该变量为空，则使用**$HOME/.config/git/ignore**。

尽管 Git 有内置的 diff 实现，你可以借助**diff.external**配置项设置外部工具代替 Git 内部的 diff 工具。通常，你会想要创建一个包装脚本来调整 Git 传递给它的参数，并按外部 diff 工具要求的顺序传递必要的参数。默认情况下，Git 会向 diff 程序传递以下参数：

```
path old-file old-hex old-mode new-file new-hex new-mode
```

参见 *图形化 diff 和合并工具* 部分，了解 `git difftool` 和 `git mergetool` 的配置。

### 变基和合并设置，配置拉取

在执行 `git pull` 操作时，Git 需要知道你是倾向于使用 *merge* 操作将本地历史和远程获取的历史合并，还是使用 *rebase* 操作来合并历史。这就是为什么它要求你提供 `pull.rebase` 配置变量的值。你可以在*第九章*中找到更多关于合并和变基的内容，*合并* *更改*。

有几个配置设置可以用于配置 `git pull` 的行为。包括 `pull.rebase` 配置选项以及特定于分支的 `branch.<name>.rebase` 选项，当设置为 `true` 时，会告诉 Git 在拉取操作中执行变基（仅限 `<name>` 分支）。如果设置为 `false`，则 `git pull` 会执行合并操作。两者还可以设置为 `merges`，使用 `--rebase-merges` 选项执行变基，以便在变基过程中不将本地合并提交扁平化。

你可以通过 `branch.autoSetupRebase` 在创建特定类型的新分支时，自动为每个分支设置“拉取变基”配置。可以将其设置为 `never`、`local`（仅适用于本地跟踪的分支）、`remote`（仅适用于远程跟踪的分支）或 `always`（适用于本地和远程）。还有 `branch.autoSetupMerge` 用于设置分支跟踪另一个分支。

### 保留撤销信息 – 对象的过期

默认情况下，Git 会自动删除未引用的对象，并清理 `git gc` 命令。你可以在*第十章*中了解关于仓库面向对象结构的更多内容，*保持* *历史清晰*。

为了安全起见，Git 在删除未引用的对象时会使用两周的宽限期；这一设置可以通过 `gc.pruneExpire` 配置项进行更改：该设置通常是相对日期（例如，`1.month.ago`；你可以使用点作为单词分隔符）。要禁用宽限期（通常从命令行完成），可以使用 `now` 值。

分支提示历史记录默认会保留 90 天（如果设置了 `gc.reflogExpire`，则按其设置）以用于可达修订版本，而对不属于当前历史记录的 reflog 条目，则保留 30 天（或 `gc.reflogExpireUnreachable`）。这两个设置可以按每个引用进行配置，方法是提供要匹配的引用名称模式作为子部分名称，即 `gc.<pattern>.reflogExpire`，其他设置类似。这可以用来更改 `HEAD` 或 `refs/stash`（参见*第三章*，*管理你的* *工作区*）的过期设置，或者单独为远程跟踪分支 `refs/remotes/*` 设置。该设置为一个时间长度（例如，6 个月）；要完全关闭 reflog 过期，请使用 `never` 的值。你可以使用后者，例如，关闭 `stash` 条目的过期。

### 格式化和空白

代码格式化和空白问题是你在协作过程中可能遇到的一些令人头疼且微妙的问题，尤其是在跨平台开发时。补丁和合并很容易引入微妙且不必要的空白变化，因为编辑代码时可能悄悄引入这些变化（这些变化通常不可见），而且不同操作系统对行结尾有不同的定义：MS Windows、Linux 和 macOS。Git 提供了一些配置选项来帮助解决这些问题。

跨平台工作中一个重要的问题是 **行结尾** 的定义。这是因为 MS Windows 使用 **回车**（**CR**）字符和 **换行**（**LF**）字符的组合来表示文本文件中的新行，而 macOS 和 Linux 仅使用换行字符。许多 MS Windows 上的编辑器会悄悄地将现有的 LF 风格的行结尾替换为 CRLF，或者为新行使用 CRLF，这导致了微妙但恼人的问题。

Git 可以通过在将文件添加到索引时自动将行结尾转换为 LF 来处理此问题。如果你的编辑器使用 CRLF 行结尾，Git 在检出文件时也可以将行结尾转换为本地格式。影响此问题的有两个配置设置：`core.eol` 和 `core.autocrlf`。第一个设置 `core.eol`，设置在将文件检出到工作目录时使用的行结尾格式，对于已设置 `text` 属性的文件（请参见下面的*按文件配置的 gitattributes*部分，该部分总结并回顾了*第三章*中关于文件属性的信息，*管理* *你的* *工作区*）。

第二个较旧的设置，`core.autocrlf`，可以用于开启自动转换行尾为 CRLF 的功能。将其设置为`true`时，会在检出文件时将仓库中的 LF 行尾转换为 CRLF，在暂存文件时则反向操作；这是你在 Windows 机器上可能需要的设置。（这几乎与将`text`属性设置为`core.eol`为`crlf`相同。）你也可以通过将`core.autocrlf`设置为`input`，让 Git 在提交时将 CRLF 转换为 LF，但不会进行反向转换；如果你使用的是 Linux 或 Mac 系统，这种设置最为合适。要关闭此功能，并按当前设置记录仓库中的行尾，则将此配置值设置为`false`。

这处理了空白字符问题的一个方面——行尾变异性，以及引入该问题的一种途径——编辑文件。Git 还提供了一种检测并修复其他空白字符问题的方法。你可以配置它以查找一组常见的空白字符问题。可以使用`core.whitespace`配置选项来启用它们（对于那些默认禁用的选项），或将其关闭（对于那些默认启用的选项）。默认启用的三个选项如下：

+   **blank-at-eol**：此选项查找行尾的多余空格。

+   **blank-at-eof**：此选项查找文件末尾的空行。

+   **space-before-tab**：此选项查找行首（开始处）缩进部分的制表符前面紧跟的空格。

`core.whitespace`中的`trailing-space`值是一个简写，涵盖了`blank-at-eol`和`blank-at-eof`。

默认情况下禁用但可以启用的三个选项如下：

+   **indent-with-non-tab**：此选项将把使用空格字符（而不是等效的制表符）缩进的行视为错误（等效性由**tabwidth**选项控制）。此选项强制执行*使用 Tab 字符缩进*。

+   **tab-in-indent**：此选项会检查行的初始缩进部分是否存在制表符（此处使用**tabwidth**来修复此类空白错误）。此选项强制执行*使用* *空格字符*进行缩进。

+   **cr-at-eol**：此选项告诉 Git，行尾的回车符是可以的（允许在仓库中使用 CRLF 行尾）。

你可以通过将`core.whitespace`设置为用逗号分隔的值列表，来告诉 Git 启用或禁用这些选项。要禁用某个选项，只需在值前面加上`-`前缀。例如，如果你希望启用除了`cr-at-eol`和`tab-in-indent`以外的所有选项，并且同时将*Tab*空格值设置为`4`，你可以使用：

```
$ git config --local core.whitespace \
    trailing-space,space-before-tab,indent-with-non-tab,tabwidth=4
```

你也可以在每个文件的基础上使用`whitespace`属性来设置这些选项。例如，你可以用它来关闭对测试用例中空白字符问题的检查，处理空白字符问题，或确保 Python 2 代码使用空格缩进：

```
*.py whitespace=tab-in-indent
```

EditorConfig

存在一个名为 EditorConfig 的项目 ([`editorconfig.org/`](https://editorconfig.org/))，它包括一个用于定义编码风格的文件格式，其中包括行结束符的类型，以及一组文本编辑器插件，使编辑器遵循选定的风格。**.editorconfig** 文件应由 Git 进行跟踪。

当你运行 `git diff` 命令时，Git 会检测到这些问题，并通过 `color.diff.whitespace` 颜色通知你，以便你在创建新提交之前注意到它们并可能修复它们。在使用 `git apply` 应用补丁时，你可以要求 Git 通过 `git apply --whitespace=warn` 警告空格问题，或通过 `--whitespace=error` 报错，或者让 Git 尝试自动修复问题，使用 `--whitespace=fix`。同样的操作也适用于 `git rebase` 命令。

### 服务器端配置

Git 服务器端有一些可用的配置选项，这些选项将在*第十四章*《Git 管理》一节中详细介绍；在这里，你将找到一些更有趣的参数的简短总结。

你可以让 Git 服务器检查对象的一致性，即确保每个在推送过程中接收到的对象与其 SHA-1 标识符匹配，并且是有效对象，可以通过一个名为 `receive.fsckObjects` 的布尔配置变量来实现。默认情况下，该选项是关闭的，因为 `git fsck` 是一个相对昂贵的操作，可能会拖慢操作速度，特别是在进行大规模推送时（这在大型仓库中很常见）。这是对有缺陷或恶意客户端的检查。

如果你重写了已经推送到服务器的提交（如*第十章*《保持历史清晰》中所解释的那样，这是不好的做法），并尝试再次推送，你将被拒绝。然而，客户端可以通过向 `git push` 命令添加 `--force` 标志来强制更新远程分支。但是，可以通过将 `receive.denyNonFastForward` 设置为 `true` 来让服务器拒绝强制推送。

`receive.denyDeletes` 设置阻止了 `denyNonFastForward` 策略的一个解决方法，即删除并重新创建一个分支。此设置禁止删除分支和标签；你必须手动从服务器中删除引用。

所有这些功能也可以通过类似于服务器端接收的钩子来实现；这将在 *安装 Git 钩子* 部分讨论，并在*第十四章*《Git 管理》中有所涉及。

## 使用 gitattributes 进行逐文件配置

一些自定义设置也可以为路径指定（可能通过 glob），这样 Git 仅对某些文件或子目录应用这些设置。这些路径特定的设置被称为 gitattributes。

应用此类设置的优先顺序始于存储库本地（用户本地）路径设置，位于 `$GIT_DIR/info/attributes` 文件中。然后，会查阅`.gitattributes` 文件，从涉及路径所在目录开始，逐步向上查找父目录中的`.gitattributes` 文件，直至工作树的顶层（项目的根目录）。

最后，还会考虑全局用户属性文件（由 `core.attributesFile` 指定，如果未设置，则在 `~/.config/git/attributes` 中），以及系统范围内的文件（在默认安装中为 `/etc/gitattributes`）。

可用的 Git 属性在*第三章*，*管理您的工作树*中有详细描述。通过属性，您可以执行诸如为特定类型的文件（例如 `ChangeLog`）指定单独的合并策略，告知 Git 如何比较非文本文件，或在检出（在写入到工作区域，即文件系统时）和提交（在暂存内容和提交更改到仓库，即创建对象到仓库数据库时）时过滤内容。

### Git 属性文件的语法

`gitattributes` 文件是一个简单的文本文件，以每个路径为基础设置本地配置。空行和以井号（`#`）开头的行将被忽略；因此，以 `#` 开头的行用作注释，而空行可用作可读性的分隔符。要为路径指定一组属性，请将模式放在水平空格分隔的属性列表之前：

```
pattern    attribute1 attribute2
```

当路径匹配多个模式时，后面的行将覆盖前面的行，就像`.gitignore` 文件一样（您也可以认为 Git 属性文件从最不特定的系统范围文件读取到最特定的本地存储库文件）。

Git 使用反斜杠（`\`）作为模式的转义字符。因此，对于以井号开头的模式，需要在第一个井号前面加上反斜杠（写为 `\#`）。由于属性信息由空格分隔，模式末尾的空格将被忽略，内部空格将被视为模式的结尾，除非它们用反斜杠引用（即写为“**\** “）。

如果模式不包含斜杠（`/`），即目录分隔符，Git 将把该模式视为 shell 通配符模式，并检查相对于`.gitattributes` 文件所在位置的路径是否匹配。例如，`*.c` 模式将匹配任何从`.gitattributes` 文件所在位置开始的 C 文件。以斜杠开头的模式匹配路径的开头。例如，`/*.c` 匹配 `bisect.c`，但不匹配 `builtin/bisect--helper.c`，而 `*.c` 模式将匹配两者。

如果模式包含至少一个斜杠，Git 会将其视为适合 `fnmatch(3)` 函数调用的 shell 通配符，并使用 `FNM_PATHNAME` 标志。这意味着模式中的通配符不会匹配目录分隔符，即路径名中的斜杠（`/`）；匹配是从路径的开始处进行的。例如，`include/*.h` 模式匹配 `include/version.h`，但不匹配 `include/linux/asm.h` 或 `libxdiff/includes/xdiff.h`。Shell 通配符如下：

+   ***** 匹配任意字符串（包括空字符串）

+   **?** 匹配任何单个字符

+   **[…]** 表达式匹配字符类（在方括号内，星号和问号失去特殊意义）；注意，与正则表达式不同，字符类的补充/否定是用 **!** 而不是 **^** 来完成的。例如，要匹配任何非数字字符，可以使用 **[!0-9]** shell 模式，它等价于正则表达式中的 **[⁰-9]**。

模式中的两个连续星号（`**`）可能具有特殊含义，但仅在两个斜杠之间（`/**/`），或者在斜杠和模式的开始或结束之间。这种通配符匹配零个或多个路径组件。因此，前导 `**` 后跟斜杠（`**/`）表示在所有目录中进行匹配，而尾部的 `/**` 匹配指定目录内的所有文件或目录。

每个属性可以在给定路径上处于四种状态之一：

+   首先，它可以是 **设置**（该属性具有特殊值为 true）。通过仅在属性列表中列出属性的名称来指定，例如，**text**。

+   其次，它可以是 **取消设置**（该属性具有特殊值为 false）。通过列出属性名称并加上负号来指定，例如，**-text**。

+   其次，它可以 **设置为特定值**；通过列出属性名称后跟等号及其值来指定，例如，**text=auto**（请注意，与配置文件语法不同，等号两边不能有空格）。

+   如果没有模式匹配路径，并且没有任何规则指定路径是否具有属性，则该属性被称为 **未指定**（你可以通过 **!text** 强制将属性显式设置为未指定）。

如果你发现自己在多个不同模式中反复使用相同的属性集，你应该考虑定义一个宏属性。这可以在本地、全局或系统范围的属性文件中定义，但（在所有可能的仓库特定属性文件位置中），宏只能在顶级 `.gitignore` 文件中定义。宏使用 `[attr]<macro>` 代替文件模式来定义；属性列表定义了宏的扩展。例如，内建的 `binary` 宏属性定义如下：

```
[attr]binary -diff -merge -text
```

但是，命令行选项、环境变量、配置文件、gitattributes 和 gitignore 文件并非改变 Git 行为的唯一方式。还有钩子机制，可以在 Git 执行的特定点自动触发用户定义的操作。

# 使用钩子自动化 Git

通常生成的代码都有一定的前提条件，可以是自我诱导的，也可以是外部强制的。代码应始终能够编译并至少通过一组快速测试。在某些开发工作流程中，每个提交消息可能需要引用一个问题 ID（或匹配消息模板），或者包括一个数字签名的 **Signed-off-by** 行。在许多情况下，这些开发过程的一部分可以由 Git 自动化完成。

像许多编程工具一样，Git 包括一种方法来触发用户提供的代码中包含的自定义功能（自定义脚本），当某些重要预定义操作发生时，即当某些事件触发时。作为事件处理程序调用的这种功能称为 **钩子**。它允许我们采取额外的操作，并且至少对于某些钩子，还可以停止触发的功能。

Git 中的钩子可以分为客户端钩子和服务器端钩子。**客户端钩子**由本地操作（在客户端上）触发，如提交、应用补丁系列、变基和合并。另一方面，**服务器端钩子**在网络操作发生时在服务器上运行，例如接收推送的提交。

您还可以将钩子分为预钩子和后钩子。**预钩子**在操作完成之前调用，通常是在执行操作的下一步之前。如果它们以非零值退出，则会取消当前的 Git 操作。**后钩子**在操作完成后调用，可用于通知和日志记录；它们无法取消操作。

## 安装 Git 钩子

Git 中的钩子是可执行程序（通常是脚本），存储在 Git 仓库管理区域的 `hooks/` 子目录中，即非裸仓库的 `.git/hooks/`。您可以通过 `core.hooksPath` 配置变量更改 Git 搜索钩子的目录位置。

钩子程序的命名方式是根据触发它们的事件命名的。这意味着如果您希望一个事件触发多个脚本，您将需要自己实现多路复用。

当你使用 `git init` 初始化一个新的仓库时（在使用 `git clone` 创建另一个仓库的副本时也会执行此操作；`clone` 内部会调用 `init`），Git 会将一堆未激活的示例脚本填充到 `.git/hooks/` 目录中。许多这些脚本本身就非常有用，而且它们还记录了钩子的 API。所有的示例都是用 shell 或 Perl 脚本编写的，但任何正确命名的可执行文件都可以正常工作。如果你想使用捆绑的示例钩子脚本，你需要重命名它们，去掉 `.sample` 扩展名，并确保它们具有可执行权限。

## 仓库模板

有时你可能希望为所有的仓库使用相同的钩子集。你可以拥有一个全局（每个用户和系统范围内的）配置文件，一个全局属性文件和一个全局忽略列表。实际上，可以选择在创建仓库时填充钩子。默认的示例钩子会被复制到 `.git/hooks` 仓库，这些钩子是从 `/usr/share/git-core/templates` 填充的。

此外，可以将包含仓库创建模板的替代目录作为参数传递给 `--template` 命令行选项（用于 `git clone` 和 `git init`），作为 `GIT_TEMPLATE_DIR` 环境变量，或作为 `init.templateDir` 配置选项（可以在每个用户的配置文件中设置）。该目录必须遵循 `.git`（或 `$GIT_DIR`）的目录结构，这意味着钩子需要位于其中的 `hooks/` 子目录下。

需要注意的是，这种机制有一些限制。由于模板目录中的文件只会在初始化时复制到 Git 仓库，因此对模板目录的更新不会影响现有的仓库。尽管你可以重新运行 `git init` 来重新初始化现有仓库，但请记得保存对钩子所做的任何修改。

钩子管理工具

为一组开发人员维护钩子可能会很棘手。有很多工具和框架可以用于 Git 钩子的管理；例如 **Husky** 和 **pre-commit**。你可以在 [`githooks.com`](https://githooks.com) 网站上找到更多此类工具的示例。这些工具通常允许更轻松地跳过钩子、为所有钩子运行公共代码，或为特定钩子运行多个脚本。

## 客户端钩子

客户端钩子有很多种。它们可以分为提交工作流钩子（由创建新提交的不同阶段调用的一组钩子）、应用邮件工作流钩子以及其他所有未组织成多钩子工作流的部分。

重要提示

需要注意的是，钩子在你克隆仓库时*不会*被复制。这部分是出于安全原因，钩子是无人值守并且大多不可见地运行的。你需要手动复制（并重命名）钩子文件，但在创建或重新初始化仓库时，你可以控制哪些钩子会被安装（见前面的章节）。这意味着，你不能依赖客户端钩子来强制执行某些策略；如果你需要引入一些强制要求，必须在服务器端进行。

### 提交过程钩子

在提交更改时（默认情况下）会调用四个客户端钩子。它们如下所示。

#### pre-commit 钩子

`git commit --no-verify`。这个钩子没有参数。

这个钩子可以用于检查正确的代码风格、运行静态代码分析器（linter）检查问题代码结构、确保代码能够编译并通过所有测试（并且确保新代码被测试覆盖），或者检查某些新功能的适当文档。默认钩子检查空白错误（默认是尾部空白）使用 `git diff --check`（或者其内部实现），并可选地检查修改文件中的非 ASCII 文件名。例如，你可以创建一个钩子，在提交时确认工作区有未提交的修改（这些修改不会成为当前提交的一部分）；不过这是一个高级技巧。或者，你也可以让它检查新方法是否有文档和单元测试。

还有 `git merge`。默认情况下，当启用时，该钩子会运行 `pre-commit` 钩子。

#### prepare-commit-msg 钩子

`commit.template`（如果有的话），并在提交信息在编辑器中打开之前。它允许你在提交作者看到信息之前，编辑默认的提交信息或以编程方式创建一个模板。如果钩子以非零状态失败，提交将被中止。这个钩子以文件路径作为参数，该文件包含提交信息（稍后传递给编辑器），以及提交信息的来源信息（对于普通的 `git commit` 不存在此信息）：如果给定了 `-m` 或 `-F` 选项、给定了 `-t` 选项或设置了 `commit.template`、存在 `.git/MERGE_MSG` 文件、存在 `.git/SQUASH_MSG` 文件，或者给定了 `-c`、`-C` 或 `--amend` 选项。在最后一种情况下，钩子会获得额外的参数，即作为信息来源的提交的 SHA-1 哈希值。

这个钩子的目的是编辑或创建提交信息，并且该钩子不会被 `--no-verify` 选项抑制。当使用自动生成默认信息的提交时，这个钩子最为有用，例如模板化的提交信息、合并提交、压缩提交和修改提交。Git 提供的示例钩子会将合并提交信息中的 `Conflict:` 部分注释掉。

另一个示例是，这个钩子可以使用 `branch.<branch-name>.description` 给出的当前分支描述（如果存在）作为分支相关的动态提交模板的基础。或者，它可以检查我们是否在主题分支上，然后列出项目问题跟踪器中分配给你的所有问题，以便轻松地将适当的工件 ID 添加到提交信息中。

#### commit-msg 钩子

`.git/COMMIT_EDITMSG`。

如果这个脚本以非零状态退出，Git 会中止提交过程，因此你可以使用它来验证，例如，提交信息是否与项目状态匹配，或提交信息是否符合所需的模式。Git 提供的示例钩子可以检查、排序并删除重复的 `Signed-off-by:` 行（如果签名是来源链的一部分，这可能不是你想要的）。你也可以在这个钩子中检查问题编号的引用是否正确（并可能扩展它们，添加每个提到的问题的当前总结）。

Gerrit 代码审查提供了一个 `commit-msg` 钩子（需要安装在本地 Git 仓库中），它可以在 `git commit` 时自动创建、插入并维护一个唯一的 `Change-Id:` 行，位于签名行之上。此行用于追踪提交的迭代；如果推送到 Gerrit 的修订版缺少此信息，服务器将提供关于如何获取和安装该钩子脚本的说明。

#### post-commit 钩子

`HEAD`。这个钩子的退出状态会被忽略。还有 **post-merge 钩子**。

通常，这个脚本（像大多数 `post-*` 脚本一样）最常用于通知和日志记录，显然它无法影响 `git commit` 的结果。你可以用它，例如，触发一个本地构建，使用类似 Jenkins 的持续集成工具。然而，在大多数情况下，你可能会希望在专用的持续集成服务器上使用 `post-receive` 钩子来完成这项工作。

另一个用例是列出所有代码和文档中的 **TODO** 和 **FIXME** 注释信息（例如，作者、版本、文件路径、行号和信息），将它们打印到钩子的标准输出中，以确保它们不会被遗忘，并保持最新和有用。

### 用于从电子邮件应用补丁的钩子

你可以为基于电子邮件的工作流（提交通过电子邮件发送）设置三个客户端钩子。它们都由 `git am` 命令调用（其名称来源于 `git format-patch`，并通过 `git send-email` 发送），并将它们转化为一系列的提交。接下来我们将讨论这些钩子。

#### applypatch-msg 钩子

第一个运行的钩子是**applypatch-msg 钩子**。它在从补丁中提取提交消息后、应用补丁之前运行。像往常一样，对于非 post-*钩子，如果该钩子以非零状态退出，Git 将中止应用补丁。它接受一个参数：包含提取的提交消息的临时文件名。

你可以使用此钩子确保提交消息的格式正确，或通过让脚本修改文件来规范化提交消息。Git 提供的示例`applypatch-msg`钩子会在存在钩子（文件存在且可执行）时，运行`commit-msg`钩子。

#### pre-applypatch 钩子

下一个运行的钩子是`git am`脚本，但不提交补丁。

Git 提供的示例钩子会运行`pre-commit`钩子（如果存在）。

#### post-applypatch 钩子

最后运行的钩子是**post-applypatch 钩子**，它在提交完成后运行。它可以用于通知或记录日志，例如，通知所有开发者或仅通知补丁的作者你已应用了补丁。

### 其他客户端钩子

还有一些其他不属于单一过程步骤的客户端钩子。

#### pre-rebase 钩子

`pre-*`钩子可以通过非零退出码中止变基过程。你可以使用此钩子来禁止对已发布的任何提交进行变基（即重写）。该钩子会使用基分支的名称（分支系列所分叉的上游分支名称）和正在变基的分支名称进行调用。只有当变基的分支不是当前分支时，才会将变基的分支名称传递给钩子。Git 提供的示例`pre-rebase`钩子会尝试执行这一操作，尽管它假设了一些特定于 Git 项目开发的内容，这些假设可能不符合你的工作流程（请注意，修改提交也会重写它们，且变基可能会创建一个分支副本而非重写它）。

#### pre-push 钩子

`git push` 操作，在检查远程状态并确定服务器上缺少哪些版本后，但在推送任何更改之前调用该钩子。该钩子使用远程的引用（URL 或远程名称）和实际的推送 URL（远程位置）作为脚本参数进行调用。待推送的提交信息通过标准输入提供，每个要更新的引用占一行。你可以使用此钩子在推送发生前验证一组引用更新；非零退出码会中止推送。Git 提供的示例会检查待推送的版本集中是否存在以**WIP**开头的提交，或者在提交消息中标记了**nopush**关键字，如果符合这两种情况中的任何一种，则会中止推送。你甚至可以让钩子提示用户确认他们是否确定要进行此操作。这个钩子补充了服务器端的检查，避免了那些反正会失败验证的数据传输。

#### post-rewrite 钩子

`git commit --amend` 和 `git rebase`。但是，请注意，这个钩子不会在大规模历史重写时执行，例如 `git filter-repo`。触发重写的命令类型（`post-checkout` 和 `post-merge` 钩子），并且它会在自动复制注释之后运行，这由 `notes.rewriteRef` 配置变量控制（你可以在 *第十章**, 保持* *历史清洁* 中找到更多关于注释机制的信息）。

#### post-checkout 和 post-merge 钩子

在更新工作树之后使用 `git checkout`（或 `git checkout <file>`）。该钩子会传递三个参数：前一个和当前 `HEAD` 的 SHA-1 哈希值（这两个值可能相同也可能不同），以及一个标志，指示是否为整个项目的检出（你正在切换分支；标志参数为 1），或者是文件的检出（从索引或指定的提交中恢复文件；标志参数为 0）。作为特殊情况，在 `git clone` 之后的初始检出期间，此钩子将传递全零的 SHA-1 作为第一个参数（作为源修订版本）。你可以使用这个钩子来根据你的使用场景正确设置工作目录。这可能意味着处理存储库之外的大型二进制文件（作为替代方案，不需要在每个文件上应用 `filter` Git 属性），或者设置工作目录的元数据属性，例如完整的权限、所有者、组、时间、扩展属性或 ACL。它还可以用于执行存储库有效性检查，或者通过自动显示与之前检出版本之间的差异（或仅显示差异统计信息），来增强 `git checkout` 输出（如果它们有所不同）。

`post-checkout` 用于恢复 Git 不跟踪的工作树中的数据和元数据，如完整的权限数据（或者直接调用 `post-checkout`）。这个钩子同样可以验证 Git 控制之外的文件是否存在，并在工作树发生变化时将其复制进来。

对于 Git，存储库中的对象（例如，表示修订的提交对象）是不可变的；重写历史（即使是修改提交）实际上是在创建一个修改过的副本并切换到它，从而将重写前的历史遗弃。

#### pre-auto-gc 钩子

删除分支也会留下被遗弃的历史。为了防止存储库过度膨胀，Git 会偶尔执行垃圾回收，通过移除旧的、未引用的对象来清理。除非是在 Git 的最古老版本中，否则这通常会作为正常 Git 操作的一部分通过执行 `git gc --auto` 来完成。**pre-auto-gc 钩子** 在垃圾回收发生之前被调用，可以用于中止操作，例如，如果你正在使用电池电源。它也可以用来通知你正在进行垃圾回收。

## 服务器端钩子

除了在你自己仓库中运行的客户端钩子外，还有一些重要的 **服务器端钩子**，系统管理员可以使用这些钩子来强制执行几乎任何类型的项目策略。

这些钩子会在你推送到服务器之前和之后运行。前置钩子（如前所述）可以通过退出非零状态来拒绝推送或其中一部分；前置钩子打印的消息将被发送回客户端（发送者）。你可以利用这些钩子来设置复杂的推送策略。Git 仓库管理工具，如 `gitolite` 和 Git 托管解决方案，使用这些钩子来实现更复杂的仓库访问控制。后置钩子可以用于通知、启动构建过程（或仅仅是重新构建和重新部署文档），或者运行完整的测试套件，例如作为 CI 解决方案的一部分。

在编写服务器端钩子时，你需要考虑钩子在操作序列中的位置以及可用的相关信息，这些信息以参数、标准输入和仓库的形式提供。

让我们回顾一下服务器接收到推送时发生的事情：

1.  简单来说，第一步是将客户端存在而服务器缺失的所有对象发送到服务器并存储（但尚未被引用）。如果接收端未能正确完成此操作（例如，由于磁盘空间不足），整个推送操作将失败。

1.  **pre-receive 钩子**会运行。它会将描述正在推送引用的列表传递到标准输入。如果它以非零状态退出，则会中止整个操作，且所有推送的引用都不会被接受。

1.  对于每个正在更新的引用，内置的有效性检查可能会拒绝对该引用的推送，包括检查正在更新的分支、非快进推送（除非强制推送）等。

1.  **update 钩子**会为每个引用运行，并将要推送的引用作为参数传递；如果此脚本以非零状态退出，只有这个引用会被拒绝。

1.  对于每个推送的引用，相关引用会被更新（除非在早期阶段被拒绝）。

1.  **post-receive 钩子**会运行，接收与 **pre-receive** 钩子相同的数据。这个钩子可以用于更新其他服务（例如，通知 CI 服务器）或通知用户（通过电子邮件、邮件列表、IRC 或问题跟踪系统）。

如果推送是原子的，要么所有引用都被更新（如果没有被拒绝），要么都不更新。

对于每个更新的引用，运行 `git update-server-info` 来准备一个仓库，保存额外的信息以便在 *简单* 传输中使用，尽管如果在 `post-receive` 后运行会更有效。

如果推送尝试更新当前检出的分支，而 `receive.denyCurrentBranch` 配置变量被设置为 `updateInstead`，则会运行 **push-to-checkout** 钩子。

重要提示

你需要记住，在 pre 钩子中，引用尚未更新，而 post 钩子不能影响操作结果。你可以将 pre 钩子用于访问控制（权限检查），并将 post 钩子用于通知、更新附加数据和日志。

你将在*第十四章*《Git 管理》中看到 Git 强制执行的策略示例钩子（包括服务端和客户端）。你还将学习其他工具如何使用这些钩子，例如用于访问控制和在推送时触发操作。

# 扩展 Git

Git 提供了几种扩展机制。你可以添加快捷方式、创建新命令，并为新传输方式提供支持；所有这些都不需要你修改 Git 源代码。

## Git 命令别名

有一个小技巧可以使你的 Git 命令行体验更简单、更容易、更熟悉，即 `alias.<command-name>` 配置变量；其值是别名的扩展。

使用别名的一个场景是为常用命令及其参数定义简短的缩写。另一个场景是创建新命令。以下是你可能希望设置的一些示例：

```
$ git config --global alias.co checkout
$ git config --global alias.ps = '--paginate status'
$ git config --global alias.lg "log --graph --oneline --decorate"
$ git config --global alias.aliases 'config --get-regexp ^alias\.'
```

前述设置意味着例如输入 `git co` 等同于输入 `git checkout`，而 `git aliases` 会打印出所有定义的别名。别名接受参数，和常规 Git 命令一样。Git 默认不提供任何别名来为常见操作定义快捷方式，除非你使用 `git-fc` 项目，这是 Felipe Contreras 对 Git 的一个友好的分支。

这里的参数由空格分隔，并且支持常规的 shell 引号和转义方式。特别地，你可以使用引号对 `("a b"`) 或反斜杠 (`a\ b`) 来将空格包含在单个参数中。

重要提示

然而需要注意的是，你不能将别名命名为与 Git 命令相同的名称。换句话说，你不能通过别名来改变命令的行为。做出这一限制的原因是，这样可能会导致现有的脚本和钩子意外失败。隐藏现有 Git 命令的别名（与 Git 命令同名的别名）会被直接忽略。

然而，你可能希望在别名中运行外部命令，而不是 Git 命令。或者，你可能希望将几个独立命令的结果组合在一起。在这种情况下，你可以通过 `!` 字符来开始别名定义：

```
$ git config --global alias.unmerged \
  '!git ls-files --unmerged | cut -f2 | sort -u'
```

由于在这里别名扩展的第一个命令可能是外部工具，因此需要明确指定 `git` 包装器，如前面的示例所示。

注意

请注意，在许多 shell 中，例如在 **bash** 中，感叹号 **!** 是历史扩展字符，需要转义为 **\!** 或者放在单引号 (**'**) 内。

请注意，这些 shell 命令将从仓库的顶级目录执行（在执行 `cd` 到顶级目录后），而不一定是当前目录。Git 会将 `GIT_PREFIX` 环境变量设置为相对于仓库顶级目录的当前目录路径，即 `git rev-parse --show-prefix`。和往常一样，`git rev-parse`（以及一些 `git` 包装选项）在这里可能会派上用场。

前面提到的事实可以在创建别名时使用。`git serve` 别名，通过运行 `git daemon` 来服务（只读）当前仓库，地址为 `git://127.0.0.1/`，利用了别名中的 shell 命令从仓库的顶级目录执行这一事实：

```
[alias]
    serve = !git daemon --reuseaddr --verbose --base-path=. --export-all ./.git
```

有时候，你需要重新排列参数，使用某个参数两次，或者在管道的早期阶段传递一个参数。你可能想要像在 shell 脚本中那样，通过 `$1`、`$2` 等方式引用后续参数，或者通过 `$@` 来引用所有参数。一个你可以在旧示例中找到的技巧是使用 `-c` 参数运行 shell，如下文第一个示例所示；最后的短横线是为了让参数从 `$1` 开始，而不是从 `$0` 开始。一种更现代的方式是定义并立即执行一个 shell 函数，如第二个示例所示（这种方法更受欢迎，因为它少用了一级引号，并且允许你使用标准的 shell 参数处理）：

```
[alias]
    record-1 = !sh -c 'git add -p -- $@ && git commit' -
    record-2 = !f() {  git add -p -- $@ && git commit }; f
```

别名与命令行补全功能集成。在确定使用哪个补全时，Git 会搜索一个 `git` 命令，跳过开括号或单引号（因此支持之前提到的两种语法）。在现代 Git 中，你可以使用空命令 "`:`" 来声明所需的补全样式。例如，别名扩展为以下内容：

```
!f() { : git commit ; ... } f
```

会使用 `git commit` 的命令补全，不管别名的其余部分如何。

Git 别名也与帮助系统集成。如果你在别名上使用 `--help` 选项，Git 会告诉你它的扩展（这样你可以查看相关的手册页）：

```
$ git co --help
'git co' is aliased to 'checkout'
```

## 添加新的 Git 命令

别名最适合将小的单行命令转化为小而有用的 Git 命令。你可以写复杂的别名，但当涉及到较大的脚本时，你可能更希望将它们直接集成到 Git 中。

Git 子命令可以是独立的可执行文件，位于 Git 执行路径中（你可以通过运行 `git --exec-path` 来找到这个路径）；在 Linux 上，通常位于 `/usr/libexec/git-core`。`git` 可执行文件本身是一个薄的包装器，知道子命令的位置。如果 `git foo` 不是内建命令，包装器首先会在 Git 执行路径中搜索 `git-foo` 命令，然后在 `$PATH` 中的其他地方继续搜索。后者使得你可以编写本地 Git 扩展（本地 Git 命令），而无需访问系统的空间。

这个特性使得在项目中实现一个与 Git 其余部分更或多或少集成的用户界面成为可能，比如在 `git imerge`（见 *第九章*，*合并更改*）中，或者 `git lfs` 或 `git annex`（见 *第十二章*，*管理大型仓库*）中。这也是像 **Git Extras** 这样的项目得以实现的原因，它们提供了额外的 Git 命令。

然而，请注意，如果你没有将命令的文档安装到典型位置，或者没有配置文档系统以查找命令的帮助页面，那么 `git foo --help` 将无法正确工作。

你可以通过 `git --list-cmds=others` 列出所有以这种方式安装的外部命令，或者你可以使用 `git help --all`，该命令的输出末尾将出现以下列表：

```
$ git --list-cmds=others
   credential-helper-selector
   credential-manager
   lfs
```

## 凭证助手和远程助手

还有一个地方，通过简单地放置一个适当命名的可执行文件，可以增强和扩展 Git。Git 会在需要与远程仓库和 Git 本身不原生支持的远程传输协议交互时调用 **远程助手** 程序。你可以在 *第六章* 中了解更多关于它们的内容，*使用 Git 进行协作开发*。

当 Git 遇到 `<transport>://<address>` 形式的 URL 时，其中 `<transport>` 是一个 Git 本身不原生支持的（伪）协议，它会自动调用 `git remote-<transport>` 命令，并以远程地址和完整的远程 URL 作为参数。`<transport>::<address>` 形式的 URL 也会调用这个远程助手，但只会将 `<address>` 作为第二个参数，而不是 URL。另外，如果 `remote.<remote-name>.vcs` 设置为 `<transport>`，Git 将显式调用 `git remote-<transport>` 来访问该远程。

Git 中的助手机制是通过使用一个明确定义的格式与外部脚本进行交互。

每个远程助手都需要支持一组命令。你可以在 `gitremote-helpers(1)` 手册页中找到有关创建新助手的更多信息。

Git 中还有另一种助手，即 **凭证助手**。它们可以被 Git 用来获取用户所需的凭证，例如，用于通过 HTTP 访问远程仓库。这些助手是通过配置指定的，就像合并和差异驱动程序以及清理和污染过滤器一样。

# 摘要

本章提供了你使用 Git 所需的所有工具。你了解了如何通过 Git-aware 动态命令提示符、命令行自动补全、Git 命令的自动修正以及使用颜色来使命令行界面更易用、更有效。你还了解了替代接口的存在，从替代的瓷器到各种图形客户端。

你已经了解了多种更改 Git 命令行为的方式。你发现了 Git 如何访问其配置，并了解了一部分配置变量。你学会了如何通过钩子自动化 Git 以及如何利用它们。最后，你还学会了如何通过新命令和支持新的 URL 方案来扩展 Git。

本章主要讲解了如何让 Git 对你更高效；下一章，*第十四章**,* *Git 管理*，将解释如何让 Git 对其他开发者更高效。你将学习更多关于服务器端钩子的内容，并看到它们的使用。你还将学习关于仓库维护的知识。

# 问题

回答以下问题，测试你对本章内容的理解：

1.  如何保存和重用你最喜欢的 Git 命令选项组合？

1.  如何找到所有创建的别名？

1.  如何运行图形化工具来显示**git diff**，或帮助解决合并问题？

1.  如何找到给定配置的来源？

1.  如何确保一个提交符合推荐的最佳实践？

# 答案

以下是上面问题的答案：

1.  使用 Git 别名、Shell 别名或 Shell 函数。

1.  你可以使用**git config --get-regexp ^****alias\.** 命令。

1.  使用**git difftool**显示差异，或使用**git mergetool**帮助解决合并冲突。内置支持许多现有的图形化工具。

1.  如果是关于配置值，你可以使用**git config --show-origin**（或**--show-scope**）。如果是关于每个文件的属性，可以使用**git check-attr**。如果是关于忽略文件，可以使用**git check-ignore**。

1.  使用**pre-commit**钩子（以及其他类似的钩子）来提醒如果没有遵循最佳实践。有许多第三方工具可以帮助管理钩子，并且通常支持各种辅助工具，如代码检查器和格式化工具。

# 进一步阅读

要了解更多本章所涉及的主题，请查看以下资源：

+   Scott Chacon, Ben Straub: *Pro Git, 第二版* (2014)，Apress [`git-scm.com/book/en/v2`](https://git-scm.com/book/en/v2)

    +   *第二章* *- Git 基础，2.1 节 -* *Git 别名*

    +   *第八章 -* *自定义 Git*

    +   *附录 A: Git 在* *其他环境中的应用*

+   Matthew Hudson: *Git 钩子 - 程序员指南* [`githooks.com/`](https://githooks.com/)

+   *bash/zsh git 提示* *支持* [`github.com/git/git/blob/master/contrib/completion/git-prompt.sh`](https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh)

+   *bash/zsh 完成支持核心* *Git* [`github.com/git/git/blob/master/contrib/completion/git-completion.bash`](https://github.com/git/git/blob/master/contrib/completion/git-completion.bash)

+   Seth House：*在各种合并工具中的冲突解决*（2020） [`www.eseth.org/2020/mergetools.html`](https://www.eseth.org/2020/mergetools.html)

+   Julia Evans：*流行的 git 配置选项*（2024） [`jvns.ca/blog/2024/02/16/popular-git-config-options/`](https://jvns.ca/blog/2024/02/16/popular-git-config-options/)

+   Ricardo Gerardi：*让我更高效的 8 个 Git 别名*（2020） [`opensource.com/article/20/11/git-aliases`](https://opensource.com/article/20/11/git-aliases)

+   *Git SCM Wiki*（已归档）：*别名* [`archive.kernel.org/oldwiki/git.wiki.kernel.org/index.php/Aliases.html`](https://archive.kernel.org/oldwiki/git.wiki.kernel.org/index.php/Aliases.html)

+   *Git 首页 - GUI* *客户端* [`git-scm.com/downloads/guis`](https://git-scm.com/downloads/guis)

+   *Git 版本* *新闻* [`git.github.io/rev_news/`](https://git.github.io/rev_news/)
