# 第十一章：镜像

虽然大多数安装都乐于在一个所有开发者都能访问的单一服务器上安装 Gitolite，但其中一些公司在世界各地有开发者，通常在每个城市提供本地镜像以便快速访问是非常有用的。Gitolite 的镜像功能以非常灵活的方式满足了这些需求。

镜像可以是你想要的简单或复杂。你可以让一台服务器成为所有仓库的主服务器，并由一个或多个从服务器保存其副本。你也可以让不同的服务器成为不同仓库的主服务器，并选择其中一些服务器作为从服务器，而不是所有服务器。你甚至可以选择不将某些仓库纳入镜像过程。

# 术语和基本概念

一个镜像仓库在一台服务器上有一个可写副本，通常称为该仓库的**主服务器**，并且在一台或多台服务器上有只读副本，类似地称为**从服务器**。当主仓库被更新时，从仓库会几乎即时更新，具体取决于网络速度。

## 仓库级别镜像

大多数镜像的主要目的是通过提供位于附近服务器上的副本来加速读取访问（通过网络），以便进行拉取和克隆。因此，可以预期将指定一台服务器为主服务器，其他几台作为从服务器。

然而，Gitolite 的镜像是在*仓库*级别定义的，而不是针对整个服务器。对于*每个*仓库，管理员决定哪个服务器持有主（可写）副本，其他服务器（如果有的话）是否应该为其本地用户提供从属副本。（这就是为什么我们说主仓库和从仓库，而不是主服务器和从服务器。）

这是一个非常重要的概念，相比于镜像整个服务器，它带来了几个优势。

首先，不必在没有该仓库本地用户的服务器上提供仓库。如果用户非常少（例如一两个用户），根据仓库的开发活跃度，从网络利用率的角度来看，仍然可能有意义让这些少数用户直接从主仓库或其他从仓库拉取。这允许资源较少的分支机构仍然能成为 Gitolite 镜像网络的一部分，只要他们有足够的项目供本地用户工作。

其次，由于你不必将*所有*主仓库放在同一台服务器上，你可以选择将任何特定仓库的主副本放置在哪里。通常，你会选择将其放置在离大多数将要在其上工作的开发者最近的服务器上（从网络速度的角度来看）。

最后，仓库可以仅对特定服务器本地可用，也就是说，它们不需要被镜像。

### 注意

只能有一个主仓库——你不能让不同的用户推送到不同的服务器，因为那样会导致合并问题，无法可靠地自动化。（不过，Gitolite 确实有一个方便的解决方法，稍后我们会看到。）

## gitolite-admin 仓库

从 Gitolite 镜像功能的角度来看，gitolite-admin 仓库只是另一个仓库。就镜像而言，它没有什么特别之处——与所有其他仓库一样，其中一台服务器将持有主（可写）副本。唯一的区别是，*所有*其他服务器必须被列在从属列表中；如果某个服务器未被提及，它将无法接收该仓库的更新。

# 设置镜像

设置镜像有相当多的手动步骤，尽管每个步骤本身都非常简单。第一步是给每个主机一个名称，并确保这些主机可以通过这些名称相互通信。第二步是启用每个服务器的镜像功能。

我们首先在所有服务器上正常安装 Gitolite。然后，我们编辑每个服务器的 `$HOME/.gitolite.rc` 文件，并取消注释定义 `HOSTNAME` 的行，选择一个简单的主机名作为值。

### 提示

主机名应该是一个简单的词；它仅对 Gitolite 有意义，与操作系统和 DNS 记录所知道的服务器主机名无关。

Gitolite 镜像通过允许服务器使用名为这些主机名的 ssh 密钥对进行相互通信来实现。这与用户使用的机制相同，唯一不同的是，服务器的公钥文件命名为`server-`，后跟该服务器的主机名。所有密钥需要提供给所有服务器，添加到它们的 gitolite-admin 仓库中，并进行推送。最后，每个服务器的 $HOME/.ssh/config 需要一个主机别名，用于引用所有其他机器。

## 示例设置

一个例子会使这个更加清晰。假设你有三台服务器：jupiter、ganymede 和 callisto。这些服务器的 IP 地址分别是 `10.1.1.1`、`10.2.1.1` 和 `10.3.1.1`。

1.  首先，在所有三个服务器上安装 Gitolite。在 Jupiter 上，编辑 `$HOME/.gitolite.rc` 文件，并取消注释 `HOSTNAME` 行，按如下方式更改（不要忘记末尾的逗号！）：

    ```
    HOSTNAME    =>  "jupiter",

    ```

1.  在其他两个服务器上执行相同操作。

1.  在每个服务器上运行 `ssh-keygen` 来创建该服务器的密钥对。收集所有三个 `$HOME/.ssh/id_rsa.pub` 文件（每个服务器的一个），分别命名为 `server-jupiter.pub`、`server-callisto.pub` 和 `server-ganymede.pub`。

1.  将这些公钥添加到*所有*服务器，就像你添加普通用户一样（也就是说，*对于每个服务器*，从该服务器克隆 gitolite-admin 仓库，添加所有这些密钥到 `keydir`，然后添加、提交并推送）。

1.  接下来，将以下行添加到所有三个服务器的 `$HOME/.ssh/config` 文件中（假设三个服务器上的托管用户都是 `git`）：

    ```
    host jupiter
     user git
     hostname 10.1.1.1
    host ganymede
     user git
     hostname 10.2.1.1
    host callisto
     user git
     hostname 10.3.1.1

    ```

完成所有这些操作后，你应该能够通过从木星服务器运行 `ssh ganymede info` 来测试你的设置。你应该得到类似如下的输出：

```
hello server-jupiter, this is git@ganymede.example.com running gitolite3 v3.5.3.1-7-g31d11b9 on git 1.8.3.1 
```

从任何服务器到其他服务器的类似命令应该生成类似的响应。最好测试所有可能的组合，以避免后续出现混淆的错误。

## 启动镜像过程

上一步骤建立了所有服务器之间的通信和认证。一旦完成并检查无误，下一步是通过为 gitolite-admin 仓库设置镜像选项并推送它们，来启动镜像过程。

在每台服务器上，将以下行添加到 `conf` 文件中：

```
repo gitolite-admin
 option mirror.master   = jupiter
 option mirror.slaves    = callisto ganymede

```

一旦你添加、提交并推送这些更改到所有仓库，Gitolite 镜像就已设置并准备好使用。从此之后，你可以通过推送到 `jupiter` 服务器上的 gitolite-admin 仓库来管理一切。

## 镜像其他仓库

到现在，你应该知道需要为其他每个仓库做什么。只需像上一节那样为每个仓库添加选项行。例如，以下是一个简单的镜像设置，所有仓库的镜像方式相同：

```
repo @all
 option mirror.master   = jupiter
 option mirror.slaves    = callisto ganymede

```

如果这就是你想要的，那么镜像过程就算完成了。否则，按需要添加选项，为每个仓库指定正确的主服务器名称和正确的一组从服务器。请注意，任何没有这些设置的仓库都被认为是本地仓库。

如果允许用户创建自己的仓库（参见第八章，*允许用户创建仓库*），只需将镜像选项行添加到这些仓库定义中。以下限制适用于镜像用户创建的仓库。

只有当第一次推送到主服务器上的仓库时，才会传播该仓库的创建。作为克隆或获取结果创建的仓库不会立即传播到从服务器。

权限的更改（使用 `perms` 命令；参见第八章，*允许用户创建仓库*，特别是*授予其他用户访问权限*部分）也仅在下次推送时传播。

# 本地仓库和主机名替换

我们之前提到，某些服务器可以有本地仓库，比如如果`conf`文件没有为这些仓库指定 Gitolite 镜像选项的话。然而，只有每个服务器可以拥有自己的一组本地仓库才真正有意义。例如，假设盖尼米德的人想要一个名为 ganymede-news 的本地仓库，他们打算在内部使用。将其添加到`conf`文件将在木星和卡利斯托上创建这样一个仓库；即使没有人使用它，这也是不美观、不必要的，并且可能导致未来的混淆。我们想要避免这种情况，但由于相同的 gitolite-admin 仓库，使用相同的`conf/gitolite.conf`文件和其他文件被推送到所有从服务器，似乎很难做到。

使此功能可行的特性是`HOSTNAME`替换。具体来说，每当 Gitolite 在`conf`文件中遇到字符串`%HOSTNAME`（后面跟着一个非字母数字字符；即，除了字母、数字和下划线以外的字符），它将在处理之前使用`$HOME/.gitolite.rc`中给出的服务器`HOSTNAME`替换它。

使用我们在第六章中看到的`include`语句能力，*访问控制入门*，你现在可以提供特定于服务器的 Gitolite 配置，同时仍然保持所有内容在一个仓库中。只需将以下行添加到主配置文件（`conf/gitolite.conf`）：

```
include "%HOSTNAME.conf"

```

然后，为每个服务器创建`conf/jupiter.conf`、`conf/callisto.conf`等文件。在这些文件中，指定各自服务器特有的仓库语句和规则。

使用`include`语句在主`conf`文件中是很重要的，每个服务器在推送时会看到这行代码不同。例如，对于木星服务器，会看到如下行（其他服务器类似）：

```
include "jupiter.conf"

```

这意味着另外两个文件（`ganymede.conf`和`callisto.conf`），虽然它们在`conf`目录中确实存在，但实际上根本没有被处理。

# 重定向推送

我们之前提到只能有一个主仓库。然而，从开发者的角度来看，这会使事情有些不便。假设你希望一些开发者利用地理位置接近的从服务器来获取更新。这意味着他们必须使用推送到与他们克隆的服务器不同的服务器，并定期拉取/获取。虽然 Git 允许这样做（查看 man git-config 并查找 pushurl，是一种可能的方法之一），但每个用户仍需要在其机器上执行某些操作。此外，请记住，Gitolite 允许不同的仓库有不同的主服务器；这会增加开发者混淆的可能性。

因此，Gitolite 提供了一个功能，使得这个限制变得不那么繁重。如果管理员选择，开发者可以推送到从服务器，并且 *推送将透明地被转发到该仓库的主服务器*。事实上，除非网络速度使其显而易见，用户甚至可能不知道这种事情发生了。

这为管理员带来了极大的便利；不再需要让开发者混淆每个仓库需要克隆和推送的位置。实际上，你可以设置，使得某个特定站点的所有开发者都使用本地的 Gitolite 服务器来进行所有克隆，而无需知道 Gitolite 镜像功能正在被使用！

这个功能被称为 **重定向推送**，因为这正是后台发生的事情。以下是如何使用它。假设你希望允许从 `ganymede`（而不是 `callisto`）进行重定向推送（推送到 `repository foo`），你需要在 `conf` 文件中添加以下几行：

```
repo foo
 option mirror.redirectOK  = ganymede

```

就这样。只需列出你信任的所有从服务器，并将它们以空格分隔的形式作为该选项的值。如果你信任所有从服务器，直接使用单词 all 即可。

# 手动同步

有时你会发现某个从服务器没有更新，可能是由于某些临时的网络问题。在网络问题解决后，要让其重新同步，一种方法当然是对仓库进行一些修改并推送。然而，这种方式显得笨拙且不优雅。

### 注意

目前，Gitolite 并没有提供推送失败的报告功能，尽管它会记录 Git 本身返回的所有信息在日志文件中。这意味着管理员需要主动监控日志文件以检测失败，或者等待用户报告从服务器不同步的问题。

对于美学上较为敏感的人，Gitolite 提供了镜像命令。只需登录到包含主仓库的服务器，然后运行 `gitolite mirror push slavename reponame`。这将立即使从服务器与主服务器同步。

如果你希望远程用户能够触发此类更新，只需通过取消注释 `$HOME/.gitolite.rc` 中相应的行来启用远程使用该命令。

# 切换到不同的主服务器

镜像的最大日常好处显然是，它可以让分布广泛的开发团队更加高效地进行网络读取，尽管这会在每个从服务器位置增加额外的服务器成本。

然而，显然还有一个额外的优势。如果一个仓库的主服务器发生故障，可以轻松地将其中一个镜像从从服务器列表中移除，并将其设置为主服务器。只要没有网络问题，从服务器应该与主服务器保持相同的状态，因此不会丢失任何提交。

### 提示

镜像与备份不同。本书的范围不涉及这两者之间的区别，但你应该始终为所有服务器和可能的工作站设置一个可靠的备份系统。

当死掉的服务器包含了 gitolite-admin 仓库时，这个简单的策略就会崩溃。这有点像是进退两难的情况；你无法将更改（在 gitolite-admin 仓库的镜像选项中）推送到当前的主服务器，因为它已经宕机了。然而，你也无法将更改推送到你决定提升为“主”服务器的从服务器，因为它还不知道自己已经是新的主服务器了！（不言而喻，作为一种安全功能，从服务器不接受来自任何地方的推送——它们只会接受来自被告知是相关仓库主服务器的服务器的推送。）

解决这个问题的正确方法如下：

1.  在每个从服务器上，编辑`$HOME/.gitolite/gitolite.conf`。更改 gitolite-admin 仓库的主服务器和从服务器选项。如果你为这些选项使用了`@all`仓库，它们将会影响到所有仓库。然而，最好只为 gitolite-admin 仓库修改这些选项，如果可能的话。

1.  在保存对该文件的更改后，运行`gitolite setup`。这将覆盖限制并强制在本地服务器上应用更改。（出于安全原因，这不能远程执行。）

1.  现在，在管理员的工作站上，从新的主服务器克隆 gitolite-admin 仓库，修改其他仓库的镜像选项（如果需要），然后推送更改。

# 总结

本文结束了我们对 Gitolite 镜像功能的探索。虽然这并不是每个人都需要的功能，但对于较大的站点来说，这具有一些非常明显的好处。

希望你喜欢本次对 Gitolite 及其功能的探索。随着你对 Gitolite 的使用越来越多，你可能还需要查看官方文档，网址为[`gitolite.com`](http://gitolite.com)。我们希望这本书能帮助你理解 Gitolite 背后的概念和原理，从而更好地理解官方文档，帮助你更快地完成工作。
