# 第七章 高级访问控制与配置

上一章中描述的基本访问控制方法足以满足大多数站点的需求，许多站点甚至没有进一步的配置。然而，Gitolite 有许多更多的功能，等待那些需要它们的用户。本章将介绍其中一些高级功能。每个功能我们都会尝试描述一个实际场景，说明该需求，然后解释该功能如何满足这个需求。

# 修改 rc 文件

Gitolite 的许多高级功能和配置选项是通过编辑*rc 文件*来管理的。该文件名为`.gitolite.rc`，通常位于 Gitolite 托管用户的主目录下。

该文件有很多注释，一般来说，查看文件时很容易理解每一部分内容的作用。

文件的大部分内容都在一个顶层定义中，形式如下：

```
%RC = (
...several variables defined...
)

```

如果你熟悉 Perl，可能会意识到这其实是一个 Perl 哈希，但并不需要懂 Perl 就能编辑这个文件。

文件中定义了几个简单的变量，例如：

```
 UMASK                           =>  0077,

```

当 Gitolite 文档（或本书）告诉你编辑 rc 文件中的变量时，最好先查找一下这些变量——大多数重要的变量已经存在于文件中，只是可能被注释掉，等待取消注释并根据需要编辑其值。

`%RC`块中的一个变量是名为`ENABLE`的列表变量，其定义如下：

```
 ENABLE => [
 ...several features listed...
 ]

```

一个示例功能如下：

```
 'info',

```

这将启用`info`命令。

同样，大多数功能已经在这里列出，但可能被注释掉。

# 为用户提供个人分支

当项目中有多个开发者时，通常需要共享仍在开发中的代码，以便进行评论、讨论、初步测试等。显而易见的解决方案是，每个开发者将代码推送到 Gitolite 服务器上的一个分支，并告知同事该分支的名称。可以为此创建一个专门的分支命名空间，使所有开发者都能访问，具体如下：

```
repo foo
 RW+    sandbox/  =  @developers

```

这种方法工作得很好，但如果在*沙箱*命名空间内的分支命名没有严格控制，可能会导致某个开发者不小心覆盖或删除另一个开发者的分支。

理想情况下，所需的应该是如下的方式：

```
 RW+    sandbox/alice/  =  alice
 RW+    sandbox/bob/    =  bob

```

依此类推，为每个需要访问仓库的用户添加相应的配置。

显然，这种方式并不具备可扩展性——如果你这样做，你必须为每个用户添加一行。事实上，这实际上是一种倒退，因为我们突然失去了将用户按组管理的所有优势，因为我们被迫为每个开发者使用单独的规则。

这种情况促使了 Gitolite 中所谓的**个人分支**功能的开发。该功能基于一个简单的理念，最好的方式是通过以下示例规则来描述：

```
 RW+    sandbox/USER/  =  @developers

```

其理念是，`USER` 这个词被斜线包围，代表了来自连接信息的认证用户名，只要该用户在右侧列出（或该用户所属的组被列出）。因此，如果用户 ID `alice` 是 `@developers` 组的成员，并且 Alice 尝试访问该仓库，那么此规则有效地变成如下：

```
 RW+    sandbox/alice/    =  alice

```

这允许 Alice 向她自己的沙箱分支写入；即以 `sandbox/alice/` 开头的分支名称。请注意，这不允许一个名为 `sandbox/alice` 的分支——沙箱是指一组分支，而不仅仅是一个分支。

由于 Gitolite 不允许按分支限制读取权限，因此所有属于 `@developers` 组的用户都有权限读取该仓库，这意味着他们可以读取彼此的开发分支，但只能对自己的沙箱分支进行写操作（推送）。

# 写操作类型

到目前为止，我们在谈论权限时仅限于 `RW` 和 `RW+` 权限。前者允许用户创建新的分支和标签，并对分支进行**快速前进**推送，而后者允许用户进行非快速前进推送和重写标签，并且删除分支和标签。

### 提示

这是最常见的情况，且该语法适用于绝大多数访问控制需求。对现有标签的推送，即使新的提交是当前标签指向的提交的后代，仍然被视为非快速前进推送。这是因为，与分支不同，标签并不*意味着*可以被移动；一旦写入，标签应该是固定的，永远不会更改。

然而，在某些情况下，你可能需要显式指定*创建*分支的权限，将其与推送新提交的权限区分开。类似地，你可能希望显式指定*删除*分支或标签的权限，将其与推送非快速前进提交的权限区分开；或者，你可能希望同时指定两者。

为了实现这一点，Gitolite 在权限字段中引入了扩展语法，让你可以明确指定创建和/或删除权限。在适用于仓库的任何规则中使用这些扩展权限，会限制正常 `RW` 和 `RW+` 权限在创建或删除引用方面的权限。

这种扩展语法包括以下*新权限*：`RWC`、`RW+C`、`RWD`、`RW+D`、`RWCD` 和 `RW+CD`。当一个规则指定了包含 `C` 的权限并添加到仓库时，该仓库的 `RW` 和 `RW+` 规则将不再允许*创建*分支或标签。类似地，当任何规则指定了包含 `D` 的权限时，该仓库的 `RW+` 规则将不再允许*删除*引用。为了便于讨论，我们可以分别将其称为*显式创建*和*显式删除*模式。

将这些规则总结成表格形式非常有用，以便在需要使用这些特殊权限模式时快速参考。下表展示了在三种模式下，执行给定操作所需的最小权限“字符”（严格来说，还有第四种模式，即同时使用显式创建和显式删除模式，但这只是两者的组合）：

|   | 默认模式 | 显式创建模式 | 显式删除模式 |
| --- | --- | --- | --- |
| 创建新分支 | `RW` | `RW` 和 `C` | `RW` |
| 创建新标签 | `RW` | `RW` 和 `C` | `RW` |
| 快进推送现有分支 | `RW` | `RW` | `RW` |
| 非快进推送分支 | `RW+` | `RW+` | `RW+` |
| 覆盖现有标签 | `RW+` | `RW+` | `RW+` |
| 删除分支 | `RW+` | `RW+` | `RW` 和 `D` |
| 删除标签 | `RW+` | `RW+` | `RW` 和 `D` |

# 允许 Gitweb 和 Git-daemon 访问

**Gitweb**（以及在较小程度上，**git-daemon**）是流行的工具，提供对 Git 仓库的只读访问。Git-daemon 提供完全无认证的 Git 仓库访问，适用于开源或类似项目。Gitweb 在网页浏览器中显示仓库、分支、提交历史以及更多细节。Gitweb 本身不进行任何认证，而是依赖于网页服务器来认证用户。

Gitweb 和 git-daemon 通过不同的方式来确定哪些仓库可以对客户端开放。对于 gitweb，允许的仓库列表以特定格式（最简单的形式是每行一个仓库名称）放在一个特定文件中，该文件位于可配置的位置（具体细节请参见 gitweb 文档）。另一方面，git-daemon 会在每个仓库内部查找名为 `git-daemon-export-ok` 的文件，以确定该仓库是否可以对客户端开放。当然，两个工具在使用之前都需要进行一次性的配置设置。特别是，gitweb 可能甚至不会作为 Gitolite 托管用户运行，而一次性的设置可能涉及允许其读取 Gitolite 托管用户拥有的文件。

虽然 Gitolite 无法帮助配置这些工具的首次设置，但它肯定能帮助管理访问列表。它通过指定两个特殊的 Gitolite 用户名：`gitweb` 和 `daemon` 来实现。这些用户没有公钥，因此他们不像 Adam、Alice 或 Bob 等示例中的实际用户。然而，他们决定了哪些仓库可以通过 gitweb 和 git-daemon 访问。

这个概念非常简单。如果你希望一个仓库可以通过 gitweb 读取，你就给 `gitweb` 用户 *读* 权限。类似地，如果你希望仓库可以通过 git-daemon 访问，你就给 `daemon` 用户 *读* 权限。下面是一个同时进行两者操作的例子：

```
repo foo
 R  =  gitweb  daemon

```

当然，你可以使用已定义的任何仓库组名称，甚至是特殊的组名`@all`，而不是指定每个仓库。

当 gitolite-admin 仓库被推送时，Gitolite 会检查每个仓库，看看这些特殊用户是否被授予了读取权限。对于每个这样的仓库，Gitolite 会在之前提到的项目列表文件中添加该仓库的名称，如果`gitweb`用户可以读取它，并且如果`daemon`用户可以读取它，则会创建名为`git-daemon-export-ok`的文件。此外，如果你之前允许了访问权限，然后又决定删除它，Gitolite 将删除项目列表文件中的条目，和/或删除`git-daemon-export-ok`文件（视情况而定）。

## 定位项目列表文件

我们之前提到过，Gitweb 会查阅一个包含允许的仓库列表的文件，而 Gitolite 会创建这个文件。当然，Gitweb 和 Gitolite 必须一致地知道这个文件的位置。默认情况下，Gitolite 将其放在`$HOME/projects.list`，但如果需要，可以将其更改为任何其他位置；只需在`$HOME/.gitolite.rc`文件中添加一行，如下所示，当然要替换为你想要的路径。

```
GITWEB_PROJECTS_LIST => "/path/to/projects.list",

```

### 注意

上述语句的语法包括末尾的逗号。这一行必须放在标记为`rc variables used by various features`的部分中。

## Unix 权限和 umask

Gitweb 由你的 Web 服务器（如 Apache）调用，而 Web 服务器几乎肯定是以与你的 Gitolite 托管用户不同的用户 ID 运行的。根据你的操作系统和 Web 服务器的不同，可能是名为`apache`、`www-data`或其他名称的用户。

这意味着你需要确保该用户能够读取它所需要的文件（主要是项目列表文件，以及`$HOME/repositories`下的所有文件）。通常有两种方法来做到这一点。最简单的方法是做如下操作：

1.  确定你的 Gitolite 托管用户所属的主要组（通常与用户名相同）。你可以通过以 Gitolite 托管用户身份登录服务器后运行`id`命令来查找。在大多数系统中，它与用户 ID 相同，因此为了方便讨论，我们假设它是`git`。

1.  确定 Web 服务器运行时使用的 Unix 用户 ID。为了讨论方便，我们假设它是`apache`。

1.  使用`usermod`命令将`apache`用户添加到`git`组中。（你需要以 root 身份在服务器上运行此命令。）具体的语法可能根据你的操作系统和版本有所不同。例如，在 Red Hat 系统上的命令是`usermod -G git apache`。

1.  将`UMASK`值从默认的`0077`更改为`0027`，在`$HOME/.gitolite.rc`文件中进行修改。

1.  手动修复现有文件。这是一次性操作，所需操作是因为`umask`只会影响新创建文件的权限，而不会影响已有文件的权限。以 Gitolite 托管用户身份登录，并运行命令`chmod -R g+rX $HOME/projects.list $HOME/repositories`。

处理此问题的第二种方法是以 Gitolite 托管用户身份运行 gitweb。大多数 Web 服务器提供机制，允许在与 Web 服务器运行的用户 ID 不同的用户 ID 下运行特定程序，例如 Apache Web 服务器中的`suexec`功能。配置这些功能超出了本书的范围；有关更多信息，请查看你使用的 Web 服务器的文档。

# 指定 Git 配置值和 Gitolite 选项

如果你熟悉 Git，你可能知道`git config`命令，它允许你设置仓库选项。对于服务器端（裸）仓库，可能有用的配置变量示例包括`core.logAllRefUpdates`、`receive.fsckObjects`，以及各种与性能相关的配置变量。（有关详细信息，请参阅`git-config`的手册页）

Gitolite 旨在允许几乎所有管理操作都远程进行，因此期望管理员登录到服务器并运行`git config`命令是不合理的。因此，Gitolite 允许管理员在配置文件中指定配置设置，如下所示：

```
repo foo
 RW+                            =  adam
 config    receive.fsckObjects  =  true

```

### 注意

然而，在使用此功能之前，你需要在*rc*文件`($HOME/.gitolite.rc)`中启用你希望使用的配置键。请在该文件中查找包含`GIT_CONFIG_KEYS`一词的行，并编辑其值，默认值为空，将其修改为包含你计划使用的配置键的以空格分隔的列表。

一般来说，语法是`config sectionname.keyname = value`。在服务器上，这会作为`git config sectionname.keyname value`执行。Gitolite *不*支持`git config`命令的其他任何形式，尤其是带有多个值的键。

## 删除 git-config 键

不幸的是，一旦 Gitolite 创建了一个 git `config`键，仅仅从配置文件中删除该行，在下次推送时并不会从仓库配置文件中删除该键。这是因为你*可以*选择直接在服务器上添加键（或者你的仓库在迁移到 Gitolite 管理时可能继承了一些有用的设置）。Gitolite 没有简单的方法来区分你手动创建的`config`键和在配置文件中删除的键；也就是说，虽然可以做到，但这很复杂且容易出错。

因此，Gitolite 需要以下语法，以便明确从服务器上的仓库配置文件中删除一个`config`键：

```
 config  sectionname.keyname  =  ""

```

这是使用 Gitolite 删除`config`键的唯一方法。

## 替换仓库名称

有时候你需要在多个仓库中使用相同的配置设置，但只需要改变仓库名称。显而易见的方法似乎是这样做：

```
repo foo
 config hooks.mailinglist = foo-commits@example.tld
 config hooks.emailprefix = "[foo] "
repo bar
 config hooks.mailinglist = bar-commits@example.tld
 config hooks.emailprefix = "[bar] "

```

但，当然，这完全无法扩展！

Gitolite 允许你做以下操作：

```
repo foo bar
 config hooks.mailinglist = %GL_REPO-commits@example.tld
 config hooks.emailprefix = "[%GL_REPO] "

```

Gitolite 在实际应用配置行时，将令牌`%GL_REPO`扩展为每个仓库的名称。

### 提示

别忘了，在 `repo` 行中，你可以有一个或多个仓库组，或者仓库和组的组合。如果需要，你还可以使用 `@all`。

## 重写配置值

有时，你可能希望将一个配置值应用到所有仓库，除了其中一个或两个。例如，考虑前面提到的 `hooks.mailinglist config` 变量，假设对于大多数仓库，该设置是正确的，但某个特定仓库需要一个完全不同的邮件列表。

Gitolite 允许你按以下方式操作。首先添加适用于所有仓库的一般设置。然后，针对特定仓库添加特定设置。Gitolite 会确保对于任何仓库，最后看到的配置设置会被使用（因此，这些语句的顺序非常重要）：

```
repo @all
 config hooks.mailinglist = %GL_REPO-commits@example.tld
 config hooks.emailprefix = "[%GL_REPO] "
repo foo
 config hooks.mailinglist = foo-list@users.example.tld

```

如果你希望提到的特殊仓库甚至没有相应的配置条目在其配置文件中，你甚至可以对最后一行使用空值。

## Gitolite 选项

类似于 Git 的配置键和值，Gitolite 也有自己的一套内部选项，这些选项用于以某种方式修改其默认行为或提供某些功能可能需要的额外信息。例如，如果你使用 Gitolite 的镜像功能（在第十一章，*镜像*中讨论），你需要为每个仓库指定哪个服务器是主服务器，哪些是从服务器。这些服务器名称是通过 Gitolite 选项指定的，如下所示：

```
repo foo
 option mirror.master    =   mars 
 option mirror.slaves    =   phobos 

```

当镜像代码运行时，它会查询 Gitolite 以获取这些选项的值，从而完成其任务。

Gitolite 选项的行为与之前展示的 `config` 项目类似，后来的条目会覆盖之前的值。

# 将 deny 规则应用于读访问

在上一章中，当我们讨论 `deny` 规则时，我们仅在写操作的上下文中展示了这些规则，用于控制某个分支或标签是否可以被推送。

默认情况下，在检查读访问时不会检查 deny 规则。所以像以下这样的内容：

```
@junior-devs = alice bob carol
repo foo
 -             =  bob
 RW+           =  @junior-devs

```

即使 deny 规则首先出现，它也不会阻止 Bob 至少读取仓库（也就是使用 `git clone` 或 `git fetch`）。

然而，在这种情况下，也可以使 Gitolite 对 deny 规则生效。这是通过指定一个名为 `deny-rules` 的 Gitolite 选项来实现的，如下所示：

```
repo foo
 -                   =  bob
 RW+                 =  @junior-devs
 option deny-rules   =   1

```

现在，Bob 甚至无法克隆该仓库。

### 注意

同样重要的是要理解，对于读访问，指定实际的分支作为 deny 规则，如下所示：

```
 -          master    =  bob
 RW+                  =  @junior-devs

```

与规则中没有分支相同。这是因为 Git（因此 Gitolite）在进行读访问控制时不区分分支，所以任何指定的 refex 都会被忽略。

`deny-rules` 选项将防止写访问，方式与防止读访问相同。允许用户写入他们无法读取的内容是没有意义的！

# 理解 VREFs

前一章向我们介绍了*refex*的概念，它是一个正则表达式，用于匹配正在推送的 ref。这样我们就可以根据推送的 ref（分支或标签）的名称来决定是否允许或拒绝推送。

然而，我们可能有其他标准来决定是否允许或拒绝推送。最常见的例子是是否更改了特定的文件，如果有，则拒绝推送。

*VREF*是一种特殊类型的 refex；其中“V”代表“虚拟”。这是一种不会匹配 Git 已知的 ref（即分支名称或标签名称）的 refex。相反，它会尝试与推送的提交或提交序列的某些其他特征进行匹配。

这是一个示例。假设你正在运行一个项目，其中构建系统，尤其是`Makefile`，是一个非常关键的组件，并且已经经过精心调试，可以很好地与产品构建和销售的所有环境兼容。因此，你确实不希望除了最有经验的人以外的任何人修改这个文件（以及可能与之相关的其他文件）。因此，你希望防止你的初级开发人员推送对其的更改。你可以这样做：

```
repo foo
 RW+                      =  @developers
 -  VREF/NAME/Makefile    =  @junior-developers

```

这基本上就是你需要做的。首先，检查推送的 ref（在这个例子中，我们通过允许所有开发人员——包括初级开发人员——推送任何分支来简化了这一过程）。一旦这个操作成功，*VREFs* 会按照规则列表中出现的顺序进行检查。

一个 VREF 规则有一个简单的结构，由单词`VREF`组成，后跟 VREF 的名称（在这个例子中是`NAME`，它是一个检查已更改文件和目录名称的 VREF），然后是某种类型的参数。更改的文件名列表会与该参数进行匹配，如果找到匹配项，就像你尝试推送一个分支并且 refex 匹配一样，这意味着规则行中的权限会决定接下来发生什么。在这个例子中，这将导致推送被拒绝。

这为你简单地预览了 VREF 特性。第十章，*理解 VREFs*，将详细讲解 Gitolite 这个强大特性的更多细节。

# 总结

本章我们讨论了 Gitolite 的一些高级特性，如个人分支、Git 配置变量、Gitolite 选项等等。下一章将重点介绍 Gitolite 的另一个非常强大且受欢迎的特性——允许用户在不需要向 conf 文件中添加任何内容的情况下创建自己的仓库。
