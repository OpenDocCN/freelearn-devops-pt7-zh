# 第五章：管理仓库

使用 Gitolite 的一个优点是你不需要手动创建新仓库、设置权限等。Gitolite 会根据`gitolite-admin`仓库中的特定文件(`conf/gitolite.conf`)的内容为你完成所有这些操作。本章将展示如何将新仓库添加到 Gitolite，并且如何将现有仓库纳入 Gitolite 的管理。

# 添加仓库

要添加一个新仓库，你需要在`gitolite-admin`仓库的克隆中执行以下操作。

首先，编辑`conf/gitolite.conf`文件。这个文件应该已经有一些内容，例如：

```
repo    gitolite-admin
 RW+     =   adam
repo    testing
 RW+     =   @all

```

这基本上意味着只有名为`adam`的用户有权限对`gitolite-admin`仓库进行更改，所有用户都有权限对测试仓库进行更改。

要添加一个新仓库，你需要添加一个`repo`行，并至少添加一条访问控制规则。例如：

```
repo    my-repo-1
 RW+     =   adam

```

这将创建一个名为`my-repo-1`的仓库，使得`adam`是唯一能够读取或写入它的用户。

如果没有添加访问规则，仓库将不会被创建。例如，如果你有如下内容：

```
repo    my-repo-1
repo    my-repo-2
 RW+     =   adam

```

那么`my-repo-1`仓库既不会被创建，也不会以任何方式被 Gitolite 识别。

但是，你可以在`repo`行中指定多个仓库名称，所以下面的命令完全是可以的：

```
repo    my-repo-1 my-repo-2
 RW+     =   adam

```

# 添加现有的仓库

如前一节所述，添加一个仓库将会在服务器上创建一个空的裸仓库。你可以通过推送你喜欢的任何内容来填充这个仓库。这肯定是将现有内容纳入 Gitolite 管理的一种方式，只要这些仓库之前没有自己的 Git 钩子。

然而，大多数站点将有几个现有的仓库需要纳入 Gitolite 管理，而通过创建一个空仓库并从工作站推送内容的方式可能会非常慢，特别是当内容已经在服务器上时。本节将告诉你如何快速轻松地做到这一点。

### 提示

始终建议有备份，这样在按照描述的步骤操作时如果发生意外情况，你可以恢复。

首先，确保你查看的现有仓库是裸仓库。裸仓库是没有工作树的仓库。你不能可靠地推送到一个附带工作树的仓库，因此服务器上的仓库必须始终是裸仓库。通常，通过给`git init`或`git clone`命令传递`--bare`选项来创建裸仓库。本章后面的部分会描述如何将非裸仓库转换为裸仓库。

接下来，将裸仓库移动或复制到`$HOME/repositories`，这是 Gitolite 期望找到它所管理的所有仓库的位置。在进行此操作时，请确保仓库的名称以`.git`结尾。

### 注意

在常见的 Git 使用中，裸仓库通常以`.git`结尾命名，而非裸仓库没有扩展名。然而，在 Gitolite 中，结尾的`.git`是必要的，不再仅仅是一个约定。

一旦所有仓库就位，运行`gitolite setup`命令。

最后，在`gitolite-admin`仓库的克隆中，将这些仓库添加到`conf/gitolite.conf`文件中，如前所述，保存更改，添加、提交并推送。

# 常见问题及故障排除

在某些情况下，你可能需要修改前面描述的程序。本节将描述你可能遇到的一些问题以及如何解决它们。

## 所有权和权限

Gitolite 期望`$HOME/repositories`中的所有文件和目录都归 Gitolite 托管用户所有，并且该用户被允许对所有文件进行写操作。如果此条件未得到满足，Git 和 Gitolite 都会受到影响。

这种条件被违反的最常见原因是管理员以 root 身份复制了一些文件（比如一些现有的仓库）。当文件以 root 身份复制时，通常不会赋予它们所在目录的所有者和组 ID，而是原始所有者或执行复制操作的用户的 ID。

你可以通过在相关仓库上运行`ls -alR`来查看；如果所有文件和目录的所有者和组不是`git`（托管用户），那么你需要修改该仓库的所有权。

为了解决这个问题，请运行以下命令：（与前面章节一样，我们假设 Gitolite 托管用户是 git；如果不是，请相应替换。）

```
# as root
cd ~git
chown -R git:git repositories
chmod -R u+rwX repositories

```

如果没有所有权问题，但由于某种原因你确实遇到了权限问题，你可以省略`chown`命令，并以`git`身份执行其余操作（也就是说，你无需以 root 身份登录）。

## 将非裸仓库转换为裸仓库

裸仓库是没有工作区的仓库。相反，在非裸仓库中包含在特殊的`.git`目录中的文件和目录，会直接放置在仓库的顶级目录下。

将非裸仓库转换为裸仓库的一种方式是使用`--bare`选项进行克隆。以下命令是实现这一操作的最通用方式：

```
git clone –bare /somewhere/repo ~/repositories/repo.git

```

然而，这会将源代码的完整副本复制到目标位置，如果仓库非常大，这可能会成为一个问题。但如果源仓库和目标仓库位于同一文件系统中，Git 提供了一个非常有用的优化，你可以利用这个优化。只需在`clone`命令中添加`-l`选项即可：

```
git clone –bare -l ~/somewhere/repo ~/repositories/repo.git

```

`-l`选项告诉 Git 使用硬链接，而不是将文件复制到新仓库中，这几乎是瞬间完成的，无论仓库的大小如何。由于使用硬链接（而不是符号链接），在克隆完成后，你可以自由删除源仓库，它不会对新创建的目标仓库造成任何影响。

无论哪种方式，到此为止，你需要将源仓库中`hooks`目录下已存在的钩子文件复制到目标仓库的`hooks`目录中。因为`clone`方法不会携带钩子。

### 提示

Git 专家会意识到，将一个非裸仓库（如`my-repo`）转换为裸仓库的另一种方法是将`.git`目录提升一级，并重命名为`my-repo.git`。即通过运行命令`mv my-repo/.git my-repo.git`。此时，可以删除旧的`my-repo`目录。像往常一样，在删除任何东西之前，确保有备份。

## Gitolite 与更新钩子

Gitolite 的推送操作访问控制机制涉及钩入 Git 的`update`钩子机制（查看`githooks`的手册页面，了解 Git 提供的各种钩子）。

因此，如果你的现有仓库已经有了一个更新钩子，运行之前描述的`gitolite setup`将会删除这个现有的钩子，并用 Gitolite 自己的更新钩子替代它。

Gitolite*确实*提供了一种机制，允许你的旧`update`钩子也能够运行，但它需要由 Gitolite 来运行。为此有一个支持的机制，称为`VREF`，将在第七章《高级访问控制与配置》中简要描述，并在第十章《理解*VREFs*》中详细说明。

# 总结

本章向你展示了如何添加自己的代码库，并介绍了一些在将现有代码库引入 Gitolite 控制时可能出现的常见问题。上一章已经涵盖了添加用户的内容，因此我们现在可以开始查看访问控制了。访问控制是 Gitolite 存在的原因，下一章将（终于！）向你展示一些基本的访问控制语法、规则及其他细节。
