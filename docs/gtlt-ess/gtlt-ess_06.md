# 第六章：开始使用访问控制

到现在为止，你已经知道如何将新用户添加到 Gitolite 系统中，以及如何创建新仓库或将现有仓库纳入 Gitolite 的控制。现在是时候将这些内容结合起来，了解*访问控制*，这是大多数网站安装 Gitolite 的主要原因。

# 基本访问控制示例

任何 Git 管理员首先想到的访问控制方面，是防止某些人访问仓库的能力。我们将从一些简单的例子开始，然后再描述语法。这里是一个非常简单的规则集，适用于一个名为`foo`的仓库：

```
repo foo
 R    =  alice
 RW   =  bob
 RW+  =  carol

```

这些规则规定了 Alice、Bob、Carol 以及其他任何 Gitolite 用户可以对该仓库执行哪些操作。正如你从 Alice 的简单 R 权限中可能猜到的（或者换句话说，正是因为她的权限字符串中没有`W`），她仅被允许读取该仓库，这意味着她可以使用`git clone`、`git fetch`和`git ls-remote`命令，但不能以任何形式使用`git push`。

Bob 和 Carol 都被允许向仓库推送更改。和之前一样，你可能从他们权限行中的`W`字符中猜到了这一点。可能不那么显而易见的是 Carol 权限字符串中`+`字符的意义。这个额外的字符允许 Carol 进行*强制*推送，即使新对象不是旧对象的后代，她也可以将新对象推送到引用中。在 Git 术语中，这叫做非快进推送，即使在没有访问控制系统的普通 Git 使用中，也需要用户明确采取操作才能成功。如果你不熟悉这个概念，请参考 man `git-push`和其他 Git 文档。

选择`+`字符是因为它提醒你在`git push`命令中使用`+`来选择性地强制推送某些引用（refs）。(有关更多细节，请参考`git push`命令 man 页面中的`refspec`字段描述)。尽管我们在本章中不会遇到这种用例，但为了完整性，我们还是应该提到，`+`字符还允许用户*删除*引用，尽管在`git push`命令中对应的语法并没有使用`+`符号。

对于许多安装来说，这个基本的例子已能满足所有需求——即区分那些只能读取但不能写入的人，并且在允许写入的人中，防止某些人进行危险的强制推送（或者更糟的是，删除一个重要的分支或标签）。

## 基本分支级别访问控制

下一个示例将展示另一个非常常见的需求：限制某些人（也许是初级开发者或实习生）只能推送特定命名空间中的分支。这是一个相当常见的情况，其中最重要的分支（例如 master，或者也许是 next，或者你工作流中使用的任何分支命名）只能由受信任的开发者修改，这些开发者大概已经审核了代码并认为它是可以接受的。初级开发者和/或实习生编写的代码通常不会被视为自动可接受，通常很有必要以某种方式对他们进行*沙盒*限制。

### 提示

有趣的是，这个特定的用例似乎更多地与开发者的信任和成熟度有关，而非单纯的安全问题。然而，在控制或防止此类行为方面，意外覆盖主分支和恶意覆盖主分支之间没有区别。

这是一个实现此类限制的访问控制规则集示例：

```
repo foo
 R          =  alice
 RW+        =  bob
 RW+  dev/  =  carol

```

这允许 Carol 读取该仓库并向其推送，但它阻止她推送任何除以`dev/`开头的分支之外的内容。相比之下，Bob 的访问规则在权限字段后没有指定任何内容，因此他可以推送任何分支。

# 配置文件的词法语法

现在我们已经看到了几个有用且可立即使用的示例，是时候查看`conf/gitolite.conf`文件的**词法**语法了（在 Gitolite 中，通常称其为*配置文件*）。

配置文件是一个纯文本文件，其整体语法遵循一些简单的规则。

Gitolite 用户名（例如`alice`、`bob`等）必须以字母数字字符开头，并包含字母数字字符、句点、连字符、下划线或`@`符号。如果存在`@`符号，它后面必须跟着一个域名（即包含至少一个句点的内容）。这使得可以使用电子邮件地址作为用户名，这在组织中有多个 John Smith 时非常有用！

仓库名称必须以字母数字字符开头，并包含字母数字字符、句点、连字符、下划线或斜杠。然而，它们不能以斜杠开头或以斜杠结尾。

允许使用注释；语法与 shell、perl 等相同。任何以`#`符号开头的内容都被视为注释并被丢弃。

### 提示

默认情况下不允许使用续行（C 风格）。但是，通过编辑`$HOME/.gitolite.rc`文件（我们将在第七章《高级访问控制与配置》中详细讨论），你可以启用此功能。

# 访问控制规则的语法

访问控制列表有一个简单的结构。简而言之，它的结构如下：

```
repo <one or more repos or repo-groups>
 <permission>    <zero or more refexes>  =  <one or more users or user-groups>

```

一个配置文件有一个或多个`repo`行。每个 repo 行包含单词`repo`，后跟一个或多个仓库名称或仓库组名称（我们将在本章稍后讨论组）。这些仓库或组名称必须都在同一行。

每个`repo`行后面跟着一个或多个适用于该仓库或组的*访问规则*。访问规则包括以下内容：

+   一个权限字段（例如，R、RW 等）

+   零个或多个*引用模式*（引用模式在下一节会详细讲解，但你已经见过的一个例子是`dev/`）

+   一个`=`符号作为分隔符

+   最后是一个用户或用户组名称的列表

# 分支级别的访问控制和引用模式

本节将讨论 Gitolite 中一个非常重要的部分——指定谁可以对哪个分支或标签进行更改。作为历史背景，缺乏这个功能，正是当时最流行的 Git 服务器管理工具无法提供这一功能的唯一原因，进而促使了 Gitolite 的诞生。

### 提示

本节假设读者对*正则表达式*有一定了解。

要理解分支级别的访问控制以及如何在 Gitolite 中指定它们，我们应该首先快速回顾 Git 本身的相关概念，以便更容易理解。

Git 使用`ref`一词来指代分支和标签。分支名称通常为`refs/heads/某个名称`，而标签名称则为`refs/tags/某个名称`。当用户推送到 Gitolite 管理的仓库时，Gitolite 帮助你判断是否允许该用户更新正在更新的*引用*。

因此，为了允许 Bob 推送名为 master 的分支，你可以写下：

```
RW+  refs/heads/master  =  bob

```

当用户推送到仓库时，Git 会将推送的引用名称提供给 Gitolite。Gitolite 随后会将该引用与访问规则行中的每个引用模式（refex）进行匹配。如果匹配成功，并且用户也出现在`=`符号的右侧，那么该推送将被允许。

然而，由于分支比标签更频繁地进行访问控制，Gitolite 假设任何不以`refs/`开头的内容都应被视为以`refs/heads/`为前缀。因此，你可以直接这样写：

```
RW+  master    =  bob

```

这将被视为`refs/heads/master`。

严格来说，前述数据允许 Bob 推送任何以`master`开头的分支名称。要将规则限制为仅`master`，实际上应该将引用模式写为`master$`。但在实际应用中，这种情况很少需要。

控制标签同样简单。假设你想允许用户推送任何以字母 v 开头，后跟数字，后面可选地跟着其他内容的标签。以下是该规则：

```
RW+  refs/tags/v[0-9]  =  bob

```

正则表达式模式`[0-9]`表示从`0`到`9`之间的任意字符（包括 0 和 9）。

Gitolite 仅在开头锚定这个正则表达式，而不是在结尾。在正则表达式的术语中，这意味着在开始处隐式添加了一个 `^` 字符，但结尾处并没有添加 `$` 字符。这使得 Bob 可以推送类似 `v1`、`v2.2`、`v3.4.5` 等标签，但不能推送 `new-v1` 和 `next-v2`。

因此，我们来定义一下*refex*：refex 是一个正则表达式（即正则表达式），用于匹配正在推送的引用。

## 使用拒绝规则

到目前为止，我们看到的规则允许你指定用户可以推送哪些分支或标签。然而，我们通常需要能够指定，例如，允许用户推送*所有分支，除了 master*。

为了做到这一点，我们需要使用 Gitolite 所称的*拒绝*规则。以下是你如何为用户实施上述限制的示例：

```
-         master    =  bob
RW+                 =  bob

```

当 Gitolite 尝试确定是否允许推送某个分支时，它按顺序检查规则。当 Bob 将名为 `next`（即 `refs/heads/next`）的分支推送到此仓库时，第一个规则完全不匹配，因为 `refs/heads/master` 不是与 `refs/heads/next` 字符串匹配的模式。然后 Gitolite 检查下一个规则。由于此规则没有指定 refex，因此所有引用都将匹配，并且由于权限字段为 `RW+`，推送被允许。

然而，当 Bob 推送 `refs/heads/master` 时，引用匹配第一个规则中的正则表达式，由于该规则是拒绝规则，因此推送被拒绝。

细心的读者会注意到，规则的顺序在这里非常重要。如果我们交换这两个规则的顺序，那么我们想要实施的限制将会被移除。首先遇到的规则将是：

```
RW+      =  bob

```

这不指定 refex，因此会匹配所有引用。因此，操作可以继续进行。换句话说，拒绝规则根本不会被检查！

## 权限字段

我们现在已经看到了四种最常见的权限示例，因此总结它们是个好主意。

`R` 权限允许用户读取（克隆、获取）仓库，但不允许推送。`RW` 允许用户推送，但仅在快速前进推送或创建新分支时允许。非快速前进推送和删除是不允许的。而 `RW+` 也允许非快速前进推送和删除。

只要你的规则集仅包含这三种类型的规则，它们的顺序并不重要。然而，正如你在上一节中看到的，当你使用第四种规则——拒绝规则（由单个减号表示）时，规则的顺序就变得很重要。

### 提示

虽然这些是最常用的权限，但并非全部。还有一些其他权限将在第七章的*写操作类型*一节中出现，*高级访问控制和配置*。

# 定义用户和仓库组

Gitolite 允许你定义用户组或仓库组以便于管理。语法非常简单，并且不区分用户组和仓库组。例如，看看前一节中的拒绝规则示例：

```
-         master    =  bob
RW+                 =  bob

```

假设，现在不仅仅是 Bob，你还有几个用户必须被阻止推送到 `master` 分支，也许是因为他们都是初级开发者。一个方法是将他们每个用户的用户名添加到两条规则的后面，紧接着 Bob 的用户名，像这样：

```
-          master    =  bob carol dave
RW+                  =  bob carol dave

```

但这样会变得繁琐，而且如果有更多规则应用到同一组人身上，情况只会更糟。

然而，使用组时，你可以这样做：

```
@junior-devs    =  bob carol dave

-          master    =  @junior-devs
RW+                  =  @junior-devs

```

如你所见，这要方便得多，而且也更不容易出错。更重要的是，组名通常可以作为规则集的重要文档——未来的管理员可能不知道 Bob、Carol 和 Dave 是谁，也许会困惑他们为什么会被限制，但组名如果选得好，就能让一切变得非常清晰。

你也可以为仓库使用组名，例如：

```
@foss-repos  =  git linux apache gcc

repo @foss-repos
 R  =  @all

```

虽然在这种情况下，可能看起来不那么重要，因为组名仅替代了仓库名中的一次出现，但它仍然更简洁。而且，就像用户组名一样，仓库组名也能作为这些仓库性质的附加文档。

## 与大组合作

有时候你需要一个包含多个成员的组——成员数量远超一个行内可以轻松编辑的数量。为了使这更容易（并且因为 Gitolite 默认不允许续行），Gitolite 将每个组的定义视为累积的。这意味着，如果该组已经在之前定义过，新的成员将被添加到其中，而不是替换现有的成员列表。这使得你可以这样写：

```
@foss-repos  =  git
@foss-repos  =  linux
@foss-repos  =  apache

```

这将与我们在本节前面看到的单行定义产生相同的效果。

## 特殊的 @all 组

Gitolite 还有一个特殊的内置组叫 @all，它指代所有的仓库或所有的用户，具体取决于它的使用位置。一个常见的用途是允许某些特权用户访问所有仓库，可能是如下所示：

```
repo @all
 R            =  @QA-leads
 RW+          =  @dev-leads

```

另一个示例，让我们考虑一个只有 Adam 和 Dave 被允许推送 `master` 分支的情况。你可能会这样做：

```
repo foo
 RW+  master         =  adam dave
 -         master    =  @all

```

这里有一个*拒绝*规则，所以再次提醒，规则的顺序很重要。如果我们将*拒绝*规则放在前面，那么——因为 Adam 和 Dave 隐式地是 @all 的成员——他们也会被拒绝推送到主分支的权限。

# 包含语句

你还可以将访问规则和组定义分拆到多个文件中，并将它们*包含*到主配置文件（在你的 gitolite-admin 仓库中的 `conf/gitolite.conf`）中。例如，你可以将所有组信息（即哪些用户是哪些组的成员）保存在一个单独的文件中并包含它。语法非常简单，下面是一个示例：

```
include "groups.conf"

```

这将会在 `conf` 目录下查找一个名为 `groups.conf` 的文件，并在此处包含其内容。

高级用户可能注意到，这个命令也支持通配符。例如，你可能在 `conf` 目录下的一个子目录中有几个单独的配置文件，名为 `foss`。如果你不想单独列出它们，你可以这样写：

```
include "foss/*.conf"

```

# 规则汇总和委托

Gitolite 允许你将仓库的访问规则拆分为多个不一定是连续的部分。然后，它会将所有这些部分（按读取顺序）组合在一起，并将合并后的规则集应用到相关的仓库中。

这种行为有很好的应用场景。将组、包含语句和规则汇总结合起来，使得 Gitolite 管理比之前更为简便。以下是一个示例，带有一些注释，帮助你理解可以做哪些操作。

```
include "groups.conf"
# contains definitions of all groups used in the rest of the conf file.  All
# membership changes happen here

include "foss.conf"
# contains rules for open source repositories.  For example, "R = @all" is
# pretty much expected for such repositories.  There may be other rules
# specific to different FOSS repositories that may also be specified here

include "boss.conf"
# contains rules that define what kind of access management has to the
# development repositories.  For example, some of the managers may have
# read access to all repositories, so something like
#    repo @all
#      R  =  scott douglas
# is probably quite useful.

# repo-specific rules
# At this point you could have repository specific rules that do not fit neatly
# into any of the previous include files.  For example:
repo git
 RW+  =  linus junio

```

如你所见，仓库可以出现在主配置文件加载的任何或所有包含文件中。如果我们要求每个仓库的所有规则都集中在一个地方，那么以这种方式组织规则就变得不可能。

# 总结

我们现在已经了解了 Gitolite 的大多数基本访问控制功能，包括各种类型的访问规则、配置文件的语法，以及一些便捷的功能来简化管理。下一章，我们将讨论一些高级访问控制功能，如个人分支和**VREFs**。
