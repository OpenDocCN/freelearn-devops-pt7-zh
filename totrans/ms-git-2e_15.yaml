- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Managing Large Repositories
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理大型仓库
- en: Because of its distributed nature, Git includes the full change history in each
    copy of the repository. Every clone gets not only all the files but every revision
    of every file ever committed. This allows for efficient development (local operations
    not involving a network are usually fast enough so that they are not a bottleneck)
    and efficient collaboration with others (their distributed nature allows for many
    collaborative workflows).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其分布式特性，Git在每个仓库副本中都包括完整的变更历史。每次克隆不仅获取所有文件，还会获取每个文件的所有修订版本。这使得开发变得高效（不涉及网络的本地操作通常足够快速，不会成为瓶颈）并且与他人协作也很高效（其分布式特性支持多种协作工作流）。
- en: But what happens when the repository you want to work on is huge? Can we avoid
    taking a large amount of disk space for version control storage? Is it possible
    to reduce the amount of data that end users need to retrieve while cloning the
    repository? Do we need to have all files present to be able to work on a project?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你想要处理的仓库非常庞大时会发生什么？我们能否避免占用大量磁盘空间进行版本控制存储？是否可以在克隆仓库时减少最终用户需要检索的数据量？我们是否需要所有文件都存在才能在项目中工作？
- en: 'If you think about it, there are broadly three main reasons for repositories
    to become massive: they can accumulate a very long history (every revision direction),
    they can include huge binary assets that need to be managed together with code,
    the project can include a large number of files (every file direction), or any
    combination of those. For those scenarios, the techniques and workarounds are
    different and can be applied independently, though modern Git also includes a
    one-stop solution.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑一下，你会发现仓库变得庞大的原因大致有三种：它们可能会积累非常长的历史（每个修订方向），它们可能包含需要与代码一起管理的大型二进制资产，项目可能包含大量文件（每个文件方向），或者这些原因的任何组合。对于这些情况，技术和解决方法是不同的，并且可以独立应用，尽管现代Git也包含了一站式解决方案。
- en: Submodules (presented in the previous chapter, *Managing Subprojects*) are sometimes
    used to manage large-size assets. This chapter will describe how this can be done
    while also presenting alternate solutions to the problem of handling large binary
    files and other large assets in Git.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 子模块（在前一章中介绍的，*管理子项目*）有时用于管理大型资产。本章将介绍如何在处理大型二进制文件和其他大型资产时，使用子模块以及其他替代解决方案。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Git and large files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git和大型文件
- en: Handling repositories with a very long history with a shallow clone
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浅克隆处理具有非常长历史的仓库
- en: Storing large binary files in a submodule or outside the repository
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将大型二进制文件存储在子模块中或仓库外部
- en: Reducing the size of the working directory with sparse checkout
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用稀疏检出减少工作目录的大小
- en: How to make a local repository smaller with a sparse clone
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过稀疏克隆缩小本地仓库的大小
- en: Which operations will require network access in different variants of sparse
    clone
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同变种的稀疏克隆中，哪些操作需要网络访问
- en: Faster operations with filesystem monitor
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件系统监视器加速操作
- en: Scalar – Git at scale for everyone
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scalar – 适用于所有人的大规模Git
- en: The simplest way to configure Git so that it works better with large repositories,
    apart from enabling the relevant Git features, is to use the built-in `scalar`
    tool. This executable has been present in Git since version 2.38, which was released
    in 2022\. Earlier, it was a separate project, then part of Microsoft’s fork of
    Git.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Git以便更好地处理大型仓库的最简单方法，除了启用相关的Git功能外，就是使用内置的`scalar`工具。这个可执行文件自2022年发布的Git 2.38版本以来一直存在，在此之前它是一个独立的项目，后来成为了Microsoft的Git分支的一部分。
- en: 'Using it is very simple: instead of using `git clone`, you use `scalar clone`.
    If the repository has already been cloned, you can run `scalar register` to achieve
    the same result. One of the things that the command does is schedule background
    maintenance; you can stop this and remove the repository from the list of repositories
    that have been registered with `scalar` by using the `scalar unregister` command.
    The `scalar delete` command unregisters the repository and removes it from the
    filesystem.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它非常简单：你只需要用`scalar clone`代替`git clone`。如果仓库已经被克隆，你可以运行`scalar register`来实现相同的效果。这个命令所做的一项工作是调度后台维护；你可以通过使用`scalar
    unregister`命令停止这个过程，并将仓库从已注册的仓库列表中移除。`scalar delete`命令会取消注册仓库并将其从文件系统中删除。
- en: After a `scalar` upgrade (which might be caused by moving to newer Git), you
    can run `scalar reconfigure --all` to upgrade all repositories registered with
    Scalar.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`scalar`升级后（可能是由于迁移到更新的 Git 版本），你可以运行`scalar reconfigure --all`来升级所有使用 Scalar
    注册的仓库。
- en: By registering the repository with Scalar (or the top-level directory of the
    project, which is called the **enlistment** in the Scalar documentation), you
    can turn on **partial clone** and **sparse-checkout**, configure Git to use **filesystem
    monitor**, and turn on **background maintenance** tasks such as **repository prefetching**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Scalar 注册仓库（或项目的顶级目录，在 Scalar 文档中称为**登记**），你可以开启**部分克隆**和**稀疏检出**，配置 Git
    使用**文件系统监控**，并开启**后台维护**任务，如**仓库预取**。
- en: All these features will be described in the following sections, as will some
    other features for handling large Git repositories that are more specific to users’
    needs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能将在接下来的章节中描述，还会介绍一些更具体针对用户需求的大型 Git 仓库处理功能。
- en: Handling repositories with a very long history
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理具有非常长历史的仓库
- en: Even though Git can effectively handle repositories with a long history, very
    old projects spanning a huge number of revisions can become a pain to clone. In
    many cases, you aren’t interested in ancient history and don’t want to pay the
    time to get all the revisions of a project and the disk space to store them. In
    this section, we will talk about techniques that you can use to clone truncated
    history, or how to make Git fast despite the long history.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Git 可以有效处理具有长历史的仓库，但非常古老的项目，跨越大量修订版本，可能会让克隆变得非常麻烦。在许多情况下，你对远古历史不感兴趣，也不想花费时间获取项目的所有修订版本以及存储它们的磁盘空间。在本节中，我们将讨论你可以用来克隆截断历史的技术，或者如何让
    Git 在长历史的情况下仍然快速。
- en: For example, if you want to propose a new feature or a bug fix, you might not
    want to wait for the full clone to finish, which may take a while.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想提出一个新功能或修复一个 bug，你可能不想等到完整克隆完成，因为这可能需要一段时间。
- en: Editing project files online
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在线编辑项目文件
- en: Some Git repository hosting services, such as GitHub, offer a web-based interface
    to manage repositories, including in-browser file management and editing. They
    may even automatically create a fork of the repository so that you can write and
    propose changes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Git 仓库托管服务，比如 GitHub，提供一个基于网页的界面来管理仓库，包括浏览器内的文件管理和编辑。它们甚至可能会自动创建仓库的一个分叉，以便你可以编写并提出更改。
- en: But a web-based interface doesn’t cover everything, and you might be using self-hosted
    repositories or a service that doesn’t provide this feature.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但基于网页的界面并不能涵盖所有内容，你可能在使用自托管仓库或不提供此功能的服务。
- en: However, fixing the bug might require running `git bisect` on your machine,
    where the regression bug is easily reproducible (see [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083),
    *Exploring Project History*, for how to use bisection). If you’re tight on space
    and time, you might want to try to do either a shallow clone (described in the
    following subsection) or a sparse clone (described later in this chapter).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，修复这个 bug 可能需要在你的机器上运行`git bisect`，在这里回归 bug 容易复现（请参见[*第4章*](B21194_04.xhtml#_idTextAnchor083)，*探索项目历史*，了解如何使用二分法）。如果你时间和空间都紧张，可能想尝试执行浅克隆（在下面的小节中描述）或稀疏克隆（本章稍后描述）。
- en: Using shallow clones to get truncated history
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用浅克隆来获取截断的历史
- en: The simple solution to a fast clone and to save disk space is to perform a **shallow
    clone** using Git. This operation allows you to get a local copy of the repository
    with the history truncated to a particular specified **depth** – that is, the
    number of latest revisions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 快速克隆并节省磁盘空间的简单解决方案是使用 Git 执行**浅克隆**。此操作允许你获取一个本地仓库副本，并将历史记录截断到特定的**深度**——即最新的修订版本数量。
- en: 'How do you do it? Just use the `--``depth` option:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么做呢？只需使用`--depth`选项：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command only clones the most recent revision of the primary branch.
    This trick can save quite a bit of time and relieve a great deal of load from
    the servers. Often, a shallow clone finishes in seconds rather than minutes, which
    is a significant improvement. This can be useful if you’re only interested in
    checking out project files, and not in the whole history, such as what’s inside
    Git hooks or GitHub Actions – that is, the case of builds where you delete the
    clone immediately after the action.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令只克隆主分支的最新修订。这个技巧可以节省大量时间，并减轻服务器的负担。通常，浅克隆几秒钟就完成，而不是几分钟，这是一项显著的改进。如果你只对查看项目文件感兴趣，而不是整个历史（例如，查看Git
    hooks或GitHub Actions中的内容），这种方式非常有用——即，在构建结束后立即删除克隆的情况。
- en: Since version 1.9, Git supports pull and push operations even with shallow clones,
    though some care is still required. You can change the depth of a shallow clone
    by providing the `--depth=<n>` option to `git fetch` (however, note that tags
    for the deepened commits aren’t fetched). To turn a shallow repository into a
    complete one, use `--unshallow`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从Git 1.9版本开始，Git即使在浅克隆的情况下，也支持拉取和推送操作，尽管仍需小心。你可以通过向`git fetch`命令提供`--depth=<n>`选项来更改浅克隆的深度（但请注意，深度增加的提交的标签不会被获取）。要将浅克隆仓库转换为完整仓库，请使用`--unshallow`。
- en: Important note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Since the commit history in a shallow clone is truncated, commands such as **git
    merge-base** and **git log** show different results than they would in a full
    clone. This will happen if you try to go outside the depth of the clone. Also,
    because of how the Git server is optimized, incremental fetch in a shallow repository
    might take longer than using fetch in a full repository. Fetch might also unexpectedly
    make the repository not so shallow.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浅克隆中的提交历史被截断，像**git merge-base**和**git log**这样的命令所显示的结果，与完全克隆的情况不同。如果你尝试访问克隆的深度之外的内容，就会发生这种情况。此外，由于Git服务器的优化方式，浅克隆仓库中的增量获取可能比完全克隆仓库中的获取花费更长时间。获取操作还可能意外地让仓库变得不再是浅克隆。
- en: 'Note that `git clone --depth=1` may still get all the branches and all the
    tags. This can happen if the remote repository doesn’t have `HEAD`, so it doesn’t
    have a primary branch selected; otherwise, only the tip of the said single branch
    is fetched. Long-lived projects usually had many releases during their long history.
    To save time, you would need to combine shallow clone with the next solution:
    branch limiting.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`git clone --depth=1`仍然可能会获取所有分支和标签。如果远程仓库没有`HEAD`，即没有选择主分支，就可能发生这种情况；否则，只有指定的单个分支的最新提交会被获取。长期存在的项目通常在其漫长历史中有许多版本发布。为了节省时间，你需要将浅克隆与下一个解决方案结合使用：分支限制。
- en: With modern Git, it might make more sense to use the **partial clone** feature
    instead.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现代Git时，使用**部分克隆**功能可能更有意义。
- en: Cloning only a single branch
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只克隆单个分支
- en: 'By default, Git clones all the branches and tags (if you want to fetch notes
    or replacements, you need to specify them explicitly). You can limit the amount
    of history you clone by specifying that you want to **clone only a** **single
    branch**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Git会克隆所有分支和标签（如果你想获取备注或替换，需显式指定）。你可以通过指定只想**克隆单个分支**来限制克隆的历史记录数量：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because most of the project history (most of the DAG of revisions) is shared
    among branches, with very few exceptions, you probably won’t see a huge difference
    using this technique.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数项目历史（大部分修订的DAG）在各分支之间是共享的，只有极少数例外，你可能不会发现使用此技巧时有太大的区别。
- en: 'This feature might be quite useful if you don’t want detached orphan branches
    or the opposite: you only want an orphan branch (for example, with a web page
    for a project, or a branch used for GitHub Pages). Single-branch cloning works
    well in regard to saving disk space when they’re used together with a very shallow
    clone (with so short a history that most branches don’t have time to converge).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望有分离的孤立分支，或者相反，只希望拥有一个孤立分支（例如，项目的网页分支，或者用于GitHub Pages的分支），这个功能可能会非常有用。当与非常浅的克隆（历史记录非常短，以至于大多数分支没有足够的时间进行合并）结合使用时，单分支克隆在节省磁盘空间方面表现良好。
- en: Making operations faster in repositories with a long history
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在具有长期历史记录的仓库中加速操作
- en: One of the features that makes Git faster on repositories with a very long history
    is the **commit-graph** file. Using this feature, which is turned on by default
    as of Git 2.24, configures Git to periodically write or update a helper file with
    a serialized (and easy-to-access) graph of revisions. This makes Git operations
    that query project history much faster.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Git 在具有很长历史的仓库中加速的一个特点是 **commit-graph** 文件。使用此功能（从 Git 2.24 版本起默认启用），可以配置 Git
    定期写入或更新一个辅助文件，该文件包含一个序列化的（且易于访问的）修订图。这样，查询项目历史的 Git 操作就会变得更快。
- en: You can turn this feature off by setting the `core.commitGraph` configuration
    variable to `false`. If you need to refresh the helper file, you can do this with
    the `git commit-graph` `write` command.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 `core.commitGraph` 配置变量设置为 `false` 来关闭此功能。如果需要刷新辅助文件，可以使用 `git commit-graph`
    `write` 命令来实现。
- en: Avoiding doing the work
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 避免做繁重的工作
- en: One unexpected place that might get slower with long history is running **git
    status**. This is caused by the command in question computing detailed ahead/behind
    counts for the current branch (how many commits you have on the local branch ahead
    of the upstream branch in the remote repository, how many commits in the remote
    repository you are behind).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能在历史较长时变慢的意外地方是运行 **git status**。这是因为该命令会计算当前分支的详细 ahead/behind 计数（即本地分支领先上游远程分支多少个提交，远程仓库落后多少个提交）。
- en: You can turn off computing this information with the **--no-ahead-behind** option,
    or by setting the **status.aheadBehind** configuration variable to **false**.
    Nowadays, **git status** will print this advice when it is slowed by ahead/behind
    calculations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 **--no-ahead-behind** 选项或将 **status.aheadBehind** 配置变量设置为 **false** 来关闭计算这些信息。现在，**git
    status** 在被 ahead/behind 计算拖慢时会显示此提示。
- en: Handling repositories with large binary files
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理包含大型二进制文件的仓库
- en: In some specific circumstances, you might need to track **huge binary assets**
    in the code base. For example, gaming teams have to handle huge 3D models, and
    web development teams might need to track raw image assets or Photoshop documents.
    Both gaming development and web development might require video files to be under
    version control. Additionally, sometimes, you might want the convenience of including
    large binary deliverables that are difficult or expensive to generate – for example,
    storing a snapshot of a virtual machine image.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些特定情况下，你可能需要在代码库中跟踪 **巨大的二进制资产**。例如，游戏团队需要处理庞大的 3D 模型，网页开发团队可能需要跟踪原始图像资产或
    Photoshop 文档。游戏开发和网页开发都可能需要将视频文件纳入版本控制。此外，有时你可能希望包含那些难以或成本较高的生成的大型二进制交付文件——例如，存储虚拟机镜像的快照。
- en: There are some tweaks you can make to improve how binary assets are handled
    by Git. For binary files that change significantly from version to version (and
    not just change some metadata headers), you might want to turn off the `-delta`
    explicitly for specific types of files in a `.gitattributes` file (see [*Chapter
    3*](B21194_03_split_000.xhtml#_idTextAnchor049), *Managing Your* *Worktrees*,
    and [*Chapter 13*](B21194_13_split_000.xhtml#_idTextAnchor320), *Customizing and
    Extending Git*). Git will automatically turn off delta compression for any file
    above the `core.bigFileThreshold` size, which is 512 MiB by default. You may also
    want to turn the compression off (for example, if a file is in the compressed
    format already). However, because `core.compression` and `core.looseCompression`
    are global for the whole repository, it makes more sense if binary assets are
    in a separate repository (submodule).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些调整可以改进 Git 对二进制资产的处理。对于从版本到版本变化很大的二进制文件（而不仅仅是某些元数据头部的变化），你可能希望在 `.gitattributes`
    文件中显式关闭 `-delta`（参见 [*第 3 章*](B21194_03_split_000.xhtml#_idTextAnchor049)，*管理你的工作树*，以及
    [*第 13 章*](B21194_13_split_000.xhtml#_idTextAnchor320)，*定制和扩展 Git*）。Git 会自动对任何超过
    `core.bigFileThreshold` 大小的文件关闭增量压缩，默认值为 512 MiB。你可能还希望关闭压缩（例如，如果文件已经是压缩格式）。但是，由于
    `core.compression` 和 `core.looseCompression` 对整个仓库都是全局设置，因此如果二进制资产位于单独的仓库（子模块）中，会更有意义。
- en: Splitting the binary asset folder into a separate submodule
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将二进制资产文件夹拆分为单独的子模块
- en: One possible way of handling large binary asset *folders* is to split them into
    a separate repository and pull the assets into your main project as a **submodule**.
    The use of submodules gives you a way to control when assets are updated. Moreover,
    if a developer doesn’t need those binary assets to work, they can simply exclude
    the submodule with assets from fetching.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 处理大规模二进制资源*文件夹*的一种可能方法是将其拆分到一个单独的仓库中，并将资源作为**子模块**拉取到你的主项目中。使用子模块可以让你控制何时更新资源。此外，如果开发者不需要这些二进制资源来工作，他们可以简单地排除包含资源的子模块，从而避免拉取这些资源。
- en: The limitation is that you need to have a separate folder with these huge binary
    assets that you want to handle this way. Additionally, the service hosting the
    submodule repository with those large assets needs to be able to store those large
    files; many Git hosting sites impose hard limits on the maximum size of a file,
    or of the repository.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 限制是你需要为这些巨大的二进制资源准备一个单独的文件夹。如果选择这种方式进行处理，托管包含这些大资源的子模块仓库的服务还需要能够存储这些大文件；许多 Git
    托管网站对单个文件或整个仓库的最大大小设置了严格的限制。
- en: Storing large binary files outside the repository
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将大规模二进制文件存储在仓库之外
- en: Another solution is to use one of the many third-party tools that try to solve
    the problem of handling large binary files in Git repositories. Many of them use
    a similar paradigm, namely storing the contents of huge binary files outside the
    repository while providing some kind of pointers to the contents in the checkout.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是使用许多第三方工具之一，这些工具尝试解决在 Git 仓库中处理大二进制文件的问题。它们中的许多使用类似的方案，即将庞大的二进制文件内容存储在仓库外部，同时提供某种方式的指针来引用检出的内容。
- en: 'There are three parts to each such implementation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每种实现有三个部分：
- en: How they store the information about the contents of the managed files inside
    the repository
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们如何在仓库内存储关于管理文件内容的信息
- en: How they share large binary files between a team
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们如何在团队之间共享大规模二进制文件
- en: How they integrate with Git (and their performance penalty)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们如何与 Git 集成（以及它们的性能惩罚）
- en: While choosing a solution, you need to take this data into account, along with
    the operating system support, ease of use, and the size of the community.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择解决方案时，你需要考虑这些数据以及操作系统支持、易用性和社区的大小。
- en: What’s stored in the repository and what’s checked in might be a *symlink* to
    the file or the key, or it might be a *pointer file* (often plain text), which
    acts as a reference to the actual file contents (by name or by the cryptographic
    hash of file contents). The tracked files need to be stored in some kind of backend
    for collaboration (cloud service, rsync, shared directory, and so on). Backends
    might be accessed directly by the client, or there might be a separate server
    with a defined API into which the blobs are written, which would, in turn, offload
    the storage elsewhere.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库中存储的内容和被检入的内容可能是文件的*符号链接*或密钥，或者可能是一个*指针文件*（通常是纯文本），它作为实际文件内容的引用（通过名称或文件内容的加密哈希）。被跟踪的文件需要存储在某种后端中以便协作（云服务、rsync、共享目录等）。后端可以由客户端直接访问，或者可能有一个单独的服务器，提供一个定义好的
    API，供二进制文件（blob）写入，并将存储卸载到其他地方。
- en: The tool might either require the use of separate commands for checking out
    and committing large files and for fetching from and pushing to the backend, or
    it might be integrated into Git. The integrated solution uses the `clean`/`smudge`
    filters to handle check-out and check-in transparently, and the `pre-push` hook
    to send large file contents transparently together. You only need to state which
    files to track and, of course, initialize the repository for the tool use.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具可能要求使用单独的命令来检出和提交大文件，或从后端获取和推送文件，或者它可能已经集成到 Git 中。集成解决方案使用`clean`/`smudge`过滤器透明地处理检出和检入操作，并使用`pre-push`钩子将大文件内容一同透明地推送。你只需要指定要跟踪的文件，并且当然需要初始化仓库以便工具使用。
- en: The advantage of a filter-based approach is its ease of use; however, there
    is a performance penalty because of how this approach works. Using separate commands
    to handle large binary assets makes the learning curve a bit steeper but provides
    better performance. Some tools provide both interfaces.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基于过滤器的方法的优点在于其易用性；然而，由于该方法的工作方式，它会带来性能上的惩罚。使用单独的命令来处理大规模二进制资源会让学习曲线稍微陡峭，但它提供了更好的性能。一些工具同时提供这两种接口。
- en: Among different solutions, there’s **git-annex**, which has a large community
    and support for various backends, and **Git-Large File Storage** (**Git-LFS**),
    created by GitHub, which provides good Microsoft Windows support, a client-server
    approach, and transparency (with support for a filter-based approach). The Git-LFS
    extension is supported not only by GitHub but also by other Git hosting sites
    and software forges, such as GitLab, Bitbucket, and Gitea. Specialized services
    and projects for implementing Git-LFS also exist.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的解决方案中，有**git-annex**，它拥有一个庞大的社区，并支持各种后端，还有**Git 大文件存储**（**Git-LFS**），由 GitHub
    创建，提供了良好的 Microsoft Windows 支持、客户端-服务器模式，并具有透明性（支持基于过滤器的方式）。Git-LFS 扩展不仅由 GitHub
    支持，其他 Git 托管站点和软件平台，如 GitLab、Bitbucket 和 Gitea，也都支持 Git-LFS。也存在专门的服务和项目来实现 Git-LFS。
- en: There are many other such tools, but those two are the most popular, and both
    are still maintained.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他类似的工具，但这两种是最流行的，而且都仍在维护中。
- en: Versioning data files for data analysis and machine learning
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析和机器学习的数据文件版本控制
- en: Machine learning projects often process large files or large numbers of files.
    Those include the raw dataset, but also the results of various pre-processing
    steps, as well as the trained model.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习项目通常处理大文件或大量文件。这些文件包括原始数据集，但也包括各种预处理步骤的结果，以及训练后的模型。
- en: You want to store those large files or directories somewhere to avoid having
    to re-download or re-compute them. On the other hand, you also want to be able
    to recreate everything from scratch, to make the science reproducible. Those requirements
    are different enough from the ones that are encountered in typical software projects
    that need to handle large assets, where specialized solutions for integrating
    data handling and version control are necessary. Among such solutions, there’s
    **Data Version Control** (**DVC**) and **Pachyderm**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望将这些大文件或目录存储到某个地方，以避免需要重新下载或重新计算它们。另一方面，你也希望能够从头开始重建一切，以使科学研究具有可重复性。这些需求与典型的软件项目中处理大资产所遇到的需求有很大不同，后者需要专门的解决方案来整合数据处理和版本控制。在这些解决方案中，有**数据版本控制**（**DVC**）和**Pachyderm**。
- en: Handling repositories with a large number of files
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理包含大量文件的仓库
- en: The rise in the use of monorepos (this concept was explained in detail in [*Chapter*
    *11*](B21194_11.xhtml#_idTextAnchor270)*, Managing Subprojects*) has led to the
    need to handle repositories with large amounts of files. In a monorepo – that
    is, a repository composed of many interconnected subprojects – you would usually
    work on a single subproject and access and change files only within a specific
    subdirectory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 单一仓库（monorepo）使用的增多（这一概念在[*第 11 章*](B21194_11.xhtml#_idTextAnchor270)*《管理子项目》*中有详细解释）导致了对处理大量文件的仓库的需求。在一个单一仓库中——即由多个相互关联的子项目组成的仓库——你通常会专注于一个子项目，并仅在特定的子目录中访问和修改文件。
- en: Limiting the number of working directory files with sparse checkout
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用稀疏检出限制工作目录中文件的数量
- en: Git includes the `core.sparseCheckout` configuration variable to `true` and
    uses the `.git/info/sparse-checkout` file with the gitignore-like syntax to specify
    what is to appear in the working directory. The index (also known as the staging
    area) is populated in full, with the `skip-worktree` flag set for files missing
    from checkout.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Git 包含了 `core.sparseCheckout` 配置变量，并将其设置为 `true`，同时使用 `.git/info/sparse-checkout`
    文件，采用类似 gitignore 的语法来指定工作目录中要出现的内容。索引（也称为暂存区）被完全填充，对于缺少的文件，设置了 `skip-worktree`
    标志。
- en: While it can be helpful if you have a huge tree of folders, it doesn’t affect
    the overall size of the local repository itself. To reduce the size of the repository,
    it needs to be used together with **sparse clone** (which will be described later).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如果你有一个庞大的文件夹树，这种方式可能会有所帮助，但它并不会影响本地仓库本身的整体大小。为了减少仓库的大小，必须结合使用**稀疏克隆**（稍后会介绍）。
- en: However, sparse checkout definitions are extremely generic. This makes the feature
    very flexible but at the cost of bad performance for large definitions and large
    amounts of files. With a monorepo, you don’t need that flexibility as each subproject
    is contained in its own subdirectory – you only directory matches in sparse checkout
    definitions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，稀疏检出定义非常通用。这使得该功能非常灵活，但代价是对于大规模定义和大量文件来说性能较差。对于单一仓库，你不需要这种灵活性，因为每个子项目都包含在自己的子目录中——你只需要在稀疏检出定义中匹配目录即可。
- en: To achieve this, you need to use `sparse-checkout` feature is deprecated (see,
    for example, the `git sparse-checkout` command’s documentation). This mode has
    the additional advantage that it is much easier to use. Everything is managed
    with the help of the `git` `sparse-checkout` command.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，你需要使用已经弃用的 `sparse-checkout` 功能（例如，参见 `git sparse-checkout` 命令的文档）。这种模式的额外优点是它更容易使用。所有操作都由
    `git sparse-checkout` 命令管理。
- en: 'To restrict your working directory to a given set of directories, run the following
    command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的工作目录限制为特定目录集，运行以下命令：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Earlier versions of the feature required you to run `git sparse-checkout init
    --cone` first, but using this command is no longer needed, and the `init` subcommand
    is itself being deprecated.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能的早期版本要求你先运行 `git sparse-checkout init --cone`，但现在不再需要使用此命令，`init` 子命令本身也正在被弃用。
- en: Tip
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you’re cloning a repository with a large number of files, you can avoid filling
    out the working directory with them by using the **--no-checkout** or **--sparse**
    option of **git clone** (the second option will only check out files in the top
    directory of the project). You can add the **--filter=blob:none** option for even
    more speed (turning on blobless sparse clone).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在克隆一个包含大量文件的仓库，你可以通过使用 **--no-checkout** 或 **--sparse** 选项来避免将文件填充到工作目录中（第二个选项只会签出项目顶级目录中的文件）。你还可以添加
    **--filter=blob:none** 选项以获得更快的速度（启用无 blob 的稀疏克隆）。
- en: 'At any point, you can check which directories are included in your `sparse-checkout`
    definitions, and are present in your working directory, using the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，你都可以使用以下命令检查哪些目录被包括在你的 `sparse-checkout` 定义中，并存在于你的工作目录中：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can add a new directory to your existing sparse checkout with the `add`
    subcommand, as shown in the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `add` 子命令将一个新目录添加到现有的稀疏签出中，如下所示的示例所示：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At the time of writing, there’s no `remove` subcommand. To remove a directory
    from the list of checked-out files, you would need to edit the contents of the
    `.git/info/sparse-checkout` file and then run the following subcommand:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，尚无 `remove` 子命令。要从已签出的文件列表中删除一个目录，你需要编辑 `.git/info/sparse-checkout` 文件的内容，然后运行以下子命令：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This subcommand reapplies the existing sparse directory specifications to make
    the working directory match. It can also be used when some operation updates the
    working directory without fully respecting `sparse-checkout` definitions. This
    might be caused by using tools external to Git, or by running Git commands that
    do not fully support sparse checkouts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此子命令重新应用现有的稀疏目录规格，以使工作目录匹配。当某些操作更新工作目录但未完全遵循 `sparse-checkout` 定义时，也可以使用此命令。这可能是由使用
    Git 外部工具，或者运行不完全支持稀疏签出的 Git 命令导致的。
- en: You can turn off this feature and restore the working directory so that it includes
    all files by running the `git sparse-checkout` `disable` command.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行 `git sparse-checkout` `disable` 命令关闭此功能，并恢复工作目录以包括所有文件。
- en: Reducing the local repository size with sparse clone
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用稀疏克隆减少本地仓库大小
- en: 'The initial section of [*Chapter 11*](B21194_11.xhtml#_idTextAnchor270), *Managing
    Subprojects*, described how Git stores the history of the project, which includes
    a description of changes, directory structure, and file contents at each revision.
    This data is stored using different types of objects: tag objects, commit objects,
    tree objects, and blob objects. Objects reference other objects: tags point to
    commits, commits point to a parent commit(s), trees represent the state of the
    project at a given revision, and trees point to other trees and blobs.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第11章*](B21194_11.xhtml#_idTextAnchor270)的初始部分，*管理子项目*，描述了 Git 如何存储项目的历史记录，其中包括每次修订的变更描述、目录结构和文件内容。这些数据使用不同类型的对象存储：标签对象、提交对象、树对象和二进制对象。对象之间互相引用：标签指向提交，提交指向父提交，树代表某一修订时项目的状态，树指向其他树和二进制对象。'
- en: When running the ordinary `git clone` command, the client asks the server for
    the latest commits (representing the latest revisions). The server provides those
    objects, all objects they point to, all objects those objects point to, and so
    on. In short, the server provides those commit objects and every other reachable
    object (excluding possibly those objects that the client already has). The result
    is that you have the whole history of the whole project available locally.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行普通的 `git clone` 命令时，客户端会向服务器请求最新的提交（代表最新的修订）。服务器提供这些对象、它们所指向的所有对象、以及这些对象所指向的对象，依此类推。简而言之，服务器提供了那些提交对象和所有其他可达的对象（可能排除客户端已经拥有的那些对象）。结果就是你在本地拥有了整个项目的完整历史。
- en: Nowadays, however, many developers have network connections available as they
    work. Modern Git only allows you to download a subset of objects via **partial
    clone**. In this case, Git remembers where it can get the rest of the objects,
    and later asks the server for more data when it turns out to be necessary.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今许多开发者在工作时都有可用的网络连接。现代 Git 只允许你通过 **部分克隆** 下载对象的一个子集。在这种情况下，Git 会记住从哪里可以获取其余的对象，当有必要时，它会稍后向服务器请求更多数据。
- en: Git’s partial clone feature can be enabled by specifying the `--filter` option
    when running the `git clone` command. There are several filters available, but
    the server that hosts the repository you’re cloning can choose to deny your filter
    and revert to creating a full clone.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在运行 `git clone` 命令时指定 `--filter` 选项，可以启用 Git 的部分克隆功能。有几种可用的过滤器，但托管你克隆的仓库的服务器可以选择拒绝你的过滤器并恢复到创建完全克隆。
- en: Running `git fetch` in sparse clone preserves sparse clone filters, and it doesn’t
    download those types of objects that would not be downloaded by the initial clone.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在稀疏克隆中运行 `git fetch` 会保持稀疏克隆过滤器，并且不会下载初次克隆时不会下载的那些类型的对象。
- en: 'The two most commonly used filters that should be supported by most Git hosting
    sites are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的两种过滤器应该是大多数 Git 托管站点支持的，如下所示：
- en: '**Blobless clone**: **git clone --****filter=blob:none <url>**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无 Blob 克隆**：**git clone --****filter=blob:none <url>**'
- en: '**Treeless clone**: **git clone --****filter=tree:0 <url>**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无树克隆**：**git clone --****filter=tree:0 <url>**'
- en: When using the `--filter=blob:none` option, the initial `git clone` command
    will download everything but the blob objects (which ordinarily contain different
    versions of file contents for different files). The checkout part of the `clone`
    operation (if not suppressed) will download blobs for current versions of project
    files. The Git client knows how to batch those download requests to ask the server
    only for the missing blobs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--filter=blob:none` 选项时，初始的 `git clone` 命令会下载所有内容，除了 blob 对象（这些对象通常包含不同版本的文件内容）。如果没有被抑制，`clone`
    操作的 checkout 部分会下载当前版本项目文件的 blobs。Git 客户端知道如何将这些下载请求批量化，只向服务器请求缺失的 blobs。
- en: With `git log`, `git merge-base`, and other commands that do not examine file
    contents run without the need for additional download of blob objects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `git log`、`git merge-base` 和其他不检查文件内容的命令时，运行不会需要额外下载 blob 对象。
- en: Moreover, to examine if the file has been changed, Git can simply compare object
    IDs, and it doesn’t need to access the actual contents. Therefore, examining file
    history with `git log -- <path>` doesn’t need to download any objects either.
    This command runs with the same performance as in a full clone. This is the result
    of the fact that the object ID is based on the cryptographic hash of file contents
    (Git currently uses SHA-1 for this purpose).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了检查文件是否已更改，Git 只需比较对象 ID，而无需访问实际内容。因此，使用 `git log -- <path>` 检查文件历史记录时，也无需下载任何对象。此命令的运行性能与完全克隆时相同。这是因为对象
    ID 基于文件内容的加密哈希（目前 Git 使用 SHA-1 实现此功能）。
- en: Git commands such as `git checkout`/`git switch`, `git reset --hard <revision>`,
    and `git merge` need to download blobs to populate the working directory, the
    index (the staging area), or both. To compute diffs, Git also needs to have blobs
    to compare; therefore, commands such as `git diff` or `git blame <path>` might
    trigger blob downloads the first time they are run with specific arguments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Git 命令如 `git checkout`/`git switch`、`git reset --hard <revision>` 和 `git merge`
    需要下载 blobs 以填充工作目录、索引（暂存区）或两者。为了计算差异，Git 还需要有 blobs 来进行比较；因此，像 `git diff` 或 `git
    blame <path>` 这样的命令，第一次运行时可能会根据特定的参数触发 blob 下载。
- en: In some repositories, the tree data might be a significant portion of the repository’s
    size. This might happen if the repository has a large amount of files and directories
    and deep and wide directory hierarchies. In such cases, using a `--filter=tree:0`
    option might offer a better solution.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些代码库中，树状数据可能占据代码库大小的相当大一部分。如果代码库包含大量文件和目录，并且目录层次结构深且宽，则可能会发生这种情况。在这种情况下，使用`--filter=tree:0`选项可能会提供更好的解决方案。
- en: Note that any objects that are only referenced by those objects that were skipped
    due to the selected filter will also be missing. This means that the treeless
    clone is more sparse than the blobless clone (as only trees can point to blobs…
    well, a tag object can point to a blob object, but you won’t typically encounter
    this).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任何仅由由于所选过滤器而跳过的对象所引用的对象也将丢失。这意味着无树克隆比无blob克隆更加稀疏（因为只有树能指向blob…当然，标签对象也可以指向blob对象，但你通常不会遇到这种情况）。
- en: The advantage of a treeless clone over a blobless clone is a much faster initial
    clone and faster subsequent fetches. The disadvantage is that working in a treeless
    clone is more difficult because downloading a missing tree when needed is more
    expensive. It is also more difficult for the server to notice that the client
    already has some tree objects locally, so the request might send more data than
    necessary. Additionally, more commands require additional data to be downloaded.
    An example of this is `git log -- <file>`, which in the blobless clone could be
    run without the need to download anything extra. In a treeless clone, the command
    will start downloading trees for almost every commit in the history.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 无树克隆相对于无blob克隆的优点是初始克隆速度更快，后续获取速度更快。缺点是，在无树克隆中工作更为困难，因为在需要时下载缺失的树的成本更高。服务器也更难以察觉客户端已经在本地拥有某些树对象，因此请求可能会发送比必要的更多数据。此外，更多的命令需要额外的数据下载。例如，`git
    log -- <file>`命令在无blob克隆中可以运行而无需额外下载任何内容。而在无树克隆中，这个命令几乎会为每个历史提交下载树。
- en: Treeless clones and submodules
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 无树克隆与子模块
- en: The repositories that contain submodules (see [*Chapter 11*](B21194_11.xhtml#_idTextAnchor270),
    *Managing Subprojects*) may behave poorly with treeless clones. If you get too
    many tree download requests, you can either *turn off the automatic fetching of
    submodules* by ensuring that the **fetch.recurseSubmodules** configuration variable
    is set to **false** (or by using the **--no-recurse-submodules** option) or *also
    filter submodules* by setting the **clone.filterSubmodules** config option (or
    using the **--recurse-submodules --filter=tree:0 --also-filter-submodules** combination
    of command-line options).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 包含子模块的代码库（参见[*第11章*](B21194_11.xhtml#_idTextAnchor270)，*管理子项目*）在使用无树克隆时可能会表现不佳。如果收到过多的树下载请求，你可以通过确保**fetch.recurseSubmodules**配置变量设置为**false**（或使用**--no-recurse-submodules**选项）来*关闭自动获取子模块*，或者通过设置**clone.filterSubmodules**配置选项（或使用**--recurse-submodules
    --filter=tree:0 --also-filter-submodules**命令行选项组合）来*同时过滤子模块*。
- en: Treeless clones are helpful for automatic builds, when you want to quickly clone
    the project, check out a single revision, compile it and/or run a test, and then
    throw away the repository (instead of using shallow clone). They are also useful
    if all you’re interested in is examining the history of the whole project.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 无树克隆对于自动构建非常有用，当你想快速克隆项目，检出单个修订版本，编译它和/或运行测试，然后丢弃代码库（而不是使用浅克隆）时，它非常有效。如果你只对查看整个项目的历史感兴趣，它也很有用。
- en: The treeless clone is a special case of the `--filter=tree:<depth>`. In this
    case, the clone omits all blobs and trees whose depth from the root tree (from
    the top directory of the project) is greater than or equal to the specified limit.
    It can be easily seen that with `<depth>` being equal to 0 (that is, `--filter=tree:0`),
    the clone will not include any trees or blobs (except for those required for initial
    checkout).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 无树克隆是`--filter=tree:<depth>`的一个特例。在这种情况下，克隆会省略所有树和blob，这些树的深度从根树（从项目的顶级目录）到达或超过指定的限制。可以很容易地看出，当`<depth>`等于0（即`--filter=tree:0`）时，克隆将不包括任何树或blob（除了初始检出所需的那些）。
- en: Omitting large file contents with sparse clone
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过稀疏克隆省略大型文件内容
- en: The partial clone can also work as a tool to help you work with large files.
    This requires that the Git server (the Git hosting site) supports the specific
    type of filter. It also doesn’t remove the requirement that at least one remote
    repository must include those large files and their history so that you can download
    them on demand.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 部分克隆也可以作为处理大文件的工具。这要求 Git 服务器（Git 托管站点）支持特定类型的过滤器。它同样不会取消至少一个远程仓库必须包含那些大文件及其历史记录的要求，以便你可以按需下载它们。
- en: You can do this by providing the `--filter=blob:limit=<size>` option when you’re
    cloning, where `<size>` can include the `<size>` bytes, be it KiB, MiB, or GiB
    (depending on the suffix). For example, `blob:limit=1k` is the same as `blob:limit=1024`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在克隆时提供 `--filter=blob:limit=<size>` 选项来实现，其中 `<size>` 可以包括 `<size>` 字节，无论是
    KiB、MiB 还是 GiB（取决于后缀）。例如，`blob:limit=1k` 等同于 `blob:limit=1024`。
- en: Matching clone sparsity to checkout sparsity
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将克隆稀疏性与检出稀疏性匹配
- en: Modern Git includes basic support for the sparse clone filter, which makes it
    omit all blobs that would be not required for sparse checkout. For security reasons,
    however, support for the easier-to-use form of `--filter=sparse:path=<path>` was
    dropped from Git. The supported form is `--filter=sparse:oid=<blob-ish>`. This
    form is safe against the time of check to time of use problem, as opposed to the
    path-based form, because `<blob-ish>` (that is, a reference to a blob object)
    ultimately resolves to the object ID that defines its contents.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 Git 包括对稀疏克隆过滤器的基本支持，该过滤器使其省略所有对于稀疏检出不需要的 blob。然而，由于安全原因，Git 放弃了对 `--filter=sparse:path=<path>`
    的易用形式的支持。支持的形式是 `--filter=sparse:oid=<blob-ish>`。这种形式可以防止“检查时到使用时”问题，因为 `<blob-ish>`（即对
    blob 对象的引用）最终解析为定义其内容的对象 ID。
- en: 'At the time of writing, you would be hard to find a Git server that supports
    this filter and doesn’t respond with **warning: filtering not recognized by server,
    ignoring**. But when it starts getting widely supported, one possible solution
    would be to create a tag for every sparse checkout pattern of interest, and then
    use the selected tag for blob-ish:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作时，你很难找到一个支持此过滤器且不会响应 **警告：服务器不识别过滤器，已忽略** 的 Git 服务器。但当它开始得到广泛支持时，一个可能的解决方案是为每个感兴趣的稀疏检出模式创建一个标签，然后使用选定的标签作为
    blob-ish：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, in the third step, you need to use the SHA-1 that’s output from the
    previous command.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在第三步中，你需要使用之前命令输出的 SHA-1。
- en: In this case, cloning would use the `--filter=sparse:oid=sparse/<subdir>^{blob}`
    option (where you would need to use the name of the tag that was created by the
    sequence of commands shown previously).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，克隆将使用`--filter=sparse:oid=sparse/<subdir>^{blob}`选项（其中需要使用之前显示的命令序列所创建的标签名）。
- en: Faster checking for file changes with filesystem monitor
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文件系统监控器更快地检查文件变更
- en: When you run a Git command that operates on the worktree, such as `git status`
    or `git diff`, Git has to discover what changed relative to the index, or relative
    to the specified revision. It does that by searching the entire worktree, which
    for repositories with a large number of files can take a long time. It also has
    to rediscover the same information from scratch every time you run such a command.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行一个操作工作树的 Git 命令时，如`git status`或`git diff`，Git 必须发现相对于索引或相对于指定版本的变化。它通过搜索整个工作树来完成这项任务，而对于包含大量文件的仓库，这可能需要很长时间。每次你运行这样的命令时，它还必须从头开始重新发现相同的信息。
- en: 'Filesystem monitor is a long-running daemon or a service process that does
    the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统监控器是一个长期运行的守护进程或服务进程，其功能如下：
- en: Registers with the operating system to watch specified directories and receive
    change notification events for directories and files of interest
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向操作系统注册以监视指定目录，并接收相关目录和文件的变更通知事件
- en: Keeps the pathnames of those changed watched files and directories in some (in-memory)
    data structure that can be queried quickly
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将已更改的文件和目录的路径名保存在某些（内存中的）数据结构中，这些数据结构可以快速查询
- en: Responds to client requests for a list of files and directories that have been
    modified recently
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应客户端请求，提供最近修改的文件和目录的列表
- en: Since version 2.37, Git includes the `git fsmonitor--daemon`. It is currently
    available on macOS and Windows. This daemon listens for IPC connections from client
    processes, such as `git status`, and sends a list of changed files over a Unix
    domain socket or a named pipe.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本2.37开始，Git包含了`git fsmonitor--daemon`。目前它在macOS和Windows上可用。该守护进程监听来自客户端进程（如`git
    status`）的IPC连接，并通过Unix域套接字或命名管道发送已更改文件的列表。
- en: 'Turning it on is very simple; you just need to configure Git to use it. This
    can be done with the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 启用它非常简单；你只需要配置Git使用它。可以通过以下命令完成：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This monitor works well with `core.untrackedCache`, so it is recommended to
    set this configuration option to `true` as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该监视器与`core.untrackedCache`一起工作良好，因此建议将此配置选项设置为`true`。
- en: 'You can query this daemon for the list of watched repositories:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查询此守护进程以获取被监视仓库的列表：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If either the operating system or the filesystem the repository is on does not
    allow you to use this monitor, there is an option to use the `core.fsmonitor`
    config option to the path to the filesystem monitor hook. The hook must support
    the `fsmonitor-watchman` hook protocol, and when run return the list of changed
    files on standard output.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作系统或仓库所在的文件系统不允许你使用此监视器，可以使用`core.fsmonitor`配置选项指定文件系统监视器钩子的路径。该钩子必须支持`fsmonitor-watchman`钩子协议，并且在运行时会将已更改的文件列表输出到标准输出。
- en: Git comes with the `fsmonitor-watchman.sample` file, which is installed inside
    the `.git/hooks/` directory. Before turning it on, as described in the previous
    paragraph, rename it by removing the `*.sample` suffix. If the file is missing,
    you can download it from [https://github.com/git/git/tree/master/templates](https://github.com/git/git/tree/master/templates).
    This hook requires the **Watchman** file’s watching service ([https://facebook.github.io/watchman/](https://facebook.github.io/watchman/))
    to be installed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Git附带了`fsmonitor-watchman.sample`文件，该文件安装在`.git/hooks/`目录中。在启用之前，如前所述，需通过删除`*.sample`后缀来重命名该文件。如果文件丢失，你可以从[https://github.com/git/git/tree/master/templates](https://github.com/git/git/tree/master/templates)下载该文件。此钩子需要安装**Watchman**文件的监视服务([https://facebook.github.io/watchman/](https://facebook.github.io/watchman/))。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter provided solutions to handling large Git repositories, from the
    use of the Scalar tool to specialized solutions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了处理大型Git仓库的解决方案，从使用Scalar工具到专门的解决方案。
- en: First, you learned how to use shallow clone to download and operate on the selected
    shallow subset of the project history.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你学会了如何使用浅克隆下载并操作项目历史的选定浅子集。
- en: Then, you learned how to handle large files by storing them outside the repository
    or separating them into submodules. The problem of large data in data science
    projects was briefly mentioned, as were specialized solutions to this problem.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学会了如何通过将大文件存储在仓库外部或将其拆分成子模块来处理大文件。还简要提到了数据科学项目中大数据的问题，以及针对这一问题的专门解决方案。
- en: Finally, you learned how to manage large monorepos with sparse checkout, sparse
    clone, and filesystem monitor.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你学会了如何使用稀疏检出、稀疏克隆和文件系统监控来管理大型单体仓库。
- en: The next chapter will help you make Git easier to use and better fit it to your
    specific circumstances. This includes configuring repository maintenance, which
    is particularly important for making working with large repositories smooth.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将帮助你使Git更易于使用，并更好地适应你的特定需求。这包括配置仓库维护，这对于使大型仓库的工作更加顺畅至关重要。
- en: Questions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章的理解：
- en: What is the simplest solution to handling large repositories?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理大型仓库的最简单解决方案是什么？
- en: How you can make cloning faster for repositories with a long history?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何加速长历史仓库的克隆？
- en: How can you handle large files that are needed only by some developers?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何处理只被部分开发者需要的大文件？
- en: What techniques make working with repositories with large numbers of files faster?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用大量文件的仓库时，哪些技术可以加速工作？
- en: What’s the difference between shallow clone, sparse clone, and sparse checkout?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浅克隆、稀疏克隆和稀疏检出的区别是什么？
- en: Answers
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的答案：
- en: Use the built-in **scalar** tool, either using it to clone the repository or
    to register the given repository with the tool.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的**scalar**工具，无论是使用它来克隆仓库，还是将给定仓库注册到该工具。
- en: You can use shallow clone or blobless sparse clone. In the first case, you would
    get a shortened history, while in the second case, the repository’s size will
    be smaller but some operations will require network access to download additional
    data.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用浅克隆或无 Blob 稀疏克隆。在第一种情况下，你将获得一个简化的历史记录，而在第二种情况下，仓库的大小将更小，但某些操作需要网络访问以下载额外的数据。
- en: You can store large files outside the repository with Git-LFS or git-annex (or
    a similar solution). You can clone the repository without downloading large file
    data with the sparse clone feature.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 Git-LFS 或 git-annex（或类似解决方案）将大型文件存储在仓库之外。你可以使用稀疏克隆功能克隆仓库，而无需下载大型文件数据。
- en: Use the sparse checkout feature if you’re only working inside a specific subdirectory,
    use sparse clone to reduce repository size, and use filesystem monitor (if possible)
    to make operations faster.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你只在特定子目录中工作，请使用稀疏签出功能；使用稀疏克隆来减少仓库大小；并且使用文件系统监控（如果可能的话）来加快操作。
- en: Shallow clone only downloads selected part of the repository history, and all
    local operations are limited to this selection, though it is easy to change the
    depth of the history. Sparse clone reduces repository size by downloading only
    a selected subset of objects, fetching those objects on demand, as their presence
    becomes necessary to perform operations. Sparse checkout reduces the number of
    checked-out files, making the working directory smaller (and operations faster).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浅克隆只下载选定的部分仓库历史记录，所有本地操作仅限于该选择，尽管改变历史深度很容易。稀疏克隆通过仅下载选定的对象子集来减少仓库大小，按需获取这些对象，随着操作的进行，当它们的存在变得必要时才会下载。稀疏签出减少了已签出的文件数量，使工作目录变得更小（并且操作更快）。
- en: Further reading
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本章涉及的更多内容，请查阅以下资源：
- en: '*Introducing Scalar: Git at scale for everyone*, by Derrick Stolee (2020):
    [https://devblogs.microsoft.com/devops/introducing-scalar/](https://devblogs.microsoft.com/devops/introducing-scalar/)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*介绍 Scalar：面向每个人的 Git 大规模管理*，作者 Derrick Stolee（2020）：[https://devblogs.microsoft.com/devops/introducing-scalar/](https://devblogs.microsoft.com/devops/introducing-scalar/)'
- en: '*The Story of Scalar*, by Derrick Stolee and Victoria Dye (2022): [https://github.blog/2022-10-13-the-story-of-scalar/](https://github.blog/2022-10-13-the-story-of-scalar/)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Scalar 的故事*，作者 Derrick Stolee 和 Victoria Dye（2022）：[https://github.blog/2022-10-13-the-story-of-scalar/](https://github.blog/2022-10-13-the-story-of-scalar/)'
- en: '*scalar(1) - A tool for managing large Git* *repositories*: [https://git-scm.com/docs/scalar](https://git-scm.com/docs/scalar)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*scalar(1) - 管理大型 Git* *仓库的工具*：[https://git-scm.com/docs/scalar](https://git-scm.com/docs/scalar)'
- en: '*Supercharging the Git Commit Graph*, by Derrick Stolee (2018): [https://devblogs.microsoft.com/devops/supercharging-the-git-commit-graph/](https://devblogs.microsoft.com/devops/supercharging-the-git-commit-graph/)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*超级增强 Git 提交图*，作者 Derrick Stolee（2018）：[https://devblogs.microsoft.com/devops/supercharging-the-git-commit-graph/](https://devblogs.microsoft.com/devops/supercharging-the-git-commit-graph/)'
- en: '*git-commit-graph(1) - Write and verify Git commit-graph* *files*: [https://git-scm.com/docs/git-commit-graph](https://git-scm.com/docs/git-commit-graph)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*git-commit-graph(1) - 写入和验证 Git 提交图* *文件*：[https://git-scm.com/docs/git-commit-graph](https://git-scm.com/docs/git-commit-graph)'
- en: '*Git LFS - Git Large File* *Storage*: [https://git-lfs.com/](https://git-lfs.com/)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Git LFS - Git 大文件* *存储*：[https://git-lfs.com/](https://git-lfs.com/)'
- en: '*git-annex*: [https://git-annex.branchable.com/](https://git-annex.branchable.com/)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*git-annex*：[https://git-annex.branchable.com/](https://git-annex.branchable.com/)'
- en: '*Get up to speed with partial clone and shallow clone*, by Derrick Stolee (2020):
    [https://github.blog/2020-12-21-get-up-to-speed-with-partial-clone-and-shallow-clone/](https://github.blog/2020-12-21-get-up-to-speed-with-partial-clone-and-shallow-clone/)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跟上部分克隆和浅克隆的进度*，作者 Derrick Stolee（2020）：[https://github.blog/2020-12-21-get-up-to-speed-with-partial-clone-and-shallow-clone/](https://github.blog/2020-12-21-get-up-to-speed-with-partial-clone-and-shallow-clone/)'
- en: '*Bring your monorepo down to size with sparse-checkout*, by Derrick Stolee
    (2020): [https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/](https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用稀疏签出将你的单体仓库缩小尺寸*，作者 Derrick Stolee（2020）：[https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/](https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/)'
- en: '*git-sparse-checkout(1) - Reduce your working tree to a subset of tracked*
    *files*: [https://git-scm.com/docs/git-sparse-checkout](https://git-scm.com/docs/git-sparse-checkout)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*git-sparse-checkout(1) - 将工作树缩减为跟踪的* *文件子集*：[https://git-scm.com/docs/git-sparse-checkout](https://git-scm.com/docs/git-sparse-checkout)'
- en: '*git-clone(1) - Clone a repository into a new* *directory*: [https://git-scm.com/docs/git-clone](https://git-scm.com/docs/git-clone)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*git-clone(1) - 克隆一个仓库到新的* *目录中*: [https://git-scm.com/docs/git-clone](https://git-scm.com/docs/git-clone)'
- en: '*Improve Git monorepo performance with a file system monitor*, Jeff Hostetler
    (2022): [https://github.blog/2022-06-29-improve-git-monorepo-performance-with-a-file-system-monitor/](https://github.blog/2022-06-29-improve-git-monorepo-performance-with-a-file-system-monitor/)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过文件系统监视器提高Git单体仓库性能*，Jeff Hostetler（2022）：[https://git.blog/2022-06-29-improve-git-monorepo-performance-with-a-file-system-monitor/](https://git.blog/2022-06-29-improve-git-monorepo-performance-with-a-file-system-monitor/)'
- en: '*git-fsmonitor--daemon - A Built-in Filesystem* *Monitor*: [https://git-scm.com/docs/git-fsmonitor--daemon](https://git-scm.com/docs/git-fsmonitor--daemon)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*git-fsmonitor--daemon - 内建文件系统* *监视器*: [https://git-scm.com/docs/git-fsmonitor--daemon](https://git-scm.com/docs/git-fsmonitor--daemon)'
- en: '*githooks - Hooks used by Git:* *fsmonitor-watchman*: [https://git-scm.com/docs/githooks#_fsmonitor_watchman](https://git-scm.com/docs/githooks#_fsmonitor_watchman)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*githooks - Git使用的钩子：* *fsmonitor-watchman*: [https://git-scm.com/docs/githooks#_fsmonitor_watchman](https://git-scm.com/docs/githooks#_fsmonitor_watchman)'
