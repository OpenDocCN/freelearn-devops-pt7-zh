- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Creating and Consuming Collections
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用集合
- en: If you were familiar with Ansible releases before 2.9, so far, much of this
    book will have looked very familiar to you. If you’re a newcomer to the world
    of Ansible automation, then, of course, all of this will look new and shiny. Regardless
    of your experience with Ansible to date, no book on this would be complete without
    an in-depth look at collections. Collections are the solution to the problems
    that started to manifest as a result of Ansible’s own popularity and success,
    and they are now at the heart of every modern Ansible installation. Whether you
    realized it or not, you’ve been working with them throughout this book so far,
    and they are here to stay, so it benefits us to take a deep dive into them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前熟悉 Ansible 2.9 之前的版本，那么到目前为止，这本书的内容对你来说应该非常熟悉。如果你是 Ansible 自动化的新手，那么，当然，所有这些内容都会显得崭新且充满吸引力。无论你到目前为止对
    Ansible 的了解如何，本书都不可能在没有深入探讨集合（collections）的情况下完成。集合是解决 Ansible 在自身流行和成功过程中出现的一些问题的方案，而它们现在已经成为每个现代
    Ansible 安装的核心。无论你是否意识到，你在本书中至今一直在使用它们，而且它们将会继续存在，因此我们有必要深入了解它们。
- en: In this chapter, we will explore collections in depth, looking in more detail
    at the problem that they solve and how they came about, before taking a more technical
    look at their structure and makeup. We will conclude the chapter with a hands-on
    example of creating your own collection so that you have a solid understanding
    of how they are created, built, maintained, and used. As a result, you will be
    able to work with this powerful new addition to Ansible with ease and take advantage
    of collections in your own automation solutions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨集合，详细了解它们解决的问题以及它们是如何产生的，然后再从技术角度深入了解它们的结构和组成。最后，我们将通过一个动手实践的示例来创建你自己的集合，这样你就能全面理解它们是如何创建、构建、维护和使用的。因此，你将能够轻松地使用这个强大的新功能，并在自己的自动化解决方案中充分利用集合。
- en: 'Specifically, in this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章将涵盖以下主题：
- en: An introduction to Ansible collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 集合简介
- en: Understanding fully qualified collection names
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解完全限定的集合名称
- en: Managing collections on your control node
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制节点上管理集合
- en: Updating your Ansible collections and core installation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新你的 Ansible 集合和核心安装
- en: Creating your own collections
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的集合
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [*Chapter 1*](B20846_01.xhtml#_idTextAnchor015), *Getting Started
    with Ansible*, and are using the most recent version available – the examples
    in this chapter were tested with Ansible 8.0 and `ansible-core` 2.15\. This chapter
    also assumes that you have at least one additional host to test against, and this
    should be Linux-based. Although we will give specific examples of hostnames in
    this chapter, you are free to substitute them with your own hostnames and/or IP
    addresses, and details of how to do this will be provided in the appropriate places.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你已经按照 [*第 1 章*](B20846_01.xhtml#_idTextAnchor015)《*Ansible 入门*》中的详细说明，设置好了你的控制主机，并且正在使用最新版本——本章中的示例是使用
    Ansible 8.0 和 `ansible-core` 2.15 进行测试的。本章还假设你至少有一个额外的主机进行测试，并且该主机应为基于 Linux 的。虽然我们将在本章中给出具体的主机名示例，你可以自由地用自己的主机名和/或
    IP 地址替代，具体操作方法将在相应位置提供。
- en: 'The code bundle for this chapter is available here: https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter
    6'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包可以在这里找到： [https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter
    6](https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%206)
- en: Introduction to Ansible collections
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 集合简介
- en: Although we’ve mentioned some of this earlier in this book, our goal is for
    this to be a complete one-stop source of information for collections – thus, if
    you’ve skipped directly to this chapter, don’t worry – we’ve got you covered.
    Let’s start with some history as this is important to understand the intention
    behind collections.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本书前面已经提到了一些内容，但我们的目标是将其作为关于集合的完整一站式信息源——因此，如果你直接跳到本章，请不用担心——我们已经为你准备好了一切。让我们从一些历史背景开始，因为这对理解集合背后的意图非常重要。
- en: With Ansible releases prior to 2.9, everything was managed in one huge monolithic
    code base. While the core Ansible team owned this code base, the modules that
    really form the lifeblood of Ansible (after all, they are what enable it to automate
    so many disparate systems with ease) were not. Let’s say a network device vendor
    wanted to release a new module. Perhaps they added a new feature or fixed a bug
    in a prior release. They would have to make these changes, test them, and then
    submit them as a pull request to the main Ansible repository – not only is this
    a significant undertaking, depending on the number of **Pull Requests** (**PRs**)
    and amount of code to be merged, but it can also take a long time, slowing down
    release cycles.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.9 版本之前，Ansible 的所有内容都被管理在一个庞大的单体代码库中。虽然核心的 Ansible 团队拥有这个代码库，但真正构成 Ansible
    命脉的模块（毕竟，它们使 Ansible 能够轻松地自动化如此多不同的系统）并不属于他们。如果一个网络设备供应商想要发布一个新模块，也许他们添加了一个新特性，或者修复了先前版本中的一个
    bug，他们必须进行这些更改、进行测试，然后将其作为拉取请求提交到 Ansible 的主仓库——这不仅是一个重大的任务，而且根据**拉取请求**（**PRs**）的数量以及要合并的代码量，它可能还需要很长时间，从而拖慢发布周期。
- en: At this point, the owners of the repository would have to merge the code, test
    it themselves, and perform a release. This way of working was fine in the early
    days of Ansible, but as its adoption got greater, it became impossible to scale
    in this manner. Imagine that a large enterprise user of Ansible has a problem
    with an Ansible module and they need a fix now, or perhaps the vendor has an exciting
    new launch coming up and they want Ansible support from day one. Neither of these
    was possible with this way of working. Coupled with the fact that Ansible 2.8
    had thousands of modules, the task of managing Ansible code became an unenviable
    task.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，仓库的所有者必须合并代码、自己进行测试并进行发布。这种工作方式在 Ansible 的早期是可以的，但随着其采用度的提高，这种方式变得无法扩展。试想一下，如果一个大型企业用户在使用
    Ansible 模块时遇到问题并且需要立即修复，或者供应商有一个令人兴奋的新发布，并希望从第一天开始就支持 Ansible，这两种情况都是在这种工作方式下不可能实现的。再加上
    Ansible 2.8 版本已经有成千上万的模块，管理 Ansible 代码的任务变成了一项令人头疼的工作。
- en: This assumes, of course, that code was eligible to be integrated into the main
    code base. If something was confidential in nature, or needed distributing in
    a hurry to fix a problem, then there was no easy way to integrate it into the
    Ansible installation (to be clear, there were methods, but they were not as simple
    and straightforward as collections have made this process).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个假设前提是代码有资格被集成到主代码库中。如果某些内容是机密性质的，或者需要迅速分发以修复问题，那么就没有简单的方法将其集成到 Ansible
    安装中（明确来说，虽然有一些方法，但它们并不像集合所提供的这种简单直接）。
- en: 'It was out of these needs that collections were born. In brief, collections
    empower individual teams and vendors to develop, test, and release contributions
    to Ansible at their own pace, and independent of the release cycle of the core
    Ansible code. To be specific, collections provide a mechanism to package and distribute
    the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正是出于这些需求，集合应运而生。简而言之，集合赋予了各个团队和供应商按照自己的节奏独立开发、测试和发布对 Ansible 的贡献，而无需依赖核心 Ansible
    代码的发布周期。具体来说，集合提供了一种机制来打包和分发以下内容：
- en: Roles
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色
- en: Plugins
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件
- en: Modules
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Playbooks
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playbooks
- en: Documentation
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档
- en: As with all aspects of Ansible, the design of collections is simple and easy
    to work with. A collection is simply a set of directories containing the files
    that contain the required functionality. These are then packaged up into a gzipped
    tarball (a well-known and understood file format) for easy distribution. Collections
    can be installed and managed locally (as we shall see later, in the *Managing
    collections on your control node* section) and via Ansible Galaxy ([https://galaxy.ansible.com](https://galaxy.ansible.com)).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Ansible 的所有方面一样，集合的设计简单且易于操作。集合只是一个包含所需功能的文件的目录集合。这些文件随后被打包成一个 gzip 压缩的 tar
    包（一个广为人知并被理解的文件格式），以便于分发。集合可以在本地安装和管理（稍后我们将在*管理控制节点上的集合*部分中看到），也可以通过 Ansible Galaxy
    进行管理（[https://galaxy.ansible.com](https://galaxy.ansible.com)）。
- en: Anyone familiar with Ansible from its pre-collection days will know that roles
    were distributed via Ansible Galaxy and were easy to manage using the `ansible-galaxy`
    command-line utility. Thus, a valid question might be, if you develop your own
    role, should you distribute it as a role, or a role contained within a collection?
    After all, both are currently viable solutions, and both can be distributed via
    Ansible Galaxy. Although both routes are entirely possible at this time, it is
    the opinion of the author that, in time, roles will be distributed as collections,
    as these offer much greater scope for expansion – for example, if you need to
    develop a plugin to extend the capabilities of your role, then you can add this
    to the collection you have already created. On the other hand, distributing the
    role as is would necessitate a later migration to a collection, and thus, you
    future-proof your code by packaging it as a collection in the first place.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 任何熟悉 Ansible 早期版本的人都会知道，角色是通过 Ansible Galaxy 分发的，并且可以使用 `ansible-galaxy` 命令行工具轻松管理。因此，一个有效的问题可能是，如果你开发了自己的角色，应该将其作为角色分发，还是将其作为集合中的角色进行分发？毕竟，目前这两种方式都是可行的，并且都可以通过
    Ansible Galaxy 分发。虽然这两种方式在目前都是完全可行的，但作者认为，随着时间的推移，角色将会作为集合分发，因为集合提供了更大的扩展空间——例如，如果你需要开发一个插件来扩展角色的功能，你可以将其添加到你已经创建的集合中。另一方面，作为单独的角色分发将需要以后迁移到集合，因此，通过一开始就将其打包为集合，你可以为未来做好准备。
- en: It is very easy for developers, vendors, and enterprises to build their Ansible
    functionality into collections for packaging and distribution. They can then contribute
    this back to the community if they so desire (and in the spirit of open source
    software, this is certainly the goal), but if they contain confidential information,
    they are just as easy to host and maintain in an internal repository.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者、供应商和企业可以非常轻松地将他们的 Ansible 功能打包成集合，进行打包和分发。如果他们愿意，他们还可以将其贡献回社区（在开源软件的精神下，这无疑是目标），但如果它们包含机密信息，它们同样可以轻松地托管并维护在内部仓库中。
- en: With this introduction complete, you have gained a good idea of what a collection
    is and its intended purpose. We will now proceed in the next section of this chapter
    to begin a look at the practical aspects of creating and consuming collections
    to further your understanding.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个介绍，你已经对集合及其预期用途有了一个很好的了解。接下来，我们将进入本章的下一部分，开始探讨创建和使用集合的实际方面，以进一步加深你的理解。
- en: Understanding fully qualified collection names
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解完全限定的集合名称
- en: 'Before collections existed, every module that was created and contributed to
    Ansible had to have a unique name. Thus, it was very common to see modules named
    like this (both were taken from the Ansible 2.8 release):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合出现之前，任何创建并贡献给 Ansible 的模块都必须具有唯一的名称。因此，我们经常会看到类似下面这样的模块名称（这两个模块名称来自 Ansible
    2.8 版本）：
- en: '`ios_bgp`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ios_bgp`'
- en: '`eos_bgp`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eos_bgp`'
- en: '`fortios_router_bgp`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fortios_router_bgp`'
- en: 'All three of these modules are to modify the `bgp` to do the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个模块都是用来修改 `bgp`，实现以下功能：
- en: Ensure their names are unique
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保它们的名称是唯一的
- en: Ensure Ansible coders can understand what their code does
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保 Ansible 编码人员能够理解他们的代码做了什么
- en: Collections remove the need for unique module names, so it is now possible for
    contributors to create modules with names that overlap. This is valuable because
    it removes the need for such long and verbose module names, but it creates the
    risk of unexpected code behavior. For example, we often use the `debug` module
    to understand what our playbook code does and print something out during the execution.
    It would be entirely possible for us to create our own collection with a module
    called `debug`, which does something slightly (or entirely) different. Imagine
    the confusion that would result if your playbook performed differently on different
    control nodes, or didn’t work at all.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 集合取消了对唯一模块名称的需求，因此现在贡献者可以创建名称重复的模块。这一点非常有价值，因为它消除了冗长模块名称的需求，但也带来了意外代码行为的风险。例如，我们经常使用
    `debug` 模块来理解我们的 playbook 代码在做什么，并在执行过程中打印某些内容。我们完全可能会创建一个名为 `debug` 的模块，它做一些稍微不同（或完全不同）的事情。试想，如果你的
    playbook 在不同的控制节点上表现不同，或者根本无法工作，结果将会是多么混乱。
- en: 'It is for this reason that throughout this book, in earlier versions of Ansible
    code, you would be used to seeing code like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，在本书中，早期版本的 Ansible 代码中，你会习惯看到如下的代码：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This still works in Ansible today (you are welcome to test this!), and support
    for short-form module names has been retained for backward compatibility so that
    any legacy code that you have can be run. While this is valuable in empowering
    users to upgrade their Ansible code at their own pace without needing multiple
    versions of Ansible on the control node, the risk of unexpected behavior due to
    a module name clash is not insignificant, so it is important to start using fully
    qualified collection names as soon as possible.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式今天在 Ansible 中仍然有效（你可以自己测试！），并且为了向后兼容，短格式模块名称的支持仍然保留，以便你现有的任何遗留代码都可以运行。虽然这对让用户在不需要控制节点上安装多个版本的
    Ansible 的情况下，按自己的节奏升级 Ansible 代码非常有价值，但由于模块名称冲突导致的意外行为的风险也不容小觑，因此尽早开始使用完全限定集合名称非常重要。
- en: 'For example, in place of the previously provided example code, we would now
    write the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在之前提供的示例代码中，我们现在会写出以下内容：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The functionality of this code is identical, but the risk of module name clash
    is now removed because the fully qualified collection name has been specified.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的功能是相同的，但现在模块名称冲突的风险已经消除，因为已经指定了完全限定集合名称。
- en: 'What is a **Fully Qualified Collection Name** (**FQCN**) though? The best way
    to explain this is to break it down into its component parts, which look like
    this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，**完全限定集合名称**（**FQCN**）究竟是什么呢？最好的解释方式是将其拆解为组成部分，如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s start with the namespace – this is a unique namespace used to identify
    the developer of the collections. This might be your name if you are an individual
    developer, or the name of a company if you are contributing to a vendor. All namespaces
    must be unique, and this is reasonable as a limitation – when you look on Ansible
    Galaxy, you want to know that modules with the `cisco` namespace are all managed
    by Cisco, and thus, you can be certain of who owns and manages the code. Similarly,
    the `ansible` namespace (from which we make use of `ansible.builtin.debug`) is
    owned and managed by the Ansible project itself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从命名空间开始——这是一个唯一的命名空间，用于标识集合的开发者。如果你是个人开发者，它可能是你的名字；如果你是为供应商贡献代码，它则是公司的名字。所有命名空间必须唯一，这作为一种限制是合理的——当你查看
    Ansible Galaxy 时，你希望知道 `cisco` 命名空间下的所有模块都由 Cisco 管理，这样你就可以确定是谁拥有和管理这些代码。同样，`ansible`
    命名空间（我们从中使用了 `ansible.builtin.debug`）由 Ansible 项目本身拥有和管理。
- en: Now, it’s also safe to assume that each namespace will have one or more collections.
    It makes sense for collections to be divided up by functionality; otherwise, we
    head back to the problems of monolithic code base management we discussed earlier
    in this chapter. For example, within the `cisco` namespace, there is an `ios`
    collection to manage Cisco IOS devices and a separate `asa` collection to manage
    their `asa`, but I could not put it in the `cisco` namespace on Ansible Galaxy.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也可以安全地假设每个命名空间将有一个或多个集合。将集合按功能划分是有意义的；否则，我们又会回到本章前面讨论的单体代码库管理的问题。例如，在 `cisco`
    命名空间下，有一个 `ios` 集合用于管理 Cisco IOS 设备，还有一个单独的 `asa` 集合用于管理他们的 `asa`，但我不能把它放在 Ansible
    Galaxy 上的 `cisco` 命名空间中。
- en: The third and final part of the FQCN is the module name itself. This serves
    the same function as it always has in Ansible and must be unique within a collection.
    We have already used modules a number of times in this book, and we will continue
    to do so; thus, we will assume here that you are happy with the concept of an
    Ansible module.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: FQCN 的第三部分和最后一部分是模块名称本身。它与 Ansible 中一直以来的功能相同，并且在一个集合中必须是唯一的。在本书中，我们已经多次使用过模块，并且我们将继续使用；因此，我们在这里假设你已经理解了
    Ansible 模块的概念。
- en: Putting this all together, whereas in Ansible 2.8 (or earlier) you would have
    used the `ios_bgp` module for BGP configuration on a Cisco IOS device, the FQCN
    for this module is now `cisco.ios.ios_bgp`. A valid question you may be asking
    about this FQCN is, why, given the unique namespace and collection name within
    it, is the module still called `ios_bgp` and not simply `bgp`? The answer lies
    in backward compatibility – Ansible 8.0 still supports playbooks written for 2.8
    and earlier and, as such, still supports module names that are not fully qualified.
    Thus, if Cisco changed the module name to `bgp`, they would break backward compatibility.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 把这一切放在一起，例如在Ansible 2.8（或更早版本）中，你可能会在Cisco IOS设备上使用`ios_bgp`模块进行BGP配置，而现在这个模块的完全限定类名（FQCN）是`cisco.ios.ios_bgp`。关于这个FQCN，你可能会问的一个合理问题是，为什么在其独特的命名空间和集合名称内，模块仍然被称为`ios_bgp`而不是简单地称为`bgp`？答案在于向后兼容性——Ansible
    8.0仍然支持为2.8及更早版本编写的playbook，并且支持未完全限定的模块名称。因此，如果Cisco将模块名称更改为`bgp`，它们将破坏向后兼容性。
- en: Despite this backward compatibility functionality, it is important to start
    making friends with FQCNs as soon as possible. Module names must be unique within
    a collection, but that is the only limitation. There is nothing to stop me from
    creating my own module called `ios_bgp`, in my own `ios` collection, and calling
    it something like `practicalansible.ios.ios_bgp`. In this instance, you could
    not guarantee which module you were calling if you only specified the module by
    the name `ios_bgp` in your playbooks and roles, and as such, it is vital to use
    FQCNs to make sure you don’t come across any unexpected or erroneous behavior.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这种向后兼容性功能，尽快开始与FQCN结交是很重要的。模块名称在集合内必须是唯一的，但这是唯一的限制。没有任何阻止我创建自己的模块，例如在我的`ios`集合中创建名为`ios_bgp`的模块，并将其称为`practicalansible.ios.ios_bgp`。在这种情况下，如果你在playbooks和roles中只通过名称`ios_bgp`指定模块，那么你无法保证调用的是哪个模块，因此使用FQCN是至关重要的，以确保你不会遇到任何意外或错误的行为。
- en: Although these concepts relating to FQCNs are simple, they are foundational
    knowledge, and we will rely on this understanding as we proceed through this chapter,
    so it is important that we get them out of the way early on. Now that we’ve achieved
    this, we’ll look in the next section at how to manage collections on your control
    node.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些关于FQCN的概念很简单，它们是基础知识，我们将在本章的进程中依赖这些理解，因此尽早搞清楚它们是很重要的。现在我们已经做到了这一点，接下来我们将在下一节中看看如何管理你的控制节点上的集合。
- en: Managing collections on your control node
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的控制节点上管理集合
- en: As we discussed in [*Chapter 1*](B20846_01.xhtml#_idTextAnchor015), *Getting
    Started with Ansible*, when you install Ansible, it actually installs a set of
    collections, providing equivalent functionality to the latest 2.x release so that
    backward compatibility is maintained (alongside `ansible-core`, of course). This
    process is invisible to the user, and this accompanying collection set also gets
    updated as you update your Ansible installation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第1章*](B20846_01.xhtml#_idTextAnchor015)中讨论的，*开始使用Ansible*，当你安装Ansible时，实际上安装了一组集合，提供了与最新的2.x版本相当的功能，以保持向后兼容性（当然还有`ansible-core`）。这个过程对用户来说是不可见的，同时随着你更新Ansible的安装，伴随的集合也会得到更新。
- en: Given this, you could be forgiven for wondering why you need to learn about
    managing collections at all – after all, Ansible comes with a huge set by default,
    and the collections get updated as you update your installation. Yet this is the
    beauty of collections – if they do exactly what you need to do, then you need
    to take further action. In contrast, if you actually do need to extend the functionality
    of your Ansible control node, you can do just that – the power lies in the choice
    and flexibility, just as it always has with Ansible.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，你可能会想知道为什么需要学习如何管理集合——毕竟，Ansible默认提供了大量集合，并且随着安装更新，集合也会更新。然而，这正是集合的美妙之处——如果它们确实可以满足你的需求，那么你就不需要采取进一步的行动。相反，如果你确实需要扩展你的Ansible控制节点的功能，你可以做到这一点——力量在于选择和灵活性，正如Ansible一直以来的特点。
- en: To help us understand the management of our collections, let’s start by looking
    at the locations in which they get installed. Like everything in Ansible, the
    paths in which collections get installed are configurable, and you can install
    collections wherever you like (provided you’ve set the correct setting of course).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解如何管理我们的集合，让我们从安装它们的位置开始看起。就像Ansible中的一切一样，集合安装的路径是可配置的，你可以在任何你喜欢的地方安装集合（当然，前提是你已经设置了正确的设置）。
- en: 'If we log into our demo node, where I installed Ansible under my local user
    account using `pip3`, I can query the Ansible collection paths as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们登录到我的演示节点，在该节点上我使用`pip3`在我的本地用户帐户下安装了Ansible，我可以按如下方式查询Ansible集合路径：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What you can see here is that the `COLLECTIONS_PATHS` environment variable
    is not set (denoted by `(default)` displayed in the output), and thus, it has
    defaulted to two known locations:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到的是，`COLLECTIONS_PATHS`环境变量未设置（输出中显示为`(default)`），因此它默认为两个已知位置：
- en: '`~/.``ansible/collections`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/.``ansible/collections`'
- en: '`/``usr/share/ansible/collections`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/``usr/share/ansible/collections`'
- en: 'The collections paths are searched in the order specified, so the location
    under my home directory will be searched prior to the path under `/usr/share`.
    You can set the location for your collections by setting the environment variable
    we just queried previously, or you can create an entry in your `ansible.cfg` file
    in the `[default]` section, using the `collections_paths` key. Please refer to
    this link for more information: [https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#collections-paths](https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#collections-paths).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 集合路径按指定的顺序进行搜索，因此，我的主目录下的路径会在`/usr/share`下的路径之前被搜索。你可以通过设置我们之前查询过的环境变量来设置你的集合位置，或者你也可以在`ansible.cfg`文件的`[default]`部分创建一个条目，使用`collections_paths`键。更多信息，请参考这个链接：[https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#collections-paths](https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#collections-paths)。
- en: 'On my demo node, I have not performed any work on collections so far, and as
    a result, if I try to list the previous paths, I will find that neither of them
    exists. Nonetheless, let’s try and install the `gns3` collection from user `davidban77`
    and see what happens ([https://galaxy.ansible.com/davidban77/gns3](https://galaxy.ansible.com/davidban77/gns3)):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的演示节点上，我到目前为止还没有对集合进行任何操作，因此，如果我尝试列出之前的路径，我会发现这两个路径都不存在。不过，让我们试着从用户`davidban77`安装`gns3`集合，看看会发生什么
    ([https://galaxy.ansible.com/davidban77/gns3](https://galaxy.ansible.com/davidban77/gns3))：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we can see that the collection was installed successfully, and the `ansible-galaxy`
    tool even tells us helpfully where it was installed. However, note that it was
    installed only for my local user account, so if another user on this box wants
    to make use of this collection, they must install their own copy. This is fine,
    but it risks creating issues further down the road if they install a different
    version (which might happen because they install the same collection but later
    on, after an update has been made).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到集合已经成功安装，而且`ansible-galaxy`工具甚至告诉我们安装的位置。然而，请注意，它仅为我的本地用户帐户安装了该集合，因此如果本机上的另一个用户想要使用此集合，他们必须安装自己的副本。这是可以的，但如果他们安装了不同的版本（例如，他们安装了同一个集合，但安装时间较晚，更新后版本不同），这可能会在以后引发问题。
- en: 'However, we can get around this. The first way is to install the collection(s)
    you need centrally so that all users can access them. We know that, by default,
    the `COLLECTIONS_PATHS` variable will search `/usr/share/ansible/collections`,
    and this will be accessible to all users, so any collections that need to be available
    globally can be installed here. The path won’t exist by default, but you can easily
    create it and install the collection here by running the following commands:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以绕过这个问题。第一种方法是集中安装所需的集合，以便所有用户都可以访问它们。我们知道，默认情况下，`COLLECTIONS_PATHS`变量会搜索`/usr/share/ansible/collections`，并且所有用户都可以访问它，因此需要全局可用的集合可以安装在这里。默认情况下路径并不存在，但你可以通过运行以下命令轻松创建它并在此安装集合：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the `chmod` command used is a blunt-force method to grant all users
    access to install collections in this shared directory. It is recommended that
    you set up suitable access controls to this directory as is appropriate for your
    environment, but as this will differ in every scenario, this is left as an exercise
    for you to complete.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用的`chmod`命令是一种粗暴的方法，用来授予所有用户在此共享目录中安装集合的权限。建议你根据环境设置适当的访问控制，但由于这在不同场景下有所不同，具体操作留给你自行完成。
- en: What you will notice now is that we added the `-p` flag to the command we ran
    before, telling `ansible-galaxy` to install our collection in a different location
    than the default (which is the first entry in the `COLLECTIONS_PATHS` variable).
    As such, we have successfully installed the collection in a central location for
    all users to work with.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在会注意到，我们在之前运行的命令中添加了`-p`标志，告诉`ansible-galaxy`将我们的集合安装到与默认位置不同的地方（默认位置是`COLLECTIONS_PATHS`变量中的第一个条目）。因此，我们已经成功地将该集合安装到所有用户可以使用的中央位置。
- en: 'We can validate this using the following command (output truncated for readability):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令来验证这一点（为便于阅读，输出已截断）：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note how the output of this command lists the collections in each of its known
    locations, which includes all paths listed by the `COLLECTIONS_PATHS` variable,
    and also the install location of Ansible (which is included first and is implicit
    in the configuration – you do not need to specify this).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，命令的输出列出了每个已知位置中的集合，这些位置包括`COLLECTIONS_PATHS`变量列出的所有路径，还包括Ansible的安装位置（它排在前面，并且在配置中是隐式的——你无需显式指定）。
- en: 'There is no uninstall option when it comes to collections, but the beauty of
    Ansible has always been in its simplicity, and collections, like roles, are simply
    a set of directories and files in a known structure (there’ll be more on this
    later in the chapter). As a result, if we wanted to uninstall the centrally available
    `davidban77.gns3` collection, you would simply run the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 集合没有卸载选项，但Ansible的魅力一直在于它的简单性，集合就像角色一样，只是一个具有已知结构的目录和文件集（稍后本章会详细介绍）。因此，如果我们想卸载集中式可用的`davidban77.gns3`集合，只需运行以下命令：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you rerun the collection listing, you’ll see that this collection no longer
    appears in the output. What happens if you want to install a specific version
    of a collection though? Well, say you wanted to install the `1.4.0` release of
    the collection we’ve been testing with – you would simply run this command to
    install it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新运行集合列出命令，你会看到该集合不再出现在输出中。那么，如果你想安装特定版本的集合该怎么办呢？假设你想安装我们一直在测试的集合的`1.4.0`版本——你只需运行以下命令进行安装：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we have successfully installed version `1.4.0` of this collection, and
    it has overwritten version `1.5.0`, which we installed earlier. Upgrading collections
    is as simple as either specifying the latest version in place of the earlier one
    we used previously, or forcing a reinstallation (which, by its very nature, installs
    the latest version of the collection):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们成功安装了该集合的版本`1.4.0`，并且它覆盖了我们之前安装的版本`1.5.0`。升级集合非常简单，要么指定最新版本来替代我们之前使用的版本，要么强制重新安装（其本质上会安装集合的最新版本）：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can even specify version ranges – if, for example, we’ve established we
    need to use a version of this collection newer than the `1.2.0` release, but older
    than the `1.5.0` release, we can run the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以指定版本范围——例如，如果我们确定需要使用一个比`1.2.0`版本更新但又比`1.5.0`版本旧的集合，我们可以运行以下命令：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the latest version within the range we specified has been installed –
    a very useful and powerful feature to maintain dependencies.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们已经安装了我们指定范围内的最新版本——这是一个非常有用且强大的功能，用于维护依赖关系。
- en: This discussion on installing and maintaining collection versions brings us
    neatly back to our original concern – how to ensure users are all installing the
    correct version of collections required (or sanctioned) for playbook development.
    We’ve established that you can install collections centrally, and this is certainly
    one viable route. However, this method breaks down as soon as someone starts developing
    and/or running playbooks on another machine. It is clear then that a different
    method will be required.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安装和维护集合版本的讨论将我们带回到最初的问题——如何确保所有用户都安装了开发Playbook所需的正确版本集合（或者是被批准的版本）。我们已经确定可以集中安装集合，这无疑是一个可行的途径。然而，一旦有人开始在其他机器上开发和/或运行Playbook，这种方法就会失效。因此，很显然，我们需要另一种方法。
- en: 'Thankfully, the `ansible-galaxy` command also supports working with requirements
    files – these are simply a list of the required collections (and versions) that
    you need to have installed, and as they are simple text files, they can be committed
    to source control along with all your other automation code. Then, all the people
    involved in your playbook need to do is run a single command to install the required
    collection, and they can then proceed with development and/or running the playbooks
    with the confidence that they have the correct collections installed, and with
    the correct versions. Let’s add one more collection to the previous example and
    create a file called `requirements.yml` with the following content:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`ansible-galaxy` 命令也支持与需求文件配合使用——这些文件只是你需要安装的集合（及其版本）的一个列表，由于它们是简单的文本文件，所以可以与所有其他自动化代码一起提交到源代码控制系统中。然后，参与你剧本的所有人只需要运行一个命令来安装所需的集合，他们就可以继续进行开发和/或运行剧本，同时确保已安装了正确的集合，并且版本也是正确的。让我们在之前的例子中再添加一个集合，并创建一个名为
    `requirements.yml` 的文件，内容如下：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this file, we state that we need the `davidban77.gns3` collection with the
    version constraints we tested earlier, and also the `marmorag.ansodium` collection.
    You can see that we omitted the `name:` key with the second collection – this
    is only required if you specify additional parameters such as `version:`; thus,
    a useful shorthand if you don’t need this is to simply create a list of collection
    names. Once you have this file, you can ensure the collections meet the stated
    requirements by running the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们声明需要 `davidban77.gns3` 集合，并使用我们之前测试过的版本约束，同时还需要 `marmorag.ansodium`
    集合。你可以看到我们在第二个集合中省略了 `name:` 键——只有在你指定了额外的参数（如 `version:`）时才需要这个键；因此，如果你不需要这些参数，创建一个简单的集合名称列表就足够了。一旦有了这个文件，你可以通过运行以下命令来确保集合符合所列要求：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, you can see that the requirements for the `davidban77.gns3` collection
    were already met, so no further action was taken. However, the `marmorag.ansodium`
    collection, which we didn’t previously install, now gets installed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `davidban77.gns3` 集合的需求已经满足，因此没有进一步的操作。然而，之前未安装的 `marmorag.ansodium`
    集合现在被安装了。
- en: As a side note, all the collections we are working from here are publicly available
    at [https://galaxy.ansible.com](https://galaxy.ansible.com) – however, it is important
    to note that you can also specify your own server or even a local tarball to install
    collections with, and we shall see examples of the latter in action later in the
    chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，我们在这里使用的所有集合都可以在 [https://galaxy.ansible.com](https://galaxy.ansible.com)
    上公开获取——然而，值得注意的是，你也可以指定自己的服务器，甚至是本地 tarball 来安装集合，我们将在本章后面看到后者的实际例子。
- en: That concludes our look at managing collections on your control node, and armed
    with this information, you should be able to set up a consistent environment for
    all your automation needs. In the next section, we will look at a subtle variation
    on this theme – how to update the collections that were installed at the time
    you installed the Ansible package.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们关于在控制节点上管理集合的内容介绍，掌握了这些信息后，你应该能够为所有自动化需求建立一个一致的环境。在接下来的部分，我们将探讨这一主题的一个细微变化——如何更新安装
    Ansible 包时安装的集合。
- en: Updating your Ansible collections and core installation
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新你的 Ansible 集合和核心安装
- en: You may very well be asking what happens to the collections you installed at
    the time of installing Ansible – how do you maintain or upgrade them? Naturally,
    one way is to wait for the next release of the `ansible` package, and then upgrade
    it with `pip` – however, this is a brute-force method and may not provide you
    with the results you are looking for. Let’s take a more fine-grained approach.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，安装 Ansible 时安装的集合会发生什么——如何维护或升级它们？当然，一种方法是等待下一个 `ansible` 包的发布，然后通过 `pip`
    升级——但是这是一种暴力方式，可能无法提供你期望的结果。让我们采取一种更加细致的方法。
- en: 'Let’s say you want to get access to the latest features in the `amazon.aws`
    collection, which is bundled with the `ansible` package when you install it –
    you would simply install it (again!) as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要访问 `amazon.aws` 集合中的最新功能，该集合在安装 `ansible` 包时已经捆绑在其中——你只需再次按如下方式安装它：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, if you query the installed collections, you will see the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查询已安装的集合，你将看到以下内容：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Thus, you can see that the original version of the collection has been retained,
    but the newer version has been installed in our local collections directory (as
    specified by `COLLECTIONS_PATHS`). Ansible will use manually installed collections
    in locations specified by this variable in precedence over the originally installed
    collections, so this way, it is easy to upgrade collections that are bundled with
    the Ansible package. If you feel at all nervous about which collection is used,
    there is a handy `lookup` plugin that you can use to query the version of a collection
    being used by Ansible. Consider the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到集合的原始版本已被保留，但新版本已安装在我们的本地集合目录中（由`COLLECTIONS_PATHS`指定）。Ansible将使用手动安装的集合优先于最初安装的集合，因此可以轻松升级与Ansible包捆绑的集合。如果您对使用哪个集合感到不安，可以使用一个方便的`lookup`插件来查询Ansible正在使用的集合的版本。考虑以下代码：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Most of this code should now be familiar to you. All we do here is use a `lookup`
    plugin called `community.general.collection_version`, passing it the value of
    the collection name we want to query (in our case, `amazon.aws`). If we run this,
    it will kindly reassure us that we’re on the version we just installed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数的代码现在对你来说应该已经很熟悉了。我们在这里所做的就是使用一个名为`community.general.collection_version`的`lookup`插件，将我们要查询的集合名称的值传递给它（在我们的例子中是`amazon.aws`）。如果我们运行这个命令，它会友好地告诉我们，我们正在使用我们刚刚安装的版本：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we downgrade the collection to an older version than that installed with
    the `ansible` package (an unlikely scenario, but just for example), we can see
    then that Ansible faithfully adheres to its path search order and does not default
    to the `amazon.aws` collection that was installed as part of the Ansible installation,
    even though this version is newer:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将集合降级到比与`ansible`包一起安装的集合版本旧的版本（这是一个不太可能的场景，但仅举例说明），我们可以看到Ansible会忠实地遵循其路径搜索顺序，不会默认使用作为Ansible安装的一部分而安装的`amazon.aws`集合，尽管该版本较新：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Although simple, this management of collections installed at the time of installing
    Ansible is fundamental to maintaining your control nodes, and as such, it is important
    that we cover it. Now that you’ve learned all about collections, what they are,
    why they are important, and how to administer them, let’s create our very own
    collection to work with in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单，但是在安装Ansible时管理集合的这一步骤对于维护你的控制节点至关重要，因此我们有必要覆盖它。现在你已经学习了关于集合的所有内容，它们的定义，为什么它们重要以及如何管理它们，让我们在下一节中创建我们自己的集合来进一步学习。
- en: Creating your own collections
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的集合
- en: We have learned a great deal about collections and how to manage and maintain
    them. Let’s now complete your knowledge on this topic by creating your own one
    from scratch, thus giving you a full overview of how they are put together and
    how they work.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了关于集合及其如何管理和维护的大量知识。现在让我们通过从头开始创建您自己的集合来完成对此主题的知识，这样您将全面了解它们的组成方式和工作原理。
- en: As with roles (see [*Chapter 4*](B20846_04.xhtml#_idTextAnchor207), *Playbooks
    and Roles*), collections are simply an organized set of files within directories.
    Although you can look up all these directories and create them by hand, we can
    also get the `ansible-galaxy` utility to create a blank template for us to work
    with.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与角色一样（参见[*第四章*](B20846_04.xhtml#_idTextAnchor207)，*Playbooks and Roles*），集合只是一个目录中文件的有序集合。虽然您可以查找所有这些目录并手动创建它们，但我们也可以使用`ansible-galaxy`工具为我们创建一个空白模板来使用。
- en: Let’s start with the fundamentals. We know that we need both a namespace and
    a collection name. If we publish on the Ansible Galaxy website, then the namespace
    will be our GitHub handle, as Ansible Galaxy takes this and uses it as your namespace.
    In our case, we won’t be publishing to Ansible Galaxy, so I’ll choose the namespace
    `practicalansible`, but feel free to substitute this with your GitHub handle in
    all the following example code and commands if you want to publish your work.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始。我们知道我们需要一个命名空间和一个集合名称。如果我们在Ansible Galaxy网站上发布，那么命名空间将会是我们的GitHub句柄，因为Ansible
    Galaxy会将其作为您的命名空间使用。在我们的情况下，我们不会发布到Ansible Galaxy，所以我将选择命名空间`practicalansible`，但如果您希望发布您的工作，请随时将其替换为您的GitHub句柄以及以下所有示例代码和命令。
- en: Once we’ve decided on the namespace, the next step is a collection name. Normally,
    this would be used to indicate what a collection is for, and here, we will use
    this to amalgamate examples found elsewhere in this book, so we’ll simply call
    the collection `examples`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们决定了命名空间，下一步就是选择集合名称。通常，名称会用来表示集合的用途，而在这里，我们将用它来汇集本书中其他地方的示例，因此我们将集合命名为 `examples`。
- en: 'We’ll create an empty directory to work in to separate this from the rest of
    our code, and then we’ll create the skeleton directory structure as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个空目录来进行工作，以便与其他代码分开，然后我们将创建如下的骨架目录结构：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, you can see the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到以下内容：
- en: The top-level directory is the namespace we chose.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶级目录就是我们选择的命名空间。
- en: The next-level directory is the collection name.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一层目录是集合名称。
- en: 'Under these top-level directories, we have the following:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这些顶级目录下，我们有以下内容：
- en: A `README.md` file (mandatory documentation if you submit to Ansible Galaxy,
    and advisable in just about every scenario)
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `README.md` 文件（如果提交到 Ansible Galaxy，必须提供文档，在几乎所有场景下都建议提供）
- en: A `galaxy.yml` file that will contain important metadata about the role, such
    as tags, a license, and a documentation page so that your entry on Ansible Galaxy
    is populated correctly
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `galaxy.yml` 文件，包含角色的关键信息，如标签、许可证以及文档页面，以确保你的条目在 Ansible Galaxy 上正确展示。
- en: We then have a `docs/` directory – this should be used for all documentation
    and will be referenced by the `ansible-doc` command, so it should be populated
    according to best practices.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是 `docs/` 目录——该目录应用于存放所有文档，并将被 `ansible-doc` 命令引用，因此应根据最佳实践进行填充。
- en: There is also a `meta/` directory – this is prepopulated with a `runtime.yml`
    file that is used for submissions to Ansible Galaxy and contains important information
    about the minimum version of `ansible-core` required, as well as other artifacts
    related to deprecation and code upgrade.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一个 `meta/` 目录——这个目录中预先填充了一个 `runtime.yml` 文件，用于提交到 Ansible Galaxy，包含关于所需最低版本的
    `ansible-core` 以及与弃用和代码升级相关的其他重要信息。
- en: Last but by no means least, we have the `plugins/` and `roles/` directories,
    and this is where the code that you are going to distribute will be placed.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是 `plugins/` 和 `roles/` 目录，这里将存放你要分发的代码。
- en: Not created in the skeleton directory structure are two directories called `playbooks/`
    and `tests/`. The `playbooks/` directory is used to distribute playbooks with
    the collection (yes, you can even do this!), which you can run directly from the
    command line (provided you’re using `ansible-core` 2.11 or newer) or via the `import_playbook`
    statement within a playbook.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在骨架目录结构中没有创建的两个目录是 `playbooks/` 和 `tests/`。`playbooks/` 目录用于与集合一起分发 playbook（是的，你甚至可以这么做！），你可以直接从命令行运行它（前提是你使用的是
    `ansible-core` 2.11 或更新版本），或者在 playbook 中通过 `import_playbook` 语句来调用。
- en: 'The `tests/` directory is used to contain automated tests for your code, to
    be run by the `ansible-test` tool. We won’t focus on these in this book, but if
    you’d like to learn more about this topic, this is a great place to start: [https://docs.ansible.com/ansible/latest/dev_guide/developing_collections_testing.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_collections_testing.xhtml).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/` 目录用于存放自动化测试代码，供 `ansible-test` 工具运行。我们在本书中不会重点讲解这个部分，但如果你想深入了解，可以从这个链接开始：[https://docs.ansible.com/ansible/latest/dev_guide/developing_collections_testing.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_collections_testing.xhtml)。'
- en: As not everyone will be able to (or want to) submit to Ansible Galaxy, our focus
    in this chapter will be on the use of collections to distribute and use code such
    as modules and roles. Let’s get started on this.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非每个人都能（或愿意）提交到 Ansible Galaxy，本章的重点将放在使用集合来分发和使用代码（如模块和角色）。我们从这里开始。
- en: Throughout the book so far, you have already seen many examples of running modules
    from collections – this is the most common use case for most users, so we will
    start here.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，你已经看到了许多从集合中运行模块的示例——这是大多数用户最常见的使用场景，因此我们从这里开始。
- en: 'In [*Chapter 5*](B20846_05.xhtml#_idTextAnchor279), *Creating and Consuming*,
    we created a simple module to test called `remotecopy`. We know that collections
    are the standard way to distribute these, so let’s integrate this into our new
    collection. We do this by creating a directory called `modules/` under the `plugins/`
    directory and then copying our code there. The end results should look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 5 章*](B20846_05.xhtml#_idTextAnchor279)中，*创建和使用*部分，我们创建了一个简单的模块来测试，名为`remotecopy`。我们知道集合是分发这些模块的标准方式，所以让我们将它集成到我们的新集合中。我们通过在`plugins/`目录下创建一个名为`modules/`的目录，然后将代码复制到那里来实现。最终结果应该是这样的：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that we didn’t change the code at all in the module from that used in
    [*Chapter 5*](B20846_05.xhtml#_idTextAnchor279), *Creating and Consuming*. No
    modifications to your code are necessary to work with collections – it’s simply
    a matter of making sure you put your files in the correct subdirectory. With that
    done, we can now package up our collection for testing. This is done by changing
    to the root directory of the collection itself and then issuing the `ansible-galaxy
    collection` `build` command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有对模块中的代码做任何修改，它与[*第 5 章*](B20846_05.xhtml#_idTextAnchor279)中的*创建和使用*完全相同。要使用集合，你的代码不需要做任何修改——关键是确保将文件放入正确的子目录。完成这些后，我们现在可以将我们的集合打包进行测试。操作方法是切换到集合根目录，然后执行`ansible-galaxy
    collection` `build`命令：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that Ansible has appended a version number of `1.0.0` to the filename –
    this was obtained from the `galaxy.yml` file and is the default value. We’ll edit
    this in a future example, but for now, it serves our purpose.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Ansible 已经为文件名附加了版本号`1.0.0`——这个版本号来自于`galaxy.yml`文件，是默认值。我们将在未来的示例中进行编辑，但现在它满足我们的需求。
- en: 'With the collection built, it’s time to test it. First of all, we need to create
    an empty directory to work in. Once we’re in there, we can use the `ansible-galaxy`
    command to install our new collection:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 集合构建完成后，到了测试它的时候了。首先，我们需要创建一个空目录来工作。进入该目录后，我们可以使用`ansible-galaxy`命令来安装我们的新集合：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Congratulations! You’ve just created and installed your very first collection!
    From here, we need to create a playbook to test it out. We will create this in
    the same way we did before, making sure to use the FQCN of our newly built and
    installed collection:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你刚刚创建并安装了你的第一个集合！接下来，我们需要创建一个剧本来进行测试。我们将像之前一样创建它，确保使用我们新构建并安装的集合的FQCN：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we will run the playbook in the normal manner – again, no other special
    commands or configurations are required, even though we’ve just built and installed
    our own collection:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将以正常的方式运行剧本——同样，不需要其他特别的命令或配置，即使我们刚刚构建并安装了自己的集合：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can see that our module works perfectly, and thus, you can feel accomplished
    that you have just successfully built, installed, and integrated your first collection
    using code we already provided in the book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的模块运行完美，因此你可以感到自豪，因为你刚刚成功地构建、安装并集成了你用本书中已有代码构建的第一个集合。
- en: 'You can also query the documentation that was built into this module in the
    normal manner:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以以正常的方式查询该模块中内建的文档：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Of course, we’ve built our first collection but also written a separate playbook
    as a test harness for it. In many cases, you wouldn’t just write a simple test
    harness as we have here – you would write a playbook to solve an actual use case,
    or even provide some example code to show how the collection can be used. Let’s
    do this now by adding our playbook to the collection:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不仅构建了第一个集合，还写了一个单独的剧本作为测试工具。在很多情况下，你不仅仅会像我们这里写一个简单的测试工具——你会编写一个剧本来解决实际用例，甚至提供一些示例代码来展示如何使用该集合。现在，让我们通过将剧本添加到集合中来做到这一点：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Although we don’t modify the playbook code, our playbook has a hardcoded `hosts`
    line in the play definition set to `localhost` – you’d probably never do this
    in a real collection, and the Ansible documentation itself recommends using a
    variable to define the hosts so that users can specify their own pattern here.
    We’re just distributing example code via the collection though, so in our case,
    we can justify this decision.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有修改剧本代码，但我们的剧本在剧本定义中有一个硬编码的`hosts`行，设置为`localhost`——在实际集合中你可能永远不会这样做，Ansible
    文档本身也建议使用变量来定义主机，以便用户可以在此处指定自己的模式。不过，我们这里只是通过集合分发示例代码，因此在我们的案例中，这一决策是合理的。
- en: 'While not changing the playbook file contents, we change the filename as part
    of the `cp` command. This is done because Ansible does not support the use of
    hyphens (`-`) in filenames when you refer to objects in a collection – an important
    point that might trip you up later! Also, note here that we’ve used the `sed`
    command to change the version number in the `galaxy.yml` file to make it easy
    to read the code in the book, but you are welcome to edit it with your favorite
    text editor. With this done, we can repackage the collection in the same manner
    as we did before:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有改变playbook文件的内容，但我们在`cp`命令中更改了文件名。这样做是因为Ansible不支持在引用集合中的对象时使用文件名中的连字符（`-`）——这是一个重要的细节，稍后可能会让你困扰！另外，注意我们使用了`sed`命令来更改`galaxy.yml`文件中的版本号，使得书中的代码更易读，但你也可以使用你喜欢的文本编辑器进行编辑。完成这些操作后，我们可以像之前一样重新打包集合：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can now run the playbook from the command line by simply providing the
    fully qualified playbook name:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过提供完全限定的playbook名称从命令行运行playbook：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You have now successfully added a playbook to your collection, bumped up the
    version number, and upgraded your local installation. You’ve even run the playbook
    from the collection directly rather than from a local file, as we have throughout
    all other examples in the book. We hope you feel a sense of accomplishment at
    this point! Let’s now extend our collection with another example – integrating
    a plugin. Once again, we’ll make use of code provided elsewhere in this book –
    specifically, [*Chapter 7*](B20846_07.xhtml#_idTextAnchor343), *Creating and*
    *Consuming* *Plugins*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经成功地将一个playbook添加到你的集合中，提升了版本号，并升级了本地安装。你甚至直接从集合中运行了playbook，而不是像本书中的其他例子一样从本地文件中运行。希望你此刻能感受到一种成就感！接下来，我们将通过另一个例子来扩展我们的集合——集成插件。我们将再次使用本书中其他地方提供的代码——具体来说是[*第7章*](B20846_07.xhtml#_idTextAnchor343)，*创建和*
    *使用* *插件*。
- en: 'To do this, we need to copy the code we need into our collection. While you
    would expect plugins to go under the `plugins/` directory, they must actually
    be placed under a subdirectory within this, named by the plugin type. We will
    copy over a `lookup` plugin, so we must create a directory called `lookup/` before
    we can copy the plugin code to it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要将所需的代码复制到我们的集合中。虽然你可能期望插件放在`plugins/`目录下，但它们实际上必须放在该目录下的一个子目录中，并按照插件类型命名。我们将复制一个`lookup`插件，因此我们必须先创建一个名为`lookup/`的目录，然后才能将插件代码复制到其中：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once again, we haven’t modified the plugin code at all – we have just placed
    it into our directory structure. Again, we’ve bumped up the version number of
    the collection using `sed` to edit the `galaxy.yml` file in place. With this done,
    we can build and install the new version of the collection in the normal manner:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，我们并没有修改插件代码——我们只是将它放入了我们的目录结构中。同样，我们使用`sed`编辑`galaxy.yml`文件以提升集合的版本号。完成这些操作后，我们可以以正常方式构建并安装新版本的集合：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With that completed, it is once again time to test our newly enhanced collection
    via a playbook. This time, we won’t build the playbook into the collection – we’ll
    simply create it and run it from the test directory we created earlier. The playbook
    code should look like the following – again, you should find it unchanged from
    [*Chapter 7*](B20846_07.xhtml#_idTextAnchor343), *Creating and Consuming* *Plugins*,
    except that we’ve put the FQCN of the `lookup` plugin into the playbook rather
    than the short form name you might otherwise use:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一点后，又到了通过playbook测试我们新增强的集合的时刻。这次，我们不会将playbook构建到集合中——我们只需创建它并从之前创建的测试目录中运行它。playbook代码应如下所示——再次，你应该发现它与[*第7章*](B20846_07.xhtml#_idTextAnchor343)，*创建和使用*
    *插件*中的内容完全一致，唯一的不同是我们在playbook中使用了`lookup`插件的FQCN，而不是你可能会使用的简短名称：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Remember to also create a file called `testdoc.txt` in the same directory as
    the playbook for the `lookup` plugin to reference – our example contains the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在与playbook相同的目录下创建一个名为`testdoc.txt`的文件，以供`lookup`插件引用——我们的示例包含如下内容：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, run the playbook in the normal manner, and you should find that the
    plugin works as desired:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以正常方式运行playbook，你应该会发现插件如预期般正常工作：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, our `lookup` plugin works perfectly as part of our newly expanded
    collection. To round off our look at building our own collection, we will expand
    it further still by adding a role to it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的`lookup`插件在我们新扩展的集合中表现完美。为了完整地展示如何构建自己的集合，我们将通过向其中添加一个角色来进一步扩展它。
- en: To provide a little background, `ansible-galaxy` (both the tool and the Ansible
    Galaxy website) were originally envisaged to be used to manage, distribute, and
    install roles. Given that the processes for managing collections, and that their
    purpose as reusable Ansible code artifacts is very similar to the original roles
    for which they were designed, it makes perfect sense to use the same tooling for
    collection management.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一些背景信息，`ansible-galaxy`（包括工具和 Ansible Galaxy 网站）最初设想用于管理、分发和安装角色。考虑到管理集合的过程，以及集合作为可重用的
    Ansible 代码工件的用途与其最初设计的角色非常相似，因此使用相同的工具来管理集合是非常合理的。
- en: At the time of writing, the Galaxy tools and website support both roles and
    collections and are likely to for the foreseeable future. However, collections
    provide a number of advantages, including the option to package multiple roles
    in a single collection, and you also can use them to distribute any plugins (or
    even modules) that might be needed for the roles.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在写本文时，Galaxy 工具和网站同时支持角色和集合，并且预计在可预见的未来仍将继续支持。不过，集合提供了许多优点，包括将多个角色打包到一个集合中的选项，并且你还可以使用集合分发任何可能需要的插件（甚至模块）。
- en: The process to migrate a role to a collection is incredibly easy, and if you
    have a simple role that only includes objects such as tasks, files, templates,
    handlers, and variables, then you can copy the code over as is (to the correct
    place, naturally) without any modifications. However, special care needs to be
    taken if you included plugins with your role previously, as these will need to
    be moved aside from the role and integrated into the collection itself at the
    top level (in exactly the same way as we integrated our demo `lookup` plugin a
    little earlier in this section).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将角色迁移到集合的过程非常简单，如果你有一个仅包含任务、文件、模板、处理程序和变量等对象的简单角色，那么你可以直接将代码复制过去（自然是到正确的位置）而无需任何修改。然而，如果你之前在角色中包含了插件，那么需要特别注意，因为这些插件需要从角色中分离出来，并以与我们在本节稍早时候集成的
    `lookup` 插件相同的方式，集成到集合的顶层。
- en: 'To extend our example, we’ll take one of the roles that we demonstrated in
    [*Chapter 4*](B20846_04.xhtml#_idTextAnchor207), *Playbooks and Roles*, to show
    how it can be integrated and tested. As before, we need to change to our collection
    directory and copy the role over (retaining its directory structure) into a `roles/`
    directory within the collection. You can do this as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展我们的示例，我们将取自 [*第 4 章*](B20846_04.xhtml#_idTextAnchor207)《剧本与角色》中的一个角色，演示如何将其集成并进行测试。与之前一样，我们需要切换到集合目录，并将角色复制到集合中的
    `roles/` 目录中（保留其目录结构）。你可以按照以下方式操作：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you can see, the role is now copied into place and retains the same structure
    as before, under the `roles/` subdirectory within the collection. With this complete,
    we can now build the new collection (we have incremented the version number again)
    and install it:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，角色现在已被复制到适当位置，并且保持与之前相同的结构，位于集合中的 `roles/` 子目录下。完成此操作后，我们可以构建新的集合（我们再次增加了版本号）并进行安装：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With the newly updated role in place, all that remains to do is test it. We
    will borrow the same playbook we used to test it before, with a small modification
    to call the role from the collection:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的更新版角色后，剩下的工作就是测试它。我们将借用之前用于测试的相同剧本，只需稍作修改，从集合中调用角色：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As this is a role to install Apache on external nodes, we will need to copy
    over the inventory we used before – if you use the GitHub repository that accompanies
    this book, that has been done for you. All that remains is to run the code, which
    should return something like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个在外部节点上安装 Apache 的角色，我们需要复制之前使用的库存文件——如果你使用了本书附带的 GitHub 仓库，这些都已经为你做了。剩下的就是运行代码，结果应该类似于：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: No changes will be made if you ran this role previously as part of [*Chapter
    4*](B20846_04.xhtml#_idTextAnchor207), *Playbooks and Roles*, but you can clearly
    see from the preceding that we successfully call the role from the collection
    and it works perfectly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前作为 [*第 4 章*](B20846_04.xhtml#_idTextAnchor207)《剧本与角色》的一部分运行了这个角色，那么不会做任何更改，但从前面的内容可以清楚地看到，我们成功地从集合中调用了该角色，并且它运行得非常完美。
- en: With that, we have successfully integrated a plugin, a module, a playbook, and
    a role into a collection, taking you through the entire process of building and
    adding to your own collection. That wraps up our look at collections in depth,
    but I hope that this has given you enough information to proceed with your own
    testing and development, ultimately building your own collections.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经成功地将插件、模块、剧本和角色集成到集合中，带您完成了构建和添加到自己集合的整个过程。这也标志着我们对集合的深入探讨的结束，但我希望这些信息足以帮助您进行自己的测试和开发，最终构建您自己的集合。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Collections are now a vitally important part of Ansible’s overall architecture,
    and they provide an easy and effective mechanism for all code to be distributed
    and managed on control nodes everywhere. Learning about collections is vital to
    your understanding of the architecture of any modern version of Ansible, and armed
    with this information, you can manage, build, and maintain collections on your
    control nodes, even contributing them back to the community if you so desire.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 集合现在是 Ansible 整体架构中至关重要的一部分，它为所有代码的分发和管理提供了一个简单而有效的机制，控制节点上的所有代码都能通过它进行管理。学习集合对理解任何现代版本
    Ansible 的架构至关重要，掌握这些信息后，您可以在控制节点上管理、构建和维护集合，甚至将其贡献回社区，如果您愿意的话。
- en: In this chapter, you learned about the history of collections, how they came
    about, and why they are so important to Ansible. You then learned how to reference
    objects from within collections using FQCNs, before moving on to learning about
    the installation and management of collections on your control node. Finally,
    we looked at the process involved in building, installing, and testing your own
    collection, such that you can progress to contributing collections to the wider
    Ansible community if you so desire.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了集合的历史，它们是如何产生的，以及它们对 Ansible 为什么如此重要。接着，您学会了如何使用 FQCN 引用集合中的对象，然后继续学习如何在控制节点上安装和管理集合。最后，我们查看了构建、安装和测试自己集合的过程，您可以根据需要将自己的集合贡献给更广泛的
    Ansible 社区。
- en: In the next chapter, we will learn how to consume and create our very own plugins,
    providing you with the skills you need to expand the capabilities of Ansible to
    suit your own bespoke environments and contribute to the community.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习如何使用和创建我们自己的插件，提供扩展 Ansible 功能所需的技能，以适应您的定制环境，并为社区做出贡献。
- en: Questions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Collections are an optional feature of Ansible versions later than 2.9:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合是 Ansible 2.9 之后版本的可选功能：
- en: 'True'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'False'
- en: What does the acronym FQCN stand for?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩写 FQCN 代表什么？
- en: Fully Qualified Collection Namespace
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全限定集合命名空间
- en: Fully Qualified Control Node
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全限定控制节点
- en: Fully Qualified Collection Name
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全限定集合名称
- en: Fully Qualified Control Name
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全限定控制名称
- en: Collections are installed and managed with which command?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用哪个命令安装和管理集合？
- en: '`ansible-galaxy`'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible-galaxy`'
- en: '`ansible-collection`'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible-collection`'
- en: '`ansible`'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible`'
- en: '`collection-manager`'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`collection-manager`'
- en: Further reading
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '`ansible-galaxy` and its documentation can be found here: [https://galaxy.ansible.com/docs/](https://galaxy.ansible.com/docs/)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-galaxy` 及其文档可以在此找到：[https://galaxy.ansible.com/docs/](https://galaxy.ansible.com/docs/)'
