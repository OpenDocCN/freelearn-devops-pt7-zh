["```\ngit clone git@github.com:JesseLiberty/ProGitForProgrammers.git \n```", "```\ngit status \n```", "```\ngit add ProGitForProgrammers/\ngit commit -m \"First commit – from command line\" \n```", "```\ngit push \n```", "```\nnamespace ProGitForProgrammers\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World!\");\n           `**Console.WriteLine(\"I just added this in Visual Studio\");**         }     } }` \n```", "````Having made your change, you want to check it in. Since we are in the `VisualStudio` directory, we'll do the work right within Visual Studio. Click the `Git` menu and choose **Commit or Stash**. A Git window will open as a tab next to **Solution Explorer**. Enter a commit message and press **Commit All**:  ![](img/B17441_02_14.png)  Figure 2.14: Git window in Visual Studio    Note that if you drop down the **Commit All** menu, you have a number of shortcuts for adding, committing, and pushing your changes.    As you can see, and will see often in this book, you can do almost anything in Visual Studio that you can do at the command line.    ### Pushing to the server    You have now committed your changes to your local repository. The GitHub repository, however, doesn't know about your changes. (You can prove this to yourself by returning to GitHub and drilling down to `Program.cs`.)    The other programmers' repositories (for example, `CommandLine` and `GitHubDesktop`) are equally oblivious. To disseminate this change, you first push your changes up to the server (GitHub) and then pull them down to the other repositories.    From within Visual Studio's Git window, press **Staged**. This will stage your changes for committing. Next, click **Commit**. This will put your changes into your local repository (be sure to give the commit a meaningful message).    Examine the Git window; there is a lot of information:  ![](img/B17441_02_15.png)  Figure 2.15: The Git window in Visual Studio    You are told that the commit was created locally (and locally is the important part!). Below that is the status of your commit. You have one to push up to the server (outgoing) and none to bring down (incoming):  ![](img/B17441_02_16.png)  Figure 2.16: Uploading a commit from Visual Studio    Now, find the up-pointing arrow in the upper-right corner. Hover over it and you'll see that it says `Push`. Click that button to push your changes to the server. When it is done, it will give you a success message. Ignore the offer to create a pull request for now.    Look to the left of your Git menu and see the local history of your commits:  ![](img/B17441_02_17.png)  Figure 2.17: The history of commits    Each dot signals a commit, and next to each dot is your commit message (and now you can see why meaningful commit messages are both hard to write and worth the effort). There is also an indicator that main is pointing to your last commit.    If you check GitHub (remember to refresh the page) you will now see the line in `Program.cs`. Make sure you understand why: this is because after we committed the change, we pushed it to the remote repository.    ## Downloading the changes at the command line    We created the changes in the `VisualStudio` directory. `CommandLine` and `GitHubDesktop` know nothing of the changes, even though they are now on GitHub.    For these directories to know about the changes, you need to pull the changes down.    Change directories to `CommandLine`. Examine the contents of `Program.cs`; the new line is not there. Open your terminal and enter `pull`. This will pull any changes from the server to your local repository.    The result should look like this:  ![](img/B17441_02_18.png)  Figure 2.18: Pulling from the remote repository    Git is telling you that it formatted and compressed your files and passed them down to your repository. Toward the bottom it says that it used Fast-forward. We'll discuss this in *Chapter 4*, *Merging, Pull Requests, and Handling Merge Conflicts*.    Take a look at `Program.cs` now in your command directory; the new addition should now be there.    Want to do something cool? Open the `Program.cs` file before updating. After the update you will see the second `WriteLine` pop into view. What is actually happening is that the code that was in your directory is replaced by the new code on the pull.    ### Downloading the changes using GitHub Desktop    Change directories to `GitHubDesktop` and open the GitHub Desktop program. It will give you a lot of information about the status of your repository (**No Local Changes**) and it will automatically check and inform you that there is one commit to update your local repository with:  ![](img/B17441_02_19.png)  Figure 2.19: The view from the remote repository    Go ahead and click **Pull origin**. It does the pull, and the button disappears. Check your code; the change should now be in your `Program.cs` (and is recorded in your local repository).    All three local repositories and the server repository are now in sync.    # Starting at the command line    You can start the process at any of our repositories. Last time we started in the `VisualStudio` repository and then pulled the changes down to the `CommandLine` and `GitDesktop` repos. This time, let's start at the command line.    Open Visual Studio and point it to the project in your `CommandLine` directory. Just to be certain, right-click on **Solution**, select **Open Folder in File Explorer**, and make sure you are in the right directory.    To keep this example very simple, we'll just add another line to `Program.cs`:    ``` class Program {     static void Main(string[] args)     {         Console.WriteLine(\"Hello World!\");         Console.WriteLine(\"I just added this in Visual Studio\");         Console.WriteLine(\"I just added this in the command line repo\");     } }  ```    Normally you would make many more changes before checking in, but again, this is a demo and we're more interested in using Git than we are in fussing with this silly program. Save all your files and at the command line get the status by entering:    ``` git status  ```    This will give you output that looks like this:  ![](img/B17441_02_20.png)  Figure 2.20: The command line indicating one file has been modified    The key piece of information is the modified file. That is just as it should be, as that is the file we modified. You can now add it to the index and then commit it:    ``` git add ProGitForProgrammers/ProGitForProgrammers/Program.cs git commit -m \"Add writeline indicating we are in command line\"  ```    On the other hand, you can combine these two steps with the `-a` flag:    ``` git commit -a -m \"Add writeline indicating we are in command line\"  ```    You will want to draw a distinction between untracked files and modified files. Untracked files are outside of Git and cannot be manipulated inside Git until they are added; modified files are tracked by Git but have changed since the last commit.    If we are happy with the commit we've added, we can (optionally) push it to the server:  ![](img/B17441_02_21.png)  Figure 2.21: Pushing our commit to the remote repository    We'll want to do that because we want to share this code with the other programmers.    ## Pulling to GitHub Desktop    Switching to GitHub Desktop, we see that it already knows there is something to pull, as we saw last time. (If it doesn't, push the **Fetch** button, which will go to the server to see if there is anything to bring back.)    That's two repos that are identical, but the `VisualStudio` repo is not yet up to date. Let's return to Visual Studio in the `VisualStudio` folder.    ## Pulling to Visual Studio    Open the Git menu item, and select `Pull`. Watch your source code and see the third line pop into existence. Once again, the three local repositories and the remote repo are all in sync.    # Commits – best practices    Like everything else in programming, best practices in commits are, to some degree, controversial. The first issue is frequency.    ## How often should I commit?    There are those who say a commit should be atomic: representing exactly one unit of work (one task, one bug fix). No more and no less. So, according to this line of thought, if you are in the middle of work and you get called away, you should not commit, but you should use the stash. The stash is an area where you can put files that you want to come back to later. You can name sets of files that you stash, and then pick the one you want to restore by name.    This is a defensible position, but I hold the opposite: commit early and commit often.    Commits are cheap and fast in Git, and interactive rebase (see *Chapter 6*, *Interactive Rebasing*) allows you to \"squash\" commits together. Therefore, if you are working on a feature and you make five interim commits before you are done, you'll have the opportunity to squash them into a single commit with a single message. This is the best of both worlds: you secure your interim work with a commit, and you present only one commit (rather than five) to the server.    ## Keep your commit history clean    The first way that a programmer reviews your code is to look at the list of commits and then dive into those that are interesting. A good history of commits with well-written messages is a delight to review. A long, tedious history with meaningless messages is only slightly more fun than eating glass.    ## A note on commit messages    As you will see later in this book, commit messages are very important for anyone (including you) reviewing your commit history. By convention, commit messages should be in the imperative, and should tell you exactly what is in that commit.    ``` Fixing some files                        // bad Fix WriteLine in helloworld.cs           // good  ```    In practice you'll often find comments in the past tense:    ``` Fixed WriteLine in helloworld.cs         // good enough  ```    > *\"In theory, theory and practice are the same; in practice, they never are*.\" -- Pat Johnson    It pays to get into the habit of writing good messages in the right format. Your teammates will thank you.    ## When the title isn't enough    The message title should be kept to 50 characters. Most of the time this is enough, but if it isn't, leave the `-m` message off and let Git open your editor. There you can add additional information. Skip a line after the header and consider using bullet points or other ways of making the things you want to convey easy to read.    Important: By default Git uses vi (a Unix editor). You'll want to enter:    ``` git config ––global core editor \"code -w\"  ```    This ensures that Visual Studio Code is your default editor:  ![](img/B17441_02_22.png)  Figure 2.22: Editing in Visual Studio Code    Note that `#` is the comment character, and all lines that begin with `#` will be ignored.    When you use `log` (see *Chapter 9*, *Using the Log*) to see your history (or view history in Visual Studio, etc.) you'll see the entire message:  ![](img/B17441_02_23.png)  Figure 2.23: The output of the log command    You can see just the headers if you want, using `git log -–oneline`, but we'll leave the details for *Chapter 9*, *Using the Log*:  ![](img/B17441_02_24.png)  Figure 2.24: log using the oneline flag    # Summary    In this chapter, we have covered a number of topics relating to creating and interacting with your repository. We discussed:    *   Creating your repository *   The relationship between your local and remote repositories *   Git pull *   Git push *   Starting at the command line *   Using Visual Studio *   Commits: best practices    In the next chapter, we'll take a look at the various places Git keeps your files, and the relationship between adding an untracked file and committing a tracked file.````"]