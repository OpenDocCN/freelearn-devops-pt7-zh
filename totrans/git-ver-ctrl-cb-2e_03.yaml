- en: Branching, Merging, and Options
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支、合并和选项
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下几种方法：
- en: Managing your local branches
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理你的本地分支
- en: Branches with remotes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有远程的分支
- en: Forcing a merge commit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制合并提交
- en: Using git reuse recorded resolution (rerere) to merge Git conflicts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Git 重用已记录的解决方案（rerere）来合并 Git 冲突
- en: Computing the difference between branches
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算分支之间的差异
- en: Orphan branches
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 孤立分支
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: If you are developing a small application in a big corporation as a developer,
    or you are trying to wrap your head around an open source project from GitHub,
    you have already been using branches with Git.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在大公司作为开发者开发一个小型应用，或者你正在尝试理解一个来自 GitHub 的开源项目，你已经在使用 Git 的分支功能了。
- en: Most of the time, you may have just been working on a local development or master
    branch, and so didn't care so much about other branches.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你可能只是一直在本地的开发分支或主分支上工作，因此没有太在意其他分支。
- en: In this chapter, we will show you different branch types and how to work with
    them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示不同类型的分支以及如何使用它们。
- en: Managing your local branches
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理你的本地分支
- en: Suppose you just have your local Git repository, and, at the moment, you have
    no intention of sharing the code with others; you can, however, easily share the
    knowledge you have while working with a repository with one or more remotes. Local
    branches with no remotes work exactly in this fashion. As you can see in the examples,
    we are cloning a repository, and thus we have a remote.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你只有本地 Git 仓库，并且目前没有分享代码给其他人的计划；不过，你仍然可以轻松地将你在与仓库合作时所获得的知识分享给一个或多个远程仓库。没有远程的本地分支正是这样工作的。如你所见，在示例中，我们正在克隆一个仓库，因此我们有一个远程。
- en: Let's start by creating a few local branches.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建几个本地分支开始。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Use the following command to clone the `jgit` repository to match:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令克隆 `jgit` 仓库以进行匹配：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to manage your local branches:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来管理你的本地分支：
- en: 'Whenever you start working on a bug fix or a new feature in your project, you
    should create a branch. You can do so using the following code:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当你开始修复 Bug 或开发新特性时，都应该创建一个分支。你可以使用以下代码做到这一点：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `newBugFix` branch points to the current `HEAD` you were on at the time
    of the creation. You can see the `HEAD` with `git log -1`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`newBugFix` 分支指向创建时你所处的当前 `HEAD`。你可以通过 `git log -1` 查看 `HEAD`：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you want to add a description to the branch, you can do this with the `--edit-description`
    option for the git branch command:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想为分支添加描述，可以使用 `git branch` 命令的 `--edit-description` 选项来做到这一点：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The previous command will open an editor where you can type in a description:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一个命令会打开一个编辑器，你可以在其中输入描述：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Close the editor and the message will be saved.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器后，消息将被保存。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Git stores the information in the local `git config` file; this also means that
    you cannot push this information to a remote repository.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Git 会将信息存储在本地的 `git config` 文件中；这也意味着你无法将这些信息推送到远程仓库。
- en: 'To retrieve the description for the branch, you can use the `--get` flag for
    the `git config` command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索分支的描述，你可以使用 `git config` 命令的 `--get` 标志：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will be beneficial when we automate some tasks in [Chapter 7](fcc6f77f-119c-41e9-b4b0-9b7df263b7f1.xhtml),
    *Enhancing Your Daily Work with Git Hooks*, *Aliases, and Scripts*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们在 [第7章](fcc6f77f-119c-41e9-b4b0-9b7df263b7f1.xhtml) 中自动化一些任务时非常有帮助，*通过
    Git Hooks、*别名* 和脚本来提升你的日常工作*。
- en: Remember to perform a checkout of `newBugFix` before you start working on it.
    This must be done with the Git checkout of `newBugFix`. If you are in a hurry,
    you can create and checkout a new branch in a single command. Just give the option
    `-b` to `checkout`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在开始工作之前先切换到 `newBugFix` 分支。这必须通过 Git 的 `checkout` 命令来完成。如果你着急，也可以通过一个命令来创建并切换到新分支。只需在
    `checkout` 命令中加上 `-b` 选项。
- en: 'The branch information is stored as a file in `.git/refs/heads/newBugFix`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 分支信息会以文件的形式存储在 `.git/refs/heads/newBugFix` 中：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that it is the same commit hash we retrieved with the `git log` command.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是我们通过 `git log` 命令获取的相同提交哈希。
- en: There's more...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Perhaps you want to create specific branches from specific commit hashes. The
    first thought might be to check out the commit, and then create a branch; however,
    it is much easier to use the `git branch` command to create the branches without
    checking out the commits:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你想从特定的提交哈希值创建特定的分支。你可能首先想到的是检出该提交，然后创建一个分支；然而，使用`git branch`命令直接创建分支而不检出提交要简单得多：
- en: 'If you need a branch from a specific commit hash, you can create it with the
    `git branch` command as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你需要从特定的提交哈希值创建一个分支，可以使用`git branch`命令如下：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, the abbreviated commit hash is shown when you use `%h`, and
    the full commit hash is shown when you use `%H`. You can see that the abbreviated
    commit hash is the same as the one used to create the branch. Most of the time,
    you want to create and start working on the branch immediately:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，当你使用`%h`时，显示的是简化的提交哈希，而当你使用`%H`时，显示的是完整的提交哈希。你可以看到，简化的提交哈希与用于创建分支的哈希相同。大多数情况下，你希望立即创建并开始在分支上工作：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Git switches to the new branch immediately after it creates the branch. Verify
    with `gitk` to see whether the `lastBugFix` branch is checked out and another
    `BugFix` branch is at the same commit hash:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Git会在创建分支后立即切换到新分支。可以使用`gitk`验证是否已经切换到`lastBugFix`分支，并且另一个`BugFix`分支处于相同的提交哈希值：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This can be shown via a screenshot as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下截图来展示：
- en: '![](img/77c7e1a2-9511-4240-878c-ab4d41cdafe5.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77c7e1a2-9511-4240-878c-ab4d41cdafe5.png)'
- en: 'Instead of using Gitk, you can also add `-v` to the `git branch` command or
    even another `-v`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不使用Gitk时，你也可以在`git branch`命令中添加`-v`，甚至可以再加一个`-v`：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With `-v`, you can see the abbreviated commit hash for each branch, and with
    `-vv`, you can also see that the master branch tracks the origin/master branch:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-v`，你可以查看每个分支的简化提交哈希，而使用`-vv`，你还可以看到`master`分支跟踪`origin/master`分支：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Branches with remotes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有远程仓库的分支
- en: At some point, it is very likely that you have cloned somebody's repository.
    This means that you have an associated remote. The remote is usually called origin
    because it is where the source originated from.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，很可能你已经克隆了别人的仓库。这意味着你有一个关联的远程仓库。这个远程仓库通常被称为`origin`，因为它是源代码的来源。
- en: While working with Git and remotes, you will get some benefits from Git.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Git和远程仓库时，你将从Git中获得一些好处。
- en: We can start with git status and see what we get while working with the remote.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`git status`开始，看看在与远程仓库交互时我们得到的结果。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Follow these steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'We will start by checking out a local branch that tracks a remote branch:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先检查一个跟踪远程分支的本地分支：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The previous command creates and checks out the `remoteBugFix` branch that will
    track the `origin/stable-3.2` branch. Therefore, for instance, executing `git
    status` will automatically show how different your branch is from `origin/stable-3.2`,
    and it will also show whether your branch's `HEAD` can be fast forwarded to the
    `HEAD` of the remote branch or not.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一个命令创建并切换到`remoteBugFix`分支，该分支将跟踪`origin/stable-3.2`分支。因此，例如，执行`git status`将自动显示你的分支与`origin/stable-3.2`的差异，并且它还会显示你的分支`HEAD`是否可以快速前移到远程分支的`HEAD`。
- en: 'To provide an example of how the previous step works, we need to do some manual
    work that will simulate this situation. First, we find a commit:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提供一个如何执行前一步骤的示例，我们需要做一些手动操作来模拟这种情况。首先，我们找到一个提交：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The command will list the last 10 commits on the `stable-3.2` branch from the
    remote origin. The `--oneline` option will show the abbreviated commit hash and
    the commit subject. For this recipe, we will be using the following commit:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该命令将列出`stable-3.2`分支的最后10个提交，这些提交来自远程的`origin`。`--oneline`选项将显示简化的提交哈希和提交主题。对于这个例子，我们将使用以下提交：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will reset the `remoteBugFix` branch to the `2e0d178` commit hash. We are
    now ready to continue using the free benefits of Git when we have a remote tracking
    branch.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将重置`remoteBugFix`分支到`2e0d178`提交哈希值。现在我们已经准备好继续使用Git的免费功能，当我们有远程跟踪分支时。
- en: We are resetting to a commit that is accessible from the `origin/stable-3.2`
    remote tracking branch; this is done to simulate that we have performed a Git
    fetch and new commits were downloaded for the `origin/stable-3.2` branch.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在重置到一个可以从`origin/stable-3.2`远程跟踪分支访问的提交；这样做是为了模拟我们已经执行了Git fetch并下载了`origin/stable-3.2`分支的新提交。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here, we will try a few commands that assist you when you have a remote tracking
    branch:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将尝试一些命令，帮助你在有远程跟踪分支时操作：
- en: 'Start by executing `git status`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从执行`git status`开始：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Git is very descriptive when you have a tracking branch and you use `git status`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个跟踪分支并使用`git status`时，Git 会非常详细地描述当前状态。
- en: 'As you can see from the message, you can use `git pull` to update your local
    branch, which we will try in the next example. The message says it can be fast-forwarded.
    It simply means that Git can advance the `HEAD` without merging. Now, we will
    just perform the merge:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从消息中你可以看到，可以使用`git pull`来更新你的本地分支，我们将在下一个示例中尝试这个。消息说它可以进行快进合并。这意味着 Git 可以在不进行合并的情况下推进`HEAD`。现在，我们将执行合并操作：
- en: The `git pull` command is just a `git fetch` command and then a `git merge`
    command with the remote tracking branch.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`git pull`命令实际上是一个`git fetch`命令，接着是一个与远程跟踪分支的`git merge`命令。'
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: From the output, you can see it is a fast-forward merge, as Git predicted in
    the
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输出中你可以看到，这是一个快进合并，就像 Git 预测的那样。
- en: output of `git status`.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`git status`的输出。'
- en: There's more...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can also add a remote to an existing branch, which is very handy when you
    realize that you actually wanted a remote tracking branch but forgot to add the
    tracking information while creating the branch:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以向现有分支添加远程，这在你意识到其实想要一个远程跟踪分支，但在创建分支时忘记添加跟踪信息时非常有用：
- en: 'Start by creating a local branch at the `2e0d17` commit:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`2e0d17`提交开始创建一个本地分支：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `remoteBugFix2` branch is just a local branch at the moment with no tracking
    information; to set the tracking branch, we need to use `--set-upstream-to`  or
    `-u` as a flag to the `git branch` command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`remoteBugFix2`分支目前只是一个本地分支，没有跟踪信息；要设置跟踪分支，我们需要使用`--set-upstream-to`或`-u`作为`git
    branch`命令的标志：'
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see from the Git output, we are now tracking the `stable-3.2` branch
    from the origin:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Git 输出中可以看到，我们现在正在跟踪`origin`的`stable-3.2`分支：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can see from the Git output that you are nine commits ahead, and you can
    use `git pull` to update the branch. Remember that a `git pull` command is just
    a `git fetch` command, followed by a `git merge` command with the upstream branch,
    which we also call the remote tracking branch:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Git 输出中你可以看到你领先了九次提交，你可以使用`git pull`来更新分支。记住，`git pull`命令实际上是一个`git fetch`命令，接着是一个与上游分支的`git
    merge`命令，我们也称之为远程跟踪分支：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'From the output, you can see that the branch has been fast forwarded to the
    `f839d383e` commit hash, which is equivalent to `origin/stable-3.2`. You can verify
    this with `git log`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输出中可以看到，分支已被快进到`f839d383e`提交哈希，相当于`origin/stable-3.2`。你可以使用`git log`验证这一点：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Forcing a merge commit
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制合并提交
- en: You might have seen a lot of basic examples of software delivery chains and
    branching models before reading this book. It is very likely that you have been
    trying to use different strategies and found that none of them completely support
    your scenario, which is perfectly fine as long as the tool can support your specific
    workflow.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本书之前，你可能已经见过很多关于软件交付链和分支模型的基本示例。很可能你已经尝试过使用不同的策略，但发现没有一种完全支持你的场景，这完全没问题，只要工具能够支持你特定的工作流。
- en: Git supports almost any workflow. We have often encountered a situation that
    requires a merge commit while merging a feature, even though it can be done with
    a fast-forward merge. Those who requested it often use it to indicate that you
    have actually merged in a feature and want to store the information in the repository.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Git 支持几乎所有的工作流。我们经常遇到在合并功能时需要一个合并提交的情况，尽管可以使用快进合并来完成。那些请求合并提交的人通常是为了表明你确实合并了某个功能，并希望将该信息存储在仓库中。
- en: Git has fast and easy access to all the commit messages, so the repository should
    be used as a journal, and not just a backup of the source code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Git 可以快速访问所有的提交信息，因此代码仓库应当作为日志使用，而不仅仅是源代码的备份。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start by checking out a local branch `remoteOldbugFix` that tracks `origin/stable-3.1`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从`origin/stable-3.1`跟踪的本地分支`remoteOldbugFix`开始：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps will show you how to force a merge commit:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将向你展示如何强制进行合并提交：
- en: 'To force a merge commit, you need to use the `--no-ff` flag; *no-ff* means
    no fast forward. We will also use the `--quiet` flag to minimize the output and
    `--edit` to allow us to edit the commit message. Unless you have a merge conflict,
    Git will create the merge commit for you automatically:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要强制进行合并提交，你需要使用`--no-ff`标志；*no-ff*表示不进行快进合并。我们还将使用`--quiet`标志来最小化输出，并使用`--edit`来允许我们编辑提交信息。除非你有合并冲突，否则
    Git 会自动为你创建合并提交：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The commit message editor will open, and you can write a commit message. Closing
    the editor creates the merge commit and we are done.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交消息编辑器将会打开，你可以写下提交消息。关闭编辑器后会创建合并提交，完成操作。
- en: 'To verify this, you can reset back to `origin/stable-3.1` and perform the merge
    without the `--no-ff` flag:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证这一点，你可以重置回`origin/stable-3.1`并在没有`--no-ff`标志的情况下进行合并：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, perform the merge with the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令执行合并：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can see the difference using Gitk. The following screenshot shows the fast-
    forward merge; as you can see, our `remoteOldBugFix` branch points to `origin/stable-3.2`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过Gitk查看差异。以下截图显示了快速前进合并；如你所见，我们的`remoteOldBugFix`分支指向`origin/stable-3.2`：
- en: '![](img/89096683-4d34-4b7c-83f8-f2a6c4d6ca81.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89096683-4d34-4b7c-83f8-f2a6c4d6ca81.png)'
- en: 'The next screenshot shows the merge commit we forced Git to create. Our branch
    `remoteOldBugFix` is ahead of `remotes/origin/stable-3.2`, and then we performed
    the commit:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一张截图展示了我们强制Git创建的合并提交。我们的分支`remoteOldBugFix`领先于`remotes/origin/stable-3.2`，然后我们进行了提交：
- en: '![](img/58b2d86a-c920-4e9e-ba1e-4c28cf78ec48.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58b2d86a-c920-4e9e-ba1e-4c28cf78ec48.png)'
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Although most branching scenarios expect you to completely merge branches, there
    are situations when, while working in a real environment, you only need to merge
    specific pieces of one branch into another branch. Using the `--no-commit` option,
    Git will make the merge and stop before committing, allowing you to modify and
    add files to the merge commit before committing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数分支场景期望你完全合并分支，但在实际环境中，仍然有一些情况，只需要将一个分支中的特定部分合并到另一个分支中。使用`--no-commit`选项，Git将会执行合并并在提交前停止，允许你在提交之前修改并添加文件到合并提交中。
- en: 'For example, we have been working with projects where versions of strings have
    been updated in the feature branch but not in the master branch. So, an automatic
    merge into master would replace the current version string used on the master
    branch, which, in this case, was not the intention. In the following example,
    we will use a simple Git repository with a few commits and files:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们一直在处理这样的项目：字符串版本在功能分支中更新了，但在主分支中没有更新。因此，自动合并到主分支时，将会替换主分支当前使用的版本字符串，而这在本例中并非我们的意图。在接下来的示例中，我们将使用一个简单的Git仓库，里面有几个提交和文件：
- en: 'Start by checking out a local `remotePartlyMerge` branch that tracks `origin/release/1.0`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查出一个本地的`remotePartlyMerge`分支，该分支跟踪`origin/release/1.0`：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, to create the merge and allow you to decide what will be part of the
    commit, you can use `--no-commit`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为了创建合并并允许你决定哪些内容将成为提交的一部分，你可以使用`--no-commit`选项：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, Git is very informative; you can see from the output that everything
    went well and Git stopped before committing as requested. To continue, let's pretend
    we didn't want the `LICENSE` file to be part of the merge commit.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，Git提供了非常详细的信息；从输出中可以看到，一切正常，并且Git在提交之前按照要求停止了。接下来，假设我们不希望`LICENSE`文件成为合并提交的一部分。
- en: 'To achieve this, we reset the directory using the `git reset <path>` command:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们使用`git reset <path>`命令重置了目录：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can see from the output that you have unstaged changes after the reset;
    this is exactly what we want. You can check which unstaged changes you have by
    running `git status`. Now, we will just finish the merge:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输出中你可以看到，重置后有未暂存的更改；这正是我们想要的。你可以通过运行`git status`查看有哪些未暂存的更改。现在，我们将完成合并：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The merge commit is complete. If you run a `git status` command now, you will
    still have the unstaged changes in you work area. To verify whether the result
    is as expected, we can compute the difference for this using `git diff` to show
    that the files are as they are on the `origin/master` branch, excluding the `LICENSE`
    file:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并提交已完成。如果现在运行`git status`命令，你仍然会看到工作区中有未暂存的更改。为了验证结果是否如预期，我们可以使用`git diff`计算差异，显示文件与`origin/master`分支上的文件一致，排除`LICENSE`文件：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There is no output from diff; this is the expected result. We are telling the
    `diff` command to `diff` our current `HEAD` commit and branch `origin/master`,
    and we do not care about the diffs in `LICENSE`
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`diff`没有任何输出，这是预期的结果。我们告诉`diff`命令将当前的`HEAD`提交与分支`origin/master`进行`diff`，并且我们不关心`LICENSE`中的差异。'
- en: If you don't specify `HEAD`, you will `diff` with your current `WA`, and the
    `diff` command will have a lot of output as you have unstaged changes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定`HEAD`，你将会与当前的`WA`进行`diff`，并且由于有未暂存的更改，`diff`命令会产生很多输出。
- en: Using git reuse recorded resolution (rerere) to merge Git conflicts
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Git重用已记录的解决方案（rerere）来合并Git冲突
- en: While working on a feature branch, you probably like to merge daily or perhaps
    more often, but when you work on long-living feature branches, you end up in a
    situation where you have the same conflicts occurring repeatedly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理功能分支时，你可能喜欢每天合并一次，甚至更频繁。但是，当你在长期存在的功能分支上工作时，你会发现自己处于一个不断出现相同冲突的局面。
- en: 'Here, you can use `git rerere`, which stands for *reuse recorded resolution*.
    Git rerere is not enabled by default, but can be enabled with the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以使用`git rerere`，它代表*重用记录的解决方案*。`git rerere`默认是未启用的，但可以通过以下命令启用：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can configure it globally by adding `--global` to the `git config` command.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将`--global`添加到`git config`命令来全局配置它。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 怎么做...
- en: 'Perform the following steps to merge the known conflicts:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来合并已知的冲突：
- en: 'In the `jgit` repository folder, start by checking out a branch that tracks `origin/stable-2.2`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jgit`仓库文件夹中，首先检出一个跟踪`origin/stable-2.2`的分支：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, change the maven-compiler-plugin version to something personalized, such
    as 2.5.2, as this is in line 211 in `pom.xml`. If you run `git diff`, you should
    get a result very similar to the following:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将maven-compiler-plugin版本更改为个性化的版本，比如2.5.2，因为这是`pom.xml`中的第211行。如果你运行`git
    diff`，你应该会看到类似下面的结果：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now add the file and create a commit:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加文件并创建一个提交：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Store your current commit in a backup branch named `rerereExample2`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前提交存储在一个名为`rerereExample2`的备份分支中：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, `git branch rerereExample2` is just storing the current commit as a branch,
    as we need to use that for the second rerere example.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`git branch rerereExample2`只是将当前提交存储为一个分支，因为我们需要用它来做第二个rerere示例。
- en: 'Now, we need to perform the first merge that will fail on auto merge. Then
    we can solve that. After solving it, we can reuse the merge resolution to solve
    the same problem in the future:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要执行第一次合并，这次合并将会在自动合并时失败。然后我们可以解决这个问题。解决后，我们可以复用合并的解决方案，以后遇到相同的问题时可以再次使用：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As we have `git rerere` enabled, we can use `git rerere status` to see which
    files or paths will be recorded:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们启用了`git rerere`，我们可以使用`git rerere status`来查看哪些文件或路径将被记录：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Edit the `pom.xml` file (around line 229) and solve the merge conflict so that
    you can get the `diff` output shown as follows. You have to remove the line with
    3.1 and the merge markers:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`pom.xml`文件（大约在第229行），解决合并冲突，使其得到如下所示的`diff`输出。你需要删除包含3.1的行和合并标记：
- en: Merge markers are lines that begin with `<<<<<<`, `>>>>>>`, or `======`; these
    lines indicate the points where Git could not perform an auto merge.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 合并标记是以`<<<<<<`、`>>>>>>`或`======`开头的行；这些行标记了Git无法自动合并的地方。
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Mark the merge as complete by adding `pom.xml` to the staging area using `git
    add` and then run `git commit` to finish the merge:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`git add`将`pom.xml`添加到暂存区，然后运行`git commit`来完成合并，标记合并为完成：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note the recorded resolution for the `pom.xml` output from Git; this will not
    be here without enabling `git rerere`. Git has recorded this resolution to this
    particular merge conflict and will also record how to resolve this. Now, we can
    try to `rebase` the change to another branch.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意Git记录的`pom.xml`输出的解决方案；如果没有启用`git rerere`，这里是不会出现的。Git已经记录了这个特定合并冲突的解决方案，并且会记录如何解决这个冲突。现在，我们可以尝试将更改进行`rebase`到另一个分支。
- en: 'Start by checking out the `rerereExample2` branch from our repository:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的仓库中检出`rerereExample2`分支：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Try to rebase your change on top of the `origin/stable-3.2` branch:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将你的更改基于`origin/stable-3.2`分支进行`rebase`：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should notice the following output:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该注意到以下输出：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As the merge conflict is the same in `pom.xml`, Git can solve the conflict
    in the file for you. This is very clear when you open the file and see there are
    no merge markers, as the resolution Git had recorded has been applied. Finish
    the merge by adding `pom.xml` and continue the `rebase`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于合并冲突发生在`pom.xml`中，Git可以自动解决该文件中的冲突。你可以通过打开文件并看到没有合并标记来清楚地看到这一点，因为Git已应用记录的解决方案。完成合并后，添加`pom.xml`并继续`rebase`：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Start Gitk to see that the commit has been rebased on top of the `origin/stable-3.2`
    branch:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Gitk以查看提交是否已经在`origin/stable-3.2`分支之上进行了`rebase`：
- en: '![](img/910cc116-cd54-4833-b72a-488fa62440c4.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/910cc116-cd54-4833-b72a-488fa62440c4.png)'
- en: You can try the same scenario with merging and it will merge the file automatically
    for you.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试相同的场景进行合并，Git将自动为你合并该文件。
- en: There's more...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When you merge different branches often and you are not sure which branch a
    specific error fix is a part of, it is actually quite easy to find out:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你经常合并不同的分支时，如果你不确定某个特定错误修复属于哪个分支，实际上很容易找出：
- en: 'You need to find a commit for which you are interested in getting this information.
    Then, use the `--contains` flag for the `git branch` command:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要找到一个提交，然后使用 `git branch` 命令的 `--contains` 标志获取这个信息：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The previous command lists all the branches that have the specific commit.
    If you leave out the commit argument (`8e2886897`), Git will check `HEAD`. So,
    for instance, checking out the `rerereExample2` branch and executing the following
    command, you will see the commit is present only on that branch:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令列出了所有包含特定提交的分支。如果省略提交参数（`8e2886897`），Git 会检查 `HEAD`。例如，检出 `rerereExample2`
    分支并执行以下命令，你会看到该提交只出现在该分支上：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `-a` option indicates that you wish to check all the remote branches as
    well. If you leave this out, it will check only local branches.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`-a` 选项表示你希望检查所有的远程分支。如果省略该选项，它只会检查本地分支。'
- en: However, as you can see, our commit is not on any remote branch, as the commit
    has just been created locally and has not been pushed to any remotes yet.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你所看到的，我们的提交不在任何远程分支上，因为该提交刚刚在本地创建，并且尚未推送到任何远程仓库。
- en: You can use tags, branch names, or commit hashes while using the git branch
    `-a --contains` command.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在使用 `git branch -a --contains` 命令时使用标签、分支名称或提交哈希。
- en: 'Let''s try to see the branches where the `v2.3.0.201302130906` tag is present:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试查看 `v2.3.0.201302130906` 标签存在的分支：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: That tag can be found in quite a lot of branches.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该标签可以在许多分支中找到。
- en: Compute the difference between branches
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算分支之间的差异
- en: Checking the difference between branches can show valuable information before
    merging.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并之前，检查分支之间的差异可以提供有价值的信息。
- en: A regular `git diff` between two branches will show you all the information,
    but it can be rather exhausting to sit and look at; maybe you are only interested
    in one file. Thus, you don't need the long unified diff.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常规的 `git diff` 可以显示两个分支之间的所有差异信息，但它可能非常冗长，也许你只关心某一个文件。因此，你不需要查看长的统一差异。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始
- en: To start with, we decide on two branches, tags, or commits we want to see the
    difference between. Then, to list files that have changed between these branches,
    you can use the `--name-only` flag.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们决定想要查看差异的两个分支、标签或提交。然后，为了列出这两个分支之间有变化的文件，你可以使用 `--name-only` 标志。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to see the difference between the branches:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以查看分支之间的差异：
- en: 'Diff `origin/stable-3.1` with the `origin/stable-3.2` branch:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `origin/stable-3.1` 与 `origin/stable-3.2` 分支进行差异比较：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We are building the command in this pattern, that is, `git diff [options] <commit>
    <commit> <path>`. Then, we can diff what we care about while looking into the
    differences between branches. This is very useful if you are responsible for a
    subset of the source code, and you wish to diff that area only.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按照这个模式构建命令，即 `git diff [options] <commit> <commit> <path>`。然后，我们可以在查看分支之间的差异时，专注于我们关心的部分。这对于负责源代码某一子集的人非常有用，你只需查看该区域的差异。
- en: 'Let''s try the same diff between branches, but this time we will diff the entire
    branches, not just a sub-directory; however, we only want to show the deleted
    or added files between the branches. This is done by using the `--diff-filter=DA`
    and `--name-status` options. The `--name-status` option will only show the filenames
    and the type of change. The `--diff-filter=DA` option will only show the deleted
    and added files:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试在两个分支之间执行相同的差异比较，但这次我们将对整个分支进行比较，而不仅仅是一个子目录；不过，我们只想显示分支之间被删除或添加的文件。通过使用
    `--diff-filter=DA` 和 `--name-status` 选项可以做到这一点。`--name-status` 选项只会显示文件名和变化类型，`--diff-filter=DA`
    选项只会显示删除和添加的文件：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This shows the files that have been added and deleted while moving from `origin/stable-3.1` to
    `origin/stable-3.2`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这显示了在从 `origin/stable-3.1` 到 `origin/stable-3.2` 的过程中被添加和删除的文件。
- en: 'If we switch the branches around, as in the following command, we will get
    the opposite result:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们交换分支，如以下命令所示，我们将得到相反的结果：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that the indication letters A and D switched places because now we want
    to know what happens if we move from `origin/stable-3.2` to `origin/stable-3.1`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字母 A 和 D 交换了位置，因为现在我们想知道如果从 `origin/stable-3.2` 切换到 `origin/stable-3.1`
    会发生什么。
- en: Orphan branches
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 孤立分支
- en: You are now familiar with Git's data model, the DAG. You have seen that objects
    have a parent. When you create a new branch, the commit is its parent. However,
    in some situations, it is useful to have a branch with no parent.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 Git 的数据模型——有向无环图（DAG）。你已经看到对象有一个父对象。当你创建一个新分支时，提交就是它的父对象。然而，在某些情况下，拥有一个没有父分支的分支是非常有用的。
- en: One example would be an instance where you have your code base in two separate
    repositories, but, for some reason, you now want to consolidate it into one. One
    way is to simply copy the files and add them to one of the repositories, but the
    disadvantage is that you will lose the histories. The second way is to use an
    orphan branch that can help you to fetch one repository in another.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是，当你有两个独立的代码库，但出于某种原因，现在想要将它们合并到一个库中。一种方法是直接复制文件并将其添加到其中一个仓库，但缺点是你会丢失历史记录。第二种方法是使用孤立分支，它可以帮助你将一个仓库的内容拉取到另一个仓库中。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'It is actually easy to create an orphan branch. The flag `--orphan` to `checkout`
    will do it. It can be executed as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 其实创建孤立分支并不难。使用`--orphan`标志与`checkout`命令就可以实现。执行方法如下：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We now have a branch with no parent. You can verify it by examining the commit
    log as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个没有父分支的分支。你可以通过检查提交日志来验证这一点，如下所示：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`Fresh start` does not mean that you are starting from scratch. The files and
    directories that have been added to the repository still exist:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`全新开始`并不意味着你从头开始。已经添加到仓库中的文件和目录仍然存在：'
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you need a fresh start, you can delete the files (but remember not to delete `.git`)
    as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你需要一个全新的开始，可以删除文件（但记得不要删除`.git`），方法如下：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You have a branch with no files and no commits. Moreover, the branch does not
    share any commit history with your `master` branch. You could add another repository
    and fetch all its commits using `git remote add` and `git fetch`. Instead, we
    will simply add a text file to illustrate it as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有一个没有文件和提交的分支。此外，该分支与`master`分支没有任何提交历史记录。你可以通过`git remote add`和`git fetch`将另一个仓库添加到该分支并拉取所有提交记录。但我们将通过简单地添加一个文本文件来说明这一点，如下所示：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Commit is the only thing in the history that you can verify with the command
    `git log`. If you fetch another repository into the branch, you will see all the
    commits and, more importantly you will have a copy of the repository's history.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 提交是你可以通过`git log`命令验证的历史记录中的唯一内容。如果你将另一个仓库拉取到该分支中，你将看到所有的提交记录，最重要的是，你将拥有该仓库历史的副本。
- en: 'Once you have your commits in place on the orphan branch, it is time to merge
    them into your master branch. However, your first attempt will fail. For example,
    check the following:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你在孤立分支上完成提交，就该将它们合并到主分支上了。然而，你的第一次尝试会失败。例如，检查如下内容：
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As you can see, the orphan branch does not share history with the master branch,
    and git will not allow you to merge the branch. It shouldn''t come as a surprise,
    since it is basically what an orphan branch is all about. However, you can still
    merge an orphan branch by allowing unrelated histories to be merged:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所见，孤立分支与主分支没有共享历史记录，git 将不允许你合并该分支。这不应该让你感到意外，因为孤立分支的基本特征就是如此。不过，你仍然可以通过允许合并不相关的历史记录来合并孤立分支：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It is unlikely that you will use orphan branches on a daily basis, but it is
    a strong feature to know when you need to reorganize your code base.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不太可能每天都使用孤立分支，但当你需要重组代码库时，它是一个很强大的功能，值得掌握。
- en: There's more...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: There are more options in the help files for Git. Just run `git merge --help`
    or `git branch --help` to see what other options are available.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Git 的帮助文件中有更多选项。只需运行`git merge --help`或`git branch --help`即可查看其他可用的选项。
