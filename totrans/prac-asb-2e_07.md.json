["```\n$ ansible-doc --version\nansible-doc [core 2.15.0]\n  config file = None\n  configured module search path = ['/Users/danieloh/Library/Python/3.11/bin/plugins/modules', '/usr/share/ansible/plugins/modules']\n  ansible python module location = /Users/danieloh/Library/Python/3.11/lib/python/site-packages/ansible\n  ansible collection location = /Users/danieloh/Library/Python/3.11/bin/collections:/usr/share/ansible/collections\n  executable location = /Users/danieloh/Library/Python/3.11/bin/ansible-doc\n  python version = 3.11.3 (main, Apr  7 2023, 20:13:31) [Clang 14.0.0 (clang-1400.0.29.202)] (/opt/homebrew/opt/python@3.11/bin/python3.11)\n  jinja version = 3.1.2\n  libyaml = True\n```", "```\n    $ ansible-doc -t connection -l\n    ```", "```\n    $ ansible-doc -t connection paramiko_ssh\n    ```", "```\n$ ls /usr/lib/python3.11/site-packages/ansible/plugins/\naction cliconf httpapi inventory lookup terminal\nbecome connection __init__.py loader.py netconf test\ncache doc_fragments __init__.pyc loader.pyc shell vars\ncallback filter __init__.pyo loader.pyo strategy\n```", "```\n$ ls -l /usr/lib/python3.11/site-packages/ansible/plugins/connection/paramiko_ssh.py\n-rw-r—r—1 root root 23544 Mar 5 05:39 /usr/lib/python3.11/site-packages/ansible/plugins/connection/paramiko_ssh.py\n```", "```\n    $ git clone https://github.com/ansible/ansible.git\n    lib/ansible/plugins/:\n\n    ```", "```\n    $ ls -al connection/\n    ```", "```\n\n    ```", "```\n$ ls -al connection/\ntotal 176\ndrwxr-xr-x 2 root root 109 May 15 17:24 .\ndrwxr-xr-x 19 root root 297 May 15 17:24 ..\n-rw-r--r-- 1 root root 16411 May 15 17:24 __init__.py\n-rw-r--r-- 1 root root 6855 May 15 17:24 local.py\n-rw-r--r-- 1 root root 23525 May 15 17:24 paramiko_ssh.py\n-rw-r--r-- 1 root root 32839 May 15 17:24 psrp.py\n-rw-r--r-- 1 root root 55367 May 15 17:24 ssh.py\n-rw-r--r-- 1 root root 31277 May 15 17:24 winrm.py\n```", "```\n    $ less connection/paramiko_ssh.py\n    ```", "```\n# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n# (c) 2017 Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\nDOCUMENTATION = \"\"\"\n    author: Ansible Core Team\n    connection: paramiko\n    short_description: Run tasks via python ssh (paramiko)\n    description:\n        - Use the python ssh implementation (Paramiko) to connect to targets\n        - The paramiko transport is provided because many distributions, in particular EL6 and before do not support ControlPersist\n          in their SSH implementations.\nDOCUMENTATION block, which is very similar to what we saw when we were working with the module source code. If you explore the source code of each plugin, you will find that the structure bears some similarity to the module code structure. However, rather than simply taking this statement at face value, in the next section, we’ll build our very own custom plugin to learn, through a practical example, how they are put together.\nCreating custom plugins\nIn this section, we will take you through a practical guide to creating a plugin. The example will be, by necessity, simple. However, hopefully, it will serve you well in guiding you in the principles and best practices of plugin development and give you a solid foundation to build more complex plugins. We will even show you how to integrate these with your playbooks and, when you’re ready, submit them to the official Ansible project for inclusion.\nAs we noted when we built a module, Ansible is written in Python, and its plugins are no exception. As a result, you will need to write your plugin in Python; so, to get started on developing a plugin, you will need to make sure you have Python and a few essential tools installed. If you already have Ansible running on your development machine, you probably have the required packages installed.\nLet’s get started with creating a plugin. Although there are many similarities between coding modules and plugins, there are also fundamental differences. Each of the different types of plugins that Ansible can work with is coded slightly differently and has different recommendations. Sadly, we don’t have space to go through each one in this book, but you can find out more about the requirements for each plugin type by reading the official Ansible documentation at [https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.xhtml).\nFor our simple example, we’ll create a filter plugin that replaces a given string with another. If you refer to the preceding documentation link, filter plugins are perhaps some of the easiest ones to code because there isn’t a stringent requirement on the documentation in the same way that there is for modules. However, if we were to create a `lookup` plugin, we would be expected to create the same `DOCUMENTATION`, `EXAMPLES`, and `RETURN` documentation sections that we created in [*Chapter 5*](B20846_05.xhtml#_idTextAnchor279), *Creating and Consuming* *Modules*. We would also need to test and build our web documentation in the same way.\nWe have already covered this, so it doesn’t serve to repeat the entirety of this process in this chapter. Instead, we will focus on creating a filter plugin. In contrast with other Ansible plugins and modules, you can have several filters defined in a single Python plugin file. Filters are, by nature, quite compact to code. They are also numerous, so having one file per filter doesn’t scale well. However, if you want to code other types of plugins (such as `lookup` plugins), you *will* need to create one Python file per plugin.\nLet’s start creating our simple filter plugin. As we are only creating one, it will live in its own single Python file. You could propose a modification to one of the Ansible core filter Python files if you want to submit your code back to the Ansible project; but for now, we’ll leave that as a project for you to complete yourself. Our filter file will be called `custom_filter.py` and it will live in a directory called `filter_plugins`, which must be created in the same directory as your playbook.\nFor clarity, your final directory structure should look as follows:\n\n```", "```\n\n Perform the following steps to create and test your plugin code:\n\n1.  Start your plugin file with a header so that people will know who wrote the plugin and what license it is released under. Naturally, you should update both the copyright and license fields with values appropriate to your plugin, but the following text is given as an example for you to get started with:\n\n    ```", "```\n\n     2.  Next, we’ll add a very simple Python function – yours can be as complex as you want it to be, but for ours, we will simply use the Python `.replace` function to replace one string with another inside a `string` variable. The following example looks for instances of `Puppet` and replaces them with `Ansible`:\n\n    ```", "```\n\n     3.  Next, we need to create an object of the `FilterModule` class, which is how Ansible will know that this Python file contains a filter. Within this object, we can create a `filters` definition and return the value of our previously defined filter function to Ansible:\n\n    ```", "```\n\n     4.  As you can see, this code is all incredibly simple and we’re able to use built-in Python functions, such as `replace`, to manipulate the strings. There isn’t a specific test harness for plugins in Ansible, so we will test out our plugin code by writing a simple playbook that will implement it. The following playbook code defines a simple string that includes the word `Puppet` in it and prints this to the console using the `debug` module, applying our newly defined filter to the string:\n\n    ```", "```\n\nNow, before we attempt to run this, let’s recap what the directory structure should look like. Just as we were able to utilize the custom module that we created in [*Chapter 5*](B20846_05.xhtml#_idTextAnchor279), *Creating and Consuming* *Modules*, by creating a `library/` subdirectory to house our module, we can also create a `filter_plugins/` subdirectory for our plugin. Your directory tree structure, when you have finished coding the various file details in the preceding code block, should look something like this:\n\n```", "```\n\n Now, let’s run our little test playbook and see what output we get. If all goes well, it should look something like the following:\n\n```", "```\n\n As you can see, our new filter plugin replaced the `Puppet` string in our variable’s contents and replaced it with the `Ansible` string. This, of course, is just a silly test and not one you are likely to contribute back to the Ansible project. However, it shows how, in just six lines of code and with a modicum of Python knowledge, we have created a filter plugin to manipulate a string. You could come up with something far more complex and useful, I’m sure!\nOther plugin types require more effort than this; although we won’t go through the process of creating a filter plugin here, you’ll find coding a filter plugin more akin to coding a module, as you need to do the following:\n\n*   Include the `DOCUMENTATION`, `EXAMPLES`, and `RETURN` sections with the appropriate documentation\n*   Ensure you have incorporated appropriate and sufficient error handling in the plugin\n*   Test it thoroughly, including both the failure and success cases\n\nAs an example of this, we’ll repeat the preceding process but create a `lookup` plugin instead. This plugin will be based heavily on a simplified version of the file `lookup` plugin. However, we want to adapt our version so that it only returns the first character of a file. You could adapt this example to perhaps read the header from a file, or you could add arguments to the plugin so that you can extract a substring using character indexes. We will leave this enhancement activity as an exercise for you to carry out yourself.\nLet’s get started! Our new lookup plugin will be called `firstchar`, and as `lookup` plugins have a one-to-one mapping with their Python files, the plugin file will be called `firstchar.py`. (In fact, Ansible will use this filename as the name of the plugin – you won’t find a reference to it in the code anywhere!). If you intend to test this from a playbook, as executed previously, you should create this in a directory called `lookup_plugins/`:\n\n1.  Start by adding a header to the plugin file, as before, so that the maintainer and copyright details are clear. We are borrowing a large chunk of the original `lookup` plugin code from `file.py` for our example, so we must include the relevant credit:\n\n    ```", "```\n\n     2.  Next, add the Python 3 headers – these are an absolute requirement if you intend to submit your plugin via a **Pull Request** (**PR**) to the Ansible project:\n\n    ```", "```\n\n     3.  Next, add a `DOCUMENTATION` block to your plugin so that other users can understand how to interact with it:\n\n    ```", "```\n\n     4.  Add the relevant `EXAMPLES` blocks to show how to use your plugin, just as we did with our modules:\n\n    ```", "```\n\n     5.  Also, make sure you document the `RETURN` values from your plugin:\n\n    ```", "```\n\n     6.  With the documentation complete, we can now start working on our Python code. We will start by importing all the Python modules we need to make our module work. We’ll also set up the `display` object, which is used for verbose output and debugging. This should be used in place of the `print` statements in your plugin code if you need to display the `debug` output:\n\n    ```", "```\n\n     7.  We will now create an object of the `LookupModule` class. Define a default function within this called `run` (this is expected for the Ansible `lookup` plugin framework) and initialize an empty array for our return data:\n\n    ```", "```\n\n     8.  With this in place, we will start a loop to iterate over each of the terms (which, in our simple plugin, will be the filenames passed to the plugin). Although we will only test this on simple use cases, the way that lookup plugins can be used means that they need to support the lists of `terms` to operate on. Within this loop, we display valuable debugging information and, most importantly, define an object with the details of each of the files we will open, called `lookupfile`:\n\n    ```", "```\n\n     9.  Now, we will read in the file contents. This could be as simple as using one line of Python code, but we know from our work on modules in [*Chapter 5*](B20846_05.xhtml#_idTextAnchor279), *Creating and Consuming* *Modules*, that we should not take it for granted that we will be passed a file we can read. As a result, we will put the statement to read our file contents into a `try` block and implement exception handling to ensure that the behavior of the plugin is sensible, even in error cases, and that easy-to-understand error messages are passed back to the user, rather than to Python tracebacks:\n\n    ```", "```\n\nNotice that here, we append the first character of the file contents (denoted by the `[0]` index) to our empty array. We also remove any training spaces using `rstrip`.\n\n1.  Finally, we must return the character we gathered from the file to Ansible with a `return` statement:\n\n    ```", "```\n\n     2.  Once again, we can create a simple test playbook to test out our newly created plugin:\n\n    ```", "```\n\nAgain, we are using the debug module to print output to the console and referencing our `lookup` plugin to obtain the output.\n\n1.  Create the text file referenced in the previous code block, called `testdoc.txt`. This can contain anything you like – mine contains the following simple text:\n\n    ```", "```\n\n     2.  Now, when we run our new playbook, we should see an output similar to the following:\n\n    ```", "```\n\nIf all goes well, your playbook should return the first character of the text file you created. Naturally, there is a lot we could do to enhance this code, but this serves as a nice, simple example to get you started.\nWith this foundation in place, you should now have a reasonable idea of how to get started with writing your plugins for Ansible. The next logical step for us is to look in greater depth at how we can test our newly written plugins. We will do this in the next section.\nLearning to integrate custom plugins with Ansible source code\nSo far, we have only tested our plugin in a standalone manner. This is all well and good, but what if you wanted to add it either to your own fork of the Ansible source code – or, better yet, submit it back to the Ansible project for inclusion with a PR? Fortunately, this process is very similar to the one we covered in [*Chapter 5*](B20846_05.xhtml#_idTextAnchor279), *Creating and Consuming* *Modules*, only with slightly different folder structures.\nNext, you will need to copy your plugin code into one of the appropriate plugin directories:\n\n*   For example, our example filter would be copied to the following directory in the source code you just cloned:\n\n    ```", "```\n    $ cp ~/firstchar.py ./lib/ansible/plugins/lookup/\n    ```", "```\n\nWith your code copied into place, you need to test the documentation (that is, whether your plugin includes it) as before. You can build the `webdocs` documentation in the same way as we did in [*Chapter 5*](B20846_05.xhtml#_idTextAnchor279), *Creating and Consuming* *Modules*, so we will not recap this here. However, as a refresher, we can quickly check whether the documentation renders correctly using the `ansible-doc` command, as follows:\n\n```", "```\n\n As you have seen so far, there is a great deal of overlap between plugin development and module development in Ansible. It is especially important to pay attention to error handling with exceptions to produce good quality, easy-to-understand error messages and to adhere to and uphold Ansible’s high documentation standards. One additional item that we have not covered here is the plugin’s output. All plugins must return strings in Unicode; this ensures that they can run through the `jinja2` filters correctly. Further guidance can be found in the official Ansible documentation at [https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.xhtml).\nArmed with this knowledge, you should now be well placed to begin your plugin development work, and even submit your code back to the community, if you desire. We’ll offer a brief recap of this in the next section.\nSharing plugins with the community\nYou may wish to submit your new plugin to the Ansible project, just as we considered for our custom modules in [*Chapter 5*](B20846_05.xhtml#_idTextAnchor279), *Creating and Consuming* *Modules*. The process for doing this with plugins is almost identical to what you do for modules, which this section will recap.\nNote\nUsing the following process will submit a real request to the Ansible project on GitHub to merge the code you submit with their code. Do *not* follow this process unless you genuinely have a new module that is ready to be submitted to the Ansible code base.\nTo submit your plugin as a PR of the Ansible repository, you need to fork the `devel` branch of the official Ansible repository. To do this, log in to your GitHub account on your web browser (or create an account if you don’t already have one), and then navigate to [https://github.com/ansible/ansible.git](https://github.com/ansible/ansible.git). Click on **Fork** at the top-right corner of the page:\n￼\nFigure 7.3 – Ansible GitHub repository\nOnce you have forked the repository to your account, we will walk you through the commands you need to run to add your module code to it and then create the required PRs to merge your new module with the upstream Ansible project:\n\n1.  Clone the `devel` branch that you just forked to your local machine. Use a command similar to the following, but be sure to replace the URL with one that matches your own GitHub account:\n\n    ```", "```\n    $ cd ansible\n    $ cp ~/ansible-development/plugindev/firstchar.py ./lib/ansible/plugins/lookup\n    $ git add lib/ansible/plugins/lookup/firstchar.py\n    $ git commit -m 'Added tested version of firstchar.py for pull request creation'\n    ```", "```\n\n     2.  Now, be sure to push the code to your forked repository using the following command:\n\n    ```", "```\n\n     3.  Return to GitHub in your web browser and navigate to the **Pull requests** page, as shown in the following screenshot. Click on the **New pull** **request** button:\n\n￼\nFigure 7.4 – Ansible pull request\nFollow the PR creation process, as guided by the GitHub website. Once you have successfully submitted your PR, you should be able to navigate to the list of PRs on the official Ansible source code repository and find yours there. An example of the PR list is shown in the following screenshot for your reference:\n￼\nFigure 7.5 – Ansible pull request list\nAs discussed previously, don’t be alarmed if it takes a long time for your PR to be reviewed – this is simply due to how many PRs there are to review and process. You can always use your plugin code locally by adding it to a local `*_plugins/` directory, as we demonstrated earlier, so that the processing speed of your PR doesn’t hinder your work with Ansible. Further details of where to place your plugin code when working locally can be found at [https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.xhtml).\nThat completes our look at creating plugins, including two working examples. Hopefully, you have found this journey informative and valuable and it has enhanced your ability to work with Ansible and extend its functionality where required.\nSummary\nAnsible plugins are a core part of Ansible’s functionality and as we discovered in this chapter, we have been working with them throughout this book without even realizing it! Ansible’s modular design makes it easy to extend and add functionality, regardless of whether you are working with modules or the various types of plugins that are currently supported. Whether it’s to add a new filter for string processing or a new way of looking up data (or perhaps even a new connection mechanism to new technology), Ansible plugins provide a complete framework that can extend Ansible far beyond its already extensive capabilities.\nIn this chapter, we learned about the various types of plugins that are supported by Ansible, before exploring them in greater detail and looking at we you can obtain documentation and information on the existing ones. We then completed two practical examples to create two different types of plugins for Ansible while looking at the best practices for plugin development and how this overlaps with module development. We finished off by recapping how to submit our new plugin code as a PR back to the Ansible project.\nIn the next chapter, we will explore the best practices that you should adhere to when writing your Ansible playbooks to ensure that you produce manageable, high-quality automation code.\nQuestions\nAnswer the following questions to test your knowledge of this chapter:\n\n1.  Which of the following `ansible-doc` commands can you use to list the names of all the cache plugins?\n    1.  `ansible-doc -a` `cache -l`\n    2.  `ansible-doc` `cache -l`\n    3.  `ansible-doc -``a cache`\n    4.  `ansible-doc -t` `cache -l`\n    5.  `ansible-doc cache`\n2.  Which class do you need to add to your `lookup` plugin’s code to include the bulk of the plugin code, including `run()`, the `items` loop, `try`, and `except`?\n    1.  `LookupModule`\n    2.  `RunModule`\n    3.  `StartModule`\n    4.  `InitModule`\n    5.  `LoadModule`\n3.  True or false: To create custom plugins with complex operations rather than printing simple hello world text using Python, you need to install Python with the relevant dependencies on your OS.\n    1.  True\n    2.  False\n\nFurther reading\nYou can find all of the plugins on Ansible by accessing the Ansible repository directly at [https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins).\n\n```"]