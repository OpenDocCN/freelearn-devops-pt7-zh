["```\n[frontends]\nfrt01.example.com\nfrt02.example.com\n```", "```\n---\n- name: Play to demonstrate asynchronous tasks\n  hosts: frontends\n  become: true\ntasks:\n  - name: A simulated long running task\n    shell: \"sleep 20\"\n    async: 30\n    poll: 5\n```", "```\n$ ansible-playbook -i hosts async.yml\nPLAY [Play to demonstrate asynchronous tasks] **********************************\nTASK [Gathering Facts] *********************************************************\nok: [frt02.example.com]\nok: [frt01.example.com]\nTASK [A simulated long running task] *******************************************\nchanged: [frt02.example.com]\nchanged: [frt01.example.com]\nPLAY RECAP *********************************************************************\nfrt01.example.com : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\nfrt02.example.com : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n```", "```\n---\n- name: Play to demonstrate asynchronous tasks\n  hosts: frontends\n  become: true\ntasks:\n  - name: A simulated long running task\n    shell: \"sleep 20\"\n    async: 30\n    poll: 0\n    register: long_task\n  - name: Check on the asynchronous task\n  async_status:\n    jid: \"{{ long_task.ansible_job_id }}\"\n  register: async_result\n  until: async_result.finished\n  retries: 30\n```", "```\n$ ansible-playbook -i hosts async2.yml\nPLAY [Play to demonstrate asynchronous tasks] **********************************\nTASK [Gathering Facts] *********************************************************\nok: [frt01.example.com]\nok: [frt02.example.com]\nTASK [A simulated long running task] *******************************************\nchanged: [frt02.example.com]\nchanged: [frt01.example.com]\nTASK [Check on the asynchronous task] ******************************************\nFAILED - RETRYING: Check on the asynchronous task (30 retries left).\nFAILED - RETRYING: Check on the asynchronous task (30 retries left).\nFAILED - RETRYING: Check on the asynchronous task (29 retries left).\nFAILED - RETRYING: Check on the asynchronous task (29 retries left).\nFAILED - RETRYING: Check on the asynchronous task (28 retries left).\nFAILED - RETRYING: Check on the asynchronous task (28 retries left).\nFAILED - RETRYING: Check on the asynchronous task (27 retries left).\nFAILED - RETRYING: Check on the asynchronous task (27 retries left).\nchanged: [frt01.example.com]\nchanged: [frt02.example.com]\nPLAY RECAP *********************************************************************\nfrt01.example.com : ok=3 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\nfrt02.example.com : ok=3 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n```", "```\n    ---\n    - name: Simple serial demonstration play\n      hosts: frontends\n      gather_facts: false\n      tasks:\n        - name: First task\n          command: date\n        - name: Second task\n          command: date\n    ```", "```\n    $ ansible-playbook -i hosts serial.yml\n    PLAY [Simple serial demonstration play] ****************************************\n    TASK [First task] **************************************************************\n    changed: [frt02.example.com]\n    changed: [frt01.example.com]\n    TASK [Second task] *************************************************************\n    changed: [frt01.example.com]\n    changed: [frt02.example.com]\n    PLAY RECAP *********************************************************************\n    frt01.example.com : ok=2 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    tasks sections exactly as they were in *Step 1*:\n\n    ```", "```\n\n    ```", "```\n    $ ansible-playbook -i hosts serial.yml\n    PLAY [Simple serial demonstration play] ****************************************\n    TASK [First task] **************************************************************\n    changed: [frt01.example.com]\n    TASK [Second task] *************************************************************\n    changed: [frt01.example.com]\n    PLAY [Simple serial demonstration play] ****************************************\n    TASK [First task] **************************************************************\n    changed: [frt02.example.com]\n    TASK [Second task] *************************************************************\n    changed: [frt02.example.com]\n    PLAY RECAP *********************************************************************\n    frt01.example.com : ok=2 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    frt02.example.com : ok=2 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    ```", "```\nserial:\n- 1\n- 3\n- 5\n```", "```\n[frontends]\nfrt[01:10].example.com\n```", "```\n    ---\n    - name: A simple play to demonstrate use of max_fail_percentage\n      hosts: frontends\n      gather_facts: no\n      serial: 5\n      max_fail_percentage: 50\n    ```", "```\n    tasks:\n    - name: A task that will sometimes fail\n      debug:\n        msg: This might fail\n      failed_when: inventory_hostname in ansible_play_batch[0:3]\n    ```", "```\n    - name: A task that will succeed\n      debug:\n        msg: Success!\n    ```", "```\n    $ ansible-playbook -i morehosts maxfail.yml\n    PLAY [A simple play to demonstrate use of max_fail_percentage] *****************\n    TASK [A task that will sometimes fail] *****************************************\n    fatal: [frt01.example.com]: FAILED! => {\n     \"msg\": \"This might fail\"\n    }\n    fatal: [frt02.example.com]: FAILED! => {\n     \"msg\": \"This might fail\"\n    }\n    fatal: [frt03.example.com]: FAILED! => {\n     \"msg\": \"This might fail\"\n    }\n    ok: [frt04.example.com] => {\n     \"msg\": \"This might fail\"\n    }\n    ok: [frt05.example.com] => {\n     \"msg\": \"This might fail\"\n    }\n    NO MORE HOSTS LEFT *************************************************************\n    NO MORE HOSTS LEFT *************************************************************\n    PLAY RECAP *********************************************************************\n    frt01.example.com : ok=0 changed=0 unreachable=0 failed=1 skipped=0 rescued=0 ignored=0\n    frt02.example.com : ok=0 changed=0 unreachable=0 failed=1 skipped=0 rescued=0 ignored=0\n    frt03.example.com : ok=0 changed=0 unreachable=0 failed=1 skipped=0 rescued=0 ignored=0\n    frt04.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    frt05.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    ```", "```\n[frontends]\nfrt01.example.com\nfrt02.example.com\n```", "```\n    #!/bin/sh\n    add_to_loadbalancer.sh, which will contain the following:\n\n    ```", "```\n\n    ```", "```\n    ---\n    - name: Play to demonstrate task delegation\n      hosts: frontends\n      tasks:\n        - name: Remove host from the load balancer\n          command: ./remove_from_loadbalancer.sh {{ inventory_hostname }}\n          args:\n            chdir: \"{{ playbook_dir }}\"\n          delegate_to: localhost\n    ```", "```\n    - name: Deploy code to host\n      debug:\n        msg: Deployment code would go here....\n    ```", "```\n    - name: Add host back to the load balancer\n      command: ./add_to_loadbalancer.sh {{ inventory_hostname }}\n      args:\n        chdir: \"{{ playbook_dir }}\"\n      delegate_to: localhost\n    ```", "```\n    $ ansible-playbook -i hosts delegate.yml\n    PLAY [Play to demonstrate task delegation] *************************************\n    TASK [Gathering Facts] *********************************************************\n    ok: [frt01.example.com]\n    ok: [frt02.example.com]\n    TASK [Remove host from the load balancer] **************************************\n    changed: [frt02.example.com -> localhost]\n    changed: [frt01.example.com -> localhost]\n    TASK [Deploy code to host] *****************************************************\n    ok: [frt01.example.com] => {\n     \"msg\": \"Deployment code would go here....\"\n    }\n    ok: [frt02.example.com] => {\n     \"msg\": \"Deployment code would go here....\"\n    }\n    TASK [Add host back to the load balancer] **************************************\n    changed: [frt01.example.com -> localhost]\n    changed: [frt02.example.com -> localhost]\n    PLAY RECAP *********************************************************************\n    frt01.example.com : ok=4 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    frt02.example.com : ok=4 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    ```", "```\n---\n- name: Second task delegation example\n  hosts: frontends\n  tasks:\n  - name: Perform an rsync from localhost to inventory hosts\n    local_action: command rsync -a /tmp/ {{ inventory_hostname }}:/tmp/target/\n```", "```\ntasks:\n- name: Perform an rsync from localhost to inventory hosts\n  command: rsync -a /tmp/ {{ inventory_hostname }}:/tmp/target/\n  delegate_to: localhost\n```", "```\n$ ansible-playbook -i hosts delegate2.yml\nPLAY [Second task delegation example] ******************************************\nTASK [Gathering Facts] *********************************************************\nok: [frt02.example.com]\nok: [frt01.example.com]\nTASK [Perform a rsync from localhost to inventory hosts] **********************\nchanged: [frt02.example.com -> localhost]\nchanged: [frt01.example.com -> localhost]\nPLAY RECAP *********************************************************************\nfrt01.example.com: ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\nfrt02.example.com: ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n```", "```\n    ---\n    - name: Play to demonstrate the run_once directive\n      hosts: frontends\n      tasks:\n        - name: Upgrade database schema\n          debug:\n            msg: Upgrading database schema...\n          run_once: true\n    ```", "```\n    $ ansible-playbook -i morehosts runonce.yml\n    PLAY [Play to demonstrate the run_once directive] ******************************\n    TASK [Gathering Facts] *********************************************************\n    ok: [frt02.example.com]\n    ok: [frt05.example.com]\n    ok: [frt03.example.com]\n    ok: [frt01.example.com]\n    ok: [frt04.example.com]\n    ok: [frt06.example.com]\n    ok: [frt08.example.com]\n    ok: [frt09.example.com]\n    ok: [frt07.example.com]\n    ok: [frt10.example.com]\n    TASK [Upgrade database schema] *************************************************\n    ok: [frt01.example.com] => {\n     \"msg\": \"Upgrading database schema...\"\n    }\n    ---\n    PLAY RECAP *********************************************************************\n    frt01.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    frt02.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    frt03.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    frt04.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    frt05.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    frt06.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    frt07.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    frt08.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    frt09.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    frt10.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    ```", "```\n$ ansible-playbook -i morehosts runonce.yml\nPLAY [Play to demonstrate the run_once directive] ******************************\nTASK [Gathering Facts] *********************************************************\nok: [frt04.example.com]\nok: [frt01.example.com]\nok: [frt02.example.com]\nok: [frt03.example.com]\nok: [frt05.example.com]\nTASK [Upgrade database schema] *************************************************\nok: [frt01.example.com] => {\n \"msg\": \"Upgrading database schema...\"\n}\nPLAY [Play to demonstrate the run_once directive] ******************************\nTASK [Gathering Facts] *********************************************************\nok: [frt08.example.com]\nok: [frt06.example.com]\nok: [frt07.example.com]\nok: [frt10.example.com]\nok: [frt09.example.com]\nTASK [Upgrade database schema] *************************************************\nok: [frt06.example.com] => {\n \"msg\": \"Upgrading database schema...\"\n}\nPLAY RECAP *********************************************************************\nfrt01.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\nfrt02.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\nfrt03.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\nfrt04.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\nfrt05.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\nfrt06.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\nfrt07.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\nfrt08.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\nfrt09.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\nrun_once option is designed to work—you can observe, in the preceding output, that our schema upgrade ran twice, which is probably not something we wanted! However, with this awareness, you should be able to take advantage of this option to control your playbook flow across clusters and still achieve the results you want. Let’s now move away from cluster-related Ansible tasks and look at the subtle but important difference between running playbooks locally and running them on localhost.\nRunning playbooks locally\nIt is important to note that when we talk about running a playbook locally with Ansible, it is not the same as talking about running it on `localhost`. If we run a playbook on `localhost`, Ansible actually sets up an SSH connection to `localhost` (it doesn’t differentiate its behavior or attempt to detect whether a host in the inventory is local or remote—it simply tries faithfully to connect).\nIndeed, we can try creating a `local` inventory file with the following contents:\n\n```", "```\n\n Now, if we attempt to run the `ping` module in an ad hoc command against this inventory, we see the following:\n\n```", "```\n\n As you can see, Ansible set up an SSH connection that needed the host key to validate, as well as our SSH password. Now, although you could add the host key (as we did in the preceding code block), add key-based SSH authentication to your `localhost`, and so on, there is a more direct way of doing this.\nWe can now modify our inventory so that it looks as follows:\n\n```", "```\n\n We’ve added a special variable to our `localhost` entry—the `ansible_connection` variable—which defines which protocol is used to connect to this inventory host. So, we have told it to use a direct local connection instead of SSH-based connectivity (which is the default).\nIt should be noted that `ansible_connection` specifies the type of communication, such as `local`/`ssh`/`etc`. So, if we change our inventory to look as follows, Ansible will not even attempt to connect to the remote host called `frt01.example.com`—it will connect locally to the machine running the playbook (without SSH):\n\n```", "```\n\n We can demonstrate this very simply. Let’s first check for the absence of a test file in our local `/``tmp` directory:\n\n```", "```\n\n Now, let’s run an ad hoc command to touch this file on all hosts in the new inventory we just defined:\n\n```", "```\n\n The command ran successfully, so let’s see whether the test file is present on the local machine:\n\n```", "```\n\n It is! So, the ad hoc command did not attempt to connect to `frt01.example.com`, even though this hostname was in the inventory. The presence of `ansible_connection=local` meant that this command was run on the local machine without using SSH.\nThis ability to run commands locally without the need to set up SSH connectivity, SSH keys, and so on can be incredibly valuable, especially if you need to get things up and running quickly on your local machine. With this complete, let’s take a look at how you can work with proxies and jump hosts using Ansible.\nWorking with proxies and jump hosts\nOften, when it comes to configuring core network devices, these are isolated from the main network via a proxy or jump host. Ansible lends itself well to automating network device configuration as most of it is performed over SSH; however, this is only helpful in a scenario where Ansible can either be installed and operated from the jump host or, better yet, can operate via a host such as this.\nFortunately, Ansible can do exactly that. Let’s assume that you have two Cumulus Networks switches in your network (these are based on a special distribution of Linux for switching hardware, which is very similar to Debian). These two switches have the `cmls01.example.com` and `cmls02.example.com` hostnames, but both can only be accessed from a host called `bastion.example.com`.\nThe configuration to support our `bastion` host is performed in the inventory, rather than in the playbook. We begin by defining an inventory group with the switches in, in the normal manner:\n\n```", "```\n\n However, we can now start to get clever by adding some special SSH arguments into the inventory variables for this group. Add the following code to your inventory file:\n\n```", "```\n\n This special variable content tells Ansible to add extra options when it sets up an SSH connection, including to proxy via the `bastion.example.com` host. The `-W %h:%p` options tell SSH to proxy the connection and to connect to the host specified by `%h` (this is either `cmls01.example.com` or `cmls02.example.com`) on the port specified by `%p` (usually port `22`).\nNow, if we attempt to run the Ansible `ping` module against this inventory, we can see whether it works:\n\n```", "```\n\n You will notice that we can’t actually see any differences in Ansible’s behavior from the command-line output. On the surface, Ansible works just as it normally does and connects successfully to the two hosts. However, behind the scenes, it proxies via `bastion.example.com`.\nNote that this simple example assumes that you are connecting to both the `bastion` host and switches using the same username and SSH credentials (or in this case, keys). There are ways to provide separate credentials for both variables, but this involves more advanced usage of OpenSSH, which is beyond the scope of this book. However, this section intends to give you a starting point and demonstrate the possibility of this, and you are free to explore OpenSSH proxying by yourself.\nLet’s now change track and explore how it is possible to set up Ansible to prompt you for data during a playbook run.\nConfiguring playbook prompts\nSo far, all of our playbooks have had their data specified for them at runtime in variables we defined within the playbook. However, what if you actually want to obtain information from someone during a playbook run? Perhaps you want a user to select a version of a package to install? Or, perhaps you want to obtain a password from a user for an authentication task without storing it anywhere. (Although Ansible Vault can encrypt the data at rest, some companies may forbid the storing of passwords and other such credentials in tools that they have not evaluated.) Fortunately, for these instances (and many more), Ansible can prompt you for user input and store the input in a variable for future processing.\nLet’s reuse the two host frontend inventories we defined at the beginning of this chapter. Now, let’s demonstrate how to capture data from users during a playbook run with a practical example:\n\n1.  Create a simple play definition in the usual manner, as follows:\n\n    ```", "```\n\n     2.  Now, we will add a special section to the play definition. We previously defined a `vars` section, but this time, we will define one called `vars_prompt` (which enables you to do just that—define variables through user prompts). In this section, we will prompt for two variables—one for a user ID and one for a password. One will be echoed to the screen, while the other will not be, by setting `private: yes`:\n\n    ```", "```\n\n     3.  We will now add a single task to our playbook to demonstrate this prompting process of setting the variables:\n\n    ```", "```\n\n     4.  Now, run the playbook and see how it behaves:\n\n    ```", "```\n\nAs you can see, we are prompted for both variables, yet the password is not echoed to the terminal, which is important for security reasons. We can then make use of the variables later in the playbook. Here, we just used a simple `debug` command to demonstrate that the variables have been set; however, you would instead implement an actual authentication function in place of this.\nWith this complete, let’s proceed to the next section and look at how you can selectively run your tasks from within your plays with the use of tags.\nPlacing tags in the plays and tasks\nWe have discussed, at many points in this book, that as your confidence and experience with Ansible grows, it is likely that your playbooks will grow, both in scale and complexity. While this is undoubtedly a good thing, there may be times when you only want to run a subset of a playbook, rather than running it from beginning to end. We discussed how to conditionally run tasks based on the value of a variable or fact, but is there a way we can run them based on a selection made when the playbook is run?\nTags in Ansible plays are the solution to this, and in this section, we will build a simple playbook with two tasks—each bearing a different tag—to show you how tags work. We will work with the two simple host inventories that we worked with previously:\n\n1.  Create the following simple playbook to perform two tasks—one to install the `nginx` package and the other to deploy a configuration file from a template:\n\n    ```", "```\n\n     2.  Now, run the playbook in the usual manner, but with one difference—this time, we will add the `--tags` switch to the command line. This switch tells Ansible to only run the tasks that have tags matching the ones that are specified. So, for example, run the following command:\n\n    ```", "```\n\nNotice that the task to deploy the configuration file does not run. This is because it is tagged with `customize` and we did not specify this tag when running the playbook.\n\n1.  There is also a `--skip-tags` switch that does the reverse of the previous switch—it tells Ansible to skip the tags listed. So, if we run the playbook again but skip the `customize` tag, we should see an output like the following:\n\n    ```", "```\n\nThis play run is identical because, rather than including only the `install`-tagged tasks, we skipped the tasks tagged with `customize`.\nNote that if you do not specify either `--tags` or `--skip-tags`, then all the tasks are run, regardless of their tag.\nA few notes about tags. First of all, each task can have more than one tag, so we see them specified in a YAML list format. If you use the `--tags` switch, a task will run if any of its tags match the tag that was specified on the command line. Secondly, tags can be reused, so we could have five tasks that are all tagged `install`, and all five tasks would be performed or skipped if you requested them to do so via `--tags` or `--``skip-tags`, respectively.\nYou can also specify more than one tag on the command line, running all the tasks that match any of the specified tags. Although the logic behind tags is relatively simple, it can take a little while to get used to it, and the last thing you want to do is run your playbook on real hosts to check whether you understand tagging! A great way to figure this out is to add `--list-tasks` to your command, which, rather than running the playbook, lists the tasks from the playbook that would perform if you run it. Some examples are provided for you in the following code block, based on the example playbook we just created:\n\n```", "```\n\n As you can see, not only does `--list-tasks` show you which tasks would run but it also shows you which tags are associated with them, which helps you further understand how tagging works and ensure that you achieve the playbook flow that you wanted. Tags are an incredibly simple yet powerful way to control which parts of your playbook run and, often, when it comes to creating and maintaining large playbooks, it is better to be able to run only selected parts of the playbook at once. From here, we will move on to the final section of this chapter, where we will look at securing your variable data at rest by encrypting it with Ansible Vault.\nSecuring data with Ansible Vault\nAnsible Vault is a tool included with Ansible that allows you to encrypt your sensitive data at rest, while also using it in a playbook. Often, it is necessary to store login credentials or other sensitive data in a variable to allow a playbook to run unattended. However, this risks exposing your data to people who might use it with malicious intent. Fortunately, Ansible Vault secures your data at rest using AES-256 encryption, meaning your sensitive data is safe from prying eyes.\nLet’s proceed with a simple example that shows you how you can use Ansible Vault:\n\n1.  Start by creating a new vault to store sensitive data in; we will call this file `secret.yml`. You can create this using the following command:\n\n    ```", "```\n\nEnter the password you have chosen for the vault when prompted and confirm it by entering it a second time (the vault that accompanies this book on GitHub is encrypted with the `secure` password).\n\n1.  When you have entered the password, you will be sent to your normal editor (defined by the `EDITOR` shell variable). On my test system, this is `vi`. Within this editor, you should create a `vars` file, in the normal manner, containing your sensitive data:\n\n    ```", "```\n\n     2.  Save and exit the editor (press *Esc*, then `:wq` in `vi`). You will exit the shell. Now, if you look at the contents of your file, you will see that they are encrypted and are safe from anyone who should not be able to read the file:\n\n    ```", "```\n    ---\n    - name: A play that makes use of an Ansible Vault\n    hosts: frontends\n    vars_files:\n    - secret.yml\n    tasks:\n    - name: Tell me a secret\n    debug:\n    msg: \"Your secret data is: {{ secretdata }}\"\n    ```", "```\n\nThe `vars_files` directive is used in the same way as it would be if you were using an unencrypted `variables` file. Ansible reads the headers of the `variables` files at runtime and determines whether they are encrypted or not.\n\n1.  Try running the playbook without telling Ansible what the vault password is—in this instance, you should receive an error such as this:\n\n    ```", "```\n    $ ansible-playbook -i hosts vaultplaybook.yml --ask-vault-pass\n    Vault password:\n    PLAY [A play that makes use of an Ansible Vault] *******************************\n    TASK [Gathering Facts] *********************************************************\n    ok: [frt01.example.com]\n    ok: [frt02.example.com]\n    TASK [Tell me a secret] ********************************************************\n    ok: [frt01.example.com] => {\n     \"msg\": \"Your secret data is: Ansible is cool!\"\n    }\n    ok: [frt02.example.com] => {\n     \"msg\": \"Your secret data is: Ansible is cool!\"\n    }\n    PLAY RECAP *********************************************************************\n    frt01.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    frt02.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n    ```", "```\n\nSuccess! Ansible decrypted our vault file and loaded the variables into the playbook, which we can see from the `debug` statement we created. This is a very simple example of what you can do with vaults. There are multiple ways that you can specify passwords; you don’t have to be prompted for them on the command line—they can be provided either by a plain text file that contains the vault password or via a script that could obtain the password from a secure location at runtime (think of a dynamic inventory script, only for returning a password rather than a hostname). The `ansible-vault` tool itself can also be used to edit, view, and change the passwords in a vault file, or even decrypt it and turn it back into plain text. The user guide for Ansible Vault is a great place to start for more information ([https://docs.ansible.com/ansible/latest/user_guide/vault.xhtml](https://docs.ansible.com/ansible/latest/user_guide/vault.xhtml)).\nOne thing to note is that you don’t actually have to have a separate vault file for your sensitive data; you can include it inline in your playbook. For example, let’s try re-encrypting our sensitive data for inclusion in an otherwise unencrypted playbook (again, use the `secure` password for the vault if you are testing the examples from the GitHub repository accompanying this book). Run the following command in your shell (it should produce an output similar to what is shown):\n\n```", "```\n\n You can copy and paste the output of this command into a playbook. So, if we modify our earlier example, it would appear as follows:\n\n```", "```\n\n Now, when you run this playbook in exactly the same manner as we did before (specifying the vault password using a user prompt), you should see that it runs just as when we used an external encrypted `variables` file:\n\n```", "```\n\n Ansible Vault is a powerful and versatile tool for encrypting your sensitive playbook data at rest and should enable you (with a little care) to run most of your playbooks unattended without ever leaving passwords or other sensitive data in the clear. If you add multiple encrypted files in your `group_vars` directory, all files need to contain the same password. That concludes this section and this chapter; I hope that it has been useful to you.\nSummary\nAnsible has many advanced features that allow you to run your playbooks in a variety of scenarios, whether that is upgrading a cluster of servers in a controlled manner; working with devices on a secure, isolated network; or controlling your playbook flow with prompts and tags. Ansible has been adopted by a large and ever-growing user base and, as such, is designed and evolved around solving real-world problems. Most of the advanced features of Ansible we discussed are centered around exactly this—solving real-world problems.\nIn this chapter, you learned about running tasks asynchronously in Ansible, before looking at the various features available for running playbooks to upgrade a cluster, such as running tasks on small batches of inventory hosts, failing a play early if a certain percentage of hosts fail, delegating tasks to a specific host, and even running tasks once, regardless of your inventory (or batch) size. You also learned about the difference between running playbooks locally as opposed to on `localhost` and how to use SSH-proxying to automate tasks on an isolated network via a `bastion` host. Finally, you learned about handling sensitive data without storing it unencrypted at rest, either through prompting the user at runtime or through the use of Ansible Vault. You even learned about running a subset of your playbook tasks with tagging.\nIn the next chapter, we will explore a topic we touched on briefly in this chapter in more detail—automating network device management with Ansible.\nQuestions\n\n1.  Which parameter allows you to configure the maximum number of hosts in a batch that will fail before a play is aborted?\n    1.  `percentage`\n    2.  `max_fail`\n    3.  `max_fail_percentage`\n    4.  `max_percentage`\n    5.  `fail_percentage`\n2.  True or false? You can use the `--ask-vault-pass` parameter to use the vault to keep sensitive data at rest:\n    1.  True\n    2.  False\n3.  True or false? To run a playbook asynchronously, you need to use the `async` keyword:\n    1.  True\n    2.  False\n\nFurther reading\nIf you install Passlib, which is a password-hashing library for Python 3, `vars_prompt` is encrypted with any crypt scheme (such as `descrypt`, `md5crypt`, `sha56_crypt`, and more). You can learn more about this here:\n[https://passlib.readthedocs.io/en/stable/](https://passlib.readthedocs.io/en/stable/)\n\n```"]