["```\n    $ python3 --version\n    Python 3.10.6\n    ```", "```\n    $ python3 -m pip -V\n    pip 22.0.2 from /usr/lib/python3/dist-packages/pip (python 3.10)\n    ```", "```\n$ python3 -m pip -V\n/usr/bin/python3: No module named pip\n```", "```\n$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py\n$ python3 get-pip.py --user\n```", "```\n$ apt install python3-pip\n```", "```\n$ python3 -m pip install --user ansible\n```", "```\n$ /home/$USER/.local/bin/ansible-playbook\n```", "```\n$ export PATH=$PATH:/home/$USER/.local/bin\n$ ansible-playbook --version\nansible-playbook [core 2.15.0]\n…\n```", "```\n    $ sudo python3 -m pip install ansible\n    ```", "```\n    $ which ansible-playbook\n    /usr/bin/ansible-playbook\n    $ ansible-playbook --version\n    ansible-playbook [core 2.15.0]\n    …\n    ```", "```\n$ python3 -m pip install --user ansible==6.2.0\n```", "```\n$ python3 -m pip install --user --upgrade ansible\n```", "```\n$ python3 -m pip uninstall ansible ansible-core\n```", "```\n    venv installed—this can be installed using PIP, and while most operating systems have a native package for it, Ubuntu Server 22.04 only has it for Python 3\\. Thus, I installed it with the following command:\n\n    ```", "```\n\n    ```", "```\n    $ python2 -m virtualenv ansible-2.7.18\n    ```", "```\n    $ . ./ansible-2.7.18/bin/activate\n    --user flag is not required in a venv):\n\n    ```", "```\n\n    ```", "```\n    (ansible-2.7.18) $ ansible-playbook --version\n    ansible-playbook 2.7.18\n    …\n    ```", "```\n    (ansible-2.7.18) $ deactivate\n    $\n    ```", "```\n    $ sudo apt install python3-venv\n    ```", "```\n    $  python3 -m venv ansible-8.0.0\n    $ . ./ansible-8.0.0/bin/activate\n    (ansible-8.0.0) $\n    ```", "```\n    (ansible-8.0.0) $ python3 -m pip install ansible\n    …\n    (ansible-8.0.0) $  ansible-playbook --version\n    ansible-playbook [core 2.15.0]\n    deactivate command first, and then using the appropriate activate command as demonstrated previously.\n    ```", "```\n    $ git clone https://github.com/ansible/ansible.git\n    $ cd ansible\n    ```", "```\n    hacking environment setup—this will set your shell up so that you can access the development version of Ansible you just cloned. You will need to do this every time you open a new shell or reconnect to your development host so that the setup is transient, which is normally perfect for development work:\n\n    ```", "```\n\n    ```", "```\n    $ echo \"app01.example.org\" > ~/my_ansible_inventory\n    $ export ANSIBLE_INVENTORY=~/my_ansible_inventory\n    ```", "```\n    $ ansible all -m ansible.builtin.ping\n    [WARNING]: You are running the development version of Ansible. You should only run Ansible from \"devel\" if you are modifying the Ansible engine,\n    or trying out features under development. This is a rapidly changing source of code and can become unstable at any point.\n    app01.example.org | SUCCESS => {\n        \"ansible_facts\": {\n            \"discovered_interpreter_python\": \"/usr/bin/python3\"\n        },\n        \"changed\": false,\n        \"ping\": \"pong\"\n    }\n    ```", "```\n    $ git pull –rebase\n    $ git submodule update --init --recursive\n    ```", "```\n    $ xcode-select –install\n    $ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n    ```", "```\nxcode-select: error: command line tools are already installed, use \"Software Update\" in System Settings to install updates\n```", "```\n    $ brew doctor\n    Please note that these warnings are just used to help the Homebrew maintainers\n    with debugging if you file an issue. If everything you use Homebrew for is\n    working fine: please don't worry or file an issue; just ignore this. Thanks!\n    Warning: Homebrew's sbin was not found in your PATH but you have installed\n    formulae that put executables in /opt/homebrew/sbin.\n    Consider setting the PATH for example like so\n    /usr/bin/python3—this should be the case with almost all modern installations of macOS) or you can install a newer version via Homebrew by running the following command:\n\n    ```", "```\n\n    ```", "```\n    ansible command as before, and if all has gone according to plan, you will see output similar to the following:\n\n    ```", "```\n    $ brew upgrade ansible\n    ```", "```\n\n    ```", "```\n    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\n    $url = \"https://raw.githubusercontent.com/jborean93/ansible-windows/master/scripts/Upgrade-PowerShell.ps1\"\n    $file = \"$env:temp\\Upgrade-PowerShell.ps1\"\n    $username = \"Administrator\"\n    $password = \"Password\"\n    (New-Object -TypeName System.Net.WebClient).DownloadFile($url, $file)\n    Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Force\n    &$file -Version 5.1 -Username $username -Password $password -Verbose\n    ```", "```\n$reg_winlogon_path = \"HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\"\nSet-ItemProperty -Path $reg_winlogon_path -Name AutoAdminLogon -Value 0\nRemove-ItemProperty -Path $reg_winlogon_path -Name DefaultUserName -ErrorAction SilentlyContinue\nusername and password parameters aren’t set, the script will ask the user to reboot and log in manually if necessary, and the next time the user logs in, the script will continue at the point where it was interrupted. The process continues until the host meets the requirements for Ansible automation.\nOnce you have completed the script run, you should set the execution policy back to a more secure value. For Windows servers, this would be achieved using this PowerShell command:\n\n```", "```\n\n On Windows clients (for example, Windows 10 or Windows 11), this would be achieved via the following command:\n\n```", "```\n\n These are the default settings for the aforementioned operating systems, but if you want to check the execution policy setting prior to performing any of the script runs, you can query it before running your scripts with the following command:\n\n```", "```\n\n Once you have the required version of PowerShell and the .NET Framework installed, you can move on to the next step.\n\n1.  When PowerShell has been upgraded to at least version 3.0, the next step will be to configure the WinRM service so that Ansible can connect to it. WinRM service configuration defines how Ansible can interface with the Windows hosts, including the listener port and protocol.\n\nIf you have never set up a WinRM listener before, you have three options to do this, as follows:\n\n*   Firstly, you can use `winrm quickconfig` for HTTP and `winrm quickconfig -transport:https` for HTTPS. This is the simplest method to use when you need to run outside of the domain environment and just create a simple listener. This process has the advantage of opening the required port in the Windows Firewall and automatically starting the WinRM service.\n\nNote\nMore recent versions of Windows (for example, Windows Server 2022) will only let you run `winrm quickconfig -transport:https` if you already have a **Secure Sockets Layer** (**SSL**) certificate installed on your node that matches its hostname and is not self-signed. If this is not the case in your environment, the simplest approach is actually to use the PowerShell commands given next.\n\n*   If you are running in a domain environment, I strongly recommend using **group policy objects** (**GPOs**) because if the host is the domain member, then the configuration is done automatically without user input. There are many documented procedures for doing this available, but as this is a very Windows domain-centric task, it is beyond the scope of this book.\n*   Finally, you can create a listener with a specific configuration by running the following PowerShell commands with administrative privileges:\n\n    ```", "```\n\nThe preceding `CertificateThumbprint` value should match the thumbprint of a valid SSL certificate that you previously created or imported into the Windows Certificate Store. Note that if you use this method to configure your WinRM listener, the Windows Firewall is not automatically configured. You can configure it appropriately to listen on port `5986` (HTTPS) using a PowerShell command such as the following:\n\n```", "```\n\n In this simple example, we will perform basic authentication against a Windows host—this will only work with local accounts (not domain accounts) but is a quick and easy way to get acquainted with Windows automation. When you are ready to start experimenting with Kerberos authentication, the Ansible documentation provides a valuable reference for you to work from: [https://docs.ansible.com/ansible/latest/os_guide/windows_winrm.xhtml](https://docs.ansible.com/ansible/latest/os_guide/windows_winrm.xhtml).\nIn the meantime, it is important to note that basic authentication isn’t enabled by default on Windows hosts. To enable it, run the following PowerShell command:\n\n```", "```\n\n If you are running in PowerShell v3.0, you might face an issue with the WinRM service that limits the amount of memory available. This is a known bug, and a hotfix is available to resolve it. An example process (written in PowerShell) to apply this hotfix is given here:\n\n```", "```\n\n Configuring WinRM listeners can be a complex task, so it is important to be able to check the results of your configuration process. The following command (which can be run from Command Prompt) will display the current WinRM listener configuration:\n\n```", "```\n\n If all goes well, you should have output similar to this:\n\n```", "```\n\n According to the preceding output, two listeners are active—one to listen on port `5985` over HTTP and the other to listen on port `5986` over HTTPS, providing greater security. By way of additional explanation, the following parameters are also displayed in the preceding output:\n\n*   `Transport`: This should be set to either `HTTP` or `HTTPS`, though it is strongly recommended that you use the `HTTPS` listener to ensure your automation commands are not subject to snooping or manipulation.\n*   `Port`: This is the port on which the listener operates, by default `5985` for `HTTP` or `5986` for `HTTPS`.\n*   `URLPrefix`: This is the URL prefix to communicate with—by default, `wsman`. If you change it, you must set the `ansible_winrm_path` host on your Ansible control host to the same value.\n*   `CertificateThumbprint`: If running on an HTTPS listener, this is the certificate thumbprint of the Windows Certificate Store used by the connection.\n\nIf you need to debug any connection issues after setting up your WinRM listener, you may find the following commands valuable as they perform WinRM-based connections between Windows hosts without Ansible—hence, you can use them to distinguish whether an issue you might be experiencing is related to your Ansible host or whether there is an issue with the WinRM listener itself:\n\n```", "```\n\n If one of the preceding commands fails, you should investigate your WinRM listener setup before attempting to set up or configure your Ansible control host.\nAt this stage, Windows should be ready to receive communication from Ansible over WinRM. To complete this process, you will need to also perform some additional configuration on your Ansible control host. First of all, you will need to install the `winrm` Python module, which, depending on your control host’s configuration, may or may not have been installed before. The installation method will vary from one operating system to another, but it can generally be installed on most platforms with PIP, as follows:\n\n```", "```\n\n Once this is complete, you will need to define some additional inventory variables for your Windows hosts—don’t worry too much about inventories for now as we will cover these later in this book. The following example is just for reference:\n\n```", "```\n\n Finally, you should be able to run the Ansible `ansible.windows.win_ping` module to perform an end-to-end connectivity test with a command such as the following (adjust for your inventory):\n\n```", "```\n\n This is just the beginning of Windows automation with Ansible—once you decide on your connectivity strategy and way of configuring (whether it be through Group Policy, PowerShell scripts, or otherwise), you will be able to automate your Windows tasks with as much effectiveness as you automate your Linux tasks.\nIn Ansible 2.8, support was even added for OpenSSH connectivity to Windows hosts, removing the complexity of WinRM configuration and the various authentication mechanisms. While this looks like a great addition to Ansible’s Windows automation capabilities, it must be stressed that even now (on release 8.0.0) it is marked as experimental and that the future may bring changes that are not backward compatible with the current code. As such, we will not explore the setup here, but if you are interested in experimenting with this Windows support for yourself, you are encouraged to look at this section of the official Ansible documentation: [https://docs.ansible.com/ansible/latest/os_guide/windows_setup.xhtml#windows-ssh-setup](https://docs.ansible.com/ansible/latest/os_guide/windows_setup.xhtml#windows-ssh-setup).\nNow that you have learned the fundamental steps to configure Windows hosts for Ansible, let’s see how to manage multiple nodes via Ansible in the next section.\nGetting to know your Ansible installation\nBy this stage in this chapter, regardless of your choice of operating system for your Ansible control machine, you should have a working installation of Ansible with which to begin exploring the world of automation. In this section, we will carry out a practical exploration of the fundamentals of Ansible to help you to understand how to work with it. Once you have mastered these basic skills, you will then have the knowledge required to get the most out of the remainder of this book. Let’s get started with an overview of how Ansible connects to non-Windows hosts.\nUnderstanding how Ansible connects to hosts\nWith the exception of Windows hosts (as discussed at the end of the previous section), Ansible uses the SSH protocol to communicate with hosts. The reasons for this choice in the Ansible design are many, not least that just about every Linux/FreeBSD/macOS host has it built in, as do many network devices such as switches and routers. The SSH service is normally integrated with the operating system authentication stack, enabling you to take advantage of host-based identity verification, and a variety of authentication mechanisms, including Kerberos, to improve authentication security. Also, features of OpenSSH such as `ControlPersist` are used to increase the performance of automation tasks and SSH jump hosts/bastions for network isolation and security.\nNote\n`ControlPersist` is enabled by default on most modern Linux distributions as part of the OpenSSH server installation. However, on some older operating systems such as RHEL 6 (and CentOS 6), it is not supported, so you will not be able to use it. Ansible automation is still perfectly possible, but longer playbooks might run slower.\nAnsible makes use of the same authentication methods that you will already be familiar with, and SSH keys are normally the easiest way to proceed as they remove the need for users to input the authentication password every time a playbook is run. However, this is by no means mandatory, and Ansible supports password authentication through the use of the `--ask-pass` switch. If you are connecting to an unprivileged account on the managed nodes and need to perform the Ansible equivalent of running commands under `sudo` with a password, you can also add `--ask-become-pass` when you run your playbooks to allow this to be specified at runtime as well.\nThe goal of automation is to be able to run tasks securely but with minimal user intervention. As a result, it is highly recommended that you use SSH keys for authentication, and if you have several keys to manage, then it is advisable to make use of `ssh-agent`.\nEvery Ansible task, whether it is run individually or as part of a complex playbook, is run against an inventory. An inventory is, quite simply, a list of hosts that you wish to run automation tasks against. Ansible supports a wide range of inventory formats, including the use of dynamic inventories, which can populate themselves automatically from an orchestration provider (for example, you can generate an Ansible inventory dynamically from your Amazon **Elastic Compute Cloud** (**EC2**) instances, meaning you don’t have to keep up with all of the changes in your cloud infrastructure).\nDynamic inventory plugins have been written for most major cloud providers (for example, Amazon EC2, **Google Cloud Platform** (**GCP**), and Microsoft Azure), as well as on-premises systems such as OpenShift and OpenStack. There are even plugins for Docker. The beauty of OSS is that for most of the major use cases you can dream of, someone has already contributed the code, so you don’t need to figure it out or write it for yourself.\nTip\nAnsible’s agentless architecture and the fact that it doesn’t rely on SSL means that you don’t need to worry about DNS not being set up or even time skew problems as a result of the **Network Time Protocol** (**NTP**) not working—these can, in fact, be tasks performed by an Ansible playbook! Ansible really was designed to get your infrastructure running from a virtually bare operating system image.\nFor now, let’s focus on the INI-formatted inventory. An example is shown here with four servers, each split into two groups. Ansible commands and playbooks can be run against an entire inventory (that is, all four servers), one or more groups (for example, `webservers`), or even a single server:\n\n```", "```\n\n Let’s use this inventory file along with the Ansible `ping` module, which is used to test whether Ansible can successfully perform automation tasks on the inventory host in question. The following example assumes you have installed the inventory in the default location, which is normally `/etc/ansible/hosts`. When you run the following `ansible` command against this inventory with the `ping` module, you should see output similar to this:\n\n```", "```\n\n Notice that the `ansible.builtin.ping` module was only run on the two hosts in the `webservers` group and not the entire inventory—this was by virtue of us specifying this group name in the command-line parameters.\nThe `ansible.builtin.ping` module is one of many thousands of modules for Ansible, all of which perform a given set of tasks (from copying files between hosts to text substitution to complex network device configuration). Again, as Ansible is OSS, there is a veritable army of coders out there who are writing and contributing modules, which means if you can dream of a task, there’s probably already an Ansible module for it. Even in the instance that no module exists, Ansible supports sending raw shell commands (or PowerShell commands for Windows hosts), and so even in this eventuality, you can complete your desired tasks without having to move away from Ansible.\nAs long as the Ansible control node can communicate with the managed nodes in your inventory, you can automate your tasks. However, it is worth giving some consideration to where you place your control node. For example, if you are working exclusively with a set of Amazon EC2 machines, it arguably would make more sense for your Ansible control machine to be an EC2 instance—in this way, you are not sending all of your automation commands over the internet. It also means that you don’t need to expose the SSH port of your EC2 hosts to the internet, hence keeping them more secure.\nWe have so far covered a brief explanation of how Ansible communicates with its target hosts, including what inventories are and the importance of SSH communication to all except Windows hosts. In the next section, we will build on this by looking in greater detail at how to verify your Ansible installation.\nVerifying the Ansible installation\nIn this section, you will learn how you can verify your Ansible installation with simple ad hoc commands.\nAs discussed previously, Ansible can authenticate with your managed nodes in several ways. In this section, we will assume you want to make use of SSH keys and that you have already generated your public and private key pair and applied your public key to all of the managed nodes that you will be automating tasks on.\nTip\nThe `ssh-copy-id` utility is incredibly useful for distributing your public SSH key to your target hosts before you proceed any further. An example command might be `ssh-copy-id -i ~/.``ssh/id_rsa ansibleuser@web1.example.com`.\nTo ensure Ansible can authenticate with your private key, you could make use of `ssh-agent`—the following commands show a simple example of how to start `ssh-agent` and add your private key to it. Naturally, you should replace the path with that to your own private key:\n\n```", "```\n\n As we discussed in the previous section, we must also define an inventory for Ansible to run against. Another simple example is shown here:\n\n```", "```\n\n The `ansible` command that we used in the previous section has two important switches that you will almost always use: `-m <MODULE_NAME>` to run a module on the managed nodes from your inventory that you specify and, optionally, the module arguments passed using the `-a OPT_ARGS` switch. Commands run using the `ansible` binary are known as ad hoc commands.\nThe following are three simple examples that demonstrate ad hoc commands—they are also valuable for verifying both the installation of Ansible on your control machine and the configuration of your target hosts, and they will return an error if there is an issue with any part of the configuration. Here, we are introducing the `-i` switch, which is used to tell Ansible that we are specifying a different inventory file from the default— we’ll be using this frequently throughout the book from here on:\n\n*   `ping` on your inventory hosts using the following command:\n\n    ```", "```\n\n     *   **Display gathered facts**: You can display gathered facts about your inventory hosts using the following command:\n\n    ```", "```\n\n     *   **Filter gathered facts**: You can filter gathered facts using the following command:\n\n    ```", "```\n\nFor every ad hoc command you run, you will get a response in JSON format—the following example output results from running the `ansible.builtin.ping` module successfully:\n\n```", "```\n\n Ansible can also gather and return facts about your target hosts—facts are all manner of useful information about your hosts, from CPU and memory configuration, to network parameters, to disk geometry. These facts are intended to enable you to write intelligent playbooks that perform conditional actions—for example, you might only want to install a given software package on hosts with more than 4 GB of RAM or perhaps perform a specific configuration only on macOS hosts. The following is an example of the filtered facts from a macOS-based host—note the special syntax of the  `-i` inventory parameter; by placing a comma after the hostname, we are telling the `ansible` command to read the inventory from the command line, rather than a file (a handy shortcut when you’re testing and developing):\n\n```", "```\n\n Ad hoc commands are incredibly powerful, both for verifying your Ansible installation and for learning Ansible and how to work with modules, as you don’t need to write a whole playbook—you can just run a module with an ad hoc command and learn how it responds. Here are some more ad hoc examples for you to consider:\n\n*   Copy a file from the Ansible control node to all managed nodes in the `webservers` group with the following command:\n\n    ```", "```\n    webservers group with the following command:\n\n    ```", "```\n    state=present to state=latest causes Ansible to install the (latest version of the) package if it is not present, and update it to the latest version if it is present:\n\n    ```", "```\n\n    ```", "```\n\n    ```", "```\n\n     *   Display all facts about all the hosts in your inventory (warning—this will produce a lot of JSON!):\n\n    ```", "```\n\nNow that you have learned more about verifying your Ansible installation and about how to run ad hoc commands, let’s proceed to look in a bit more detail at the requirements of nodes that are to be managed by Ansible.\nManaged node requirements\nSo far, we have focused almost exclusively on the requirements for the Ansible control host and have assumed that (except for the distribution of the SSH keys) the target hosts will just work. This, of course, is not always the case, and for example, while a modern installation of Linux installed from an ISO will often just work, cloud operating system images are often stripped down to keep them small, and so might lack important packages such as Python, without which Ansible cannot operate.\nIf your target hosts are lacking Python, it is usually easy to install it through your operating system’s package management system. Ansible requires you to install either Python version 2.7 or 3.5 (and above) on the Ansible-managed nodes but has more stringent requirements for the control node. At the time of writing, `ansible-core` 2.15 (which accompanies Ansible 8.0.0) requires a version of Python between 3.9 and 3.11 to be installed on the control node. This is likely to change with new releases, so you are advised to always consult the official documentation to check the latest requirements: [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#managed-node-requirements](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#managed-node-requirements).\nTip\nAgain, the exception here is Windows, which relies on PowerShell instead of Python.\nIf you are working with operating system images on managed nodes that lack Python, the following commands provide a quick guide to getting Python installed:\n\n*   To install Python using `yum` (on older releases of Fedora and CentOS/RHEL 7 and below), use the following command:\n\n    ```", "```\n    $ sudo dnf install python\n    ```", "```\n\nYou might also elect to install a specific version to suit your needs, as in this example:\n\n```", "```\n\n*   On Debian and Ubuntu systems, you would use the `apt` package manager to install Python, again specifying a version if required (the example given here is to install Python 3.10 and would work on Ubuntu 22.04):\n\n    ```", "```\n\nThe `ansible.builtin.ping` module we discussed earlier in this chapter for Ansible not only checks connectivity and authentication with your managed hosts but also uses the managed hosts’ Python environment to perform some basic host checks. As a result, it is a fantastic end-to-end test to give you confidence that your managed nodes are configured correctly, with the connectivity and authentication set up perfectly, and to be safe in the knowledge that if Python is missing, the test would return a `failed` result.\nOf course, a perfect question at this stage would be: How can Ansible help if you roll out 100 cloud servers using a stripped-down base image without Python? Does that mean you have to manually go through all 100 nodes and install Python by hand before you can start automating?\nThankfully, Ansible has you covered even in this case, thanks to the `ansible.builtin.raw` module. This module is used to send raw shell commands to the managed nodes—and it works both with SSH-managed hosts and Windows PowerShell-managed hosts. As a result, you can use Ansible to install Python on a whole set of systems from which it is missing, or even run an entire shell script to bootstrap a managed node. Most importantly, the `ansible.builtin.raw` module is one of very few that does not require Python to be installed on the managed node, so it is perfect for our use case where we must roll out Python to enable further automation.\nThe following are some examples of tasks in an Ansible playbook that you might use to bootstrap a managed node and prepare it for Ansible management:\n\n```", "```\n\n We have now covered the basics of setting up Ansible both on the control host and the managed nodes, and we gave you a brief primer on configuring your first connections. It is hoped that you’ve found this chapter helpful and that it forms the foundation for the rest of your journey through this book.\nSummary\nAnsible is a powerful and versatile yet simple automation tool, of which the key benefits are its agentless architecture and its simple installation process. Ansible was designed to get you from zero to automation rapidly and with minimal effort, and we have demonstrated the simplicity with which you can get up and running with Ansible in this chapter.\nIn this chapter, you learned the basics of setting up Ansible—how to install it to control other hosts, and the requirements for nodes being managed by Ansible. You learned about the fundamentals required to set up SSH and WinRM for Ansible automation, as well as how to bootstrap managed nodes to ensure they are suitable for Ansible automation. You also learned about ad hoc commands and their benefits. Finally, you learned how to run the latest version of the code directly from GitHub, which both enables you to contribute directly to the development of Ansible and gives you access to the very latest features should you wish to make use of them on your infrastructure.\nIn the next chapter, we will learn Ansible language fundamentals to enable you to write your first playbooks and to help you to create templated configurations and start to build up complex automation workflows.\nQuestions\n\n1.  On which operating systems can you set up an Ansible control node? (There are multiple correct answers.)\n    1.  Ubuntu 22.04\n    2.  Fedora 35\n    3.  Windows Server 2022\n    4.  HP-UX\n    5.  Mainframe\n2.  Which protocol does Ansible use to connect to non-Windows managed nodes for running tasks?\n    1.  HTTP\n    2.  HTTPS\n    3.  SSH\n    4.  TCP\n    5.  UDP\n3.  To execute a specific module in the Ansible ad hoc command line, you need to use the `-``m` option.\n    1.  True\n    2.  False\n\nFurther reading\n\n*   For any questions about installation via Ansible’s mailing list on Google Groups, refer to the following URL:\n\n[https://groups.google.com/forum/#!forum/ansible-project](https://groups.google.com/forum/#!forum/ansible-project)\n\n*   Information on how to install the latest version of `pip` can be found here:\n\n[https://pip.pypa.io/en/stable/installation/](https://pip.pypa.io/en/stable/installation/)\n\n*   Details of specific Windows modules using PowerShell can be found here:\n\n[https://docs.ansible.com/ansible/latest/collections/ansible/windows/index.xhtml](https://docs.ansible.com/ansible/latest/collections/ansible/windows/index.xhtml)\n\n*   If you have a GitHub account and want to follow the GitHub project, you can keep tracking issues, bugs, and ideas for Ansible at the following URL:\n\n[https://github.com/ansible/ansible](https://github.com/ansible/ansible)\n\n```"]