- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Getting Started with Ansible
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Ansible
- en: Ansible enables you to easily deploy applications and systems consistently and
    repeatably using native communication protocols such as SSH and WinRM. As a result,
    Ansible is agentless and so requires nothing to be installed on the managed systems
    (except for Python, which, these days, is present on most systems). As a result,
    it enables you to build a simple yet robust automation platform for your environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 使你能够轻松地使用原生通信协议（如 SSH 和 WinRM）一致且可重复地部署应用程序和系统。因此，Ansible 是无代理的，不需要在被管理系统上安装任何东西（除了
    Python，现如今大多数系统上都有 Python）。因此，它使你能够为你的环境构建一个简单而强大的自动化平台。
- en: Ansible is straightforward to install and also comes packaged for many modern
    systems. Its architecture is serverless as well as agentless, so it has a minimal
    footprint. You can choose to run it from a central server or your own laptop—the
    choice is entirely yours. You can manage anything from a single host to hundreds
    of thousands of remote hosts from one Ansible control machine. All remote machines
    can be managed by Ansible, and with sufficient playbooks created, you may never
    have to log in to any of these machines individually again.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 安装简便，并且已经为许多现代系统打包。它的架构是无服务器和无代理的，因此占用资源最少。你可以选择从中央服务器或自己的笔记本电脑运行它——完全由你决定。你可以从一个
    Ansible 控制机管理从单一主机到数十万个远程主机的所有机器。所有远程机器都可以通过 Ansible 进行管理，并且通过创建足够的剧本，你可能再也不需要单独登录到这些机器中去。
- en: In this chapter, we will begin to teach you practical skills to cover the very
    fundamentals of Ansible, starting with how to install Ansible on a wide variety
    of operating systems. We will then look at how to configure Windows hosts to enable
    them to be managed with Ansible automation, before delving in greater depth into
    how Ansible connects to its target hosts. We’ll then look at node requirements
    and how to validate your Ansible installation, before finally looking at how to
    obtain and run the very latest Ansible source code if you wish to either contribute
    to its development or gain access to the very latest features.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将开始教授你实际操作技能，涵盖 Ansible 的基本知识，从如何在多种操作系统上安装 Ansible 开始。然后我们将探讨如何配置 Windows
    主机，以使它们能够通过 Ansible 自动化进行管理，接着深入了解 Ansible 如何与目标主机连接。接下来，我们将讨论节点要求和如何验证你的 Ansible
    安装，最后，我们将探讨如何获取并运行最新的 Ansible 源代码，如果你希望为其开发做出贡献或访问最新功能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing and configuring Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置 Ansible
- en: Getting to know your Ansible installation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解你的 Ansible 安装
- en: Managed node requirements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被管理节点的要求
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Ansible has a fairly minimal set of system requirements—as such, you should
    find that if you have a machine (either a laptop, a server, or a **virtual machine**
    (**VM**)) that is capable of running Python, then you will be able to run Ansible
    on it. Later in this chapter, we will demonstrate the installation methods for
    Ansible on a variety of operating systems—it is hence left to you to decide which
    operating systems are right for you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 对系统的要求相对较低，因此，如果你的机器（无论是笔记本电脑、服务器，还是 **虚拟机**（**VM**））能够运行 Python，你就能在其上运行
    Ansible。本章后续部分将演示如何在多种操作系统上安装 Ansible——因此，最终选择哪些操作系统适合你将由你决定。
- en: The one exception to the preceding statement is Microsoft Windows—although there
    are Python environments available for Windows, there is as yet no native build
    of Ansible for Windows. Readers running more recent versions of Windows will be
    able to install Ansible using **Windows Subsystem for Linux** (henceforth, **WSL**)
    by following the procedures outlined later for their chosen WSL environment (for
    example, if you install Ubuntu on WSL, you should simply follow the instructions
    given in this chapter for installing Ansible on Ubuntu).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前述声明的唯一例外是 Microsoft Windows——尽管 Windows 上有可用的 Python 环境，但目前没有适用于 Windows
    的 Ansible 原生版本。使用较新版本 Windows 的读者可以通过 **Windows 子系统 Linux**（以下简称 **WSL**）安装 Ansible，只需按照后面为他们选择的
    WSL 环境所列的步骤进行操作（例如，如果你在 WSL 上安装 Ubuntu，只需按照本章中为 Ubuntu 安装 Ansible 的说明进行操作）。
- en: Installing and configuring Ansible
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置 Ansible
- en: Ansible is written in Python and, as such, can be run on a wide range of systems.
    This includes the most popular flavors of Linux, FreeBSD, and macOS. The one exception
    to this is Windows, where though native Python distributions exist, there is as
    yet no native Ansible build. As a result, your best option at the time of writing
    is to install Ansible under WSL, proceeding as if you were running on a native
    Linux host.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible用Python编写，因此可以在广泛的系统上运行。这包括最流行的Linux、FreeBSD和macOS版本。唯一的例外是Windows，尽管存在原生Python发行版，但目前尚无原生Ansible构建版本。因此，在撰写时，您最好的选择是在WSL下安装Ansible，操作方式与在本地Linux主机上运行相同。
- en: Once you have established the system on which you wish to run Ansible, the installation
    process is normally simple. In the following sections, we will discuss how to
    install Ansible on a wide range of different systems so that most readers should
    be able to get up and running with Ansible in a matter of minutes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了您希望在其上运行Ansible的系统，安装过程通常很简单。在接下来的部分中，我们将讨论如何在各种不同的系统上安装Ansible，以便大多数读者应该能够在几分钟内开始并运行Ansible。
- en: Understanding Ansible version numbers
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Ansible版本号
- en: When the previous edition of this book was published, Ansible followed a relatively
    simple version numbering scheme. All releases of Ansible included all the modules,
    plugins, and other code accepted into the Ansible release (which was version 2.9
    in the previous edition of this book).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一版书籍发布时，Ansible遵循了一个相对简单的版本编号方案。所有的Ansible发布版本都包含了所有被接受到Ansible发布中的模块、插件和其他代码（在上一版书籍中是版本2.9）。
- en: This worked well for many years but also created a problem for the maintainers
    of Ansible—as its popularity and adoption grew, the number of modules (the lifeblood
    of Ansible, which perform the actual automation tasks you will run) numbered in
    the thousands. Releasing these with the core Ansible software meant that if a
    bug was discovered in a module, or perhaps a new release with new features was
    available, then there had to be a new release of Ansible before end users could
    take advantage of this. Not only did this slow down releases of new module code,
    but it also created a significant workload for the Ansible maintainers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这在多年来运行良好，但也为Ansible的维护人员创建了问题—随着其流行度和采纳率的增加，模块的数量（这些模块是Ansible的命脉，执行您将运行的实际自动化任务）已达数千个。将这些模块与核心Ansible软件一起发布意味着，如果在模块中发现了错误或者可能有新功能的新版本可用，则必须在终端用户能够利用之前发布新版本的Ansible。这不仅减慢了新模块代码的发布速度，还为Ansible维护人员创建了大量的工作负担。
- en: As a direct result of this, Ansible was split into two separate packages. The
    first is called `ansible-core`, and this contains just the Ansible runtime code
    (such as the `ansible-playbook` command, which we’ll see in use later), as well
    as some built-in functionality that is core to all playbooks and roles. The `ansible-core`
    package follows the *classic* Ansible versioning scheme, and so where the previous
    release of this book was written around Ansible 2.9, this version of the book
    will be based around `ansible-core` 2.15.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为直接结果，Ansible被分成两个独立的包。第一个称为`ansible-core`，它仅包含Ansible运行时代码（如稍后将看到的`ansible-playbook`命令）以及一些内置功能，这些功能对所有playbook和角色都是核心的。`ansible-core`包遵循*经典*的Ansible版本控制方案，因此在此书的先前版本围绕Ansible
    2.9编写时，此书的这个版本将基于`ansible-core` 2.15。
- en: All the modules and plugins that provided the functionality present in the 2.9
    release (the last release before the package split was implemented) are contained
    in the **Ansible community package** release. This follows semantic versioning,
    meaning that, as the current release at the time of writing is 8.0, the next major
    release will be 9.0.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模块和插件，这些功能都包含在**Ansible社区包**发布的2.9版本（在实施包拆分之前的最后一个版本）中。这遵循语义化版本控制，这意味着，在撰写时当前版本为8.0，下一个主要版本将是9.0。
- en: To enable this separate management of `ansible-core` and modules, plugins, and
    the like, an implementation called **collections** was created. Collections are
    individually bundled sets of modules, plugins, and roles intended for a specific
    purpose; we’ll be learning all about these in detail in [*Chapter 6*](B20846_06.xhtml#_idTextAnchor318),
    *Creating and Consuming Collections*, so don’t worry if this all seems a bit daunting—it
    will all become clear later in the book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现 `ansible-core` 和模块、插件等的独立管理，创建了一种名为 **collections** 的实现方式。Collections 是独立捆绑的模块、插件和角色集合，旨在实现特定功能；我们将在
    [*第六章*](B20846_06.xhtml#_idTextAnchor318)《创建和使用 Collections》中详细学习这些内容，所以如果你觉得有些复杂，不必担心——后续内容会逐渐清晰。
- en: 'Each release of the Ansible community package is dependent on a specific version
    of the `ansible-core` package, and the 8.0 release we will use in this book depends
    upon `ansible-core` version 2.15\. You can find the change log and other details
    about the 8.0 release here: [https://github.com/ansible-community/ansible-build-data/blob/8.0.0/8/CHANGELOG-v8.rst#v8-0-0](https://github.com/ansible-community/ansible-build-data/blob/8.0.0/8/CHANGELOG-v8.rst#v8-0-0).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Ansible 社区包的发布都依赖于特定版本的 `ansible-core` 包，我们将在本书中使用的 8.0 版本依赖于 `ansible-core`
    版本 2.15。你可以在这里查看 8.0 版本的变更日志和其他详细信息：[https://github.com/ansible-community/ansible-build-data/blob/8.0.0/8/CHANGELOG-v8.rst#v8-0-0](https://github.com/ansible-community/ansible-build-data/blob/8.0.0/8/CHANGELOG-v8.rst#v8-0-0)。
- en: 'The beauty of this separation of code lies in this: let’s say you want to create
    a playbook or role based around new functionality in a module; you can install
    an updated collection containing the module without updating your entire Ansible
    installation (or, indeed, waiting for the next release, as you would have had
    to until after version 2.9 was released).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码分离的优点在于：假设你想创建一个基于模块中新功能的 playbook 或角色；你可以安装一个更新后的包含该模块的 collection，而不需要更新整个
    Ansible 安装（或者，实际上，等待下一个版本发布，就像在 2.9 版本之前那样）。
- en: With this information in hand, we’ll proceed to explore the specifics of installing
    Ansible on a variety of systems, but it’s important to discuss this upfront as
    if you’ve had exposure to any of the 2.x releases of Ansible, the new versioning
    scheme will look rather different.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了这些信息后，我们将继续探索如何在各种系统上安装 Ansible 的具体步骤，但在开始之前很重要的一点是，如果你接触过 Ansible 的任何 2.x
    版本，新版本的版本管理方案将会有所不同。
- en: 'If you’d like to read more details on the rationale behind the new versioning
    scheme, release cadence, and how it works, the official Ansible documentation
    here has more details: [https://docs.ansible.com/ansible/latest/reference_appendices/release_and_maintenance.xhtml](https://docs.ansible.com/ansible/latest/reference_appendices/release_and_maintenance.xhtml).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解有关新版本管理方案、发布周期及其工作方式的更多细节，可以在这里查看官方 Ansible 文档：[https://docs.ansible.com/ansible/latest/reference_appendices/release_and_maintenance.xhtml](https://docs.ansible.com/ansible/latest/reference_appendices/release_and_maintenance.xhtml)。
- en: Installing Ansible on Linux and FreeBSD
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Linux 和 FreeBSD 上安装 Ansible
- en: The release cycle for Ansible is usually about six months, and during this short
    release cycle, there are normally many changes, from minor bug fixes to major
    ones, new features, and even sometimes fundamental changes to the language. At
    the end of each release cycle, you would expect to see a new version of the Ansible
    community package (for example, 8.0), and a corresponding release of the `ansible-core`
    package (for example, 2.15). While there are native packages still built for many
    operating systems, your mileage will vary as to how up to date these are, and
    the recommended way to install Ansible is now to use the PIP package manager for
    Python.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 的发布周期通常为六个月，在这个较短的周期内，通常会有许多变化，从小的 bug 修复到重大的 bug 修复、新功能，甚至有时是语言的根本性变化。在每个发布周期结束时，你应该会看到一个新的
    Ansible 社区包版本（例如 8.0），以及相应版本的 `ansible-core` 包（例如 2.15）。虽然很多操作系统仍然会提供原生包，但这些包的更新频率可能会有所不同，目前推荐的安装
    Ansible 方式是使用 Python 的 PIP 包管理器。
- en: There will, of course, be exceptions to this. For example, if you are using
    a commercial Linux distribution such as **Red Hat Enterprise Linux** (**RHEL**),
    especially to perform workflows supported by your operating system vendor, then
    you should make sure you use the packages provided by that vendor. They will invariably
    also provide instructions on how to install Ansible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这其中会有例外。例如，如果你正在使用商业 Linux 发行版，如**Red Hat 企业 Linux**（**RHEL**），尤其是为了执行操作系统供应商支持的工作流，那么你应确保使用该供应商提供的软件包。它们通常也会提供有关如何安装
    Ansible 的说明。
- en: This does bring with it a separate challenge. When Ansible was installed using
    your native package manager such as `yum`, `dnf`, or `apt`, it would be updated
    along with your system. When using PIP, you will need to ensure that you update
    Ansible separately (we will show you how shortly).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实带来了一个单独的挑战。当 Ansible 通过操作系统的本地包管理器如`yum`、`dnf`或`apt`安装时，它会和系统一起更新。而使用 PIP
    时，你需要单独更新 Ansible（稍后我们会演示如何操作）。
- en: Talking of upgrades, most playbooks that were created under the 2.x releases
    of Ansible will still work today, and you will often find that updating does not
    specifically cause any issues. However, it is strongly recommended that you read
    the porting notes for each release to ensure your code remains functional as you
    intended it. As such, an Ansible upgrade should be a planned activity, and it
    is almost certainly not desirable to patch Ansible in line with your operating
    system. In short, the move away from native operating system packages to PIP package
    management is unlikely to cause you any issues, and may even prove beneficial.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 说到升级，绝大多数在 Ansible 2.x 版本下创建的 playbook 至今仍然可以使用，而且你通常会发现升级不会特别引发任何问题。然而，强烈建议你在每个版本的迁移说明中阅读相关内容，以确保你的代码依然按预期工作。因此，Ansible
    升级应该是一个计划好的活动，几乎不建议你按照操作系统的升级来修补 Ansible。简而言之，从操作系统本地软件包转向 PIP 包管理不会引发问题，甚至可能带来好处。
- en: 'Suppose you want to install Ansible on a node—the following procedure should
    work on any version of Linux or FreeBSD provided the required version of Python
    is available:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你要在某个节点上安装 Ansible——以下步骤应该适用于任何版本的 Linux 或 FreeBSD，只要该节点上安装了所需版本的 Python：
- en: 'Check that Python is installed on your intended node—henceforth, we will refer
    to this as the `PATH` using a command such as this:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查你打算使用的节点是否已安装 Python——从现在开始，我们将使用类似以下命令来称呼它为`PATH`：
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, you can see that Python 3.10.6 is installed. The minimum requirement for
    Ansible 8.0 is Python 3.9, so in this instance, we are good to proceed. However,
    if you find that Python is not present, please refer to the documentation for
    your operating system for guidance on how to install it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 Python 3.10.6 已经安装。Ansible 8.0 的最低要求是 Python 3.9，因此在这种情况下，我们可以继续操作。但是，如果你发现没有安装
    Python，请参考操作系统文档获取有关如何安装 Python 的指导。
- en: Tip
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Depending upon your system, Python may be run using a command such as `python`,
    `python3`, or `python3.10`—again, please refer to the documentation for your operating
    system to learn more. Ansible will work in any of these cases, but it is important
    to understand how to run Python on your system to complete the rest of this process.
    Here, we will assume that Python is executed using the `python3` command.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的系统，Python 可能使用诸如`python`、`python3`或`python3.10`之类的命令运行——再次提醒，请参考操作系统文档了解更多信息。Ansible
    在这些情况下都能正常工作，但理解如何在系统上运行 Python 对于完成后续步骤非常重要。这里，我们假设使用`python3`命令来执行 Python。
- en: 'Once you know that Python is installed, the next step is to ensure that the
    PIP package manager is installed. A successful query of this should look something
    like this:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦确认 Python 已安装，下一步是确保安装了 PIP 包管理器。成功查询的输出应该类似于下面这样：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You may see output such as this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到如下输出：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In such cases, you will need to install PIP. You can do this by running the
    following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要安装 PIP。你可以通过运行以下命令来完成安装：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Most operating systems will also have a native package for installing PIP—for
    example, on Ubuntu, you can install PIP using this command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统也会提供用于安装 PIP 的本地软件包——例如，在 Ubuntu 上，你可以使用以下命令来安装 PIP：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How you install PIP doesn’t matter—as long as it’s installed, you can proceed
    to the next step.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 PIP 的方式无关紧要——只要它已经安装，你就可以继续下一步。
- en: With these steps completed, all that is left is to install Ansible. Now, this
    might seem like a bit of a departure from the previous ways of installing Ansible,
    where operating-system-native packages were available for most major operating
    systems. Yet the beauty of using PIP is that once you’ve learned how to install
    and manage Ansible on one system, the method is exactly the same on all others,
    regardless of whether you are using Fedora, Ubuntu, FreeBSD, Debian, or Gentoo.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些步骤后，剩下的就是安装 Ansible。现在，这可能看起来与以前安装 Ansible 的方式有所不同，以前大多数主要操作系统都提供了操作系统原生的安装包。但使用
    PIP 的好处是，一旦你学会了在一个系统上安装和管理 Ansible，其他所有系统的安装方法都是完全相同的，无论你使用的是 Fedora、Ubuntu、FreeBSD、Debian
    还是 Gentoo。
- en: 'In fact, even if you’re using Linux under WSL, the installation method is exactly
    the same once you’ve got WSL up and running. The simplest and easiest way to complete
    your Ansible install is to run the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，即使你在 WSL 下使用 Linux，一旦 WSL 启动并运行，安装方法也是完全相同的。完成 Ansible 安装的最简单、最直接的方式就是运行以下命令：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output should look something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于下面这样：
- en: '![Figure 1.1 – Installing Ansible using PIP on Linux](img/B20846_01_001.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 在 Linux 上使用 PIP 安装 Ansible](img/B20846_01_001.jpg)'
- en: Figure 1.1 – Installing Ansible using PIP on Linux
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 在 Linux 上使用 PIP 安装 Ansible
- en: From the output here, you can see that this command has successfully installed
    Ansible 8.0.0, along with its dependent package, `ansible-core` 2.15.0—these are
    the latest versions available at the time of writing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，你可以看到这个命令已经成功安装了 Ansible 8.0.0，以及其依赖包 `ansible-core` 2.15.0——这些是写作时可用的最新版本。
- en: Also, you will note that Ansible has been installed in `/home/james/.local/bin`,
    which is not on the system path, so you won’t be able to run commands such as
    `ansible-playbook` without either updating the path or specifying the full path.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你会注意到 Ansible 已经安装在 `/home/james/.local/bin` 目录下，而该目录不在系统路径中，因此你将无法运行像 `ansible-playbook`
    这样的命令，除非你更新路径或指定完整路径。
- en: 'Thus, if you want to run the `ansible-playbook` command, you could run it as
    follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想运行 `ansible-playbook` 命令，你可以按照以下方式运行：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, you could update your path, and then you can run the command
    without needing to specify the full path, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以更新你的路径，然后你就可以运行命令而无需指定完整路径，具体如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Of course, this process is only installing Ansible for the current user. This
    will often be sufficient for most scenarios, but there might be times when you
    have multiple developers accessing the same control node, and in this case, you
    would want them all to access one centrally installed copy of Ansible—otherwise,
    one developer might have version 6.2.0 and another 8.0.0, and your development
    processes would be inconsistent.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个过程只是为当前用户安装 Ansible。对于大多数场景，这通常已经足够，但有时你可能有多个开发人员访问同一个控制节点，在这种情况下，你会希望他们都访问一个集中安装的
    Ansible 副本——否则，一个开发人员可能使用的是版本 6.2.0，另一个使用的是 8.0.0，开发过程就会变得不一致。
- en: 'If you want to install Ansible for everyone, you should follow the preceding
    process up to *step 2* to ensure that PIP is installed. Then, proceed as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为所有用户安装 Ansible，你应该按照前面的步骤完成*步骤 2*，确保 PIP 已经安装。然后，按照以下步骤操作：
- en: 'Install Ansible as the root user by running the following command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 root 用户身份安装 Ansible，运行以下命令：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, you will find that Ansible is installed centrally—on my Ubuntu Server
    22.04 test system, I see the following results after running this command:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你会发现 Ansible 已经集中安装——在我的 Ubuntu Server 22.04 测试系统上，运行此命令后，我看到如下结果：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: PIP has more tricks up its sleeve, however, and we’re going to show you another
    one now—specifying your installation version.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，PIP 还有更多技巧，我们现在将展示其中的另一个——指定安装版本。
- en: So far, we’ve just been specifying the `ansible` package for installation. This
    works great if you always want the latest and greatest version, but what if, for
    reasons of development or consistency, you want to install a specific version?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只指定了安装 `ansible` 包。如果你总是希望安装最新的版本，这样的做法非常有效，但如果出于开发或一致性的原因，你希望安装特定版本呢？
- en: 'First of all, suppose that you want to install Ansible 6.2.0 because you need
    to test or develop against that version. You could do this by altering your `install`
    command as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设你想安装 Ansible 6.2.0，因为你需要在该版本上进行测试或开发。你可以通过修改你的 `install` 命令来实现：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will install version `6.2.0` (and the corresponding version of `ansible-core`,
    which in this example is `2.13.8`) in your local user directory, and if you watch
    the installation process closely, you’ll see that it uninstalls any version you
    have already installed, even if it’s newer. Proceed with caution if this isn’t
    what you want.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装`6.2.0`版本（以及相应版本的`ansible-core`，在这个例子中是`2.13.8`）到你的本地用户目录，如果你密切关注安装过程，你会看到它会卸载你已经安装的任何版本，即使是更新的版本。如果这不是你想要的结果，请小心操作。
- en: Tip
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can, of course, add a `==6.2.0` suffix to any of the installation commands
    we’ve given previously to specify the version to be installed. You can also change
    `6.2.0` to any valid version number. You can explore the available versions by
    browsing to the following URL: [https://pypi.org/project/ansible/#history](https://pypi.org/project/ansible/#history).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在我们之前给出的任何安装命令后加上`==6.2.0`后缀来指定要安装的版本。你也可以将`6.2.0`更改为任何有效的版本号。你可以通过浏览以下网址来查看可用的版本：[https://pypi.org/project/ansible/#history](https://pypi.org/project/ansible/#history)。
- en: 'Any time you want to upgrade your installed Ansible version (when it has been
    installed using PIP), you can simply add the `--upgrade` flag to the installation
    command, as in the following example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想要升级已安装的Ansible版本（当它是通过PIP安装时），你只需在安装命令中添加`--upgrade`标志，如下例所示：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example command will install the very latest version, as we have not explicitly
    set one otherwise.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例命令将安装最新版本，因为我们没有显式设置其他版本。
- en: 'If you ever need to remove Ansible from your system for any reason, PIP can
    also handle this—for example, you could run this command to remove the version
    of Ansible and `ansible-core` that you installed (note that you must specify both—dependencies
    are not automatically removed):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你出于某种原因需要从系统中删除Ansible，PIP也可以处理这一操作——例如，你可以运行此命令来删除你安装的Ansible和`ansible-core`版本（注意，你必须指定两者——依赖项不会自动删除）：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once you’ve mastered these commands, you will be set to install, maintain, and
    uninstall Ansible on all your control nodes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了这些命令，你将能够在所有控制节点上安装、维护和卸载Ansible。
- en: Working with virtual environments
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用虚拟环境
- en: Another incredibly useful and powerful feature of Python is **virtual environments**
    (henceforth **venvs**). Venvs are small isolated Python environments that are
    separate from both the system install of Python (and its libraries) and all other
    virtual environments. This is incredibly useful for Ansible development. For example,
    let’s say that you have a set of playbooks and roles that you developed under
    Ansible 2.7.18, and these have all been tested and known to work well. You want
    to upgrade to Ansible 8.0.0, but you can’t take the risk of the existing code
    being inoperable in case you have to use it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Python的另一个非常有用且强大的功能是**虚拟环境**（以下简称**venvs**）。Venvs是与系统安装的Python（及其库）和所有其他虚拟环境分开的独立Python环境。这对Ansible开发非常有用。例如，假设你有一套在Ansible
    2.7.18下开发的Playbook和角色，这些都已经过测试并且能够正常工作。你想升级到Ansible 8.0.0，但你不敢冒险让现有代码无法使用，以防万一需要用到它。
- en: 'With venvs, you can have an isolated Ansible 2.7.18 and an isolated Ansible
    8.0.0 environment on the same machine, and you can switch between them at will.
    To get started, follow the process provided next:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟环境（venvs），你可以在同一台机器上拥有一个独立的Ansible 2.7.18环境和一个独立的Ansible 8.0.0环境，并且可以随时在它们之间切换。要开始，按照接下来提供的步骤进行：
- en: 'To start with, you will need to make sure you have both an operable Python
    environment and PIP, as described earlier in this chapter. Once these are in place,
    proceed to *step 2*. If you are going back to a version of Ansible as old as 2.7.18,
    you’ll also need to ensure it supports the Python version you are using. My Python
    environment on Ubuntu Server 22.04 is version 3.10, which is not supported by
    Ansible 2.7.18\. As a result, I’ll install Python 2.7, like so:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要确保你有一个可操作的Python环境和PIP，正如本章前面所述。一旦这些准备就绪，继续进行*步骤2*。如果你需要回退到Ansible 2.7.18的版本，你还需要确保它支持你使用的Python版本。我的Ubuntu
    Server 22.04上的Python环境是3.10，而Ansible 2.7.18不支持该版本。因此，我将安装Python 2.7，如下所示：
- en: '[PRE13]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: $ sudo pip2 install virtualenv
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ sudo pip2 install virtualenv
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You’re now ready to create your first venv—let’s create one for Ansible 2.7.18:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在已经准备好创建你的第一个虚拟环境——让我们为Ansible 2.7.18创建一个虚拟环境：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will create a venv under the current directory containing the minimum
    set of files for an operating Python 2 environment. Now, we’ll activate the environment
    (without this step, you will still be using the system Python environment):'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在当前目录下创建一个包含 Python 2 环境最小文件集的虚拟环境。现在，我们将激活该环境（如果没有这一步，你仍然会使用系统的 Python 环境）：
- en: '[PRE16]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (ansible-2.7.18) $ python -m pip install ansible==2.7.18
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （ansible-2.7.18）$ python -m pip install ansible==2.7.18
- en: '[PRE17]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You’ll see Ansible installed via PIP in the usual way. Now, you should be able
    to query the version of Ansible installed, as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到通过 PIP 安装 Ansible，如同以前一样。现在，你应该能够查询已安装的 Ansible 版本，如下所示：
- en: '[PRE18]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That’s it—we have Ansible 2.7.18 working in its own Python environment, all
    isolated from the system and other environments. Now, we can repeat the process
    for Ansible 8.0.0\. You will doubtless have received warnings that Python 2.7
    is deprecated during this process (this is to be expected), so we definitely want
    to use our system-installed version of Python 3.10 for the later version of Ansible.
    As such, we first want to deactivate our venv so that we can revert to the system-installed
    Python libraries. Here’s how we can do that:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样——我们已经在自己的 Python 环境中运行了 Ansible 2.7.18，并且完全与系统及其他环境隔离开来。现在，我们可以对 Ansible
    8.0.0 重复这一过程。你在此过程中无疑会收到关于 Python 2.7 已废弃的警告（这是预期中的），所以我们确实想使用系统安装的 Python 3.10
    来运行较新版本的 Ansible。因此，我们首先需要停用虚拟环境，以便恢复到系统安装的 Python 库。下面是我们可以怎么做：
- en: '[PRE19]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note how your prompt returns to normal, demonstrating that the venv is no longer
    active. As before, we need to ensure we have the Python venv library installed—however,
    there is a native package for it, so we can simply install it using this command:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意你的提示符如何恢复正常，表明虚拟环境不再处于活动状态。如之前所示，我们需要确保安装了 Python venv 库——不过，已经有一个本地包，所以我们可以通过以下命令直接安装：
- en: '[PRE20]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you can create a Python 3 venv for Ansible 8.0.0 and activate it using
    the following commands:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以为 Ansible 8.0.0 创建一个 Python 3 虚拟环境并使用以下命令激活它：
- en: '[PRE21]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can now install Ansible via PIP in the same manner as before:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以像以前一样通过 PIP 安装 Ansible：
- en: '[PRE22]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, we’ve used completely different versions of Python and Ansible,
    yet they remain isolated from each other on the system. As such, you can safely
    use the older version to run your playbooks while you test your updated code on
    the newer version. This is quite an extreme example, and you almost certainly
    won’t need to go back to Python 2.7 and Ansible 2.7.18, but it does demonstrate
    how nicely you can create completely separate Python environments for your development
    and testing work without needing multiple systems.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了完全不同版本的 Python 和 Ansible，但它们在系统中依然相互隔离。因此，你可以安全地使用旧版本来运行你的 playbook，同时在更新的版本上测试你的代码。这是一个相当极端的例子，你几乎不需要回到
    Python 2.7 和 Ansible 2.7.18，但它展示了如何创建完全独立的 Python 环境来进行开发和测试工作，而不需要多个系统。
- en: Installing from GitHub
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 GitHub 安装
- en: It has always been possible to run the very latest development version of Ansible
    from GitHub, and this is as true today as it has always been. However, there is
    now one important caveat. If you have done this previously (on releases of Ansible
    from the 2.x series or earlier, on which the previous edition of this book was
    based), then you would be working with the complete install of Ansible, including
    all the modules you might want to use. Since the introduction of collections,
    you will now only be checking out the code for `ansible-core` when you do this.
    As such, if you want to test code including module calls, you will need to install
    or manage collections to go alongside your `ansible-core` setup.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GitHub 上运行最新版本的 Ansible 一直是可行的，这一点至今依然如此。然而，现在有一个重要的警告。如果你之前已经这样做过（在 2.x 系列或更早版本的
    Ansible 上，这本书的上一版正是基于这个版本），那么你会使用完整的 Ansible 安装，包括你可能想要使用的所有模块。自从引入了 collections（集合）后，你现在只会检出
    `ansible-core` 的代码。因此，如果你想测试包括模块调用在内的代码，你将需要安装或管理 collections 来与 `ansible-core`
    配置一起使用。
- en: We will explore the management of collections in [*Chapter 6*](B20846_06.xhtml#_idTextAnchor318),
    *Creating and Consuming Collections*, so we won’t specifically explore this here—however,
    for completeness, we will show you how to install `ansible-core` development releases
    from code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第六章*](B20846_06.xhtml#_idTextAnchor318)《创建和使用集合》中探讨集合的管理，因此我们不会在此处专门探讨此内容——不过，为了完整性，我们将向你展示如何从代码安装
    `ansible-core` 开发版。
- en: 'To do this, follow these steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请按照以下步骤操作：
- en: Check that you have PIP installed—if you don’t, please take a look at how we
    did this earlier in the chapter. Once you have this (and, by inference, a working
    Python 3 environment), you can move forward to the next step.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请检查是否已安装 PIP——如果没有，请参考本章前面介绍的内容。安装好 PIP（以及推断出来的工作 Python 3 环境）后，你可以继续进行下一步。
- en: 'Clone the Ansible GitHub repository, like so:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像这样克隆 Ansible 的 GitHub 仓库：
- en: '[PRE23]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Ensure you have all development requirements installed using PIP:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 PIP 确保你已经安装了所有开发要求：
- en: '[PRE24]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ansible, ansible-playbook, and ansible-galaxy.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ansible、ansible-playbook 和 ansible-galaxy。
- en: '[PRE25]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'On Linux distributions such as Ubuntu 22.04, the default Python installation
    is Python 3, and the binary used to execute it is named `python3`. This won’t
    work on the development install of Ansible, which expects the Python binary to
    be called `python`. You can fix this on Ubuntu 22.04 by installing a special meta
    package. To do so, run this command: `sudo apt install python-is-python3`. Or,
    you could just create a symbolic link from `python3` to `python` by running the
    following command: `sudo ln -s /``usr/bin/python3 /usr/bin/python`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 22.04 等 Linux 发行版上，默认的 Python 安装是 Python 3，执行该 Python 版本的二进制文件名为 `python3`。但这在开发安装的
    Ansible 中不可行，因为它期待名为 `python` 的 Python 二进制文件。你可以通过安装一个特殊的元包来解决这个问题。在 Ubuntu 22.04
    上，可以运行以下命令：`sudo apt install python-is-python3`。或者，你也可以通过运行以下命令创建一个从 `python3`
    到 `python` 的符号链接：`sudo ln -s /usr/bin/python3 /usr/bin/python`。
- en: 'When you run the `env-setup` script, Ansible runs from the source code checkout,
    and the default inventory file is `/etc/ansible/hosts`, which will not have been
    created by your code checkout; however, you can optionally specify an inventory
    file wherever you want on your machine (see *How to build your inventory*, [https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.xhtml#inventory-basics-formats-hosts-and-groups](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.xhtml#inventory-basics-formats-hosts-and-groups),
    for more details). The following command provides an example of how you might
    do this, but obviously, your filename and contents are almost certainly going
    to vary:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行 `env-setup` 脚本时，Ansible 会从源代码检出运行，默认清单文件是 `/etc/ansible/hosts`，该文件并未通过代码检出创建；不过，你可以选择性地指定你机器上任意位置的清单文件（详情请见
    *如何构建清单*，[https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.xhtml#inventory-basics-formats-hosts-and-groups](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.xhtml#inventory-basics-formats-hosts-and-groups)）。以下命令提供了如何执行此操作的示例，但显然，你的文件名和内容几乎肯定会有所不同：
- en: '[PRE26]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This demonstrates another powerful way to configure Ansible—environment variables.
    The `ANSIBLE_INVENTORY` variable is used to tell Ansible where to look for its
    inventory file by default—this is normally `/etc/ansible/hosts`, but in the preceding
    example, we are changing this to the `my_ansible_inventory` file in our home directory.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了配置 Ansible 的另一种强大方式——环境变量。`ANSIBLE_INVENTORY` 变量用于告诉 Ansible 默认查找哪个清单文件——通常是
    `/etc/ansible/hosts`，但在前面的示例中，我们将其更改为主目录中的 `my_ansible_inventory` 文件。
- en: Tip
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can learn about the various Ansible configuration variables here: [https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#environment-variables](https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#environment-variables).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解关于各种 Ansible 配置变量的信息：[https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#environment-variables](https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#environment-variables)。
- en: 'Once you have completed these steps, you can run Ansible exactly as we have
    discussed throughout this chapter. The `env-setup` script alters your `PATH` variable
    so that you don’t need to specify the location where you checked out the Ansible
    repository. By way of example, if you set up your inventory using the environment
    variable as demonstrated previously, and have cloned the Ansible source and run
    the `env-setup` script, you could run the ad hoc `ansible.builtin.ping` command
    that we are now familiar with, as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些步骤后，你可以像本章中讨论的那样运行 Ansible。`env-setup` 脚本会修改你的 `PATH` 变量，这样你就不需要指定检出的 Ansible
    仓库的位置。举个例子，如果你按照之前的示范使用环境变量设置了清单，并且克隆了 Ansible 源代码并运行了 `env-setup` 脚本，你可以像我们现在熟悉的那样运行即时命令
    `ansible.builtin.ping`，例如：
- en: '[PRE27]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this in place, you can now work with the development branch of Ansible
    just as you would if you had installed it by any other means.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些设置后，你现在可以像通过其他任何方式安装 Ansible 一样，使用开发分支。
- en: 'Of course, the Ansible source tree is constantly changing, and it is unlikely
    you would just want to stick with the copy you cloned. When the time comes to
    update it, you don’t need to clone a new copy; you can simply update your existing
    working copy using the following commands:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，Ansible 的源代码树是不断变化的，你不太可能只想一直使用你克隆的副本。当需要更新时，你无需克隆一个新的副本；你可以简单地使用以下命令更新你现有的工作副本：
- en: '[PRE28]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This concludes our look at installing Ansible on Linux—now that we’ve done that,
    we’ll look at some of the specifics of installing Ansible on macOS.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在 Linux 上安装 Ansible 的过程，现在我们已经完成了这部分，我们将来看一下在 macOS 上安装 Ansible 的一些具体内容。
- en: Installing Ansible on macOS
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 Ansible
- en: In this section, you will learn how to install Ansible on macOS. The easiest
    installation method is to use Homebrew, but you could also use the Python package
    manager (PIP). The procedure for installation with PIP is the same as for Linux,
    so we won’t go over that again here.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何在 macOS 上安装 Ansible。最简单的安装方法是使用 Homebrew，但你也可以使用 Python 包管理器（PIP）。使用
    PIP 的安装步骤与 Linux 相同，因此我们不会在这里再讲解。
- en: Instead, let’s get started with the Homebrew installation method, which is probably
    your fastest and easiest approach on macOS.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们从 Homebrew 安装方法开始，这是在 macOS 上最快和最简单的方法。
- en: 'If you don’t already have Homebrew installed on macOS, you can easily install
    it, as detailed here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有在 macOS 上安装 Homebrew，可以按照这里的详细说明轻松安装：
- en: 'Normally, the two commands shown here are all that is required to install Homebrew
    on macOS:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，下面显示的两个命令是安装 Homebrew 在 macOS 上所需的全部：
- en: '[PRE29]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you have already installed the Xcode command-line tools for another purpose,
    you might see the following error message:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经为了其他目的安装了 Xcode 命令行工具，可能会看到以下错误信息：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You may want to open the **Software Update** setting from **System Settings**
    on macOS and check whether updates to the Xcode command-line tools are required,
    but as long as they are installed, your Homebrew installation should proceed smoothly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要打开 **软件更新** 设置，进入 **系统设置**，检查是否需要更新 Xcode 命令行工具，但只要它们已安装，你的 Homebrew 安装应该能顺利进行。
- en: 'If you wish to confirm that your installation of Homebrew was successful, you
    can run the following command, which will warn you about any potential issues
    with your install—for example, the following output is warning us that, although
    Homebrew is installed successfully, it is not in our `PATH`, and so we may not
    be able to run any executables without specifying their absolute path:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想确认 Homebrew 安装是否成功，可以运行以下命令，这将警告你安装中可能出现的任何问题——例如，下面的输出警告我们，虽然 Homebrew
    安装成功，但它不在我们的 `PATH` 中，因此我们可能无法在不指定绝对路径的情况下运行任何可执行文件：
- en: '[PRE31]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: $ brew install python3
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ brew install python3
- en: …
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: $ which python3
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ which python3
- en: /opt/homebrew/bin/python3
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /opt/homebrew/bin/python3
- en: $ python3  --version
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ python3  --version
- en: Python 3.11.3
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Python 3.11.3
- en: '[PRE32]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this completed, you can now proceed to install Ansible.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，你现在可以继续安装 Ansible。
- en: 'To install Ansible via Homebrew, run the following command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要通过 Homebrew 安装 Ansible，请运行以下命令：
- en: '[PRE33]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: $ ansible --version
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ ansible --version
- en: ansible [core 2.15.0]
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ansible [core 2.15.0]
- en: config file = None
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 配置文件 = None
- en: configured module search path = ['/Users/james/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 配置的模块搜索路径 = ['/Users/james/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
- en: ansible python module location = /opt/homebrew/Cellar/ansible/8.0.0/libexec/lib/python3.11/site-packages/ansible
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ansible python 模块位置 = /opt/homebrew/Cellar/ansible/8.0.0/libexec/lib/python3.11/site-packages/ansible
- en: ansible collection location = /Users/james/.ansible/collections:/usr/share/ansible/collections
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ansible 集合位置 = /Users/james/.ansible/collections:/usr/share/ansible/collections
- en: executable location = /opt/homebrew/bin/ansible
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可执行文件位置 = /opt/homebrew/bin/ansible
- en: python version = 3.11.3 (main, Apr  7 2023, 20:13:31) [Clang 14.0.0 (clang-1400.0.29.202)]
    (/opt/homebrew/Cellar/ansible/8.0.0/libexec/bin/python3.11)
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: python 版本 = 3.11.3 (main, 2023年4月7日，20:13:31) [Clang 14.0.0 (clang-1400.0.29.202)]
    (/opt/homebrew/Cellar/ansible/8.0.0/libexec/bin/python3.11)
- en: jinja version = 3.1.2
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: jinja 版本 = 3.1.2
- en: 'brew command, as follows:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: brew 命令，如下所示：
- en: '[PRE34]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now that you have learned the steps to install Ansible on macOS, let’s see how
    to configure a Windows host for automation with Ansible.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了如何在 macOS 上安装 Ansible，让我们来看一下如何配置 Windows 主机，以便使用 Ansible 进行自动化。
- en: Configuring Windows hosts for Ansible
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Windows 主机以供 Ansible 使用
- en: As discussed earlier, there is no direct installation method for Ansible on
    Windows—simply, it is recommended that, where available, you install WSL and install
    Ansible as if you were running Linux natively, using the processes outlined earlier
    in this chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Windows 上没有直接的 Ansible 安装方法——建议在有 WSL 的情况下，将其安装并像运行 Linux 一样安装 Ansible，按照本章之前概述的过程进行。
- en: Despite this limitation, however, Ansible is not limited to managing just Linux-
    and BSD-based systems—it is capable of the agentless management of Windows hosts
    using the native WinRM protocol, with modules and raw commands making use of PowerShell,
    which is available in every modern Windows installation. In this section, you
    will learn how to configure Windows to enable task automation with Ansible.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这一限制，Ansible 并不限于管理仅基于 Linux 和 BSD 的系统——它能够使用本地 WinRM 协议对 Windows 主机进行无代理管理，模块和原始命令利用
    PowerShell（在每个现代 Windows 安装中都有）。在本节中，你将学习如何配置 Windows，以启用使用 Ansible 进行任务自动化。
- en: 'Here are some examples of what Ansible is capable of when automating Windows
    hosts:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Ansible 在自动化 Windows 主机时所能做到的一些示例：
- en: Gathering facts about remote hosts
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集远程主机的事实信息
- en: Installing and uninstalling Windows features
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和卸载 Windows 功能
- en: Managing and querying Windows services
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理和查询 Windows 服务
- en: Managing user accounts and a list of users
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户账户和用户列表
- en: Managing packages using Chocolatey (a software repository and accompanying management
    tool for Windows)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Chocolatey 管理软件包（一个 Windows 的软件仓库和管理工具）
- en: Performing Windows updates
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 Windows 更新
- en: Fetching multiple files from a remote machine to the Windows host
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从远程机器将多个文件获取到 Windows 主机
- en: Executing raw PowerShell commands and scripts on target hosts
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目标主机上执行原始 PowerShell 命令和脚本
- en: Ansible allows you to automate tasks on Windows machines by connecting with
    either a local user or a domain user. You can run actions as an administrator
    using the Windows `runas` support, just as with the `sudo` command on Linux distributions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 允许你通过连接本地用户或域用户来自动化 Windows 机器上的任务。你可以像在 Linux 发行版中使用 `sudo` 命令一样，通过
    Windows `runas` 支持以管理员身份运行操作。
- en: Also, as Ansible is **open source software** (**OSS**), it is easy to extend
    its functionality by creating your own modules in PowerShell or even sending raw
    PowerShell commands. For example, an InfoSec team could manage filesystem **access
    control lists** (**ACLs**), configure Windows Firewall, and manage hostnames and
    domain membership with ease, using a mix of native Ansible modules and, where
    necessary, raw commands.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，作为**开源软件**（**OSS**），Ansible 容易通过创建自定义模块或直接发送原始 PowerShell 命令来扩展其功能。例如，信息安全团队可以使用原生的
    Ansible 模块和必要时的原始命令，轻松地管理文件系统**访问控制列表**（**ACLs**）、配置 Windows 防火墙以及管理主机名和域成员身份。
- en: 'The Windows host must meet the following requirements for the Ansible control
    machine to communicate with it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 主机必须满足以下要求，以便 Ansible 控制机与其通信：
- en: Ansible attempts to support all Windows versions that are under either current
    or extended support from Microsoft, including desktop platforms such as Windows
    8.1, 10, and 11, along with server operating systems, including Windows Server
    2012 (and R2), 2016, 2019, and 2022.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 尝试支持微软当前或扩展支持下的所有 Windows 版本，包括 Windows 8.1、10 和 11 等桌面平台，以及 Windows
    Server 2012（及 R2）、2016、2019 和 2022 等服务器操作系统。
- en: You will also need to install PowerShell 3.0 or later and at least .NET 4.0
    on your Windows host.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还需要在 Windows 主机上安装 PowerShell 3.0 或更高版本，并至少安装 .NET 4.0。
- en: You will need to create and activate a WinRM listener, which is described in
    detail later. For security reasons, this is not enabled by default.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要创建并激活 WinRM 监听器，稍后会详细描述。出于安全原因，默认情况下未启用此功能。
- en: 'Let’s look in more detail at how to prepare a Windows host to be automated
    by Ansible:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解如何准备 Windows 主机，以便让 Ansible 自动化：
- en: 'With regard to prerequisites, you have to make sure PowerShell 3.0 and .NET
    Framework 4.0 are installed on Windows machines. On many modern Windows versions,
    you will find these are already in place, but if you’re still using an older version
    of PowerShell or .NET Framework, you will need to upgrade them. You are free to
    perform this manually, or the following PowerShell script can handle it automatically
    for you. You will observe that this script is not from the official Ansible repository—however,
    the owner is a maintainer and reviewer of the official Ansible repository. Nonetheless,
    whenever downloading scripts, it is good practice to review the source code and
    ensure that it is aligned with your security protocols and requirements:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '关于前提条件，您需要确保在 Windows 计算机上安装了 PowerShell 3.0 和 .NET Framework 4.0。在许多现代 Windows
    版本中，您会发现这些已经安装好了，但如果您仍在使用旧版本的 PowerShell 或 .NET Framework，您需要升级它们。您可以手动执行此操作，或者以下
    PowerShell 脚本可以自动为您处理。您会发现该脚本不是来自官方的 Ansible 仓库——但是，脚本作者是官方 Ansible 仓库的维护者和审阅者。尽管如此，每当下载脚本时，最好检查源代码，确保它符合您的安全协议和要求：  '
- en: '[PRE36]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This script works by examining the programs that need to be installed (such
    as .NET Framework 4.5.2) and the required PowerShell version (we have specified
    `5.1` on the last line of the preceding code snippet—valid values for this are
    `3.0`, `4.0`, or `5.1`. We also specify an account with administrator privileges,
    so be sure to set the `$username` and `$password` variables appropriately for
    your system. If a valid username and password are set, and a reboot is required
    after the script finishes, it will automatically restart and log on at reboot
    so that no more action is required, and the script will continue until the PowerShell
    version matches the target version.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '这个脚本通过检查需要安装的程序（如 .NET Framework 4.5.2）和所需的 PowerShell 版本（我们在前面的代码片段最后一行指定了
    `5.1`——有效值为 `3.0`、`4.0` 或 `5.1`）以及一个具有管理员权限的账户来工作，因此务必根据您的系统适当设置 `$username` 和
    `$password` 变量。如果设置了有效的用户名和密码，并且脚本执行完毕后需要重启，脚本将在重启时自动重新启动并登录，以便无需进一步操作，脚本将继续执行，直到
    PowerShell 版本与目标版本匹配。  '
- en: 'It is important to note that if the credentials are set to enable automatic
    reboots, they are also stored in plaintext in the registry, so it’s important
    to check that they have been cleared out after the script run. The following snippet
    of PowerShell will achieve this, and it is recommended you run it after the script
    as a matter of routine to ensure your credentials do not get leaked:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '需要注意的是，如果凭据设置为启用自动重启，它们也会以明文形式存储在注册表中，因此在脚本执行后，必须检查是否已将它们清除。以下的 PowerShell
    代码段将实现这一点，建议在脚本执行后作为常规操作运行，以确保您的凭据不会泄漏：  '
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Force
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 'Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Force  '
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Set-ExecutionPolicy -ExecutionPolicy Restricted -Force
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 'Set-ExecutionPolicy -ExecutionPolicy Restricted -Force  '
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Get-ExecutionPolicy
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'Get-ExecutionPolicy  '
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: $selector_set = @{
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '$selector_set = @{  '
- en: Address = "*"
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Address = "*"
- en: Transport = "HTTPS"
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'Transport = "HTTPS"  '
- en: '}'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}  '
- en: $value_set = @{
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '$value_set = @{  '
- en: CertificateThumbprint = "2c8951160e63b33593e7bbc3a22414a5ab259717"
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'CertificateThumbprint = "2c8951160e63b33593e7bbc3a22414a5ab259717"  '
- en: '}'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}  '
- en: New-WSManInstance -ResourceURI "winrm/config/Listener" -SelectorSet $selector_set
    -ValueSet $value_set
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'New-WSManInstance -ResourceURI "winrm/config/Listener" -SelectorSet $selector_set
    -ValueSet $value_set  '
- en: '[PRE41]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: New-NetFirewallRule -DisplayName 'WinRM over HTTPS' -Profile 'Any' -Direction
    Inbound -Action Allow -Protocol TCP -LocalPort 5986
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'New-NetFirewallRule -DisplayName ''WinRM over HTTPS'' -Profile ''Any'' -Direction
    Inbound -Action Allow -Protocol TCP -LocalPort 5986  '
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Set-Item -Path "WSMan:\localhost\Service\Auth\Basic" -Value $true
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'Set-Item -Path "WSMan:\localhost\Service\Auth\Basic" -Value $true  '
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12  '
- en: $url = "https://raw.githubusercontent.com/jborean93/ansible-windows/master/scripts/Install-WMF3Hotfix.ps1"
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '$url = "https://raw.githubusercontent.com/jborean93/ansible-windows/master/scripts/Install-WMF3Hotfix.ps1"  '
- en: $file = "$env:temp\Install-WMF3Hotfix.ps1"
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '$file = "$env:temp\Install-WMF3Hotfix.ps1"  '
- en: (New-Object -TypeName System.Net.WebClient).DownloadFile($url, $file)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '(New-Object -TypeName System.Net.WebClient).DownloadFile($url, $file)  '
- en: powershell.exe -ExecutionPolicy ByPass -File $file -Verbose
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'powershell.exe -ExecutionPolicy ByPass -File $file -Verbose  '
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: winrm enumerate winrm/config/Listener
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'winrm enumerate winrm/config/Listener  '
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Listener
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listener  '
- en: Address = *
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'Address = *  '
- en: Transport = HTTP
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'Transport = HTTP  '
- en: Port = 5985
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'Port = 5985  '
- en: Hostname
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'Hostname  '
- en: Enabled = true
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'Enabled = true  '
- en: URLPrefix = wsman
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'URLPrefix = wsman  '
- en: CertificateThumbprint
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'CertificateThumbprint  '
- en: ListeningOn = 10.0.50.100, 127.0.0.1, ::1, fe80::460:ba22:fac4:71ff%5
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'ListeningOn = 10.0.50.100, 127.0.0.1, ::1, fe80::460:ba22:fac4:71ff%5  '
- en: Listener
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listener  '
- en: Address = *
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'Address = *  '
- en: Transport = HTTPS
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Transport = HTTPS
- en: Port = 5986
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Port = 5986
- en: Hostname
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 主机名
- en: Enabled = true
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Enabled = true
- en: URLPrefix = wsman
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: URLPrefix = wsman
- en: CertificateThumbprint = 2c8951160e63b33593e7bbc3a22414a5ab259717
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: CertificateThumbprint = 2c8951160e63b33593e7bbc3a22414a5ab259717
- en: ListeningOn = 10.0.50.100, 127.0.0.1, ::1, fe80::460:ba22:fac4:71ff%5
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ListeningOn = 10.0.50.100, 127.0.0.1, ::1, fe80::460:ba22:fac4:71ff%5
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: test out HTTP
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 HTTP
- en: winrs -r:http://<server address>:5985/wsman -u:Username -p:Password ipconfig
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: winrs -r:http://<server address>:5985/wsman -u:Username -p:Password ipconfig
- en: test out HTTPS (will fail if the cert is not verifiable)
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 HTTPS（如果证书无法验证将失败）
- en: winrs -r:https://<server address>:5986/wsman -u:Username -p:Password -ssl ipconfig
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: winrs -r:https://<server address>:5986/wsman -u:Username -p:Password -ssl ipconfig
- en: test out HTTPS, ignoring certificate verification
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 HTTPS，忽略证书验证
- en: $username = "Username"
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: $username = "Username"
- en: $password = ConvertTo-SecureString -String "Password" -AsPlainText -Force
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: $password = ConvertTo-SecureString -String "Password" -AsPlainText -Force
- en: $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList
    $username, $password
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList
    $username, $password
- en: $session_option = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: $session_option = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck
- en: Invoke-Command -ComputerName <server address> -UseSSL -ScriptBlock { ipconfig
    } -Credential $cred -SessionOption $session_option
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Invoke-Command -ComputerName <server address> -UseSSL -ScriptBlock { ipconfig
    } -Credential $cred -SessionOption $session_option
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: $ python3 -m pip install pywinrm
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: $ python3 -m pip install pywinrm
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[windows]'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[windows]'
- en: 10.0.50.101
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 10.0.50.101
- en: '[windows:vars]'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[windows:vars]'
- en: ansible_user=administrator
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ansible_user=administrator
- en: ansible_password=password
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ansible_password=password
- en: ansible_port=5986
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ansible_port=5986
- en: ansible_connection=winrm
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ansible_connection=winrm
- en: ansible_winrm_server_cert_validation=ignore
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ansible_winrm_server_cert_validation=ignore
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: $ ansible -i inventory -m ansible.windows.win_ping windows
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: $ ansible -i inventory -m ansible.windows.win_ping windows
- en: 10.0.50.101 | SUCCESS => {
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 10.0.50.101 | SUCCESS => {
- en: '"changed": false,'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '"changed": false,'
- en: '"ping": "pong"'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '"ping": "pong"'
- en: '}'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[webservers]'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[webservers]'
- en: web01.example.org
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: web01.example.org
- en: web02.example.org
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: web02.example.org
- en: '[apservers]'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[apservers]'
- en: app01.example.org
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: app01.example.org
- en: app02.example.org
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: app02.example.org
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: $ ansible webservers -m anisble.builtin.ping
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: $ ansible webservers -m anisble.builtin.ping
- en: web01.example.org | SUCCESS => {
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: web01.example.org | SUCCESS => {
- en: '"ansible_facts": {'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '"ansible_facts": {'
- en: '"discovered_interpreter_python": "/usr/bin/python3"'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '"discovered_interpreter_python": "/usr/bin/python3"'
- en: '},'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"changed": false,'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '"changed": false,'
- en: '"ping": "pong"'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '"ping": "pong"'
- en: '}'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: web02.example.org | SUCCESS => {
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: web02.example.org | SUCCESS => {
- en: '"ansible_facts": {'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '"ansible_facts": {'
- en: '"discovered_interpreter_python": "/usr/bin/python3"'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '"discovered_interpreter_python": "/usr/bin/python3"'
- en: '},'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"changed": false,'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '"changed": false,'
- en: '"ping": "pong"'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '"ping": "pong"'
- en: '}'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: $ eval $(ssh-agent)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: $ eval $(ssh-agent)
- en: Agent pid 3064
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Agent pid 3064
- en: $ ssh-add ~/.ssh/id_rsa
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: $ ssh-add ~/.ssh/id_rsa
- en: 'Identity added: /home/james/.ssh/id_rsa (james@controlnode)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'Identity added: /home/james/.ssh/id_rsa (james@controlnode)'
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[webservers]'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[webservers]'
- en: web01.example.org
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: web01.example.org
- en: web02.example.org
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: web02.example.org
- en: '[PRE54]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: $ ansible webservers -i /etc/ansible/hosts -m ansible.builtin.ping
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ ansible webservers -i /etc/ansible/hosts -m ansible.builtin.ping
- en: '[PRE55]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: $ ansible webservers -i /etc/ansible/hosts -m ansible.builtin.setup | less
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ ansible webservers -i /etc/ansible/hosts -m ansible.builtin.setup | less
- en: '[PRE56]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: $ ansible webservers -i /etc/ansible/hosts -m ansible.builtin.setup -a "filter=ansible_distribution*"
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ ansible webservers -i /etc/ansible/hosts -m ansible.builtin.setup -a "filter=ansible_distribution*"
- en: '[PRE57]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: $ ansible webservers -m ansible.builtin.ping
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: $ ansible webservers -m ansible.builtin.ping
- en: web02.example.org | SUCCESS => {
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: web02.example.org | SUCCESS => {
- en: '"ansible_facts": {'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '"ansible_facts": {'
- en: '"discovered_interpreter_python": "/usr/bin/python3"'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '"discovered_interpreter_python": "/usr/bin/python3"'
- en: '},'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"changed": false,'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '"changed": false,'
- en: '"ping": "pong"'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '"ping": "pong"'
- en: '}'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: web01.example.org | SUCCESS => {
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: web01.example.org | SUCCESS => {
- en: '"ansible_facts": {'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '"ansible_facts": {'
- en: '"discovered_interpreter_python": "/usr/bin/python3"'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '"discovered_interpreter_python": "/usr/bin/python3"'
- en: '},'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"changed": false,'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '"changed": false,'
- en: '"ping": "pong"'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '"ping": "pong"'
- en: '}'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE58]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: $ ansible -i machost.example.org, -m ansible.builtin.setup -a "filter=ansible_distribution*"
    all
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: $ ansible -i machost.example.org, -m ansible.builtin.setup -a "filter=ansible_distribution*"
    all
- en: machost.example.org | SUCCESS => {
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: machost.example.org | SUCCESS => {
- en: '"ansible_facts": {'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '"ansible_facts": {'
- en: '"ansible_distribution": "MacOSX",'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '"ansible_distribution": "MacOSX",'
- en: '"ansible_distribution_major_version": "13",'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '"ansible_distribution_major_version": "13",'
- en: '"ansible_distribution_release": "22.4.0",'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '"ansible_distribution_release": "22.4.0",'
- en: '"ansible_distribution_version": "13.3.1",'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '"ansible_distribution_version": "13.3.1",'
- en: '"discovered_interpreter_python": "/opt/homebrew/bin/python3.11"'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '"discovered_interpreter_python": "/opt/homebrew/bin/python3.11"'
- en: '},'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"changed": false'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '"changed": false'
- en: '}'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE59]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'webservers inventory group, and create it with specific ownership and permissions,
    as follows:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'webservers inventory group, and create it with specific ownership and permissions,
    as follows:'
- en: '[PRE60]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'apache2 package with apt if it is not already present—if it is present, do
    not update it. Again, this applies to all hosts in the webservers inventory group.
    Note the presence of the --become switch—as we’re installing packages, we must
    *become* the root user using sudo. This command assumes that the user account
    on the managed node can perform passwordless sudo commands:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果apache2软件包尚未安装，则使用apt安装；如果已经安装，则不更新。同样，这适用于webservers库存组中的所有主机。注意--become开关的存在——因为我们要安装软件包，所以必须使用sudo*成为*root用户。此命令假定托管节点上的用户帐户可以执行无需密码的sudo命令：
- en: '[PRE61]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: $ ansible webservers -m ansible.builtin.apt -a "name=apache2 state=latest" --become
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ ansible webservers -m ansible.builtin.apt -a "name=apache2 state=latest" --become
- en: '[PRE62]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: $ ansible all -m ansible.builtin.setup
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ ansible all -m ansible.builtin.setup
- en: '[PRE65]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'dnf package manager instead. Here’s the command you’d execute:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用dnf包管理器代替。这里是你需要执行的命令：
- en: '[PRE66]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: $ sudo dnf install python39
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo dnf install python39
- en: '[PRE68]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: $ sudo apt update
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ sudo apt update
- en: $ sudo apt install python3.10
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ sudo apt install python3.10
- en: '[PRE69]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '- name: Bootstrap a host without python3 installed'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '- name: 在没有安装python3的主机上引导启动'
- en: 'ansible.builtin.raw: dnf install -y python3 python3-dnf libselinux-python3'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 'ansible.builtin.raw: dnf install -y python3 python3-dnf libselinux-python3'
- en: '- name: Run a command that uses non-posix shell-isms (in this example /bin/sh
    doesn''t handle redirection and wildcards together but bash does)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '- name: 运行一个使用非POSIX Shell特性的命令（在这个例子中，/bin/sh无法同时处理重定向和通配符，但bash可以）'
- en: 'ansible.builtin.raw: cat < /tmp/*txt'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 'ansible.builtin.raw: cat < /tmp/*txt'
- en: 'args:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 'args:'
- en: 'executable: /bin/bash'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 'executable: /bin/bash'
- en: '- name: safely use templated variables. Always use quote filter to avoid injection
    issues.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '- name: 安全使用模板化变量。始终使用引用过滤器以避免注入问题。'
- en: 'ansible.builtin.raw: "{{package_mgr|quote}} {{pkg_flags|quote}} install {{python|quote}}"'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'ansible.builtin.raw: "{{package_mgr|quote}} {{pkg_flags|quote}} install {{python|quote}}"'
- en: '[PRE70]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
