- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Common Troubleshooting Tips and Best Practices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见故障排除技巧和最佳实践
- en: So far in the book, we have primarily discussed code samples that have been
    pre-written and shared through the GitHub repository accompanying this book. As
    you progress in your journey with **Infrastructure as Code** (**IaC**), it’s essential
    to understand that writing and planning your IaC projects will involve a learning
    curve and some inevitable debugging.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们主要讨论了已经编写好的代码示例，这些代码示例已通过本书附带的 GitHub 仓库共享。随着您在**基础设施即代码**（**IaC**）的旅程中不断进步，必须理解编写和规划您的
    IaC 项目将涉及学习曲线，并且需要进行一些不可避免的调试。
- en: In this chapter, the second-to-last one, we’ll look at some essential aspects
    to help you better plan, write, and troubleshoot your IaC projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章——倒数第二章中，我们将探讨一些关键方面，帮助您更好地规划、编写和调试您的 IaC 项目。
- en: 'We’ll cover three key areas to ensure you’re well equipped to handle any challenges
    that may arise during the process:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖三个关键领域，以确保您能充分准备好应对过程中的任何挑战：
- en: Infrastructure as Code – best practices and troubleshooting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施即代码 – 最佳实践和故障排除
- en: Terraform – best practices and troubleshooting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform – 最佳实践和故障排除
- en: Ansible – best practices and troubleshooting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible – 最佳实践和故障排除
- en: Throughout this chapter, you’ll notice some common themes and advice that apply
    to both Terraform and Ansible, as they are both IaC tools. However, each tool
    uniquely interacts with your resources, resulting in some differences in the approaches
    and techniques you’ll use when troubleshooting.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中，您会注意到一些适用于 Terraform 和 Ansible 的共同主题和建议，因为它们都是 IaC 工具。然而，每个工具与您的资源的交互方式各不相同，这导致在故障排除时采取的方式和技术有所不同。
- en: By the end of this chapter, you’ll be well prepared to tackle the challenges
    of implementing IaC projects using these powerful tools.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将为使用这些强大工具实施 IaC 项目中的挑战做好充分准备。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的源代码可以在这里获取：
- en: '[https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter08](https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter08)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter08](https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter08)'
- en: Infrastructure as Code – best practices and troubleshooting
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施即代码 – 最佳实践和故障排除
- en: Let us start by discussing some general IaC best practices that can apply to
    various tools and platforms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论一些可以应用于各种工具和平台的一般 IaC 最佳实践。
- en: General IaC best practices
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般的 IaC 最佳实践
- en: 'There are some common threads that we have already touched upon here, but it
    is essential to bring them up again as they are important:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有些常见的主题我们已经提到过，但它们非常重要，值得再次强调：
- en: '**Version control**: Make sure you use a version control system such as Git
    or one of the other available systems such as Mercurial, Subversion, or Azure
    DevOps Server, which was previously known as **Team Foundation Server** (**TFS**),
    to name a few of the more common ones, to store and manage your infrastructure
    code.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：确保使用版本控制系统，如 Git，或其他可用的系统，如 Mercurial、Subversion 或 Azure DevOps Server（以前称为**团队基础服务器**（**TFS**）等较为常见的工具）来存储和管理您的基础设施代码。'
- en: The odds of you, either personally or within the business, already using version
    control for your other projects is extremely high if you are taking steps to both
    define and deploy your infrastructure in and as code. This means that you have
    experience with version control and access to the tools, processes, and procedures
    to maintain code using version control.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在采取步骤来定义并以代码形式部署基础设施，那么您个人或在公司内部已经在其他项目中使用版本控制的可能性极高。这意味着您已经具备版本控制的经验，并且能够访问使用版本控制维护代码所需的工具、流程和程序。
- en: Employing version control enables collaboration, change tracking, and easy rollback
    to previous versions if needed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用版本控制能够促进协作、跟踪变更，并在需要时轻松回滚到之前的版本。
- en: '**Documentation**: You can approach documentation in several ways, and it doesn’t
    matter how you do it, just as long as you do it!'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：您可以通过多种方式来处理文档，重要的是无论采取哪种方式，只要完成文档编写就好！'
- en: My personal approach to documenting my IaC deployments is to try and keep as
    much of the documentation within the code as possible using both in-comments and
    making sure that sections, tasks, functions, or variables are as clearly named
    and descriptive as possible while keeping within any of the constraints of the
    tool I am using.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人的IaC部署文档记录方法是尽量将文档内容保留在代码中，使用注释并确保各个部分、任务、功能或变量的命名尽可能清晰且具有描述性，同时遵守我所使用工具的任何约束。
- en: Also, depending on the complexity, I will summarise what the code does, attach
    it as a `README` file, and commit it to version control.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，根据复杂性，我将总结代码的功能，将其附加为`README`文件，并提交到版本控制系统中。
- en: The reason I do this is that while it is easy to keep track of what is going
    on while you are working on the project, when it comes to someone else picking
    it up – or even you revisiting it yourself after a few months of being away from
    the project – it can sometimes take them a little time to get their bearings.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我这么做的原因是，虽然在项目进行时很容易跟踪正在发生的事情，但当其他人接手项目时——或者即使你自己在离开项目几个月后重新回顾时——有时他们需要一点时间来适应。
- en: Your approach may differ, which leads nicely into the next piece of best practice.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你的做法可能有所不同，这也自然引出了下一个最佳实践。
- en: '**Code reviews**: I recommend conducting regular code reviews to maintain code
    quality, ensure compliance with best practices, and share knowledge among team
    members.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码审查**：我建议定期进行代码审查，以保持代码质量，确保遵守最佳实践，并在团队成员之间共享知识。'
- en: You may already have processes to enforce this across other types of development
    within the business, such as your applications. It is just as crucial that the
    same principles govern your IaC projects as you may be asked to demonstrate that
    your code adheres to any guidelines that your application has to follow for compliance
    reasons. After all, your IaC project will be deploying and maintaining the resources
    your application will run upon.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经有了强制执行这一过程的机制，适用于业务中的其他类型开发，例如你的应用程序。同样，确保相同的原则适用于你的IaC项目也同样重要，因为你可能需要证明你的代码遵循了应用程序必须遵守的任何合规性指南。毕竟，你的IaC项目将会部署并维护你的应用程序运行所需的资源。
- en: '**Modularity**: When you write your infrastructure code, do it in smaller,
    reusable modules. This promotes reusability, maintainability, and better organization
    of your code base. We covered this in [*Chapter 6*](B19537_06.xhtml#_idTextAnchor350),
    *Building upon* *the Foundations*.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：编写基础设施代码时，将其拆分为较小的、可重用的模块。这样有利于代码的重用性、可维护性以及更好的代码组织。我们在[*第6章*](B19537_06.xhtml#_idTextAnchor350)《在基础上构建》中已经讨论过这一点。'
- en: '**Continuous Integration and Continuous Deployment** (**CI/CD**): We discussed
    this at length in the previous chapter, [*Chapter 7*](B19537_07.xhtml#_idTextAnchor431),
    *Leveraging CI/CD in the Cloud*. Even for development purposes, if you have your
    code in source control, you should ideally be leveraging CI/CD.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成与持续部署**（**CI/CD**）：我们在前一章[*第7章*](B19537_07.xhtml#_idTextAnchor431)《在云中利用CI/CD》中详细讨论了这一点。即使是为了开发目的，如果你的代码在源代码管理中，理想情况下你也应该利用CI/CD。'
- en: '**Testing**: In the perfect world, you should implement automated testing for
    your infrastructure code to validate its correctness, identify issues early, and
    increase its overall reliability. If you are using version control and CI/CD,
    you already have most of the tools to make this process easy. For example, in
    [*Chapter 7*](B19537_07.xhtml#_idTextAnchor431), *Leveraging CI/CD in the Cloud*,
    we had some break-points when running Terraform plan to catch potential issues.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：在理想的世界里，你应该为你的基础设施代码实现自动化测试，以验证其正确性、及早发现问题并提高整体可靠性。如果你正在使用版本控制和CI/CD，你已经拥有了大部分工具，使这一过程变得简单。例如，在[*第7章*](B19537_07.xhtml#_idTextAnchor431)《在云中利用CI/CD》中，我们在运行Terraform计划时遇到了一些断点，以便捕捉潜在问题。'
- en: '**Monitoring and logging**: Implement monitoring and logging solutions to track
    executions and detect issues allowing you to troubleshoot problems promptly. In
    [*Chapter 7*](B19537_07.xhtml#_idTextAnchor431), *Leveraging CI/CD in the Cloud*,
    our CI/CD pipelines kept a log of everything that happened during the execution.
    In Terraform’s case, we generated and attached a snapshot of the plan file – this
    level of information can be very valuable when trying to figure out what would
    happen if something unexpected happened.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控与日志记录**：实施监控和日志记录解决方案，以跟踪执行情况并检测问题，从而使你能够及时排除故障。在[*第7章*](B19537_07.xhtml#_idTextAnchor431)《*在云中利用CI/CD*》中，我们的CI/CD管道记录了执行过程中发生的所有事件。在Terraform的案例中，我们生成并附加了计划文件的快照——这种信息层级在试图理解意外情况时非常有价值。'
- en: '**The principle of least privilege**: Limit access to resources and creation
    by granting the minimum necessary permissions for your infrastructure code executions
    to interact with the components they are working with.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小权限原则**：通过为你的基础设施代码执行操作时，只授予与它们所需组件交互所必需的最小权限，来限制对资源和创建的访问。'
- en: Depending on your target infrastructure, this may only sometimes be possible,
    but most cloud providers allow you to be very granular with the permissions. Also,
    depending on what you are deploying, this could take a little trial and error
    – but in the long run, it is worth investing the time in looking at it from a
    security point of view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的目标基础设施，这种方法并非总是可行，但大多数云服务提供商允许你在权限方面做到非常精细。另外，具体的部署操作可能需要一些反复试验，但从长远来看，值得投入时间从安全角度去审视。
- en: '**Immutable infrastructure**: Rather than updating existing infrastructure,
    create new infrastructure to replace the old one and reroute requests to it. This
    reduces the risk of errors due to configuration drift and forces deployments to
    be more predictable.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变基础设施**：与其更新现有基础设施，不如创建新的基础设施来替代旧的，并将请求路由到新基础设施。这可以减少由于配置漂移而引发的错误风险，并强制执行更可预测的部署。'
- en: This approach depends on your application, and it may only sometimes be practical
    for you to fully implement this approach. Still, the more your infrastructure
    components you can make immutable, the easier it will be for you to scale out
    and back down.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法取决于你的应用程序，可能并不总是实际可行的，但你能够使更多的基础设施组件不可变时，扩展和收缩将变得更加容易。
- en: '**Secure by Design (SBD)**: As you write your infrastructure code, incorporate
    security best practices and tools from the beginning, such as encryption, identity
    management, and network segmentation if possible, and as already mentioned, focus
    on making these parts of your code as modular as possible so that you can easily
    reuse them across your projects.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从设计开始即保障安全（SBD）**：在编写基础设施代码时，从一开始就将安全最佳实践和工具结合其中，例如加密、身份管理和网络分段等（如果可能的话），并且如前所述，尽量使代码的这些部分模块化，以便在多个项目中轻松复用。'
- en: Now that we have established some general best practices, let us move on and
    discuss some general troubleshooting tips.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经建立了一些通用的最佳实践，让我们继续讨论一些常见的故障排除技巧。
- en: General IaC troubleshooting tips
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般的IaC故障排除技巧
- en: 'The following are some general troubleshooting tips, tricks, and approaches.
    As we are talking about general IaC tips, many of them are more preventive than
    tasks you would do to debug an issue:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些通用的故障排除技巧、窍门和方法。因为我们谈论的是通用的IaC技巧，许多技巧更多的是预防性措施，而不是用来调试问题的步骤：
- en: '**Avoid hardcoding sensitive information**: Use secret management tools such
    as Azure Key Vault, HashiCorp Vault, or AWS Secrets Manager to securely store
    and retrieve sensitive information at runtime or use your infrastructure code
    to configure your resources to use the secret management tools directly.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免硬编码敏感信息**：使用如 Azure Key Vault、HashiCorp Vault 或 AWS Secrets Manager 等秘密管理工具，在运行时安全地存储和检索敏感信息，或者使用你的基础设施代码配置资源，直接利用秘密管理工具。'
- en: While it goes without saying that you shouldn’t hardcode sensitive information
    such as passwords, private information, or secrets directly within your code (Ansible
    could be an exception, but more on that in the *Ansible – best practices and troubleshooting*
    section), there are advantages to using secret management tools – the biggest
    one is for things such as certificate management.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不言而喻，你不应将敏感信息如密码、私人信息或密钥直接硬编码到代码中（Ansible 可能是个例外，但关于这一点会在 *Ansible – 最佳实践与故障排除*
    部分中提及），使用秘密管理工具有其优势——其中最大的一点是用于证书管理等任务。
- en: Imagine it’s a day or two before your SSL certificate expires, and you are rushing
    to get all resources that reference it updated. Using your target platform’s secret
    store may mean that you only have to update the certificate; then all resources
    that use the certificate are automatically updated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的 SSL 证书即将到期，距离到期还有一两天，你正在赶紧更新所有引用它的资源。如果你使用目标平台的密钥存储，可能只需要更新证书，然后所有使用该证书的资源会自动更新。
- en: '**Keep dependencies up-to-date**: Throughout [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*, and [*Chapter 5*](B19537_05.xhtml#_idTextAnchor268),
    *Deploying to Amazon Web Services*, you will have noticed that our infrastructure
    code utilized a lot of different tasks and modules.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持依赖项更新**：在[*第 4 章*](B19537_04.xhtml#_idTextAnchor151)《部署到 Microsoft Azure》和[*第
    5 章*](B19537_05.xhtml#_idTextAnchor268)《部署到 Amazon Web Services》中，你会注意到我们的基础设施代码使用了许多不同的任务和模块。'
- en: Regularly updating your dependencies will help you avoid security vulnerabilities
    and compatibility issues. As your target cloud APIs are updated, you may find
    that your code has issues or no longer works.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 定期更新依赖项有助于避免安全漏洞和兼容性问题。随着目标云 API 的更新，你可能会发现你的代码出现问题或不再工作。
- en: '**Don’t overcomplicate your infrastructure code**: Keep your infrastructure
    code as simple as possible and avoid unnecessary complexity that may be difficult
    to maintain and troubleshoot should there be issues.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要过度复杂化你的基础设施代码**：保持基础设施代码尽可能简单，避免引入不必要的复杂性，这些复杂性可能会在出现问题时难以维护和排查。'
- en: It may look “cool” to build lots of logic or loops into your IaC. Still, it
    only takes a slight change as part of a tool or dependency update for it to come
    tumbling down – the more effort and time needed to code something, the more effort
    you are likely to put into debugging and refactoring it if and when there are
    problems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的基础设施代码里充满大量逻辑或循环看起来可能很“酷”，但只需要工具或依赖项的一个小变动，它就会崩溃——编写的代码越复杂，遇到问题时，你所需要花费的调试和重构的时间和精力就越多。
- en: Trust me, from experience, your future self will thank you for this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 相信我，凭经验，你未来的自己会感谢你这样做的。
- en: '**Maintain a clean, well-organized code base**: Consistently use naming conventions,
    follow a directory structure, and remove obsolete code.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持代码库的整洁和良好的组织结构**：始终使用命名约定，遵循目录结构，并删除过时的代码。'
- en: Anyone within your team needs to be able to pick up your code and know what
    is going on without having seen it; you will not always be the only one who looks
    into any problems with your code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 团队中的任何人都应该能够接手你的代码，并了解发生了什么，即使他们之前没有看到过它；你不可能永远是唯一一个处理代码问题的人。
- en: You want to avoid creating more work for whoever picks it up, as they will likely
    already be under pressure because someone has reported a problem.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你要避免为接手你工作的人增加更多负担，因为他们可能已经因为有人报告了问题而承受压力。
- en: '**Don’t ignore error or warning messages**: Address any messages, especially
    non-breaking warning messages in your infrastructure code, promptly to prevent
    future issues.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要忽视错误或警告信息**：及时处理任何信息，尤其是基础设施代码中的非致命警告信息，以防止未来出现问题。'
- en: Most tools will stop execution when there are errors. However, most will also
    print warnings – these could be just be small things such as letting you know
    that functionality you are using will be deprecated or changed in future releases,
    and warnings will not stop execution. Still, they need to be addressed just like
    any errors you receive; it isn’t every day you get the chance to avoid future
    errors, so take it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数工具在出现错误时会停止执行。然而，大多数工具也会打印警告——这些可能只是一些小问题，例如提醒你正在使用的功能将在未来的版本中弃用或发生变化，而警告不会停止执行。但这些警告仍然需要解决，就像你收到的任何错误一样；并不是每天都有机会避免未来的错误，所以抓住这个机会。
- en: Finally, and this goes without saying, **communicate with your team**. Regularly
    communicate with your team about infrastructure changes, potential issues, and
    best practices to ensure everyone is on the same page when it comes to your IaC.
    You do not want to be a single point of failure, nor do you want to set your team
    up for failure should there be any problems.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不言而喻，**与团队沟通**。定期与团队沟通基础设施的变化、潜在问题和最佳实践，确保每个人在处理 IaC 时都在同一页面上。你不想成为单点故障，也不希望在出现问题时让团队陷入困境。
- en: Now that we have worked through the general best practices and troubleshooting
    tips, let us look at some of the things you should consider when using the two
    tools we have discussed in the book, starting with Terraform.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了通用的最佳实践和故障排除技巧，让我们来看看在使用本书中讨论的两种工具时，你需要考虑的一些事项，从Terraform开始。
- en: Terraform – best practices and troubleshooting
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform – 最佳实践和故障排除
- en: We will cover some of the recommendations we have already touched upon in the
    *General IaC best practices* section. Still, as mentioned at the start of the
    chapter, we will go into more detail about how they apply to just Terraform.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将覆盖在*通用IaC最佳实践*部分中已经提到的一些建议。但正如本章开头所述，我们将更详细地探讨这些建议如何应用于Terraform。
- en: Terraform – best practices
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform – 最佳实践
- en: 'Here are some best practices for approaching your Terraform deployment:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理Terraform部署时的一些最佳实践：
- en: '**Use a modular approach**: Break down infrastructure into reusable modules,
    simplifying code maintenance and enabling reusability across different environments.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采用模块化方法**：将基础设施拆分为可重用的模块，从而简化代码维护并支持在不同环境中的重用。'
- en: 'As we discussed in [*Chapter 6*](B19537_06.xhtml#_idTextAnchor350), *Building
    upon the Foundations*, Terraform modules can be hosted in the Terraform Registry
    or, which I have not mentioned, privately in your own Git repository. The following
    example code downloads the module from GitHub using **Secure Shell** (**SSH**):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第6章*](B19537_06.xhtml#_idTextAnchor350)中讨论的，*在基础上构建*，Terraform模块可以托管在Terraform注册表中，或者（我没有提到过）私下托管在你自己的Git仓库中。以下示例代码通过**安全外壳**
    (**SSH**)从GitHub下载模块：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assuming you are executing your Terraform code from somewhere that has access
    to the repository, it will download and use it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在从可以访问仓库的地方执行Terraform代码，它将下载并使用该代码。
- en: This allows you to build a library of reusable modules for use across all of
    your projects, and it also allows you to share modules with the rest of your teams.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得你可以构建一个可重用模块的库，供所有项目使用，同时也可以与其他团队共享这些模块。
- en: '**Keep a consistent naming convention**: Using a consistent naming convention
    for resources and modules improves readability and maintainability.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持一致的命名约定**：为资源和模块使用一致的命名约定可以提高可读性和可维护性。'
- en: Depending on the size of the team working on your infrastructure code, you should
    establish a style guide and guidelines for developing and maintaining your Terraform
    infrastructure code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据团队规模，你应该为开发和维护Terraform基础设施代码制定样式指南和准则。
- en: '**Manage state files securely**: We have already discussed storing your state
    files remotely in a backend such as an Azure storage account or AWS **Simple Storage
    Service** (**S3**) in [*Chapter 7*](B19537_07.xhtml#_idTextAnchor431), *Leveraging
    CI/CD in* *the Cloud*.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全管理状态文件**：我们已经讨论了将状态文件远程存储在后端，如Azure存储账户或AWS **简单存储服务** (**S3**)中，在[*第7章*](B19537_07.xhtml#_idTextAnchor431)中，*利用CI/CD在*
    *云中的实践*。'
- en: Most of the supported backend services allow you to enable versioning and force
    encryption to ensure data integrity and security – make sure that this is enabled.
    Most services do it by default, but it is best to double-check.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数支持的后端服务允许你启用版本控制和强制加密，以确保数据的完整性和安全性——确保启用了这些功能。大多数服务默认启用，但最好再次确认。
- en: 'Also, there is another service that should have been mentioned: Terraform Cloud.
    HashiCorp (the makers of Terraform), has a cloud service that can store your state
    files securely and also act as a remote execution environment for your Terraform
    run. There are both free and paid options, and if you can use them, I recommend
    taking a look.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，还有一个应该提到的服务：Terraform Cloud。Terraform的开发者HashiCorp提供了一项云服务，可以安全地存储你的状态文件，并且作为Terraform运行的远程执行环境。该服务提供免费和付费选项，如果可以使用，我建议你了解一下。
- en: '`terraform plan` command to visualize the potential impact of the code run.
    Use code reviews and automated testing to validate changes and minimize the risk
    of errors or something unexpected.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`terraform plan`命令来可视化代码运行的潜在影响。使用代码审查和自动化测试来验证更改，最小化错误或意外情况的风险。
- en: '**Use provider and resource version pinning**: While Terraform development
    rates differ from provider to provider, you may find that breaking changes are
    introduced.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用提供者和资源版本固定**：尽管Terraform的开发速度因提供者而异，但你可能会发现会引入破坏性更改。'
- en: You should lock the versions of providers within your infrastructure code and
    define an explicit version number when registering the providers used to ensure
    a consistent and stable infrastructure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在基础设施代码中锁定提供程序的版本，并在注册所用的提供程序时定义明确的版本号，以确保基础设施的一致性和稳定性。
- en: '`lookup`, `count`, and `for_each` to reduce complexity and improve flexibility.
    There are also functions, as we discussed in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*, and [*Chapter 5*](B19537_05.xhtml#_idTextAnchor268),
    *Deploying to Amazon Web Services*, where you work out **Classless Inter-Domain
    Routing** (**CIDR**) ranges and perform transformations on input and output variables
    – all of which can help reduce the number of variables you have to define.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lookup`、`count` 和 `for_each` 用来减少复杂性并提高灵活性。我们在[*第4章*](B19537_04.xhtml#_idTextAnchor151)《部署到微软Azure》和[*第5章*](B19537_05.xhtml#_idTextAnchor268)《部署到亚马逊Web服务》中也讨论过一些函数，您将计算**无类域间路由**（**CIDR**）范围，并对输入和输出变量进行转换—这一切都有助于减少您需要定义的变量数量。'
- en: Terraform – troubleshooting
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform – 故障排除
- en: 'Here are some of the best practices for approaching your Terraform deployment:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些最佳实践，用于部署您的 Terraform：
- en: '**Avoid hardcoding sensitive information**: As you may have already guessed,
    this is a common but significant recurring theme; *please do not do it!* Instead,
    with Terraform, you can use environment variables or secret management tools to
    avoid exposing sensitive data in your code.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免硬编码敏感信息**：正如您可能已经猜到的，这是一个常见但重要的反复主题；*请不要这样做！* 相反，使用 Terraform，您可以使用环境变量或密钥管理工具，避免在代码中暴露敏感数据。'
- en: '`depends_on` parameter when necessary to avoid issues related to resource ordering.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必要时使用 `depends_on` 参数，以避免资源顺序相关的问题。
- en: We discussed this in [*Chapter 2*](B19537_02.xhtml#_idTextAnchor085), *Ansible
    and Terraform beyond the Documentation*, in the *Fixing the error* section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第2章*](B19537_02.xhtml#_idTextAnchor085)《Ansible 和 Terraform 超越文档》中，在《修复错误》部分讨论过这个问题。
- en: '`prevent_destroy` and ensure proper access controls.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `prevent_destroy` 并确保正确的访问控制。
- en: 'The following is an example of how you would use `prevent_destroy` to protect
    against the accidental deletion of an Azure storage account:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用 `prevent_destroy` 来防止意外删除 Azure 存储账户的示例：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You would receive an error if you attempted to run `terraform` `destroy` against
    the resource, which is much better than unexpectedly deleting the resource.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试对资源运行 `terraform` `destroy`，系统会报错，这比意外删除资源要好得多。
- en: Please note that this is not a resource lock at the cloud-provider level; you
    are just instructing Terraform that it can’t destroy the resource on execution.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这并不是云提供商级别的资源锁定；您只是指示 Terraform 在执行时不能销毁该资源。
- en: '**Monitor resource limits**: Be aware of provider-specific limits and quotas,
    which could lead to resource provisioning failures if they are hit.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控资源限制**：了解提供商特定的限制和配额，如果达到这些限制，可能会导致资源配置失败。'
- en: Errors while provisioning resources due to limits or quotas could result in
    a corrupted state file, which may not be easily recoverable depending on the resource
    you are targeting.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因为限额或配额问题在资源配置时出现的错误，可能导致状态文件损坏，这取决于您要操作的资源，恢复起来可能并不容易。
- en: '`terraform refresh` and `terraform plan`. You could do this using CI/CD and
    have it alert depending on the output.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terraform refresh` 和 `terraform plan`。您可以通过 CI/CD 完成这项工作，并根据输出进行报警。'
- en: '**Watch for state file conflicts**: If multiple team members work on the same
    infrastructure, use remote state backends with locking mechanisms to prevent conflicting
    changes. Most backends support this by default, but to avoid state file corruption
    for production resources, I recommend triple-checking.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意状态文件冲突**：如果多个团队成员在同一基础设施上工作，使用具有锁定机制的远程状态后端来防止冲突更改。大多数后端默认支持此功能，但为了避免生产资源的状态文件损坏，我建议您进行三重检查。'
- en: '**If possible, avoid using multiple provisioning tools**: Mixing Terraform
    with other provisioning tools (for example, CloudFormation or **Azure Resource
    Manager** (**ARM**) templates) can cause conflicts and unexpected behavior on
    subsequent executions. Stick to one provisioning tool for consistency and predictability,
    and if possible, attempt to find a workaround for your reason to deploy using
    the multiple tools in this place. This is a slightly different use case than what
    we discussed in [*Chapter 6*](B19537_06.xhtml#_idTextAnchor350), *Building upon
    the Foundations*, where we used Ansible to trigger Terraform; this is using Terraform
    to run other IaC tools – which some providers support.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果可能，避免使用多个配置工具**：将Terraform与其他配置工具（例如CloudFormation或**Azure资源管理器**（**ARM**）模板）混合使用，可能会导致冲突并在后续执行时出现意外行为。为了保持一致性和可预测性，最好坚持使用一个配置工具，并且如果可能，尝试为你需要使用多个工具进行部署的原因找到一种变通方法。这与我们在[*第六章*](B19537_06.xhtml#_idTextAnchor350)《在基础之上构建》中讨论的情况略有不同，在那一章中我们使用Ansible来触发Terraform；而这里是使用Terraform来运行其他基础设施即代码工具——这是一些提供商所支持的。'
- en: As this functionality is built into each provider, and each provider is a separate
    project away from the core Terraform development, you may see that functionality
    between different providers is very different.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该功能内置于每个提供商中，并且每个提供商都是与核心Terraform开发分离的独立项目，因此你可能会发现不同提供商之间的功能差异非常大。
- en: If you have to take this route, please consult your provider’s documentation
    and, where necessary, examine the issues logged in its GitHub repo to see whether
    any problems have been reported with the functionality.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不得不走这条路，请查阅你所使用提供商的文档，并在必要时检查其GitHub仓库中记录的问题，看看是否有功能相关的问题被报告。
- en: As you have seen in this section, much of the advice is similar to the general
    advice we covered at the start of the chapter. Let us see if this trend continues
    for Ansible.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节中看到的，大部分建议与我们在本章开头讨论的通用建议相似。让我们看看这种趋势是否会在Ansible中继续存在。
- en: Ansible – best practices and troubleshooting
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible – 最佳实践与故障排除
- en: 'At this point in the chapter, you know the drill by now: we are going start
    by discussing best practices, but this time putting an Ansible spin on them.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，你已经知道了流程：我们将从讨论最佳实践开始，但这次我们将加入Ansible的元素。
- en: Ansible – best practices
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible – 最佳实践
- en: 'Here are some of the best practices for approaching your Ansible playbooks:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理你的Ansible Playbooks时的一些最佳实践：
- en: '**Organize your playbooks with roles**: Use roles to group related tasks, variables,
    files, and templates, making your playbooks easier to understand and maintain.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用角色组织Playbook**：使用角色将相关任务、变量、文件和模板进行分组，使你的Playbook更易于理解和维护。'
- en: For more information on this, see [*Chapter 6*](B19537_06.xhtml#_idTextAnchor350),
    *Building upon the Foundations*, where we discussed roles and Ansible Galaxy in
    more detail – this also leads into our next bit of advice.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参见[*第六章*](B19537_06.xhtml#_idTextAnchor350)《在基础之上构建》，我们在那一章中更详细地讨论了角色和Ansible
    Galaxy——这也引出了我们接下来的建议。
- en: '**Keep playbooks modular and reusable**: Write modular playbooks and tasks
    that can be reused in different scenarios to minimize duplication and improve
    maintainability.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持Playbook模块化和可重用**：编写模块化的Playbook和任务，可以在不同的场景中重用，以最小化重复工作并提高可维护性。'
- en: This is where we start to differ slightly from Terraform, as Ansible can also
    be used to access both Linux or Windows hosts and execute commands on them, so
    reusable code for everyday tasks such as installing Apache, enabling **Internet
    Information Services** (**IIS**), or even just patching the operating systems
    you are targetting will be useful.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们与Terraform有所不同，因为Ansible也可以用于访问Linux或Windows主机并在其上执行命令，因此，用于日常任务（如安装Apache、启用**Internet信息服务**（**IIS**）或仅仅是修补你目标操作系统的代码）的可重用代码将非常有用。
- en: '**Use version control**: Keep your Ansible playbook and configurations in a
    version control system such as Git to track changes and encourage/enable collaboration
    amongst your team members.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用版本控制**：将你的Ansible Playbook和配置保存在版本控制系统中（如Git），以便跟踪更改并促进/支持团队成员之间的协作。'
- en: '**Employ a consistent naming convention**: Adopt a clear and consistent naming
    convention for tasks, files, templates, and especially variables to make it easier
    for other team members to pick up and follow your playbook quickly.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采用一致的命名规范**：为任务、文件、模板，特别是变量，采用清晰一致的命名规范，使其他团队成员更容易理解和跟进你的Playbook。'
- en: '**Use a dynamic inventory**: This is not something we have touched upon so
    far, but when Ansible targets a host’s operating system, it uses an inventory
    file, which is a list of hosts to interact with.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用动态库存**：这是我们到目前为止还没有涉及的内容，但当 Ansible 目标指向主机的操作系统时，它会使用库存文件，这是一个列出要交互的主机的清单。'
- en: Instead of hardcoding host details in an inventory file, you can use a dynamic
    inventory script to discover and manage resources in your environment automatically.
    There are scripts for most providers that typically work on tags to discover what
    to target.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要在库存文件中硬编码主机详情，你可以使用动态库存脚本自动发现并管理环境中的资源。大多数提供商都有脚本，通常是通过标签来发现需要定位的资源。
- en: Let’s imagine your Ansible playbook launches half a dozen virtual machines in
    your chosen cloud. If you were to tag them with `Role:Web`, then you could use
    a dynamic inventory script to search the cloud provider for all virtual machines
    tagged with `Role` of `Web` and build up a list of IP addresses to run your playbook
    against.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的 Ansible playbook 在你选择的云平台上启动了半打虚拟机。如果你将它们标记为 `Role:Web`，那么你可以使用动态库存脚本在云提供商中搜索所有标记为
    `Role` 为 `Web` 的虚拟机，并建立一个包含 IP 地址的清单，以便运行 playbook。
- en: '**Implement idempotence**: Ensure your tasks are idempotent, which means they
    can be executed multiple times without producing unexpected results or side effects.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现幂等性**：确保你的任务是幂等的，这意味着它们可以多次执行而不会产生意外结果或副作用。'
- en: If your Ansible playbook deals exclusively with just infrastructure code, then
    this should be straightforward, as much of this logic is handled by the APIs with
    which the modules will interact.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Ansible playbook 仅处理基础设施代码，那么这应该是直接的，因为大部分逻辑是由 API 处理的，模块将与这些 API 交互。
- en: However, if you are targeting operating systems, this becomes important, as
    you want to avoid anything unexpected happening across potentially several hosts.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你要操作操作系统，这一点变得重要，因为你需要避免在多个主机之间发生任何意外情况。
- en: '**Secure sensitive data with Ansible Vault**: I have left this one until the
    end. Ansible has a built-in secrets management system called Ansible Vault, which
    allows you to encrypt sensitive data, such as passwords and API keys, to protect
    them from unauthorized access.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Ansible Vault 保护敏感数据**：我将这一点留到最后。Ansible 具有内建的秘密管理系统，叫做 Ansible Vault，它允许你加密敏感数据，如密码和
    API 密钥，以保护它们免受未经授权的访问。'
- en: As well as commands such as `ansible-playbook` and `ansible-galaxy`, Ansible
    also ships with `ansible-vault`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像 `ansible-playbook` 和 `ansible-galaxy` 这样的命令外，Ansible 还附带了 `ansible-vault`。
- en: 'This command can encrypt and decrypt both entire files and simple strings.
    In the following example, we will look at encrypting a string:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令可以加密和解密整个文件以及简单的字符串。在以下示例中，我们将演示如何加密一个字符串：
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running the command will prompt for a new password and confirmation of the
    password. Once entered, it will encrypt the specified text, which is super-secret
    `HelloWorld`, and give you something that looks like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令时会提示输入新密码并确认密码。输入后，它将加密指定的文本，这里是超级机密的 `HelloWorld`，并给出如下内容：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that you have the encrypted string, you can use it in your playbook file
    as in the following example (pease note that the spacing has been removed to make
    it easier to read):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了加密的字符串，你可以在 playbook 文件中使用它，如以下示例所示（请注意，空格已被移除，以便更易阅读）：
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is a copy of the preceding code in the GitHub repository that accompanies
    this title. To run the playbook, we need to tweak our `ansible-playbook` command
    slightly:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该标题的 GitHub 仓库中有一份前面代码的副本。要运行 playbook，我们需要稍微调整一下 `ansible-playbook` 命令：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Assuming you enter the correct password for the vault, this should give you
    something like the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你输入了正确的 Vault 密码，应该会得到如下输出：
- en: '![Figure 8.1 – Running the playbook and viewing the secret](img/Figure_8.01_B19537.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 运行 playbook 并查看秘密](img/Figure_8.01_B19537.jpg)'
- en: Figure 8.1 – Running the playbook and viewing the secret
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 运行 playbook 并查看秘密
- en: If you promise not to tell anyone, the password for the playbook is `password`,
    so you can run the playbook in the repo yourself.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你承诺不告诉任何人，那么 playbook 的密码是 `password`，因此你可以自行运行仓库中的 playbook。
- en: Ansible Vault can also encrypt entire files, meaning you can include files such
    as a private key for `base64` to encode a binary file as text and then use a vault
    to encrypt the encoded context, as Ansible has built-in functions for decoding
    `base64`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Vault还可以加密整个文件，这意味着你可以包含如私钥这样的文件，使用`base64`对二进制文件进行编码为文本，然后使用Vault加密编码后的内容，因为Ansible有内置函数用于解码`base64`。
- en: So how is this any better than using a secret management tool? Well, it could
    be less complicated – you could use your secret management tool to store the password
    for Ansible Vault and then embed the rest of your secrets in your repo.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这比使用秘密管理工具好在哪里呢？好吧，它可能更简单——你可以使用秘密管理工具存储Ansible Vault的密码，然后将其他的秘密嵌入到你的代码库中。
- en: Now that we have covered some best practices, let’s talk about troubleshooting.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了一些最佳实践，让我们谈谈故障排除。
- en: Ansible – troubleshooting
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible – 故障排除
- en: 'What follows are some troubleshooting tips for Ansible, and a lot of the general
    ones also apply:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些Ansible的故障排除提示，很多通用的故障排除技巧也适用：
- en: '`debug` module to display variables, messages, or task output, helping you
    identify issues in your code.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`debug`模块显示变量、消息或任务输出，帮助你识别代码中的问题。
- en: 'This is extremely helpful when trying to find out the contents of a variable
    or the output of a task; the following example playbook uses the `debug` module
    to output the contents of the `ansible_facts` variable:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这在你尝试找出变量的内容或任务的输出时非常有用；以下示例剧本使用`debug`模块输出`ansible_facts`变量的内容：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running the playbook using `ansible-playbook site.yml` should show you information
    about your host.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ansible-playbook site.yml`运行剧本时，应该会显示关于主机的信息。
- en: '`ansible-playbook`; you can add the `-v`, `-vv`, or `-vvv` options to increase
    the verbosity of the output, providing more insight into what’s happening during
    execution.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-playbook`；你可以添加`-v`、`-vv`或`-vvv`选项，以增加输出的详细程度，提供更多关于执行过程中的信息。'
- en: '**Check your YAML syntax**: I have lost countless hours looking at a problem
    only to find I haven’t formatted the YAML in my playbook correctly. Save yourself
    some time and validate your YAML files with a linter or online validator to catch
    any formatting or syntax errors.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查你的YAML语法**：我曾浪费无数小时在问题上，结果发现只是因为我在剧本中的YAML格式不正确。节省时间，使用代码检查器或在线验证器验证你的YAML文件，以捕获任何格式或语法错误。'
- en: '**Review the failed and skipped task summaries**: Examine the *failed* and
    *skipped* task summaries at the end of a playbook run to identify tasks that did
    not execute as expected; Ansible may not completely stop execution on a failed
    task, so ensure that you pay attention to your playbook runs as you may have problems
    and not immediately realize it.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看失败和跳过的任务总结**：检查剧本执行结束时的*失败*和*跳过*任务总结，识别未按预期执行的任务；Ansible在任务失败时可能不会完全停止执行，因此请注意你的剧本运行，因为你可能会遇到问题却没有立刻察觉。'
- en: '**Verify file and directory permissions**: Ensure that the appropriate file
    and directory permissions are set for your Ansible files and target hosts, allowing
    the required access for execution.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证文件和目录权限**：确保为你的Ansible文件和目标主机设置了适当的文件和目录权限，以便执行时具有所需的访问权限。'
- en: For example, if you are using SSH to access a host after it has been launched,
    ensure that the permissions on your local machine for things such as your SSH
    key are correct, or your Ansible playbook run may fail.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在主机启动后使用SSH访问它，请确保本地机器上的SSH密钥等权限正确，否则你的Ansible剧本执行可能会失败。
- en: As you can see, with the addition of managing workloads within the target hosts
    rather than just the infrastructure, there are a few more considerations with
    Ansible than with a tool such as Terraform.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，随着在目标主机内管理工作负载的增加，而不仅仅是管理基础设施，相比像Terraform这样的工具，Ansible需要更多的考虑因素。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have discussed a lot in this chapter; we have talked about several similar
    concepts but have taken slightly different approaches depending on the tool we
    chose.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一章讨论了很多内容；我们讨论了几个相似的概念，但根据我们选择的工具，采取了稍微不同的方法。
- en: 'For me, the biggest takeaways from this chapter are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，本章的最大收获如下：
- en: '**Version control**: Use version control to track changes and collaborate with
    your team and colleagues easily.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：使用版本控制跟踪更改，并轻松与团队和同事进行协作。'
- en: '**Documentation and consistency**: Ensure that your infrastructure code is
    well documented and has been written in line with your style guides or other IaC
    projects – no one wants to pick up messy or undocumented code during a crisis.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档和一致性**：确保您的基础设施代码有良好的文档，并且符合您的样式指南或其他 IaC 项目——在危机期间没有人愿意接手混乱或未经记录的代码。'
- en: '**Keep an eye on the content**: Ensure you do not expose passwords, keys, or
    other sensitive content by checking it into your version control system. A lot
    of the IaC we have spoken about is designed to be human-readable, and that is
    the last thing you want for sensitive information.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注内容**：确保不要通过将其检入您的版本控制系统来暴露密码、密钥或其他敏感内容。我们讨论的大部分 IaC 设计为人类可读，而这是您对敏感信息不希望发生的最后一件事情。'
- en: '**Please keep it simple**: Believe me, it is very easy to go down a rabbit
    hole and create some very complex, and some would say overkill, IaC projects.
    From experience, these types of projects always end up causing more problems than
    they solve. They are challenging to maintain and for other team members to pick
    up and work with if they end up inheriting them – keep things simple and follow
    the previously listed takeaways.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请保持简单**：相信我，走进兔子洞并创建一些非常复杂的、有些人会说是过度的基础架构即代码（IaC）项目是非常容易的。从经验来看，这些类型的项目总是比解决的问题更多。它们很难维护，如果其他团队成员继承了它们，那么他们将很难上手和使用——保持简单，并遵循先前列出的要点。'
- en: In our next and final chapter, we are going to take a look at three other IaC
    tools, including two native tools from the cloud providers Microsoft Azure and
    Amazon Web Services, before then discussing what your next steps with IaC could
    be.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来并且是最后一章中，我们将看看包括两个来自云服务提供商 Microsoft Azure 和 Amazon Web Services 的本地工具在内的另外三个
    IaC 工具，然后讨论您在 IaC 方面的下一步。
