- en: '*Chapter 8*: Integrating with DevOps Tools'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：与DevOps工具集成'
- en: One of the core tenets of DevOps, beyond cultivating the associated culture
    within your organization, is the practice of automating and optimizing processes
    through the use of technology. Using automation rules in Jira, we can optimize
    the process of software development by connecting DevOps tools such as Bitbucket
    and GitHub to issues in Jira, thereby allowing us to synchronize the status of
    issues automatically.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps的核心原则之一，在于在组织内培养相关文化的同时，通过使用技术来自动化和优化流程。通过在Jira中使用自动化规则，我们可以通过将Bitbucket和GitHub等DevOps工具与Jira中的问题连接，优化软件开发流程，从而实现问题状态的自动同步。
- en: Beyond keeping issue statuses automatically synchronized to code commits, we
    can also make use of automation to keep track of and synchronize pull requests,
    create tasks to track these, and send notifications to the team to ensure maximum
    visibility of the process. All of this enables developers to spend more time focused
    on writing and delivering software and less time managing administrative tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自动将问题状态与代码提交同步外，我们还可以利用自动化来跟踪和同步拉取请求，创建任务来追踪这些请求，并向团队发送通知，以确保过程的最大可见性。所有这些都能使开发人员更多时间专注于编写和交付软件，而减少管理行政任务的时间。
- en: While integration with certain DevOps processes has been (and still is) possible
    in Jira using workflow triggers, in this chapter we will look at how automation
    rules can be used to create more flexible integrations than what has previously
    been possible. This will keep your workflow configuration clean and prevent lengthy
    workflow updates, especially when the workflow affects a large number of issues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过工作流触发器在Jira中集成某些DevOps流程（过去和现在）是可能的，但在本章中，我们将探讨如何使用自动化规则来创建比以往更加灵活的集成方式。这将保持你的工作流配置简洁，并防止冗长的工作流更新，尤其是当工作流影响大量问题时。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Synchronizing issues and Git commits
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步问题和Git提交
- en: Keeping track of pull requests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪拉取请求
- en: Automatically releasing versions using GitHub
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitHub自动发布版本
- en: Synchronizing deployments with sprint completion
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与冲刺完成同步部署
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The requirements for this chapter are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求如下：
- en: '**Jira Cloud environment**: If you don''t already have access to Jira, you
    can create a free Jira Cloud account at [https://www.atlassian.com/software/jira/free](https://www.atlassian.com/software/jira/free)
    and ensure that you have both Jira Software and Jira Service Management selected.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jira Cloud环境**：如果你还没有Jira访问权限，可以在[https://www.atlassian.com/software/jira/free](https://www.atlassian.com/software/jira/free)创建一个免费的Jira
    Cloud账户，并确保选择了Jira Software和Jira Service Management。'
- en: '**Jira Server environment**: If you are using Jira Server (available from [https://www.atlassian.com/software/jira/download](https://www.atlassian.com/software/jira/download)),
    ensure that you have licenses for both Jira Software and Jira Service Management.
    In addition, you will also need to ensure that you install the *Automation for
    Jira* app, available from the Atlassian Marketplace.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jira Server环境**：如果你使用的是Jira Server（可以在[https://www.atlassian.com/software/jira/download](https://www.atlassian.com/software/jira/download)下载），请确保你拥有Jira
    Software和Jira Service Management的许可。此外，你还需要确保安装*Automation for Jira*应用，该应用可以在Atlassian
    Marketplace中找到。'
- en: For Jira, you will need to have at least **Project Administrator** access to
    a Scrum Software project and be able to follow the examples in this chapter. For
    the examples in this chapter, we have used the *Scrum project template* to create
    the software project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Jira，你需要至少拥有**项目管理员**权限，才能访问Scrum软件项目并跟随本章的示例。在本章的示例中，我们使用了*Scrum项目模板*来创建软件项目。
- en: 'You will also need access to the following tools:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要访问以下工具：
- en: '**Bitbucket Cloud**: Bitbucket Cloud is a hosted Git-based version control
    service from Atlassian. You can sign up for a Bitbucket account at [https://bitbucket.org](https://bitbucket.org)
    or by using the application switcher from your Jira Cloud account.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bitbucket Cloud**：Bitbucket Cloud是Atlassian提供的托管Git版本控制服务。你可以在[https://bitbucket.org](https://bitbucket.org)注册Bitbucket账户，或者通过你的Jira
    Cloud账户使用应用切换器。'
- en: '**GitHub**: GitHub is a hosted software development and Git-based version control
    service from Microsoft. You can sign up for a GitHub account at [https://github.com](https://github.com).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub**：GitHub是微软提供的托管软件开发和基于Git的版本控制服务。你可以在[https://github.com](https://github.com)注册GitHub账户。'
- en: '**Jenkins**: Jenkins is a popular free, open source automation server that
    is used to facilitate **Continuous Integration** (**CI**) and **Continuous Delivery**
    (**CD**) by automating the building, testing, and deploying of software projects.
    You can download Jenkins from [https://www.jenkins.io](https://www.jenkins.io).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins**：Jenkins 是一个流行的免费开源自动化服务器，用于通过自动化构建、测试和部署软件项目来促进**持续集成**（**CI**）和**持续交付**（**CD**）。你可以从
    [https://www.jenkins.io](https://www.jenkins.io) 下载 Jenkins。'
- en: 'You can download the latest code samples for this chapter from this book''s
    official GitHub repository at [https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira](https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira).
    Please visit the following link to check the CiA videos: [https://bit.ly/2XWeuW7](https://bit.ly/2XWeuW7)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从本书的官方 GitHub 仓库下载本章的最新代码示例，网址是 [https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira](https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira)。请访问以下链接查看
    CiA 视频：[https://bit.ly/2XWeuW7](https://bit.ly/2XWeuW7)
- en: Synchronizing issues and Git commits
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步问题和 Git 提交
- en: In the normal course of writing software, developers will normally move a story
    or task to an **In Progress** state, do the actual work of writing the code, commit
    the changes to a source repository such as Bitbucket or GitHub, and then switch
    back to Jira to move the story or task to the next status in the workflow.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写软件的正常过程中，开发者通常会将一个故事或任务移动到**进行中**状态，进行实际的代码编写，将更改提交到如 Bitbucket 或 GitHub
    等源代码仓库，然后返回 Jira，将故事或任务移至工作流中的下一个状态。
- en: All of this manual work requires unnecessary context switching, and because
    the process requires the developer to remember to switch between the various tools,
    it is very likely that sometimes issues are not updated, which makes it harder
    to track actual progress on the project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些手动操作都需要不必要的上下文切换，而且由于这一过程要求开发者记得在不同工具之间切换，因此很可能有时问题没有得到更新，这使得追踪项目的实际进展变得更加困难。
- en: Jira has, for some time, had the ability to integrate with tools such as Bitbucket
    and GitHub by allowing administrators to configure the underlying Jira workflows
    with triggers on various transitions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Jira 已经具备了与 Bitbucket 和 GitHub 等工具集成的能力，允许管理员通过在各种工作流转换上配置触发器来设置底层的 Jira 工作流。
- en: While this approach does allow for automation of the process and frees up the
    developer from having to manually update their task statuses, it is limited to
    the transition on which the trigger is configured. Additionally, making adjustments
    to workflows is not always a straightforward task.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法确实可以自动化过程，并解放开发者不需要手动更新任务状态，但它仅限于触发器配置的转换。此外，调整工作流并不总是一个简单的任务。
- en: By using automation rules instead, we gain a lot more flexibility in how we
    synchronize code commits with their corresponding Jira issues.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用自动化规则，我们在同步代码提交与对应 Jira 问题时获得了更多的灵活性。
- en: Let's take a look at how we can leverage automation rules to achieve this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何利用自动化规则实现这一点。
- en: Creating a rule to transition issues on code commits
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个规则以在代码提交时转换问题
- en: For this example, we will create a rule that listens for a commit created using
    Bitbucket Cloud and transitions the corresponding issue to **In Progress** if
    it is not already in that status.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将创建一个规则，监听通过 Bitbucket Cloud 创建的提交，如果对应的问题还没有处于**进行中**状态，则将其转换为该状态。
- en: In addition, we will send a message for every commit to the *#sprint-updates*
    Slack channel, which we set up in [*Chapter 4*](B16551_04_Final_ASB_ePub.xhtml#_idTextAnchor080),
    *Sending Automated Notifications*. In reality though, you would probably not want
    to spam the developers with commit notifications and rather wait for a more significant
    event, such as the creation of a pull request.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们会为每次提交发送消息到 *#sprint-updates* Slack 频道，这个频道是在[*第 4 章*](B16551_04_Final_ASB_ePub.xhtml#_idTextAnchor080)中设置的，*发送自动通知*。但实际上，你可能并不想用提交通知骚扰开发者，而是希望等到更重要的事件，比如创建拉取请求时，再发送通知。
- en: Tip
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: For automation rules to recognize the issue that needs to be updated, the commit
    message needs to include the issue key as part of the message.If your developers
    create a branch for each issue they work on, the issue key needs to be a part
    of the branch name.In both instances, the issue key must follow the standard Jira
    format of the project key, followed by a dash and then the issue number. For example,
    if the project key is PROJ and the issue number is 123, the issue key will be
    *PROJ-123*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让自动化规则识别需要更新的问题，提交信息需要包含问题键。如果你的开发人员为他们工作的每个问题创建一个分支，则问题键需要作为分支名称的一部分。在这两种情况下，问题键必须遵循Jira的标准格式，即项目键后跟一个短横线，再加上问题编号。例如，如果项目键是PROJ，问题编号是123，则问题键将是*PROJ-123*。
- en: 'Let''s firstly take a look at the rule in *Jira Cloud* using the DevOps triggers
    available to automation rules:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看在*Jira Cloud*中如何使用可用于自动化规则的DevOps触发器来构建此规则：
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the **Project Settings** menu, and then click **Create
    rule**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Jira软件项目中，进入**项目设置**，点击**项目设置**菜单中的**自动化**链接，然后点击**创建规则**。
- en: Select the **Commit created** trigger and then click **Save**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**提交创建**触发器，然后点击**保存**。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: If you do not already have a Git provider configured for your project, the commit
    created trigger will prompt you to create a connection, which you can do by clicking
    on the **Connect now** link.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你还没有为项目配置Git提供者，提交创建触发器将提示你创建连接，你可以点击**立即连接**链接来创建连接。
- en: Next, we'll send a Slack message to the `#sprint-updates`
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将发送一条Slack消息到`#sprint-updates`
- en: In this step, we'll add a condition to check that the current status of the
    issue is not `Status`
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此步骤中，我们将添加一个条件来检查问题的当前状态是否不是`状态`
- en: '`does not equal`'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`不等于`'
- en: '`In Progress`'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`进行中`'
- en: Next, if the condition from *step 4* is satisfied, we'll transition the issue
    to **In Progress**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果*步骤4*中的条件满足，我们将把问题转换为**进行中**。
- en: Click on **New action** and then select **Transition issue**. Set the **Destination**
    field to **In Progress** and then click **Save**.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击**新动作**，然后选择**转换问题**。将**目标**字段设置为**进行中**，然后点击**保存**。
- en: 'Your rule should now look similar to the following screenshot:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的规则现在应该类似于以下截图：
- en: '![Figure 8.1 – Using the DevOps trigger to synchronize commits'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.1 – 使用DevOps触发器来同步提交'
- en: '](img/B16551_Figure_8.1.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_8.1.jpg)'
- en: Figure 8.1 – Using the DevOps trigger to synchronize commits
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.1 – 使用DevOps触发器来同步提交
- en: Finally, name the rule `Transition to In Progress on commit` and click **Turn
    it on** to save and publish the rule.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，命名规则为`Transition to In Progress on commit`，然后点击**开启**以保存并发布该规则。
- en: Automation rules for Jira Server and Data Center do not currently include DevOps
    triggers, and so we need to make use of the incoming webhook trigger to achieve
    a similar result.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Jira Server和Data Center的自动化规则目前不包括DevOps触发器，因此我们需要利用传入Webhook触发器来实现类似的结果。
- en: In this example, we'll first set up the incoming webhook automation rule in
    Jira, after which we'll copy the generated webhook URL, which we'll need to set
    up the outgoing webhook in the Bitbucket Cloud repository.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将首先在Jira中设置传入的Webhook自动化规则，然后复制生成的Webhook URL，这将在设置Bitbucket Cloud仓库中的传出Webhook时使用。
- en: 'Let''s now take a look at how we build this rule in *Jira Server* or *Jira
    Data Center*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何在*Jira Server*或*Jira Data Center*中构建此规则：
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Project automation** link in the **Project Settings** menu, and then click **Create
    rule**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Jira软件项目中，进入**项目设置**，点击**项目设置**菜单中的**项目自动化**链接，然后点击**创建规则**。
- en: Bitbucket Cloud sends a *push* webhook when a commit is created and sends a
    webhook payload, which you can read more about at [https://support.atlassian.com/bitbucket-cloud/docs/event-payloads/#EventPayloads-entity_repository](https://support.atlassian.com/bitbucket-cloud/docs/event-payloads/#EventPayloads-entity_repository).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bitbucket Cloud在创建提交时会发送一个*推送*Webhook，并发送一个Webhook负载，更多信息请查看[https://support.atlassian.com/bitbucket-cloud/docs/event-payloads/#EventPayloads-entity_repository](https://support.atlassian.com/bitbucket-cloud/docs/event-payloads/#EventPayloads-entity_repository)。
- en: 'In this example, we are assuming that the issue key is present in the commit
    message rather than the branch name. We will need to extract the issue key from
    the commit message in order to look up the correct Jira issue. Based on the Bitbucket
    payload structure detailed in the preceding link, we can find the commit message
    and extract the issue key using the following smart value:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设问题键存在于提交消息中而不是分支名称中。我们需要从提交消息中提取问题键，以便查找正确的 Jira 问题。根据前述链接中详细的 Bitbucket
    负载结构，我们可以找到提交消息并使用以下智能值提取问题键：
- en: '[PRE0]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you are using branches per issue and the issue key is encoded in the branch
    name, you can extract the issue key from the branch name with the following smart
    value instead: `{{webhookData.push.changes.first().new.target.name.match("([A-Z][A-Z0-9]+-\d+)")}}`.'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你是按问题使用分支，并且问题键编码在分支名称中，你可以使用以下智能值从分支名称中提取问题键：`{{webhookData.push.changes.first().new.target.name.match("([A-Z][A-Z0-9]+-\d+)")}}`。
- en: Select the `Issues provided by running the following JQL search`
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择`通过运行以下 JQL 查询提供的 Issue`
- en: '`key = {{webhookData.push.changes.first().new.target.message.match("([A-Z][A-Z0-9]+-\d+)")}}`'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`key = {{webhookData.push.changes.first().new.target.message.match("([A-Z][A-Z0-9]+-\d+)")}}`'
- en: Next, we'll send a Slack message to the `#sprint-updates`
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向`#sprint-updates`发送一条 Slack 消息。
- en: In this step, we'll add a condition to check that the current status of the
    issue is not `Status`
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此步骤中，我们将添加一个条件，检查问题的当前状态是否不是`状态`。
- en: '`does not equal`'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`不等于`'
- en: '`In Progress`'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`进行中`'
- en: Next, if the condition from *step 4* is satisfied, we'll transition the issue
    to **In Progress**.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果*第4步*的条件满足，我们将把问题状态转换为**进行中**。
- en: Click on **New action** and then select **Transition issue**. Set the **Destination**
    field to **In Progress** and then click **Save**.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击**新建操作**，然后选择**转换问题**。将**目标**字段设置为**进行中**，然后点击**保存**。
- en: 'Your rule should now look similar to the following screenshot:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的规则现在应该类似于下图所示：
- en: '![Figure 8.2 – Using an incoming webhook trigger to synchronize commits'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.2 – 使用传入的 Webhook 触发器同步提交'
- en: '](img/B16551_Figure_8.2.jpg)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_8.2.jpg)'
- en: Figure 8.2 – Using an incoming webhook trigger to synchronize commits
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.2 – 使用传入的 Webhook 触发器同步提交
- en: Name the rule `Transition to In Progress on commit` and click **Turn it on**
    to save and publish the rule.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将规则命名为`在提交时转换为进行中`，然后点击**启用**以保存并发布该规则。
- en: Next, we need to configure the outgoing webhook in Bitbucket Cloud.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 Bitbucket Cloud 中配置出站 Webhook。
- en: Navigate to your repository in Bitbucket Cloud and click on `Transition Jira
    issue on commit` and paste the Incoming webhook URL, which was generated in step
    2, into the **URL** field.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导航到 Bitbucket Cloud 中的仓库，点击`提交时转换 Jira 问题`，并将步骤 2 中生成的传入 Webhook URL 粘贴到**URL**字段中。
- en: Leave the rest of the fields set to their default values and click **Save**.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保持其他字段为默认值并点击**保存**。
- en: 'Your Bitbucket Cloud webhook should look similar to the following screenshot:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的 Bitbucket Cloud Webhook 应该类似于下图所示：
- en: '![Figure 8.3 – Configuring the push webhook in Bitbucket Cloud'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 在 Bitbucket Cloud 中配置推送 Webhook'
- en: '](img/B16551_Figure_8.3.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_8.3.jpg)'
- en: Figure 8.3 – Configuring the push webhook in Bitbucket Cloud
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 在 Bitbucket Cloud 中配置推送 Webhook
- en: Now that we have completed the webhook setup in Bitbucket Cloud, any commits
    pushed to the Bitbucket repository will send a request to the **Webhook URL**
    that was autogenerated in *step 2*, causing our automation rule to fire and transition
    the issue related to the commit.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了 Bitbucket Cloud 中的 Webhook 设置，任何推送到 Bitbucket 仓库的提交都会向*第2步*中自动生成的**Webhook
    URL**发送请求，触发我们的自动化规则并转换与该提交相关的问题状态。
- en: In this section, we have learned how to use the DevOps triggers available in
    Jira Cloud to automatically keep issues in Jira in sync with commits to a Git
    repository hosted in Bitbucket Cloud.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们已经学会了如何使用 Jira Cloud 中的 DevOps 触发器，自动将 Jira 问题与 Bitbucket Cloud 中托管的
    Git 仓库提交同步。
- en: Important note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The DevOps triggers such as Commit created in Jira Cloud work with most major
    Git repositories, including Bitbucket Cloud, GitHub, and Gitlab, and the example
    we have looked at using Jira Cloud will work unchanged for any of these tools.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Jira Cloud 中的 DevOps 触发器，如 Commit 创建，适用于大多数主流 Git 仓库，包括 Bitbucket Cloud、GitHub
    和 Gitlab，我们之前看过的 Jira Cloud 示例也可以在这些工具中直接使用。
- en: We also looked at how we can achieve a similar result for Jira Server and Jira
    Data Center using an incoming webhook for Bitbucket Cloud using issue keys in
    commit messages specifically.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了如何通过专门在提交消息中使用问题关键字的 Bitbucket Cloud 传入 Webhook 来为 Jira Server 和 Jira Data
    Center 实现类似的结果。
- en: In the next section, we'll look at how to use automation rules to keep track
    of pull requests created in Git-based repositories.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何使用自动化规则来跟踪在基于 Git 的仓库中创建的拉取请求。
- en: Keeping track of pull requests
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪拉取请求
- en: A common feature of DevOps practices is the use of the so-called trunk-based
    development method, which is a key enabler for the application of **Continuous
    Integration**and **Continuous Delivery** or **Development (CI/CD)** to the software
    development process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 实践的一个常见特点是使用所谓的基于主干的开发方法，这是**持续集成**和**持续交付**或**开发（CI/CD）**应用于软件开发过程的关键推动力。
- en: One of the ways to achieve this is by making use of short-lived branches taken
    from the master (or trunk) branch to perform development tasks. Jira facilitates
    this by allowing developers to automatically create branches for each development
    task when a source control repository such as Bitbucket or GitHub is configured
    for the software project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的方式之一是使用从主分支（或主干）分出的短生命周期分支来执行开发任务。Jira 通过允许开发者在配置了像 Bitbucket 或 GitHub
    这样的源代码管理仓库时，自动为每个开发任务创建分支，来方便这一点。
- en: These short-lived branches are usually merged back into the master/trunk branch
    by way of pull requests, which allow developers to review the changes introduced
    into the software before merging them into the master branch.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些短生命周期的分支通常通过拉取请求（pull requests）合并回主干/主分支，拉取请求允许开发者在合并到主分支之前，审查软件中引入的变更。
- en: In this section, we will see how using automation rules allows us to keep track
    of these pull requests, which typically happen directly inside the source control
    repository, and to automatically synchronize and transition the affected issues
    in Jira.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何使用自动化规则来跟踪这些拉取请求，这些请求通常直接发生在源代码控制仓库中，并自动同步和过渡 Jira 中的相关问题。
- en: We'll also see how to create automated tasks to track pull requests. These tracking
    tasks will allow product owners and the team to quickly see which issues have
    been merged without pull requests, or which issues have outstanding pull requests
    without leaving Jira.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到如何创建自动化任务来跟踪拉取请求。这些跟踪任务将使产品负责人和团队能够快速查看哪些问题已经合并而没有拉取请求，或者哪些问题存在未解决的拉取请求，而无需离开
    Jira。
- en: Let's take a look at the first rule, which will synchronize the development
    issue and create the tracking task.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下第一个规则，它将同步开发问题并创建跟踪任务。
- en: Creating a rule to track new pull requests
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个规则来跟踪新的拉取请求
- en: In this example, the first thing we want to achieve when managing pull requests
    is to transition the corresponding development issue into a **Waiting for review**
    status and then create a tracking task in Jira that is linked to the development
    issue under review.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当管理拉取请求时，我们首先想要实现的是将相应的开发问题转换为**等待审查**状态，然后在 Jira 中创建一个与正在审查的开发问题相关联的跟踪任务。
- en: Tip
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The **Waiting for review** status will need to be added to your workflow for
    this example to work correctly. If you have used the default workflow from the
    *Scrum software project template*, you can do this by adding a new column to your
    scrum board through the board configuration. If you have a custom workflow, you
    will need to edit the workflow to add this status.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个示例正确工作，**等待审查**状态需要添加到你的工作流中。如果你使用了*Scrum软件项目模板*的默认工作流，你可以通过在看板配置中向 Scrum
    看板添加一个新列来完成。如果你使用的是自定义工作流，则需要编辑工作流以添加此状态。
- en: Additionally, we'll send a Slack message to the team to notify them that a new
    pull request task has been created. This will allow any member of the development
    team to pick up and review the pull request.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们会向团队发送 Slack 消息，通知他们已经创建了一个新的拉取请求任务。这样开发团队的任何成员都可以接手并审查该拉取请求。
- en: 'Let''s take a look at how we build this rule:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何构建这个规则：
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the project settings menu, and then click **Create rule**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Jira 软件项目中，导航到**项目设置**，点击项目设置菜单中的**自动化**链接，然后点击**创建规则**。
- en: Select the **Pull request created** trigger and then click **Save**.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**拉取请求已创建**触发器，然后点击**保存**。
- en: Next, we want to transition the development issue to the **Waiting for review**
    status.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要将开发问题的状态转换为**等待审查**。
- en: Select **New action**, followed by **Transition issue** and then, in the **Destination
    status** field, select the **Waiting for review** option and then click **Save**.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择**新动作**，然后选择**转换问题**，接着在**目标状态**字段中选择**等待审查**选项，然后点击**保存**。
- en: Then we need to create the Jira task to track this pull request.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要创建Jira任务来跟踪此拉取请求。
- en: Select `Same project`
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择`同一项目`
- en: '`Task`'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`任务`'
- en: '`Review PR: {{pullRequest.title}}`'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`审查PR：{{pullRequest.title}}`'
- en: '`Review is required for PR: {{pullRequest.title}}`'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`需要审查的PR：{{pullRequest.title}}`'
- en: '`Source branch: {{pullRequest.sourceBranch}}`'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`源分支：{{pullRequest.sourceBranch}}`'
- en: '`Destination branch: {{pullRequest.destinationBranch}}`'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`目标分支：{{pullRequest.destinationBranch}}`'
- en: '`Access the PR here: {{pullRequest.url}}`'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`访问PR链接：{{pullRequest.url}}`'
- en: '`blocks`'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`阻塞`'
- en: '`Trigger issue`'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`触发问题`'
- en: 'To send a notification to the team via Slack, we''ll select `:bellhop_bell:
    A new pull request has been created and is ready for review <{{createdIssue.url}}|{{createdIssue.key}}>`'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '要通过Slack向团队发送通知，我们将选择`:bellhop_bell: 一个新的拉取请求已创建并准备好审查 <{{createdIssue.url}}|{{createdIssue.key}}>`'
- en: '`#slack-updates`.'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#slack-updates`。'
- en: 'Your rule should look similar to the following screenshot:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的规则应类似于以下截图：
- en: '![Figure 8.4 – Rule to track new pull requests'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.4 - 跟踪新拉取请求的规则'
- en: '](img/B16551_Figure_8.4.jpg)'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_8.4.jpg)'
- en: Figure 8.4 – Rule to track new pull requests
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.4 - 跟踪新拉取请求的规则
- en: Finally, name the rule `Track new pull requests` and click **Turn it on** to
    save and enable the rule.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将规则命名为`跟踪新拉取请求`，然后点击**启用**以保存并启用该规则。
- en: In this example, we have learned how to use the built in DevOps triggers available
    in Jira Cloud to trigger rules when new pull requests are created in connected
    Git tools such as Bitbucket and GitHub, provided these tools are configured in
    Jira and connected to the software project.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们学习了如何使用Jira Cloud中内置的DevOps触发器，在连接的Git工具（如Bitbucket和GitHub）中创建新的拉取请求时触发规则，前提是这些工具已在Jira中配置并与软件项目连接。
- en: The second rule we'll look at in this section will complete the loop of managing
    pull requests by handling the case when a pull request has been approved and merged.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们要查看的第二个规则将通过处理拉取请求已批准并合并的情况来完成管理拉取请求的循环。
- en: Creating a rule to manage merged pull requests
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个管理已合并拉取请求的规则
- en: In this example, we'll create an automation rule that will trigger when a pull
    request is merged. At this point, we want to transition the development issue
    from **Waiting for review** to **Waiting for deploy**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个自动化规则，当拉取请求被合并时触发。此时，我们希望将开发问题的状态从**等待审查**转换为**等待部署**。
- en: Tip
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The **Waiting for deploy** status will need to be added to your workflow in
    order for this example to work correctly. If you have used the default workflow
    from the *Scrum software project template*, you can do this by adding a new column
    to your scrum board through the board configuration. If you have a custom workflow,
    you will need to edit the workflow to add this status.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此示例正确工作，需要在你的工作流中添加**等待部署**状态。如果你使用的是*Scrum软件项目模板*的默认工作流，可以通过在看板配置中添加新列来实现。如果你使用的是自定义工作流，则需要编辑工作流以添加此状态。
- en: Additionally, we also want to automatically transition the tracking task that
    we created in the **Track new pull requests** rule to **Done**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还希望自动将我们在**跟踪新拉取请求**规则中创建的跟踪任务状态转换为**已完成**。
- en: Let's now take a look at how we can build a rule to achieve this.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何构建一个规则来实现这个目标。
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the **Project Settings** menu, and then click **Create
    rule**.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Jira软件项目中，导航到**项目设置**，点击**项目设置**菜单中的**自动化**链接，然后点击**创建规则**。
- en: Select the **Pull request merged** trigger and then click **Save**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**拉取请求已合并**触发器，然后点击**保存**。
- en: As we only want to transition the issue if it is in *Waiting for review* status,
    we need to have a condition to check for this.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们只希望在问题处于*等待审查*状态时才进行转换，因此需要设置一个条件来检查这一状态。
- en: Select `Status`
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择`状态`
- en: '`equals`'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`等于`'
- en: '`Waiting for review`'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`等待审查`'
- en: Next, select **New action** followed by **Transition issue** and then, in the
    **Destination status** field, select **Waiting for deploy** and then click **Save**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择**新动作**，然后选择**转换问题**，接着在**目标状态**字段中选择**等待部署**，然后点击**保存**。
- en: Now we want to automatically transition the tracking task that we created in
    the *Creating a rule to track new pull requests* section to `Linked issues`
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们想要自动过渡我们在*创建规则以跟踪新的拉取请求*部分中创建的跟踪任务到`关联问题`
- en: '`is blocked by`'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`被阻塞`'
- en: As there might be other tasks linked to this issue using the same link type,
    we want to ensure that we only automatically transition the tracking task, so
    we'll need another condition.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于可能会有其他任务通过相同的链接类型与此问题关联，我们希望确保只自动过渡跟踪任务，因此我们需要另一个条件。
- en: Select `Summary`
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择`摘要`
- en: '`starts with`'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`以...开始`'
- en: '`Review PR:`'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`审查PR:`'
- en: Now select **New action** followed by **Transition issue**. In the **Destination
    status** field, select **Done** and then click **Save**.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择**新动作**，然后选择**过渡问题**。在**目标状态**字段中，选择**已完成**，然后点击**保存**。
- en: 'The rule should now look similar to the following screenshot:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该规则现在应该与以下截图类似：
- en: '![Figure 8.5 – Rule to manage pull request merges'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.5 – 用于管理拉取请求合并的规则'
- en: '](img/B16551_Figure_8.5.jpg)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_8.5.jpg)'
- en: Figure 8.5 – Rule to manage pull request merges
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.5 – 用于管理拉取请求合并的规则
- en: Finally, name the rule `Manage pull request merges` and click **Turn it on**
    to save and enable the rule.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，给规则命名为`管理拉取请求合并`，然后点击**启用**以保存并启用规则。
- en: We now know how to integrate pull requests with Jira using automation rules.
    Firstly, to ensure that the development issues are synchronized with the actual
    work being done by the development team, and secondly, to keep track of which
    issues have been or still need to be merged into the master branch. In the next
    section, we'll see how to specifically use automation rules to integrate with
    the release functionality available in GitHub.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何通过自动化规则将拉取请求与Jira集成。首先，确保开发问题与开发团队实际执行的工作同步，其次，跟踪哪些问题已经或仍然需要合并到主分支。在下一部分，我们将看到如何具体使用自动化规则与GitHub中的发布功能进行集成。
- en: Automatically releasing versions using GitHub
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitHub自动发布版本
- en: Version control tools allow developers to tag specific revisions of their source
    code, which, in effect, creates a snapshot of the repository at a point in time.
    The most common use for tags is to identify the source components and files that
    make up a particular version or release of the software and tools such as GitHub
    and GitLab take this a step further by allowing developers to create a release
    based on a particular tag. These typically consist of the list of changes applicable
    to this particular release in the form of release notes. They can also include
    links to the list of assets that make up the release, which are typically downloadable
    binary packages.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制工具允许开发者对源代码的特定修订进行标记，这实际上创建了一个时间点上的代码库快照。标签的最常见用途是标识构成特定版本或发布的软件的源代码组件和文件，像GitHub和GitLab这样的工具进一步推动了这一点，它们允许开发者基于特定标签创建一个发布版本。这些版本通常包含适用于该版本的变更列表，形式为发布说明。它们还可以包含指向构成发布的资产列表的链接，这些资产通常是可下载的二进制包。
- en: Releases can be created using the tool's user interface, but most commonly are
    created automatically by build tools such as Bitbucket Pipelines or Jenkins upon
    the successful completion of a deployment build. These tools can, in turn, fire
    webhook events to notify other tools when a release has been created.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 发布可以通过工具的用户界面创建，但最常见的是通过构建工具（如Bitbucket Pipelines或Jenkins）在成功完成部署构建后自动创建。这些工具反过来可以触发webhook事件，在发布被创建时通知其他工具。
- en: With automation rules in Jira, we can use incoming webhooks to receive these
    notifications and automatically release the corresponding version in Jira and
    simultaneously transition all the affected issues linked to that version to *Done*.
    Let's now take a look at a rule that will allow us to achieve that.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jira中的自动化规则，我们可以使用传入的webhook接收这些通知，并自动发布Jira中的相应版本，同时将所有与该版本关联的受影响问题过渡到*已完成*。现在让我们来看一个可以帮助我们实现这一目标的规则。
- en: Creating a rule to synchronize version releases to GitHub releases
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个规则以同步版本发布到GitHub发布
- en: In this rule, we'll create an incoming webhook that can be called by GitHub
    when a release is created. The GitHub release webhook contains a JSON payload
    from which we'll be able to extract the name of the tag that identifies the release.
    In turn, this tag name should correspond to the versions in your Jira Software
    project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个规则中，我们将创建一个可以被GitHub调用的传入webhook，当发布被创建时，GitHub发布webhook会包含一个JSON负载，我们将能够从中提取出标识发布的标签名称。反过来，这个标签名称应该与Jira软件项目中的版本相对应。
- en: 'The structure of the GitHub release payload is similar to the following, and
    we''ll be using the `action` and `tag_name` fields in our rule:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 发布负载的结构类似于以下内容，我们将在规则中使用`action`和`tag_name`字段：
- en: '[PRE1]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can read more about the event payload at the following URL: [https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/webhook-events-and-payloads#release](mailto:https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/webhook-events-and-payloads#release).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下网址阅读更多关于事件负载的信息：[https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/webhook-events-and-payloads#release](mailto:https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/webhook-events-and-payloads#release)。
- en: 'You can also learn more about GitHub webhooks and events in general at the
    following URL: [https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/about-webhooks](mailto:https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/about-webhooks).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在以下网址了解更多关于 GitHub webhook 和事件的内容：[https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/about-webhooks](mailto:https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/about-webhooks)。
- en: 'Let''s take a look at the steps required to build an automation rule to synchronize
    the release of a Jira version when a version is released from GitHub:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下创建自动化规则所需的步骤，以便在从 GitHub 发布版本时同步 Jira 版本的发布：
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the **Project settings** menu, and then click **Create
    rule**.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Jira 软件项目中，导航到**项目设置**，点击**项目设置**菜单中的**自动化**链接，然后点击**创建规则**。
- en: Select the **Incoming webhook** trigger and, in the **Execute this automation
    rule with** field, select the **No issues from the webhook** option and then click
    **Save**.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**传入 webhook**触发器，并在**使用此自动化规则时**字段中选择**没有来自 webhook 的问题**选项，然后点击**保存**。
- en: Make sure to copy the webhook URL that was automatically generated as we'll
    need this later to configure the GitHub webhook.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请确保复制自动生成的 webhook URL，因为我们稍后需要它来配置 GitHub webhook。
- en: GitHub will send a webhook event for different states of the release; however,
    for this rule, we are only interested in acting on the event when the release
    is published, which we can check by looking at the `{{webhookData.action}}`
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitHub 会为发布的不同状态发送 webhook 事件；但是，对于此规则，我们只关心在发布版本时执行该事件，具体可以通过查看`{{webhookData.action}}`来判断。
- en: '`equals`'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`equals`'
- en: '`published`'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`published`'
- en: The first thing we want to do if the condition in *step 3* matches is to automatically
    transition all the issues that belong to the release and are currently waiting
    to be deployed to `JQL`
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*步骤 3*中的条件匹配，首先要做的是自动将所有属于该版本并且当前等待部署的问题转移到`JQL`
- en: '`fixVersion = {{webhookData.release.tag_name}} AND status = "Waiting for deploy"`'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`fixVersion = {{webhookData.release.tag_name}} AND status = "Waiting for deploy"`'
- en: Then we select **New action**, followed by **Transition issue**, and set the
    **Destination status** field to **Done** before clicking **Save**.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们选择**新建操作**，接着选择**转移问题**，在点击**保存**之前，将**目标状态**字段设置为**完成**。
- en: Next, we want to release the Jira version that corresponds to the tag name of
    the GitHub release.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望发布与 GitHub 版本的标签名称对应的 Jira 版本。
- en: We need to do this outside the `{{webhookData.release.tag_name}}` and then click
    **Save**.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要在`{{webhookData.release.tag_name}}`之外执行此操作，然后点击**保存**。
- en: 'The rule should now look similar to the following screenshot:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 规则现在应该看起来像以下屏幕截图：
- en: '![Figure 8.6 – Automatically releasing a Jira version from GitHub'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.6 – 从 GitHub 自动发布 Jira 版本'
- en: '](img/B16551_Figure_8.6.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_8.6.jpg)'
- en: Figure 8.6 – Automatically releasing a Jira version from GitHub
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.6 – 从 GitHub 自动发布 Jira 版本
- en: Finally, name the rule `Synchronize versions with GitHub releases` and click
    **Turn it on** to save and enable the rule.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将规则命名为`与 GitHub 发布同步版本`，然后点击**启用**以保存并启用此规则。
- en: Now that we have the automation rule in Jira, we will need to complete the configuration
    in GitHub using the webhook URL generated previously in *step 2*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在 Jira 中有了自动化规则，我们需要使用*步骤 2*中生成的 webhook URL 完成 GitHub 配置。
- en: 'Let''s now configure our GitHub repository to send release notifications to
    our automation rule in Jira:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置我们的 GitHub 仓库，将发布通知发送到 Jira 中的自动化规则：
- en: Navigate to your repository in GitHub, click on **Settings**, select the **Webhooks**
    tab from the menu on the left, and then click on the **Add webhook** button.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你在 GitHub 中的仓库，点击**设置**，从左侧菜单选择**Webhooks**标签，然后点击**添加 webhook**按钮。
- en: 'Complete the webhook fields as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式填写 Webhook 字段：
- en: '`application/json`'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`application/json`'
- en: '`Enable SSL verification`'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`启用 SSL 验证`'
- en: To ensure that we receive the correct event in the automation rule, select the
    **Let me select individual events** option in the **Which events would you like
    to trigger this webhook** field.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保我们在自动化规则中接收到正确的事件，请在**您希望触发此 Webhook 的事件**字段中选择**让我选择单独的事件**选项。
- en: Make sure to deselect the **Pushes** option, select the **Releases** option,
    and then click **Add webhook**.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保取消选择**Pushes**选项，选择**Releases**选项，然后点击**添加 Webhook**。
- en: 'Your GitHub configuration should look similar to the following screenshot:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的 GitHub 配置应类似于以下屏幕截图：
- en: '![Figure 8.7 – Configuring the releases webhook in GitHub'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – 配置 GitHub 中的 Releases Webhook'
- en: '](img/B16551_Figure_8.7.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_8.7.jpg)'
- en: Figure 8.7 – Configuring the releases webhook in GitHub
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 配置 GitHub 中的 Releases Webhook
- en: We have now learned how to integrate Jira with GitHub releases and how we can
    use automation rules to release the corresponding version in Jira after transitioning
    all the affected development tasks to **Done**. In the next section, we'll look
    at how to automatically kick off deployment builds using Jenkins when a sprint
    is completed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学习了如何将 Jira 与 GitHub Releases 集成，并且如何在将所有受影响的开发任务转移到**完成**状态后，使用自动化规则在
    Jira 中发布相应版本。在下一节中，我们将学习如何在冲刺完成时，使用 Jenkins 自动启动部署构建。
- en: Synchronizing deployments with sprint completion
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与冲刺完成同步部署
- en: In Agile scrum, one of the artifacts created during a sprint is the **Product
    increment**, which is the deliverable produced by completion of the product backlog
    tasks during a sprint. In this section, we'll learn how to integrate with Jenkins
    using automation rules to automatically initiate the final deployment build when
    the sprint in Jira is closed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷 Scrum 中，一个在冲刺期间创建的工件是**产品增量**，它是通过完成产品待办事项中的任务所产生的可交付成果。在本节中，我们将学习如何通过自动化规则与
    Jenkins 集成，以便在 Jira 中的冲刺关闭时自动启动最终部署构建。
- en: During a sprint, in a trunk-based development model, developers will commit
    code to the branch in the source repository associated with the development task,
    which will generally initiate automated tests to verify that the new code does
    not negatively affect the build process. When pull requests are created and merged,
    further automated tests can be initiated followed by automated deployments to
    QA or staging servers. By the time the sprint is completed, all these processes
    result in the final task of deploying the resultant product increment to production,
    or by using a tool such as GitHub to create a release.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个冲刺期间，在基于主干的开发模型中，开发人员会将代码提交到与开发任务相关的源代码库中的分支，这通常会启动自动化测试，以验证新代码不会对构建过程产生负面影响。当创建并合并拉取请求时，可以进一步启动自动化测试，随后是自动化部署到
    QA 或预发布服务器。到冲刺完成时，所有这些过程最终会导致将生成的产品增量部署到生产环境，或者通过像 GitHub 这样的工具创建发布。
- en: Let's take a look at how this is achievable using automation rules.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过自动化规则实现这一目标。
- en: Creating a rule to start a deployment build
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建启动部署构建的规则
- en: In this example, we'll create a rule that will initiate a production build of
    a software project each time a sprint is completed. To achieve this, we first
    need to configure the job in Jenkins to allow builds to be triggered remotely
    by scripts.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将创建一个规则，每当冲刺完成时，都会启动一个软件项目的生产构建。为了实现这一目标，我们首先需要在 Jenkins 中配置作业，以允许通过脚本远程触发构建。
- en: Tip
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you do not already have a Jenkins instance, you can sign up for an AWS account
    at [https://aws.amazon.com](https://aws.amazon.com) and launch a new EC2 instance
    based on the *Jenkins Certified by Bitnami* AMI. This AMI contains full instructions
    on how to get up and running with Jenkins in AWS.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有 Jenkins 实例，可以在 [https://aws.amazon.com](https://aws.amazon.com) 注册一个
    AWS 账户，并基于 *Jenkins Certified by Bitnami* AMI 启动一个新的 EC2 实例。此 AMI 包含了如何在 AWS 中启动并运行
    Jenkins 的完整说明。
- en: We'll start by navigating to the project in Jenkins. In the project's **Configuration**
    screen, select the **Build Triggers** tab and then select the **Trigger builds
    remotely** option. Jenkins requires an authentication token to be provided to
    ensure that only remote systems that know this token can kick off the build job.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从导航到 Jenkins 中的项目开始。在项目的**配置**屏幕中，选择**构建触发器**选项卡，然后选择**远程触发构建**选项。Jenkins
    需要提供一个身份验证令牌，以确保只有知道此令牌的远程系统才能启动构建作业。
- en: 'This token can be any text string of your choosing. In our example, we''re
    going to use `MY_SECURE_AUTH_TOKEN` as the **Authentication Token**. Once you
    have configured Jenkins, the **Build Triggers** section should look similar to
    the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个令牌可以是您选择的任何文本字符串。在我们的示例中，我们将使用 `MY_SECURE_AUTH_TOKEN` 作为 **身份验证令牌**。配置好 Jenkins
    后，**构建触发器**部分应该类似于以下截图：
- en: '![Figure 8.8 – Configuring Jenkins to allow the triggering of builds remotely'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.8 – 配置 Jenkins 以允许远程触发构建'
- en: '](img/B16551_Figure_8.8.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_8.8.jpg)'
- en: Figure 8.8 – Configuring Jenkins to allow the triggering of builds remotely
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 配置 Jenkins 以允许远程触发构建
- en: 'Now that we have Jenkins configured, let''s build the automation rule to initiate
    deployment when our sprint is completed:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好了 Jenkins，接下来我们来构建一个自动化规则，在冲刺完成时启动部署：
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the **Project settings** menu, and then click **Create
    rule**.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 Jira 软件项目中，导航到 **项目设置**，点击 **项目设置** 菜单中的 **自动化** 链接，然后点击 **创建规则**。
- en: Select the **Sprint completed** trigger and, in the **Boards** field, select
    the Scrum board for your project and then click **Save**. In this example, we'll
    select **My Application Scrum Board**.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **冲刺完成** 触发器，在 **看板** 字段中选择您的项目的 Scrum 看板，然后点击 **保存**。在这个例子中，我们将选择 **我的应用程序
    Scrum 看板**。
- en: 'Sending API requests to Jenkins requires us to acquire an API crumb from the
    Jenkins crumb issuer service. This service returns a crumb that we later need
    to use to interact with the API in the following format:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 Jenkins 发送 API 请求需要我们从 Jenkins 令牌颁发服务获取一个 API 令牌。该服务返回一个令牌，我们随后需要在与 API 交互时使用，格式如下：
- en: '[PRE2]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To do this, select `https://<your_jenkins_host>/crumbIssuer/api/json`
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为此，选择 `https://<your_jenkins_host>/crumbIssuer/api/json`
- en: '`Authorization`'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Authorization`'
- en: '`Basic <your base64-encoded credentials>`'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Basic <your base64-encoded credentials>`'
- en: '`GET`'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GET`'
- en: '`Empty`'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`空`'
- en: '`{{webhookResponse}}` smart value.'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{{webhookResponse}}` 智能值。'
- en: Next, we need to make the call to the Jenkins API to kick off the deployment
    build that we configured in Jenkins.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要调用 Jenkins API 来启动我们在 Jenkins 中配置的部署构建。
- en: We will also need to send the Jenkins crumb that we retrieved in *step 3* in
    the *Jenkins-Crumb* header.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要在 *步骤 3* 中通过 *Jenkins-Crumb* 头发送我们获取到的 Jenkins 令牌。
- en: Again, select `https://<your_jenkins_host>/job/<your_job_name>/build?token=<YOUR_AUTHORIZATION_TOKEN>`
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次选择 `https://<your_jenkins_host>/job/<your_job_name>/build?token=<YOUR_AUTHORIZATION_TOKEN>`
- en: Fill the following in the first `Authorization`
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一个 `Authorization` 中填写以下内容
- en: '`Basic <your base64-encoded credentials>`'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Basic <your base64-encoded credentials>`'
- en: Fill in the following second `Jenkins-Crumb`
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 填写以下第二个 `Jenkins-Crumb`
- en: '`{{webhookResponse.body.crumb}}`'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{{webhookResponse.body.crumb}}`'
- en: '`POST`'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`POST`'
- en: '`Empty`'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`空`'
- en: '`{{webhookResponse}}` smart value.'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{{webhookResponse}}` 智能值。'
- en: If the build is successfully kicked off in Jenkins, we want to transition all
    the issues in the sprint that were waiting for deployment to `{{webhookResponse}}`
    smart value will always contain the response from the latest `{{webhookResponses}}`
    list, which will contain the responses in order of the web request actions, starting
    from position zero (0). Also note that responses will only be added to this list
    if you have checked the `{{webhookResponse.status}}`
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在 Jenkins 中成功启动构建，我们希望将所有在冲刺中等待部署的问题转换为 `{{webhookResponse}}` 智能值，该值始终包含来自最新
    `{{webhookResponses}}` 列表的响应，该列表将按 Web 请求操作的顺序包含响应，从位置零（0）开始。还请注意，只有在您检查了 `{{webhookResponse.status}}`
    后，响应才会添加到此列表中。
- en: '`exactly matches regular expression`'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`完全匹配正则表达式`'
- en: '`2\d\d`'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`2\d\d`'
- en: Next, select **Branch rule / related issues** followed by **Issues in the sprint**
    in the **Type of related issues** field and then click **Save**.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择 **分支规则 / 相关问题**，然后在 **相关问题类型** 字段中选择 **冲刺中的问题**，然后点击 **保存**。
- en: Then, select `Status`
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择 `Status`
- en: '`equals`'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`等于`'
- en: '`Waiting for deploy`'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`等待部署`'
- en: Now we need to transition the issues if they match the condition in *step 7*.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要根据 *步骤 7* 中的条件转换这些问题。
- en: Select **New action** followed by **Transition issue**. In the **Destination
    status** field, select **Done** and then click **Save**.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择 **新建动作**，然后选择 **转换问题**。在 **目标状态** 字段中，选择 **已完成**，然后点击 **保存**。
- en: 'Your rule should look similar to the following screenshot:'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的规则应类似于以下截图：
- en: '![Figure 8.9 – Rule to start Jenkins deployment upon sprint closure'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.9 – 冲刺关闭时启动 Jenkins 部署的规则'
- en: '](img/B16551_Figure_8.9.jpg)'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16551_Figure_8.9.jpg)'
- en: Figure 8.9 – Rule to start Jenkins deployment upon sprint closure
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.9 – 冲刺关闭时启动 Jenkins 部署的规则
- en: Finally, name the rule `Start deployment on sprint closure` and click **Turn
    it on** to save and enable the rule.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将规则命名为`开始部署（冲刺关闭时）`，然后点击**启用**以保存并启用规则。
- en: This concludes the final section of this chapter, in which we have learned how
    to use automation rules to integrate with Jenkins to automatically kick off deployment
    builds when a sprint is completed and to transition all the affected development
    tasks to **Done**.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本章的最后一部分，在这一部分中，我们学习了如何使用自动化规则与Jenkins集成，在冲刺完成时自动启动部署构建，并将所有受影响的开发任务转移到**已完成**。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how using automation rules can help us with
    DevOps practices by optimizing our development and operations processes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学会了如何通过使用自动化规则，通过优化我们的开发和运维流程，来帮助我们改进DevOps实践。
- en: We have covered how to use the built-in DevOps automation triggers available
    in Jira Cloud to integrate with our source repositories, such as Bitbucket or
    GitHub. This allows us to keep development issues in Jira in sync with the code
    as it is committed to the source repository.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了如何使用Jira Cloud中内置的DevOps自动化触发器，与我们的源代码仓库（如Bitbucket或GitHub）进行集成。这使我们能够将Jira中的开发任务与提交到源代码仓库的代码保持同步。
- en: In addition, we have also learned how we can achieve similar integrations when
    using Jira Server or Data Center by using incoming webhooks in our rules in place
    of the DevOps triggers available to Jira Cloud.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还学会了如何在使用Jira Server或Data Center时，通过在规则中使用传入Webhook来实现类似的集成，而不是使用Jira Cloud中的DevOps触发器。
- en: Next, we learned how we could use the DevOps pull request triggers available
    in Jira Cloud to automatically synchronize the development tasks in Jira. We also
    learned how to create and manage tracking tasks, which provide greater visibility
    into the overall development process within Jira.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了如何使用Jira Cloud中可用的DevOps拉取请求触发器，自动同步Jira中的开发任务。我们还学会了如何创建和管理跟踪任务，这些任务为Jira中的整体开发过程提供了更大的可视性。
- en: We then learned how, when using GitHub to manage software releases, we can also
    use automation rules to release transition the affected issues in Jira to **Done**
    and how to automatically keep the version in Jira in sync when creating a GitHub
    release. Finally, we learned how to automatically initiate a deployment build
    of a software project in Jenkins whenever a sprint in Jira is completed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们学习了，在使用GitHub管理软件发布时，如何利用自动化规则将受影响的Jira问题转移到**已完成**状态，并在创建GitHub发布时，如何自动保持Jira中的版本同步。最后，我们学会了如何在Jira中完成冲刺时，自动启动Jenkins中的软件项目部署构建。
- en: By introducing automation rules into our Jira processes, we can streamline our
    DevOps processes and drastically reduce the amount of time developers need to
    perform tasks in multiple tools.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将自动化规则引入我们的Jira流程，我们可以简化我们的DevOps流程，并大幅减少开发人员在多个工具中执行任务所需的时间。
- en: In the next chapter, we will be exploring some best practices to follow when
    creating automation rules in Jira.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索在Jira中创建自动化规则时需要遵循的一些最佳实践。
