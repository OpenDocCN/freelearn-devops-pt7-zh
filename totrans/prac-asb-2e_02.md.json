["```\n$ ansible --version\nansible [core 2.15.0] (2.15 82b47c8d5c) last updated 2023/05/19 15:21:43 (GMT +000)\n  config file = None\n  configured module search path = ['/home/james/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']\n  ansible python module location = /home/james/ansible-2.15/ansible/lib/ansible\n  ansible collection location = /home/james/.ansible/collections:/usr/share/ansible/collections\n  executable location = /home/james/ansible-2.15/ansible/bin/ansible\n  python version = 3.10.6 (main, Mar 10 2023, 10:55:28) [GCC 11.3.0] (/usr/bin/python)\n  jinja version = 3.0.3\n  libyaml = True\n```", "```\n$ ssh <username>@web01.example.org\nThe authenticity of host 'web01.example.org (10.0.50.30)' can't be established.\nED25519 key fingerprint is SHA256:hU+saFERGFDERW453tasdFPAkpVws.\nAre you sure you want to continue connecting (yes/no)? yes\npassword:<Input_Your_Password>\n```", "```\n    web01.example.org\n    web02.example.org\n    app01.example.org\n    app02.example.org\n    ```", "```\n$ ping web01.example.org\nPING web01.example.org (10.0.50.30) 56(84) bytes of data.\n64 bytes from web01.example.org (10.0.50.30): icmp_seq=1 ttl=64 time=1.02 ms\n64 bytes from web01.example.org (10.0.50.30): icmp_seq=2 ttl=64 time=1.01 ms\n64 bytes from web01.example.org (10.0.50.30): icmp_seq=3 ttl=64 time=0.957 ms\n64 bytes from web01.example.org (10.0.50.30): icmp_seq=4 ttl=64 time=1.16 ms\n```", "```\n    $ ssh-keygen\n    ```", "```\n$ ssh-keygen\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/james/.ssh/id_rsa): <Enter>\nEnter passphrase (empty for no passphrase): <Press Enter>\nEnter same passphrase again: <Press Enter>\nYour identification has been saved in /home/james/.ssh/id_rsa.\nYour public key has been saved in /home/james/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:1IF0KMMTVAMEQF62kTwcG59okGZLiMmi4Ae/BGBT+24 james@controlnode.example.org\nThe key's randomart image is:\n+---[RSA 2048]----+\n|=*=*BB==+oo |\n|B=*+*B=.o+ . |\n|=+=o=.o+. . |\n|...=. . |\n| o .. S |\n| .. |\n| E |\n| . |\n| |\n+----[SHA256]-----+\n```", "```\n    $ eval $(ssh-agent)\n    $ ssh-add ~/.ssh/id_rsa\n    ```", "```\n    $ ssh-copy-id -i ~/.ssh/id_rsa.pub web01.example.org\n    /usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \"~/.ssh/id_rsa.pub\"\n    /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed\n    /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys\n    james@web01.example.org's password:\n    Number of key(s) added: 1\n    Now try logging into the machine, with: \"ssh 'web01.example.org'\"\n    ansible.builtin.ping command on the hosts you put in your inventory file. You will find that you are not prompted for a password at any point as the SSH connections to all the hosts in your inventory are authenticated with your SSH key pair. So, you should see an output similar to the following:\n\n    ```", "```\n\n    ```", "```\nweb02.example.org | UNREACHABLE! => {\n    \"changed\": false,\n    \"msg\": \"Failed to connect to the host via ssh: ssh: connect to host web02.example.org port 22: Connection refused\",\n    \"unreachable\": true\n-vvvv flag could potentially produce pages of output and so, to save space, we won’t include an example here—experimenting with the verbosity levels is left as an exercise for you. When you generate output with this highest level of verbosity, you will see that it includes many useful details, such as the raw SSH command that was used to generate the connection to the target host in the inventory, along with any error messages that may have resulted from that call. This can be incredibly useful when debugging connectivity or code issues, although the output might be a little overwhelming at first. However, with some practice, you will quickly learn how to interpret it.\nBy now, you should have a good idea of how Ansible communicates with its clients over SSH. Let’s proceed to the next section, where we will look in more detail at the various components that make up Ansible, as this will help us understand how to work with it better.\nBreaking down the Ansible components\nAnsible allows you to define policies, configurations, task sequences, and orchestration steps in playbooks—the limit is really only your imagination. A playbook can be executed to manage your tasks either synchronously or asynchronously on a remote machine, although you will find that just about all examples are synchronous. In this section, you will learn about the main components of Ansible and understand how Ansible employs those components to communicate with remote hosts.\nIn order to understand the various components, we first need an inventory to work from. Let’s create an example one, ideally with multiple hosts in it—here we will reuse the one we created earlier in this chapter. However, you are free to create your own, and while I have set up name resolution for this example, to give machines more friendly names, remember that you can get started with IP addresses if you don’t want to add name resolution just yet.\nTo really understand how Ansible—as well as its various components—works, we first need to create an Ansible playbook. While the ad hoc commands that we have experimented with so far are useful in their own right, they are just single **tasks**, whereas playbooks are organized groups of tasks that are (usually) run in sequence. Conditional logic can be applied and in any other programming language, playbooks would be considered as your code. At the head of the playbook, you should specify the name of your **play**—although this is not mandatory, it is good practice to name all your plays and tasks as, without this, it would be quite hard for someone else to interpret what the playbook does, or even for you to do so if you come back to it after some time.\nLet’s get started with building our first example playbook:\n\n1.  Specify the play name and inventory hosts to run your tasks against at the very top of your playbook. Also, note the use of `---`, which denotes the beginning of a YAML file (all Ansible playbooks that are written in YAML):\n\n    ```", "```\n\n     2.  After this, we will tell Ansible that we want to perform all the tasks in this playbook as a superuser (usually `root`). We do this with the following statement (to aid your memory, think of `become` as shorthand for `become superuser`):\n\n    ```", "```\n\n     3.  After this header, we will specify a task block that will contain one or more tasks to be run in sequence. For now, we will simply create one task to update the version of Apache using the `ansible.builtin.apt` module (because of this, this playbook is only suitable for running against Debian- or Ubuntu-derived hosts). We will also specify a special element of the play called a **handler**. Handlers will be covered in greater detail in [*Chapter 4*](B20846_04.xhtml#_idTextAnchor207), *Playbooks and Roles*, so don’t worry too much about them for now. Simply put, a handler is a special type of task that is called only if something changes. So, in this example, the handler code restarts the web server, but only if it is installed or updated, preventing unnecessary restarts if the playbook is run several times and there are no updates for Apache. The following code performs these functions exactly and should form the basis of your first playbook:\n\n    ```", "```\n\nCongratulations, you now have your very first Ansible playbook! If you run this now, you should see it iterate through all the web hosts in your inventory, where it will install or update in the `apache2` package as required, and then only restart the service where the package was installed/updated.\nIn the following command to run the playbook, we have introduced a new switch, `--limit`, which is used when you want to run a playbook on only part of an inventory. In our example, I have four hosts in my inventory, but I only want to install `apache2` on the ones named `web*`, which I specify using the `--limit web*` option. These, of course, are based on the hostnames I have used in my demo environment for this book, and you should change your limit pattern to match your environment:\n\n```", "```\n\n If you examine the output from the playbook, you can see the value in naming not only the play but also each task that is executed, as it makes interpreting the output of the run a very simple task. You will also see that there are multiple possible results from running a task; in the preceding example, we can see two of these results—`ok` and `changed`. Most of these results are fairly self-explanatory, with `ok` meaning the task ran successfully and that nothing changed as a result of the task completing. An example of this in the preceding playbook is the `Gathering Facts` stage, which is a read-only task that gathers information about the target hosts. As a result, it can only ever return `ok` or a failed status, such as `unreachable`, if the host is down. It should never return `changed`.\nHowever, you can see in the preceding output that both hosts needed to install/upgrade their `apache2` package and, as a result of this, the results from the `Install/Update to the latest of Apache Web Server` task are `changed` for all the hosts. This `changed` result means the task ran successfully (as for `ok`) but that a change was made to the managed node. It also means that our `handler` instance is notified and so the web server service is restarted.\nIf we run the playbook a second time straight away, we know that it is hugely unlikely that the `apache2` package will need upgrading again. Notice how the playbook output differs this time:\n\n```", "```\n\n You can see that this time, the output from the `Install/Update to the latest of Apache Web Server` task is `ok` for both hosts, meaning no changes were applied (the package was not updated). As a result of this, our handler is not notified and does not run—you can see that it does not even feature in the preceding playbook output. This distinction is important—the goal of an Ansible playbook (and the modules that underpin Ansible) should be to only make changes when they need to be made. If everything is all up to date, then the target host should not be altered. Unnecessary restarts to services should be avoided, as should unnecessary alterations to files. In short, Ansible playbooks are (and should be) designed to be efficient and to achieve a target machine state.\nThis has very much been a crash course on writing your first playbook, but hopefully, it has given you a taste of what Ansible can do when you move from single ad hoc commands through to more complex playbooks. Before we explore the Ansible language and components any further, let’s take a more in-depth look at the YAML language that playbooks are written in.\nLearning the YAML syntax\nIn this section, you will learn how to write a YAML file with the correct syntax, and the various constructs you will see time and again on your Ansible automation journey. Ansible uses YAML because it is easier for humans to read and write than other common data formats, such as XML or JSON. There are no commas, curly braces, or tags to worry about, and the enforced indentation in the code ensures that it is tidy and easy on the eye. In addition, there are libraries available in most programming languages for working with YAML.\nThis reflects one of the core goals of Ansible—to produce easy-to-read (and write) code that describes the target state of a given host. Ansible playbooks are (ideally) supposed to be self-documenting, as documentation is often an afterthought in busy technology environments—so, what better way to document than through the automation system responsible for deploying code?\nBefore we dive into the YAML structure, a word on the files themselves. Files written in YAML can optionally begin with `---` (as seen in the example playbook in the previous section) and end with `...`. This applies to all files in YAML, regardless of whether they are consumed by Ansible or another system, and indicates that the file is in the YAML language. You will find that most examples of Ansible playbooks (as well as roles and other associated YAML files) start with `---` but do not end with `...`—the header is sufficient to clearly denote that the file uses the YAML format.\nLet’s explore the YAML language through the example playbook we created in the preceding section:\n\n1.  Lists are an important construct in the YAML language—in fact, although it might not be obvious, the `tasks:` block of the playbook is actually a YAML list. A list in YAML contains all of its items at the same indentation level, with each item in the list preceded by a `-`. For example, we updated the `apache2` package from the preceding playbook using the following code:\n\n    ```", "```\n\nHowever, we could have specified a list of packages to be upgraded as follows:\n\n```", "```\n\n Now, rather than passing a single value to the `name:` key as a string, we pass a YAML-formatted list containing the names of two packages to be installed/updated. Only certain modules support this so do refer to the documentation to establish which ones you can pass lists to.\n\n1.  Dictionaries are another important concept in YAML—they are represented by a `key: value` format, as we have already extensively seen, but all of the items in the dictionary are indented by one more level. This is easiest explained by an example, so consider the following code from our example playbook:\n\n    ```", "```\n\nIn this example (from `handler`), the `ansible.builtin.service` definition is actually a dictionary and both the `name` and `state` keys are indented with two more spaces than the `ansible.builtin.service` key. This higher level of indentation means that the `name` and `state` keys are associated with the `ansible.builtin.service` key, therefore, in this case, telling the `ansible.builtin.service` module which service to operate on (`apache2`) and what to do with it (restart it).\nUsing these examples, we can see that you can produce quite complicated data structures by mixing lists and dictionaries.\n\n1.  As you become more proficient at playbook design (as you progress through the book, you will certainly become more proficient), you may very well start to produce quite complicated variable structures that you will put into their own separate files to keep your playbook code readable. The following is an example of a `variables` file that provides the details of two employees of a company:\n\n    ```", "```\n\nIn this example, you can see that we have a dictionary containing the details of each employee. The employees themselves are list items (you can spot this because the lines start with `-`) and, equally, the employee skills are denoted as list items. You will notice the `fullname`, `role`, `level`, and `skills` keys are at the same indentation level as `name` but do not feature `-` before them. This tells you that they are in the dictionary with the list item itself, and so they represent the details of the employee.\n\n1.  YAML is very literal when it comes to parsing the language and a new line always represents a new line of code. What if you actually need to add a block of text (for example, to a variable)? In this case, you can use a literal block scalar, `|`, to write multiple lines and YAML will faithfully preserve the new lines, carriage returns, and all the whitespace that follows each line (note, however, that the indentation at the beginning of each line is part of the YAML syntax):\n\n    ```", "```\n\nSo, if we were to get Ansible to print the preceding content to the screen, it would display as follows (note that the preceding two spaces have gone—they were interpreted correctly as part of the YAML language and not printed):\n\n```", "```\n\n Similar to the preceding is the folded block scalar, `>`, which does the same as the literal block scalar but does not preserve line endings. This is useful for very long strings that you want to print on a single line, but also want to wrap across multiple lines in your code for the purpose of readability. Take the following variation of our example:\n\n```", "```\n\n Now, if we were to print this, we would see the following:\n\n```", "```\n\n We could add trailing spaces to the preceding example to stop the words from running into each other, but I have not done this here as I wanted to provide you with an easy-to-interpret example.\nAs you review playbooks, variable files, and so on, you will see these structures used over and over again. Although simple in definition, they are very important—a missed level of indentation or a missing `-` instance at the start of a list item can cause your entire playbook to fail to run. As we discovered, you can put all of these various constructs together. One additional example is provided in the following code block of a `variables` file for you to consider, which shows the various examples we have covered all in one place:\n\n```", "```\n\n You can also express both dictionaries and lists in an abbreviated form, known as `employees` variable file:\n\n```", "```\n\n Although this displays exactly the same data structure, you can see how difficult it is to read with the naked eye. Flow collections are not used extensively in YAML and I would not recommend you make use of them yourself, but it is important to understand them in case you come across them. You will also notice that although we’ve started talking about variables in YAML, we haven’t expressed any variable types. YAML tries to make assumptions about variable types based on the data they contain, so if you want to assign `1.0` to a variable, YAML will assume it is a floating-point number. If you need to express it as a string (perhaps because it is a version number), you need to put quotation marks around it, which causes the YAML parser to interpret it as a string instead, such as in the following example:\n\n```", "```\n\n This completes our look at the YAML language syntax. Now that’s complete, in the next section, let’s take a look at ways that you can organize your automation code to keep it manageable and tidy.\nOrganizing your automation code\nAs you can imagine, if you were to write all of your required Ansible tasks in one massive playbook, it would quickly become unmanageable—that is to say, it would be difficult to read, difficult for someone else to pick up and understand, and—most of all—difficult to debug when things go wrong. Ansible provides a number of ways for you to divide your code into manageable chunks; perhaps the most important of these is the use of **roles**. Roles (for the sake of a simple analogy) behave like a library in a conventional high-level programming language. We will go into more detail about roles in [*Chapter 4*](B20846_04.xhtml#_idTextAnchor207), *Playbooks* *and Roles*.\nThere are, however, other ways that Ansible supports splitting your code into manageable chunks, which we will explore briefly in this section as a precursor to the more in-depth exploration of roles later in this book.\nLet’s build up a practical example. To start, we know that we need to create an inventory for Ansible to run against. In this instance, we’ll create four notional groups of servers, with each group containing two servers. Our hypothetical example will contain a frontend server and application servers for a fictional application, located in two different geographic locations. Our inventory file will be called `production-inventory` and the example contents are as follows:\n\n```", "```\n\n Now, obviously, we could just write one massive playbook to address the required tasks on these different hosts, but as we have already discussed, this would be cumbersome and inefficient.\nLet’s instead break the task of automating these different hosts down into smaller playbooks:\n\n1.  Create a playbook to run a connection test on a specific host group, such as `frontends_na_zone`. Put the following contents into the playbook:\n\n    ```", "```\n\n     2.  Now, try running this playbook against the hosts. (Note that we have configured it to connect to a remote user on the inventory system, called `james`. If you wish to attempt this example yourself, you will need to set up your own user account and change the `remote_user` line of your playbook accordingly. Also remember to set up SSH keys and authentication as we demonstrated earlier in this chapter.) When you run the playbook after setting up the authentication, you should see output like the following:\n\n    ```", "```\n    ---\n    - hosts: appservers_emea_zone\n      remote_user: james\n      gather_facts: no\n      tasks:\n        - name: simple connection test\n          ansible.builtin.ping:\n    ```", "```\n\nAs before, you need to ensure you can access these servers, so either create the `james` user and set up authentication to that account or change the `remote_user` line in the example playbook. Once you have done this, you should be able to run the playbook and you will see output similar to this:\n\n```", "```\n\n1.  So far, so good. However, we now have two playbooks that we need to run manually, which only address two of our inventory host groups. If we want to address all four groups, we need to create a total of four playbooks, all of which need to be run manually. This is hardly reflective of best automation practices. What if there was a way to take these individual playbooks and run them together from one top-level playbook? This would enable us to divide our code to keep it manageable but also prevent a lot of manual effort when it comes to running the playbooks. Fortunately, we can do exactly that by taking advantage of the `ansible.builtin.import_playbook` directive in a top-level playbook that we will call `site.yml`:\n\n    ```", "```\n\nNow, when you run this single playbook using the (by now, familiar) `ansible-playbook` command, you will see that the effect is the same as if we had actually run both playbooks back to back. In this way, even before we explore the concept of roles, you can see that Ansible supports splitting up your code into manageable chunks without needing to run each chunk manually:\n\n```", "```\n\n There’s much more that you can do with geographically diverse environments, such as our simple example here, as we have not even touched on things such as placing variables in your inventory (which, for example, associates different parameters with different environments). We will explore this in more detail in [*Chapter 3*](B20846_03.xhtml#_idTextAnchor158), *Defining* *Your Inventory*.\nHowever, hopefully, this has armed you with enough knowledge that you can start making informed choices about how to organize the code for your playbooks. As you complete further chapters of this book, you will be able to establish whether you wish to make use of roles or the `ansible.builtin.import_playbook` directive (or perhaps even both) as part of your playbook organization.\nLet’s carry on with our practical introduction to Ansible in the next section, with a look at the configuration file and some of the key directives that you might find valuable.\nExploring the configuration file\nAnsible’s behavior is, in part, defined by its configuration file. The central configuration file (which impacts the behavior of Ansible for all users on the system) can be found at `/etc/ansible/ansible.cfg`. However, this is not the only place Ansible will look for its configuration; in fact, it will look in the following locations, from the top to the bottom.\nThe first instance of the file is the configuration it will use; all of the others are ignored, even if they are present:\n\n*   `ANSIBLE_CONFIG`: The file location specified by the value of this environment variable, if set\n*   `ansible.cfg`: In the current working directory\n*   `~/.ansible.cfg`: In the home directory of the user\n*   `/etc/ansible/ansible.cfg`: The central configuration that we previously mentioned\n\nIf you installed Ansible through a package manager, such as `dnf`, `yum`, or `apt`, you will almost always find a default configuration file called `ansible.cfg` in `/etc/ansible`. However, if you built Ansible from the source or installed it via `pip`, the central configuration file will not exist, and you will need to create it yourself. A good starting point used to be to reference the example Ansible configuration file that was included with the source code. However, since the release of `ansible-core` 2.12, you can now generate an example configuration file with all the available options present (but commented out) using this command:\n\n```", "```\n\n As you will almost certainly be working with a version of `ansible-core` newer than this, we’ll assume this for the remainder of this section. Specifically, we will detail how to locate Ansible’s running configuration and how to manipulate it. Most people who install Ansible find that they can get a long way with Ansible before they have to modify the default configuration, as it has been carefully designed to work in a great many scenarios. Indeed, all the example code run so far in this book has been performed on a copy of Ansible installed via PIP, with no configuration changes made.\nNonetheless, it is important to know a little about configuring Ansible in case you come across an issue in your environment that can only be changed by modifying the configuration.\nLet’s get started by exploring the default configuration that is provided with Ansible:\n\n1.  The command in the following code block lists the current configuration parameters supported by Ansible. It is incredibly useful because it tells you both the environment variable that can be used to change the setting (see the `env` field) as well as the configuration file parameter and section that can be used (see the `ini` field). Other valuable information, including the default configuration values and a description of the configuration, is given (see the `default` and `description` fields, respectively). Run the following command to explore the output:\n\n    ```", "```\n\nThe following is an example of the kind of output you will see. There are, of course, many pages to it, but a snippet is shown here as an example:\n\n```", "```\n\n1.  If you want to see a straightforward display of all the possible configuration parameters, along with their current values (regardless of whether they are configured from environment variables or a configuration file in one of the previously listed locations), you can run the following command:\n\n    ```", "```\n\nThe output shows all the configuration parameters (in an environment variable format), along with the current settings. If the parameter is configured with its default value, you are told so (see the `(default)` element after each parameter name). The output is also color-coded by default, with parameters at their default displayed in green, while those that have been changed are yellow (just like the color coding from an Ansible playbook run):\n\n```", "```\n\n1.  Let’s see the effect on this output by editing one of the configuration parameters. Let’s do this by setting an environment variable, as follows (this command has been tested in the `bash` shell, but may differ for other shells):\n\n    ```", "```\n\nNow, let’s rerun the `ansible-config` command, but this time get it to tell us only the parameters that have been changed from their default values:\n\n```", "```\n# Set my configuration variables\n[defaults]\ninventory = /home/james/ansible-hosts ; Here is the path of the inventory file\n```", "```\n$ ansible-config dump --only-change\nANSIBLE_FORCE_COLOR(env: ANSIBLE_FORCE_COLOR) = True\nCONFIG_FILE() = /home/james/code/chapter02/ansible.cfg\nDEFAULT_HOST_LIST(/home/james/code/chapter02/ansible.cfg) = ['/home/james/ansible-hosts']\n```", "```\n    $ ansible --help\n    ```", "```\n    $ ansible -i production-inventory --list-host appservers_emea_zone\n    ```", "```\n$ ansible -i production-inventory --list-host appservers_emea_zone\n  hosts (2):\n    appserver1-emea.example.com\nansible-playbook executable file, too. We have already seen a few of these in the previous examples of this book and there’s more that we can do. For example, earlier, we discussed the use of ssh-agent to manage multiple SSH authentication keys. While this makes running playbooks simple (as you don’t have to pass any authentication parameters to Ansible), it is not the only way of doing this. You can use one of the command-line arguments for ansible-playbook to specify the private SSH key file, instead, as follows:\n\n```", "```\n\n Similarly, in the preceding section, we specified the `remote_user` variable for Ansible to connect with in the playbook. However, command-line arguments can also set this parameter for the playbook; so, rather than editing the `remote_user` line in the playbook, we could remove it altogether and instead run it using the following command-line string:\n\n```", "```\n\n The ultimate aim of Ansible is to make your life simpler and to complete mundane day-to-day tasks for you. As a result, there is no right or wrong way to do this—you can specify your private SSH key using a command-line argument or make it available using `ssh-agent`. Similarly, you can put the `remote_user` line in your playbook or use the `--user` parameter on the command line. Ultimately, the choice is yours, but it is important to consider that if you are distributing a playbook to multiple users and they all have to remember to specify the remote user on the command line, will they actually remember to do it? What will the consequences be if they don’t? If the `remote_user` line is present in the playbook, will that make their lives easier and be less prone to error because the user account has been set in the playbook itself?\nAs with the configuration of Ansible, you will use a small handful of the command-line arguments frequently and there will be many that you may never touch. The important thing is that you know they are there and how to find out about them, and you can make informed decisions about when to use them. Let’s proceed to the next section, where we will look in more detail at ad hoc commands with Ansible.\nUnderstanding ad hoc commands\nWe have already seen a handful of ad hoc commands so far in this book, but to recap, they are single tasks you can run with Ansible, making use of Ansible modules without the need to create or save playbooks. They are very useful for performing quick, one-off tasks on a number of remote machines or for testing and understanding the behavior of the Ansible modules that you intend to use in your playbooks. They are both a great learning tool and a quick and dirty (because you never document your work with a playbook) automation solution.\nAs with every Ansible example, we need an inventory to run against. Let’s reuse our `production-inventory` file from before:\n\n```", "```\n\n Now, let’s start with perhaps the quickest and dirtiest of ad hoc commands—running a raw shell command on a group of remote machines. Suppose that you want to check that the date and time of all the frontend servers in EMEA are in sync—you could do this by using a monitoring tool or by manually logging in to each server in turn and checking the date and time. However, you can also use an Ansible ad hoc command:\n\n1.  Run the following ad hoc command to retrieve the current date and time from all of the `frontends_emea_zone` servers:\n\n    ```", "```\n\nYou will see that Ansible faithfully logs in to each machine in turn and runs the `date` command, returning the current date and time. Your output will look something like the following:\n\n```", "```\n\n1.  This command is run with the user account you are logged in to when the command is run. You can use a command-line argument (discussed in the previous section) to run it as a different user:\n\n    ```", "```\n    $ ansible -i production-inventory frontends_emea_zone -a /usr/sbin/pvs -u james --become\n    frontend2-emea.example.com | FAILED | rc=-1 >>\n    Missing sudo password\n    frontend1-emea.example.com | FAILED | rc=-1 >>\n    james is in /etc/sudoers, it is not allowed to run commands as root without entering a sudo password. Luckily, there’s a switch to get Ansible to prompt us for this at runtime, meaning we don’t need to edit our /etc/sudoers file:\n\n    ```", "```\n    $ ansible -i production-inventory frontends_emea_zone -m ansible.builtin.copy -a \"src=/etc/hosts dest=/tmp/hosts\"\n    frontend2-emea.example.com | CHANGED => {\n        \"ansible_facts\": {\n            \"discovered_interpreter_python\": \"/usr/bin/python3\"\n        },\n        \"changed\": true,\n        \"checksum\": \"02b369653b5171fe264d0ac91c331531d04f375d\",\n        \"dest\": \"/tmp/hosts\",\n        \"gid\": 1001,\n        \"group\": \"james\",\n        \"md5sum\": \"cd9654dbef8a534df2557531038e03a7\",\n        \"mode\": \"0664\",\n        \"owner\": \"james\",\n        \"size\": 427,\n        \"src\": \"/home/james/.ansible/tmp/ansible-tmp-1682433595.1356337-8575-192421314639198/source\",\n        \"state\": \"file\",\n        \"uid\": 1001\n    }\n    frontend1-emea.example.com | CHANGED => {\n        \"ansible_facts\": {\n            \"discovered_interpreter_python\": \"/usr/bin/python3\"\n        },\n        \"changed\": true,\n        \"checksum\": \"02b369653b5171fe264d0ac91c331531d04f375d\",\n        \"dest\": \"/tmp/hosts\",\n        \"gid\": 1001,\n        \"group\": \"james\",\n        \"md5sum\": \"cd9654dbef8a534df2557531038e03a7\",\n        \"mode\": \"0664\",\n        \"owner\": \"james\",\n        \"size\": 427,\n        \"src\": \"/home/james/.ansible/tmp/ansible-tmp-1682433595.1226285-8574-79002739194384/source\",\n        \"state\": \"file\",\n        \"uid\": 1001\n    }\n    ```", "```\n\n    ```", "```\n\nThe preceding output not only shows that the copy was performed successfully to both hosts but also all the output values from the `ansible.builtin.copy` module. This, again, can be very helpful later when you are developing playbooks as it enables you to understand exactly how the module works and what output it produces in cases where you need to perform further work with that output. As we progress through this book, this will make more sense, so don’t worry right now if it doesn’t make sense.\nYou will also note that all arguments passed to the module must be enclosed in quotation marks (`\"`). All arguments are specified as `key=value` pairs and no spaces should be added between `key` and `value` (for example, `key = value` is not acceptable). If you need to place quotation marks around one of your argument values, you can escape them using the backslash character (for example, `-a \"src=/etc/yum.conf` `dest=\\\"/tmp/yum file.conf\\\"\"`).\nAll examples we have performed so far are very quick to execute and run, but this is not always the case with computing tasks. When you have to run an operation for a long time—say, more than two hours—you should consider running it as a background process. In this instance, you can run the command asynchronously and confirm the result of that execution later.\nFor example, to execute `sleep 2h` asynchronously in the background with a timeout of 7,200 seconds (`-B`) and without polling (`-P`), use this command:\n\n```", "```\n\n Note that the output from this command gives a unique job ID for each task on each host. Let’s now say that we want to see how this task proceeds on the second frontend server. Simply issue the following command from your Ansible control machine:\n\n```", "```\n\n Here, we can see that the job has started but not finished. If we now kill the `sleep` command that we issued and check on the status again, we can see the following:\n\n```", "```\n\n Here, we see a `FAILED` status result because the `sleep` command was killed; it did not exit cleanly and returned a `-15` code (see the `rc` parameter). When it was killed, no output was sent to either `stdout` or `stderr`, but if it had been, Ansible would have captured it and displayed it in the preceding code, which would aid you in debugging the failure. Lots of other useful information is included, including how long the task actually ran for, the end time, and so on. Similarly, useful output is also returned when the task exits cleanly.\nThat concludes our look at ad hoc commands in Ansible. By now, you should have a fairly solid grasp of the fundamentals of Ansible, but there’s one important thing we haven’t looked at yet, even though we briefly touched on it—variables and how to define them. We’ll proceed to look at this in the next section.\nDefining variables\nIn this section, we will explore the topic of variables and how they can be defined in Ansible. You will learn how variables should be defined step by step and understand how to work with them in Ansible.\nAlthough automation removes much of the repetition from previously manual tasks, not every single system is identical. If two systems differ in some minor way, you could write two unique playbooks—one for each system. However, this would be inefficient and wasteful, as well as difficult to manage as time goes on (for example, if the code in one playbook is changed, how can you ensure that it is updated in the second variant?).\nEqually, you might need to use a value from one system in another—perhaps you need to obtain the hostname of a database server and make it available to another. All of these issues can be addressed with variables as they allow the same automation code to run with parameter variations, as well as values to pass from one system to another (although this must be handled with some care).\nLet’s get started with a practical look at defining variables in Ansible.\nVariables in Ansible should have well-formatted names that adhere to the following rules:\n\n*   The name of the variable must only include letters, underscores, and numbers. Spaces are not allowed.\n*   The name of the variable can only begin with a letter—it can contain numbers but cannot start with one.\n\nFor example, the following are good variable names:\n\n*   `external_svc_port`\n*   `internal_hostname_ap1`\n\nThe following examples are all invalid, however, and cannot be used (if you are familiar with Python, you will know that these restrictions also apply to Python code, which Ansible, being written in Python, inherits this from):\n\n*   `appserver-zone-na`\n*   `cache` `server ip`\n*   `dbms.server.port`\n*   `01appserver`\n\nAs discussed in the *Learning the YAML syntax* section, variables can be defined in a dictionary structure, such as the following. All values are declared in key-value pairs:\n\n```", "```\n\n In order to retrieve a specific field from the preceding dictionary structure, you can use either one of the following notations:\n\n```", "```\n\n There are some exceptions to this; for example, you should use bracket notation if the variable name starts and ends with two underscores (for example, `__variable__`) or contains known public attributes (or even variables that are generated during the playbook run), such as the following:\n\n*   `as_integer_ratio`\n*   `symmetric_difference`\n\nYou can find more information on this at https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#creating-valid-variable-names.\nThis dictionary structure is valuable when defining host variables. Although earlier in this chapter we worked with a fictional set of employee records defined as an Ansible `variables` file, you could use this to specify something, such as some `redis` server parameters:\n\n```", "```\n\n These could then be applied through your playbook and one common playbook could be used for all `redis` servers, regardless of their configuration, as changeable parameters such as the `port` and `master` servers are all contained in the variables.\nYou can also pass set variables directly in a playbook, and even pass them to roles that you call. For example, the following playbook code calls four hypothetical roles and each assigns a different value to the `username` variable for each one. These roles could be used to set up various administration roles on a server (or multiple servers), with each passing a changing list of usernames as people come and go from the company:\n\n```", "```\n\n To access variables from within a playbook, you simply place the variable name inside quoted pairs of curly braces. Consider the following example playbook (based loosely on our previous `redis` example):\n\n```", "```\n\n Here, we define a variable in the playbook itself called `redis`. This variable is a dictionary, containing a number of parameters that might be important for our server. To access the contents of these variables, we use pairs of curly braces around them (as described previously) and the entire string is encased in quotation marks, which means we don’t have to individually quote the variables. If you run the playbook on a local machine, you should see an output that looks as follows:\n\n```", "```\n\n Although we are accessing these variables here to print them in a debug message, you could use the same curly brace notation to assign them to module parameters, or for any other purpose that your playbook requires them for.\nAlso note the special inventory format we used here:\n\n*   `-i localhost,` – This tells `ansible-playbook` to read a list of literal hostnames from the command line, removing the need to define an inventory file.\n*   `-c local` – This replaces the need to set up SSH authentication with the local host, by simply using the `local` connection mechanism. This is incredibly useful when running commands on the local machine itself.\n\nAnsible, just like many languages, has specially reserved variables that take on particular meanings in playbooks. In Ansible, these are known as magic variables and you can find a full list of them at [https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.xhtml](https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.xhtml). Needless to say, you should not attempt to use any magic variable names for your own variables. Some common magic variables you might come across are as follows:\n\n*   `inventory_hostname`: The hostname for the current host that is iterated over in the play\n*   `groups`: A dictionary of the host groups in the inventory, along with the host membership of each group\n*   `group_names`: A list of the groups the current host (specified by `inventory_hostname`) is a part of\n*   `hostvars`: A dictionary of all the hosts in the inventory and the variables assigned to each of them\n\nFor example, the host variables for all the hosts can be accessed at any point in the playbook using `hostvars`, even if you are only operating on one particular host. Magic variables are surprisingly useful in playbooks and you will rapidly start to find yourself using them, so it is important to be aware of their existence.\nYou should also note that you can specify Ansible variables in multiple locations. Ansible has a strict order of variable precedence and you can take advantage of this by setting default values for variables in a place that has low precedence and then overriding them later in the play. This is useful for a variety of reasons, especially where an undefined variable could cause havoc when a playbook is run (or even when the playbook would fail as a result of this). We have not yet discussed all of the places that variables can be stored, so the full list of variable precedence order is not given here.\nIn addition, it can change between Ansible releases, so it is important that you refer to the documentation when working with and understanding variable precedence—go to [https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable) for more information.\nThat concludes our brief overview of variables in Ansible, although we will see them used again in later examples in this book. Let’s now round off this chapter with a look at Jinja2 filters, which add a whole world of power to your variable definitions.\nUnderstanding Jinja2 filters\nAs Ansible is written in Python, it inherits an incredibly useful and powerful templating engine called Jinja2\\. We will look at the concept of templating later in this book, so for now, we will focus on one particular aspect of Jinja2 known as filtering. Jinja2 filters provide an incredibly powerful framework that you can use to manipulate and transform your data. Perhaps you have a string that you need to convert into lowercase, for example—you could apply a Jinja2 filter to achieve this. You can also use it to perform pattern matching, search and replace operations, and much more. There are many hundreds of filters for you to work with, and in this section, we hope to empower you with a basic understanding of Jinja2 filters and some practical knowledge about how to apply them, as well as showing you where to get more information about them if you wish to explore the subject further.\nIt is worth noting that Jinja2 operations are performed on the Ansible control node and only the results of the filter operation are sent to the remote hosts. This is done by design, both for consistency and to reduce the workload on the individual nodes as much as possible.\nLet’s explore this through a practical example. Suppose we have a YAML file containing some data that we want to parse. We can quite easily read a file from the machine filesystem and capture the result using the `register` keyword (`register` captures the result of the task and stores it in a variable—in the case of running the `ansible.builtin.shell` module, it captures all the output from the command that was run).\nOur YAML data file might look as follows:\n\n```", "```\n\n Now, we could create a playbook to read this file and register the result, but how can we actually turn it into a variable structure that Ansible can understand and work with? Let’s consider the following playbook:\n\n```", "```\n\n The `ansible.builtin.shell` module does not necessarily run from the directory that the playbook is stored in, so we cannot guarantee that it will find our `multiple-document-strings.yaml` file even when it is in the same directory as the playbook. The `ansible.builtin.copy` module does, however, source files from the current (playbook) directory, so it is useful to use it to copy it to a known location (such as `/tmp`) for the `ansible.builtin.shell` module to read the file from. The `ansible.builtin.debug` module is then run in a `loop`. The `loop` is used to iterate over all of the lines of `stdout` from the `ansible.builtin.shell` command, applying two Jinja2 filters—`from_yaml_all` and `list` to the output line by line.\nThe `from_yaml_all` filter parses the source document lines as YAML and then the `list` filter converts the parsed data into a valid Ansible list. If we run the playbook, we should see Ansible’s representation of the data structure from within our original file:\n\n```", "```\n\n As you can see, we have generated a list of dictionaries that in themselves contain the key-value pairs.\nIf this data structure was already stored in our playbook, we could take this one step further and use the `items2dict` filter to turn the list into true `key: value` pairs, removing the `key` and `value` items from the data structure. For example, consider this second playbook:\n\n```", "```\n\n Now, if we run this, we can see that our data is converted into a nice, neat set of `key:` `value` pairs:\n\n```", "```\n\n Observe the warning at the top of the playbook. Ansible displays a warning if you attempt to use a reserved name for a variable, as we did here. Normally, you should not create a variable with a reserved name, but the example here demonstrates both how the filter works and how Ansible will attempt to warn you if you do something that might cause problems.\nEarlier in this section, we used the `ansible.builtin.shell` module to read a file and used `register` to store the result in a variable. This is perfectly fine, if a little inelegant. Jinja2 contains a series of `lookup` filters that, among other things, can read the contents of a given file. Let’s examine the behavior of the following playbook:\n\n```", "```\n\n When we run this, we can see that Ansible has captured the contents of the `/etc/hosts` file for us, without us needing to resort to the `ansible.builtin.copy` and `ansible.builtin.shell` modules as we did earlier:\n\n```", "```\n\n There are many other filters that you might be interested in exploring and a full list can be found in the official Jinja2 documentation ([https://jinja.palletsprojects.com/en/3.1.x/](https://jinja.palletsprojects.com/en/3.1.x/)). The following are a handful of other examples that will give you an idea of the kinds of things that Jinja2 filters can achieve for you, from quoting strings to concatenating lists, to obtaining useful path information for a file:\n\n```", "```\n\n That concludes our look at Jinja2 filtering. It is a massive topic that deserves a book all to itself, but, as ever, I hope that this practical guide has given you some pointers on how to get started and where to find information.\nSummary\nAnsible is a very powerful and versatile automation engine that can be used for a wide variety of tasks. Understanding the basics of how to work with it is of paramount importance, before addressing the more complex challenges of playbook creation and large-scale automation. Ansible relies on a language called YAML, a simple-to-read (and write) syntax that supports the rapid development of easy-to-read and easy-to-maintain code and inherits a number of valuable features from the Python language that it is written in, including Jinja2 filtering.\nIn this chapter, you learned the fundamentals of working with various Ansible programs. You then learned about the YAML syntax and the ways that you can break down your code into manageable chunks to make it easier to read and maintain. We explored the use of ad hoc commands in Ansible, variable definition and structure, and how to make use of Jinja2 filters to manipulate the data in your playbooks.\nIn the next chapter, we will take a more in-depth look at Ansible inventories and explore some of the more advanced concepts of working with them that you may find useful.\nQuestions\n\n1.  Which component of Ansible allows you to define a block to execute task groups as a play?\n    1.  `handler`\n    2.  `service`\n    3.  `hosts`\n    4.  `tasks`\n    5.  `name`\n2.  Which basic syntax from the YAML format do you use to start a file?\n    1.  `###`\n    2.  `---`\n    3.  `%%%`\n    4.  `===`\n    5.  `***`\n3.  True or false – in order to interpret and transform output data in Ansible, you need to use Jinja2 templates.\n    1.  True\n    2.  False\n\nFurther reading\nTo find out about more configuration variables, go to [https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#ansible-configuration-settings](https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#ansible-configuration-settings).\n\n```", "```\n\n```"]