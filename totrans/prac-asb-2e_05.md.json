["```\n[frontends]\nfrt01.example.com\n[appservers]\napp01.example.com\n```", "```\n$ ansible -i hosts appservers -m ping\n```", "```\n$ ansible -i hosts appservers -m ping\napp01.example.com | SUCCESS => {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n```", "```\n$ ansible -i hosts appservers -m command -a \"/bin/echo 'hello modules'\"\n```", "```\n$  ansible -i hosts appservers -m command -a \"/bin/echo 'hello modules'\"\napp01.example.com | CHANGED | rc=0 >>\nhello modules\n```", "```\n    $ ansible-doc -l\n    ```", "```\namazon.aws.autoscaling_group Create or delete AWS AutoScaling..\namazon.aws.autoscaling_group_info Gather information about...\namazon.aws.aws_az_info Gather information about availability...\namazon.aws.aws_caller_info Get information about the user...\n```", "```\n$ ansible-doc -l | wc -l\n7484\n```", "```\n    $ ansible-doc -l | grep s3\n    amazon.aws.s3_bucket Manage S3 buckets in AWS...\n    amazon.aws.s3_object_info Gather informatio...\n    community.aws.s3_bucket_info Li...\n    aws_s3 module – just as we did on the website, simply run the following:\n\n    ```", "```\n\n    ```", "```\n$ ansible-doc aws_s3\n> AMAZON.AWS.S3_OBJECT    (/Users/danieloh/Library/Python/3.11/lib/python/site-packages/ansible_collections/amazon/aws/plugins/modules/s3_object.py)\n        This module allows the user to manage the objects and directories within S3 buckets. Includes support for creating and deleting objects and directories, retrieving\n        objects as files or strings, generating download links and copying objects that are already stored in Amazon S3\\. Support for creating or deleting S3 buckets with\n...\nADDED IN: version 1.0.0 of amazon.aws\n  * note: This module has a corresponding action plugin.\nOPTIONS (= is mandatory):\n- access_key\n        AWS access key ID.\n        See the AWS documentation for more information about access tokens https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.xhtml#access-keys-and-secret-\nansible-doc tells us about the module, provides a list of all of the arguments (OPTIONS) that we can pass it, and as we scroll down, even gives some working examples and possible return values. We shall explore the topic of return values in the next section as they are important to understand, especially as we approach the topic of developing modules.\nModule return values\nAs we discussed earlier in this chapter, Ansible modules return their results as structured data, formatted behind the scenes in JSON. You came across this return data in the previous example, both in the form of an exit code and where we used the `register` keyword to capture the results of a task in an Ansible variable. In this section, we shall explore how to discover the return values for an Ansible module so that we can work with them later on in a playbook, for example, with conditional processing (see [*Chapter 4*](B20846_04.xhtml#_idTextAnchor207), *Playbooks* *and Roles*).\nDue to conserving space, we shall choose what is perhaps one of the simplest Ansible modules to work with when it comes to return values – the `ping` module.\nWithout further ado, let’s use the `ansible-doc` tool that we learned about in the previous section and see what this says about the return values for this module:\n\n```", "```\n\n If you scroll to the bottom of the output from the preceding command, you should see something like this:\n\n```", "```\n\n Hence, we can see that the `ping` module will only return one value, and that is called `ping`. `description` tells us what we should expect this particular return value to contain, while the `returned` field tells us that it will only be returned on `success` (if it were to be returned on other conditions, these would be listed here). The `type` return value is a string (denoted by `str`), and although you can change the value with an argument provided to the `ping` module, the default return value (and hence `sample`) is `pong`.\nNow, let’s see what this looks like in practice. For example, there’s nothing contained in those return values that would tell us whether the module ran successfully and whether anything was changed; however, we know that these are fundamental pieces of information about every module run.\nLet’s put a very simple playbook together. We’re going to run the `ping` module with no arguments, capture the return values using the `register` keyword, and then use the `debug` module to dump the return values onto the Terminal:\n\n```", "```\n\n Now, let’s see what happens when we run this playbook:\n\n```", "```\n\n Notice that the `ping` module does indeed return a value called `ping`, which contains the `pong` string (as the ping was successful). However, you can see that there are, in fact, two additional return values that were not listed in the Ansible documentation. These accompany every single task run, and are hence implicit – that is to say, you can assume they will be among the data that’s returned from every module. The `changed` return value will be set to `true` if the module run resulted in a change on the target host, while the `failed` return value will be set to `true` if the module run failed for some reason.\nUsing the `debug` module to print the output from a module run is an incredibly useful trick if you want to gather more information about a module, how it works, and what sort of data is returned. At this point, we’ve covered just about all of the fundamentals of working with modules, so in the next section, we’ll make a start on developing our very own (simple) module.\nDeveloping custom modules\nNow that we’re familiar with modules, how to call them, how to interpret their results, and how to find documentation on them, we can make a start on writing a simple module. Although this will not include the deep and intricate functionality of many of the modules that ship with Ansible, it is hoped that this will give you enough information to proceed with confidence when you build out your own, more complex, ones.\nOne important point to note is that Ansible is written in Python 3, and as such, so are its modules. As a result, you will need to write your module in Python 3; to get started with developing your own module, you will need to make sure you have Python 3 and a few essential tools installed. If you are already running Ansible on your development machine, you probably have the required packages installed, but if you are starting from scratch, you will need to install Python 3, the Python 3 package manager (`pip3`), and perhaps some other development packages. The exact process will vary widely between operating systems, but here are some examples to get you started:\n\n*   On Fedora, you would run the following command to install the required packages:\n\n    ```", "```\n\n     *   Similarly, on CentOS, you would run the following command to install the required packages:\n\n    ```", "```\n\n     *   On Ubuntu, you would run the following commands to install the packages you need:\n\n    ```", "```\n\n     *   If you are working on macOS and are using the Homebrew packaging system, the following command will install the packages you need:\n\n    ```", "```\n\nOnce you have the required packages installed, you will need to clone the Ansible Git repository to your local machine as there are some valuable scripts in there that we will need later on in the module development process. Use the following command to clone the Ansible repository to your current directory on your development machine:\n\n```", "```\n\n Finally (although optionally), it is good practice to develop your Ansible modules in a **virtual environment** (**venv**) as this means any Python packages you need to install go in here, rather than in with your global system Python modules. Installing modules for the entire system in an uncontrolled manner can, at times, cause compatibility issues or even break local tools, so although this is not a required step, it is highly recommended.\nThe exact command to create a virtual environment for your Python module development work will depend on both the operating system you are running and the version of Python you are using. You should refer to the documentation for your Linux distribution for more information; however, the following commands were tested on CentOS 8 with the default Python 3.11 and higher to create a virtual environment called `moduledev` inside the Ansible source code directory you just cloned from GitHub:\n\n```", "```\n\n With our development environment set up, let’s start writing our first module. This module will be very simple as it’s beyond the scope of this book to provide an in-depth discussion about how to write large amounts of Python code. However, we will code something that can use a function from a Python library to copy a file locally on the target machine.\nThis overlaps heavily with existing module functionality, but it will serve as a nice concise example of how to write a simple Python program in a manner that allows Ansible to make use of it as a module. Now, let’s start coding our first module:\n\n1.  In your preferred editor, create a new file called (for example) `remote_filecopy.py`:\n\n    ```", "```\n\n     2.  Start with a shebang to indicate that this module should be executed with Python:\n\n    ```", "```\n\n     3.  Although not mandatory, it is good practice to add copyright information, as well as your details, in the headers of your new module. By doing this, anyone using it will understand the terms under which they can use, modify, or redistribute it. The text given here is merely an example; you should investigate the various appropriate licenses for yourself and determine which is the best for your module:\n\n    ```", "```\n\n     4.  It is also good practice to add an Ansible metadata section that includes `metadata_version`, `status`, and `supported_by` information immediately after the copyright section. Note that the `metadata_version` field represents the Ansible metadata version (which, at the time of writing, should be `1.1`) and is not related to the version of your module or the Ansible version you are using. The values suggested in the following code will be fine for just getting started, but if your module gets accepted into the official Ansible source code, they are likely to change:\n\n    ```", "```\n\n     5.  Remember `ansible-doc` and that excellent documentation that is available on the Ansible documentation website? That all gets automatically generated from special sections you add to this file. Let’s get started by adding the following code to our module:\n\n    ```", "```\n\nPay particular attention to the `author` dictionary – to pass the syntax checks for inclusion in the official Ansible code base, the author’s name should be appended with their GitHub ID in brackets. If you don’t do this, your module will still work, but it won’t pass the test we’ll perform later.\nNotice how the documentation is in YAML format, enclosed between triple single quotes?\nThe fields listed should be common to just about all modules, but naturally, if your module takes different options, you would specify these so that they match your module.\n\n1.  The examples that you will find in the documentation are also generated from this file – they have a special documentation section immediately after `DOCUMENTATION` and should provide practical examples of how you might create a task using your module, as shown in the following example:\n\n    ```", "```\n\n     2.  The data that’s returned by your module to Ansible should also be documented in its own section. Our example module will return the following values:\n\n    ```", "```\n\n     3.  Immediately after we have finished our documentation section, we should import any Python modules we’re going to use. Here, we will include the `shutil` module, which will be used to perform our file copy:\n\n    ```", "```\n    def main():\n        module = AnsibleModule(\n            argument_spec = dict(\n                source=dict(required=True, type='str'),\n                dest=dict(required=True, type='str')\n            ),\n        )\n    ```", "```\n\n     4.  At this stage, we have everything we need to write our module’s functional code – even the options that it was called with. Hence, we can use the Python `shutil` module to perform the local file copy, based on the arguments provided:\n\n    ```", "```\n\n     5.  At this point, we’ve executed the task our module was designed to complete. However, it is fair to say that we’re not done yet – we need to exit the module cleanly and provide our return values to Ansible. Normally, at this point, you would write some conditional logic to detect whether the module was successful and whether it performed a change on the target host or not. However, for simplicity, we’ll simply exit with the `changed` status every time – expanding this logic and making the return status more meaningful is left as an exercise for you:\n\n    ```", "```\n\nThe `module.exit_json` method comes from `AnsibleModule`, which we created earlier – remember, we said it was important to know that data was passed back and forth using JSON!\n\n1.  As we approach the end of our module code, we must now tell Python where it can import the `AnsibleModule` object from. This can be done with the following line of code:\n\n    ```", "```\n\n     2.  Now, let’s look at the final two lines of code for the module – this is where we tell the module that it should be running the `main` function when it starts:\n\n    ```", "```\n\nThat’s it – with a series of well-documented steps, you can write your own Ansible modules in Python. The next step is, of course, to test it (and you will need to write formal tests to merge it with Ansible’s GitHub repository). Before we test it in Ansible, let’s see whether we can run it manually in the shell. Of course, to make the module think it is being run within Ansible, we must generate some arguments in – you guessed it – JSON format. Create a file with the following contents to provide the arguments:\n\n```", "```\n\n Armed with this little snippet of JSON, you can execute your module directly with Python. If you haven’t already done so, you’ll need to set up your Ansible development environment as follows. Note that we also manually create the source file, `/tmp/foo`, so that our module can perform the file copy:\n\n```", "```\n\n Now, you’re finally ready to run your module for the first time. You can do this as follows:\n\n```", "```\n\n Success! Your module works – and it both ingests and produces JSON data, as we discussed earlier in this chapter. Of course, there’s much more to add to your module – we’ve not addressed `failed` or `ok` returns from the module, nor does it support check mode. However, we’re off to a flying start. If you want to learn more about Ansible modules and fleshing out your functionality, you can find more details here: [https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.xhtml).\nNote that when it comes to testing your module, creating arguments in a JSON file is hardly intuitive, although, as we have seen, it does work well. Luckily for us, it is easy to run our Ansible module in a playbook! By default, Ansible will check the playbook directory for a subdirectory called `library/` and will run referenced modules from here. Hence, we might create the following:\n\n```", "```\n\n Now, create a simple inventory file in this playbook directory, just as we did previously, and add a playbook with the following contents:\n\n```", "```\n\n For clarity, your final directory structure should look like this:\n\n```", "```\n\n Now, try running the playbook in the usual manner and see what happens:\n\n```", "```\n\n Success! Not only have you tested your Python code locally, but you have also successfully run it on two remote servers in an Ansible playbook. That was really easy, which proves just how straightforward it is to get started expanding your Ansible modules so that they meet your own bespoke needs.\nDespite the success of running this piece of code, we’ve not checked the documentation yet, nor tested its operation from Ansible. Before we address these issues in more detail, in the next section, we’ll take a look at some of the common pitfalls of module development and how to avoid them.\nAvoiding common pitfalls\nYour modules must be well thought out and handle error conditions gracefully – people are going to rely on your module someday to automate a task on perhaps thousands of servers, so the last thing they want is to spend significant amounts of time debugging errors, especially trivial ones that could have been trapped or handled gracefully. In this section, we’ll look specifically at error handling and ways to do this so that playbooks will still run and exit gracefully.\nOne piece of overall guidance before we get started is that just like documentation receives a high degree of attention in Ansible, so should your error messages. They should be meaningful and easy to interpret, and you should steer clear of meaningless strings such as `Error!`.\nSo, right now, if we remove the source file that we’re attempting to copy and then rerun our module with the same arguments, I think you’ll agree that the output is neither pretty nor meaningful unless you happen to be a hardened Python developer:\n\n```", "```\n\n We can, without a doubt, do better. Let’s make a copy of our module and add a little code to it. First of all, replace the `shutil.copy` lines of code with the following:\n\n```", "```\n\n This is some incredibly basic exception handling in Python, but what it does is allow the code to try the `shutil.copy` task. However, if this fails and an exception is raised, rather than exiting with a traceback, we exit cleanly using the `module.fail_json` call. This will tell Ansible that the module failed and cleanly send a JSON-formatted error message back. Naturally, we could do a lot to improve the error message; for example, we could obtain the exact error message from the `shutil` module and pass it back to Ansible, but again, this is left as an exercise for you to complete.\nNow, when we try and run the module with a non-existent source file, we will see the following cleanly formatted JSON output:\n\n```", "```\n\n However, the module still works in the same manner as before if the copy succeeds:\n\n```", "```\n\n With this simple change to our code, we can now cleanly and gracefully handle the failure of the file copy operation and report something more meaningful back to the user rather than using a traceback. Some additional pointers for exception handling and processing in your modules are as follows:\n\n*   Fail quickly – don’t attempt to keep processing after an error\n*   Return the most meaningful possible error messages using the various module JSON return functions\n*   Never return a traceback if there’s any way you can avoid it\n*   Try making errors meaningful in the context of the module and what it does (for example, for our module, `File copy error` is more meaningful than `File error` – and I think you’ll easily come up with even better error messages)\n*   Don’t bombard the user with errors; instead, try to focus on reporting the most meaningful ones, especially when your module code is complex\n\nThat completes our brief yet practical look at error handling in Ansible modules. In the next section, we shall return to the documentation we included in our module, including how to build it into HTML documentation so that it can go on the Ansible website (and indeed, if your module gets accepted into the Ansible source code, this is exactly how the web documentation will be generated).\nTesting and documenting your module\nWe have already put a great deal of work into documenting our module, as we discussed earlier in this chapter. However, how can we see it, and how can we check that it compiles correctly into the HTML that would go on the Ansible website if it were accepted as part of the Ansible source code?\nBefore we get into actually viewing our documentation, we should make use of a tool called `ansible-test`, which was newly added in the 2.15 release. This tool can perform a sanity check on our module code to ensure that our documentation meets all the standards required by the Ansible project team and that the code is structured correctly (for example, the Python `import` statements should always come after the documentation blocks). Let’s get started:\n\n1.  To run the sanity tests, assuming you have cloned the official repository, change into this directory and set up your environment. Note that if your standard Python binary isn’t Python 3, the `ansible-test` tool will not run, so you should ensure Python 3 is installed and, if necessary, set up a virtual environment to ensure you are using Python 3\\. This can be done as follows:\n\n    ```", "```\n    (venv) $ pip install -r test/runner/requirements/sanity.txt\n    ```", "```\n\n     2.  Now, provided you have copied your module code into the appropriate location in the source tree (an example copy command is shown here), you can run the sanity tests as follows:\n\n    ```", "```\n\nFrom the preceding output, you can see that apart from one warning related to us not having a base branch to compare against, the module code that we developed earlier in this chapter has passed all the tests. If you had an issue with the documentation (for example, the author’s name format was incorrect), this would be given as an error.\nNow that we have passed the sanity checks with `ansible-test`, let’s see whether the documentation looks right by using the `ansible-doc` command. This is very easy to do. First of all, exit your virtual environment, if you are still in it, and change to the Ansible source code directory you cloned from GitHub earlier. Now, you can manually tell `ansible-doc` where to look for modules instead of the default path. This means that you could run the following:\n\n```", "```\n\n You should be presented with the textual rendering of the documentation we created earlier – an example of the first page is shown here to give you an idea of how it should look:\n\n```", "```\n\n Excellent! So, we can already access our module documentation using `ansible-doc` and indeed confirm that it renders correctly in text mode. However, how do we go about building the HTML version? Fortunately, there is a well-defined process for this, which we shall outline here:\n\n1.  Under `lib/ansible/modules/`, you will find a series of categorized directories that modules are placed under – ours fits best under the `files` category, so copy it to this location in preparation for the build process to come:\n\n    ```", "```\n    $ cd docs/docsite/\n    ```", "```\n\n     2.  Build a documentation-based Python file. Use the following command to do so:\n\n    ```", "```\n\nNow, in theory, making the Ansible documentation should be this simple to get the `make webdocs` command to run at all.\nEven in this environment, on CentOS 7, the `make webdocs` command fails unless you have some very specific Python 3 requirements in place. These are not well documented, but from testing, I can tell you that Sphinx v2.4.4 works. The version that’s supplied with CentOS 7 is too old and fails, while the newest version available from the Python module repositories is not compatible with the build process and fails.\nOnce I’d started working from the Ansible source tree, I had to make sure I had removed any preexisting `sphinx` modules from my Python 3 environment (you need Python 3.11 or above to build the documentation locally – if you don’t have this installed on your node, please do this before proceeding) and then ran the following commands:\n\n```", "```\n\n With this in place, you will be able to successfully run `make webdocs` to build your documentation. You will see pages of output. A successful run should end with something like the output shown here:\n\n```", "```\n\n Now, notice how, at the end of this process, the `make` command tells us where to look for the compiled documentation. If you look in here, you will find the following:\n\n```", "```\n\n Try opening the HTML file in your web browser – you should see that the page renders just like one of the documentation pages from the official Ansible project documentation! This enables you to check that your documentation builds correctly and looks and reads well in the context that it will be viewed. It also gives you confidence that, when you submit your code to the Ansible project (if you are doing so), you are submitting something consistent with Ansible’s documentation quality standards.\nMore information on building the documentation locally is provided here: [https://docs.ansible.com/ansible/latest/community/documentation_contributions.xhtml#building-the-documentation-locally](https://docs.ansible.com/ansible/latest/community/documentation_contributions.xhtml#building-the-documentation-locally).\nThe current process of building the documentation is a little fussy around the environments that are supported; however, hopefully, this is something that will be resolved in due course. In the meantime, the process outlined in this section has given you a tested and working process to start from.\nThe module checklist\nIn addition to the pointers and good practices that we have covered so far, there are a few more things you should adhere to in your module code to produce something that will be considered of a high standard for potential inclusion with Ansible. The following list is not exhaustive but will give you a good idea of the practices you should adhere to as a module developer:\n\n*   Test your modules as much as you can, both in cases that will succeed and in those that cause errors. You can test them using JSON data, as we did in this chapter, or make use of them within a test playbook.\n*   Try and keep your Python requirements to a minimum. Sometimes, there is no way to avoid the need for additional Python dependencies (such as the `boto` requirements of the AWS-specific modules), but in general, the less you can use, the better.\n*   Don’t cache data for your module – the execution strategies of Ansible across differing hosts mean you are unlikely to get good results from doing this. Expect to gather all of the data you need on each run.\n*   Modules should be a single Python file – they shouldn’t be distributed across multiple files.\n*   Make sure you investigate and run the Ansible integration tests when you are submitting your module code. More information on these is available here: [https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.xhtml).\n*   Make sure you include exception handling at the appropriate points in your module code, as we did in this chapter, to prevent issues.\n\nArmed with the information you’ve gained from this chapter, you should have everything you need to start creating modules. You may not decide to submit them to the Ansible project, and there is certainly no requirement to do so. However, even if you don’t, following the practices outlined in this chapter will ensure that you build a good-quality module, regardless of its intended audience. Finally, on the basis that you do want to submit your source code to the Ansible project, in the next section, we’ll look at how to do this through a pull request to the Ansible project.\nContributing upstream – submitting a GitHub pull request\nWhen you’ve worked hard on your module and thoroughly tested and documented it, you might feel that it is time to submit it to the Ansible project for inclusion. Doing this means creating a pull request on the official Ansible repository. Although the intricacies of working with GitHub are beyond the scope of this book, we will give you a practically focused outline of the basic procedures involved.\nNote\nFollowing the process outlined here will generate a real request against the Ansible project on GitHub so that the code you are committing can be merged with their code. *Do not* follow this process unless you genuinely have a new module that is ready for submission to the Ansible code base.\nTo submit your module as a pull request of the Ansible repository, you need to fork the collection repository.\nNow, we will walk through the commands you need to run to add your module code to it. Then, we’ll show you how to create the required **pull requests** (also known as **PRs**) so that you can merge your new module with the upstream Ansible project:\n\n1.  Fork a collection repository that you want to create a PR for using GitHub ([https://github.com/ansible-collections](https://github.com/ansible-collections)). For example, if you need to create a PR in the `community.mysql` collection, you need to select **Fork**:\n\n![Figure 5.3 – The community.mysql collection](img/B20846_05_003.jpg)\n\nFigure 5.3 – The community.mysql collection\n\n1.  Clone the forked repository to your local machine. Use a command similar to the following, but be sure to replace the URL with the one that matches your own GitHub account:\n\n    ```", "```\n\n     2.  Add the upstream repository after you go to your cloned repository:\n\n    ```", "```\n\n     3.  Update your local branch:\n\n    ```", "```\n\n     4.  Create a branch for the PR:\n\n    ```", "```\n\n     5.  Change your code in the collection.\n6.  Submit your pull request:\n\n    ```", "```\n\n![Figure 5.4 – The Pull requests tab](img/B20846_05_004.jpg)\n\nFigure 5.4 – The Pull requests tab\nThere are many more ways to contribute to the Ansible project other than creating pull requests for custom modules. Here are some examples of other ways you can contribute to the project:\n\n*   Review the Ansible documentation and report any bugs you find in it (one was filed in the creation of [*Chapter 4*](B20846_04.xhtml#_idTextAnchor207), *Playbooks* *and Roles*)\n*   Create a local Ansible MeetUp to spread your knowledge about Ansible. If you are lucky enough to have one in your area already, consider attending it regularly.\n*   Spread Ansible knowledge and awareness via social media with the appropriate account references and hashtags; for example, `@ansible`, `#ansible`, and so on.\n\nThat completes our journey of learning how to create modules, from the very first steps of looking into the theory of module operation, all the way through to contributing your new module code to the official Ansible project on GitHub. We hope you have found this journey informative and valuable and that it enhances your ability to work with Ansible and extend its functionality where required.\nSummary\nModules are the very lifeblood of Ansible – without them, Ansible could not perform all of the complex and varied tasks it performs so well across a wide variety of systems. By being an open source project, it is incredibly easy to extend the functionality of Ansible by yourself, and in this chapter, we explored how you can, with a little Python knowledge, write a custom module from scratch. Ansible is, at the time of writing, incredibly feature-rich, but this ease of customization and extension makes Ansible virtually limitless in terms of its potential, especially given the power and popularity of Python as a programming language.\nIn this chapter, we started with a recap of how to execute multiple modules using the command line. We then explored the process of interrogating the current module index, as well as how to obtain documentation about modules to evaluate their suitability for our needs, regardless of whether we have an active internet connection or not. We then explored module data and its JSON format, before finally going on a journey through which we put together the code for a simple custom module. This provided you with a basis for creating modules in the future if you so desire.\nIn the next chapter, we will explore the process of using and creating another core Ansible feature, known as plugins.\nQuestions\nAnswer the following questions to test your knowledge of this chapter:\n\n1.  Which command line can be passed down as a parameter to a module?\n    1.  `ansible dbservers -m command \"/bin/echo '``hello modules'\"`\n    2.  `ansible dbservers -m command -d \"/bin/echo '``hello modules'\"`\n    3.  `ansible dbservers -z command -a \"/bin/echo '``hello modules'\"`\n    4.  `ansible dbservers -m command -a \"/bin/echo '``hello modules'\"`\n    5.  `ansible dbservers -a \"/bin/echo '``hello modules'\"`\n2.  Which of the following practices is not recommended when you create a custom module and address exceptions?\n    1.  Design a custom module simply and never provide a traceback to the user, if you can avoid it.\n    2.  Fail your module code quickly, and verify that you are providing helpful and understandable exception messages.\n    3.  Only display error messages for the most relevant exceptions, rather than all possible errors.\n    4.  Ensure that your module documentation is relevant and easy to understand.\n    5.  Delete playbooks that result in errors and then recreate them from scratch.\n3.  True or false: To contribute to the Ansible upstream project, you need to submit your code to the `devel` branch.\n    1.  True\n    2.  False\n\nFurther reading\nTo learn more about the topics that were covered in this chapter, take a look at the following resources:\n\n*   Documentation regarding the common return values of modules in Ansible can be found here: [https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.xhtml#common](https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.xhtml#common%0D)\n*   Check out the following documentation for all the existing modules on Windows machines that you can use: [https://docs.ansible.com/ansible/latest/collections/ansible/windows/index.xhtml](https://docs.ansible.com/ansible/latest/collections/ansible/windows/index.xhtml)\n\n```"]