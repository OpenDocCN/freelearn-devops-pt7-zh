- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Deploying to Amazon Web Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到亚马逊云服务
- en: After deploying our WordPress infrastructure into Microsoft Azure, we are now
    ready to explore how to deploy the same infrastructure to **Amazon Web Services**
    (**AWS**). However, while the high-level design of the infrastructure remains
    the same, there are some key differences between Azure and AWS that will require
    us to approach the deployment differently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的 WordPress 基础设施部署到 Microsoft Azure 后，我们现在准备探索如何将相同的基础设施部署到**亚马逊云服务**（**AWS**）。然而，尽管基础设施的高层设计保持不变，但
    Azure 和 AWS 之间存在一些关键区别，要求我们以不同的方式进行部署。
- en: In [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying to Microsoft
    Azure*, we focused on using Terraform to deploy to Azure. In this chapter, we
    will be diving deeper into Ansible, another popular infrastructure-as-code tool,
    to deploy our workload to AWS. Ansible allows us to define the desired state of
    our infrastructure in a declarative manner and manage the configuration and orchestration
    of our AWS resources.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 4 章*](B19537_04.xhtml#_idTextAnchor151)，《部署到 Microsoft Azure》中，我们重点使用 Terraform
    部署到 Azure。本章中，我们将深入探索 Ansible，这是另一个流行的基础设施即代码工具，用于将我们的工作负载部署到 AWS。Ansible 使我们能够以声明的方式定义我们基础设施的期望状态，并管理我们
    AWS 资源的配置和编排。
- en: By the end of this chapter, you will have a good understanding of how to use
    Ansible and Terraform to deploy a WordPress workload on AWS. You will also be
    familiar with the key differences between Azure and AWS and how to adapt your
    deployment approach to your infrastructure-as-code deployment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将对如何使用 Ansible 和 Terraform 在 AWS 上部署 WordPress 工作负载有一个深入的了解。你还将熟悉 Azure
    和 AWS 之间的关键区别，以及如何根据你的基础设施即代码部署来调整部署方法。
- en: 'We are going to be covering the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Introducing Amazon Web Services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍亚马逊云服务
- en: Preparing our cloud environment for deployment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备我们的云环境进行部署
- en: Producing the low-level design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成低级设计
- en: Ansible – writing the code and deploying our infrastructure
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible – 编写代码并部署我们的基础设施
- en: Terraform – reviewing the code and deploying our infrastructure
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform – 审查代码并部署我们的基础设施
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Like in the previous chapter, due to the amount of code needed to deploy our
    project, when it comes to the Terraform and Ansible sections of the chapter, we
    will only be covering some pieces of code needed to deploy the project. The code
    repository accompanying this book will contain the complete executable code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 像上一章一样，由于部署我们项目所需的代码量，在本章涉及 Terraform 和 Ansible 的部分时，我们将只涵盖一些部署项目所需的代码片段。本书随附的代码库将包含完整的可执行代码。
- en: Introducing Amazon Web Services
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍亚马逊云服务
- en: AWS is a cloud infrastructure platform owned and operated by the e-commerce
    giant Amazon, which you probably already guessed, given the name.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 是由电子商务巨头亚马逊拥有和运营的云基础设施平台，鉴于其名称，你可能已经猜到了这一点。
- en: The company began experimenting with cloud services in 2000, developing and
    deploying **application programming interfaces** (**APIs**) for their internal
    and external retail partners to consume. As more and more of the Amazon retail
    partners consumed more of the software services and grew at an exponential rate,
    they realized they would need to build a better and more standardized infrastructure
    platform to not only host the services they had been developing but also ensure
    that they could quickly scale as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该公司从 2000 年开始试验云服务，为其内部和外部零售合作伙伴开发和部署**应用程序接口**（**API**）。随着越来越多的亚马逊零售合作伙伴消费更多的软件服务并以指数级速度增长，他们意识到需要构建一个更好、更标准化的基础设施平台，不仅能够托管他们开发的服务，还能确保他们能够快速扩展。
- en: Off the back of this requirement, Amazon engineers Chris Pinkham and Benjamin
    Black wrote a white paper, which Jeff Bezos personally approved in early 2004\.
    The paper described an infrastructure platform where the compute and storage elements
    could all be deployed programmatically.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一需求，亚马逊工程师 Chris Pinkham 和 Benjamin Black 撰写了一篇白皮书，该白皮书在 2004 年初得到了 Jeff
    Bezos 的亲自批准。白皮书描述了一个基础设施平台，计算和存储元素可以通过编程方式进行部署。
- en: The first public acknowledgment of AWS’s existence was made in late 2004\. Still,
    at that time, the term was used to describe a collection of tools and APIs that
    would allow first and third parties to interact with Amazon’s retail product catalog
    rather than the fully formed public cloud service it is today. It wasn’t until
    2006 that a rebranded AWS was launched, due mainly to the service starting to
    expand beyond offering an API to Amazon’s retail services and instead starting
    to offer services that allowed users to use the services for their applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 的首次公开承认发生在 2004 年底。尽管那时该术语用于描述一组工具和 API，允许第一方和第三方与亚马逊的零售产品目录进行交互，而不是今天这个完整的公共云服务。直到
    2006 年，重新品牌的 AWS 才正式推出，主要是因为服务开始扩展，不仅提供 API 用于亚马逊的零售服务，还开始提供允许用户为其应用程序使用的服务。
- en: '**Simple Storage Service** (**S3**) was the first of these new services; this
    was, and still is, albeit a little more feature-rich, a service that allows developers
    to write and serve individual files using a web API rather than having to write
    and read from a traditional local filesystem.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单存储服务**（**S3**）是这些新服务中的第一个；这项服务，尽管现在功能更丰富，允许开发人员使用 Web API 来写入和提供单个文件，而不必像传统的本地文件系统那样进行读写。'
- en: The next service to launch is also still around, Amazon **Simple Queue Service**
    (**SQS**). It initially formed part of the original AWS collection of API endpoints.
    It is a distributed message system that again could be controlled and consumed
    by developers using an API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下一项即将推出的服务仍然存在，即 Amazon **简单队列服务**（**SQS**）。它最初是 AWS 原始 API 端点集合的一部分。它是一个分布式消息系统，同样可以通过
    API 进行控制和消费，由开发人员使用。
- en: The final service, launched in 2006, was a beta version of the Amazon **Elastic
    Compute Cloud** (**EC2**) service, which was limited to existing AWS customers
    – again, you could use the APIs developed by Amazon to launch and manage resources.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一项服务是在 2006 年推出的 Amazon **弹性计算云**（**EC2**）服务的测试版，它仅限于现有的 AWS 客户——同样，你可以使用亚马逊开发的
    API 启动和管理资源。
- en: This was the final piece of the jigsaw for Amazon. They now had the foundations
    of a public cloud platform, which had initially been envisioned in the whitepaper
    that Chris Pinkham and Benjamin Black produced a few years earlier. They could
    not only use this new service for their retail platform but also sell space to
    other companies and the public, such as you and me. The bonus was that this new
    service could have a recurring revenue stream not only to pay for the initial
    development but also so that Amazon could maximize its hardware investment by
    *renting* out its idle compute resources.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是亚马逊的最后一块拼图。他们现在拥有了一个公共云平台的基础设施，这个平台最初是在 Chris Pinkham 和 Benjamin Black 几年前发布的白皮书中构思的。他们不仅可以将这个新服务用于自己的零售平台，还可以将空间卖给其他公司和公众，比如你和我。额外的好处是，这项新服务可以有一个持续的收入流，不仅可以支付最初的开发费用，还可以让亚马逊通过*租赁*其闲置的计算资源来最大化硬件投资。
- en: AWS has grown from the 3 services mentioned in 2006 to over 200 in 2023\. All
    these 200+ services are aligned with the core principles laid out in the original
    white paper. Each service is software-defined, meaning that a developer simply
    needs to make an API request to launch, configure, sometimes consume, and terminate
    the service.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2006 年提到的 3 项服务，到 2023 年的 200 多项服务，AWS 取得了巨大的增长。所有这些 200 多项服务都与原始白皮书中阐述的核心原则一致。每项服务都是软件定义的，这意味着开发人员只需要发出
    API 请求来启动、配置、有时消费以及终止该服务。
- en: Interacting with the API is also precisely what we will do in this chapter,
    as many of the principles laid out in that original white paper are also at the
    core of infrastructure as code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与 API 交互正是我们在本章中将要做的事情，因为白皮书中阐述的许多原则也是基础设施即代码的核心内容。
- en: Preparing our cloud environment for deployment
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的云环境做好部署准备
- en: As we discussed in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying
    to Microsoft Azure*, we will be running Ansible and Terraform on our local machine,
    which means we can install and configure the AWS **command-line** **interface**
    (**CLI**).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 4 章*](B19537_04.xhtml#_idTextAnchor151) 中讨论的那样，*部署到 Microsoft Azure*，我们将在本地机器上运行
    Ansible 和 Terraform，这意味着我们可以安装并配置 AWS **命令行界面**（**CLI**）。
- en: Ansible and Terraform will use the credentials configured in the AWS CLI to
    authenticate against the AWS APIs. For details on how to install the AWS CLI,
    see [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 和 Terraform 将使用在 AWS CLI 中配置的凭证进行身份验证，访问 AWS API。有关如何安装 AWS CLI 的详细信息，请参阅
    [https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)。
- en: Once installed, you need to generate and enter your credentials. This process
    is documented at [https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您需要生成并输入您的凭证。此过程的文档说明可以在 [https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html)
    中找到。
- en: 'Once configured, you should be able to run the following commands:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，您应该能够运行以下命令：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When I run them on my own machine, I get the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在我自己的机器上运行这些命令时，我得到以下输出：
- en: '![Figure 5.1 – The output of running the AWS version command to check the version](img/Figure_5.01_B19537.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 运行 AWS 版本命令以检查版本的输出](img/Figure_5.01_B19537.jpg)'
- en: Figure 5.1 – The output of running the AWS version command to check the version
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 运行 AWS 版本命令以检查版本的输出
- en: 'For the second command, there is quite a lot of output, which should look something
    like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个命令，输出内容相当多，应该类似于以下内容：
- en: '![Figure 5.2 – The output of running the AWS version command to describe the
    regions](img/Figure_5.02_B19537.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 运行 AWS 版本命令以描述区域的输出](img/Figure_5.02_B19537.jpg)'
- en: Figure 5.2 – The output of running the AWS version command to describe the regions
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 运行 AWS 版本命令以描述区域的输出
- en: Now that we have the AWS CLI configured and hooked into our AWS account, we
    can discuss the services we will be deploying and configuring within AWS.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置并连接了 AWS CLI 到我们的 AWS 账户，我们可以讨论将在 AWS 内部署和配置的服务。
- en: Producing the low-level design
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成低级设计
- en: 'From an architecture point of view, the services that are going to be deployed
    are not too dissimilar from those we covered in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to* *Microsoft Azure*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构的角度来看，我们将要部署的服务与我们在[*第 4 章*](B19537_04.xhtml#_idTextAnchor151)中讨论的服务并无太大不同，*部署到*
    *Microsoft Azure*：
- en: '![Figure 5.3 – An overview of the services we will be deploying into AWS](img/Figure_5.03_B19537.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 我们将在 AWS 中部署的服务概览](img/Figure_5.03_B19537.jpg)'
- en: Figure 5.3 – An overview of the services we will be deploying into AWS
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 我们将在 AWS 中部署的服务概览
- en: 'The core services we are going to be deploying are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要部署的核心服务如下：
- en: Amazon **Elastic Load Balancing** (**ELB**) is the first difference in the services
    we will be deploying. Azure Load Balancer only distributed TCP requests between
    our WordPress instances. However, in AWS, we will launch ELB configured as Application
    Load Balancer, which will terminate our HTTP requests and distribute them across
    our WordPress instances.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon **Elastic Load Balancing** (**ELB**) 是我们将要部署的服务中的第一个差异。Azure Load Balancer
    仅在我们的 WordPress 实例之间分发 TCP 请求。然而，在 AWS 中，我们将启动配置为应用程序负载均衡器的 ELB，它将终止我们的 HTTP 请求并将其分发到我们的
    WordPress 实例中。
- en: '**Amazon EC2** is the compute service. For our WordPress deployment, we will
    be deploying a single Amazon EC2 instance, which will be used to bootstrap WordPress,
    and then the rest of the Amazon EC2 instances will be auto-scaling.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon EC2** 是计算服务。对于我们的 WordPress 部署，我们将部署一个 Amazon EC2 实例，该实例将用于引导 WordPress，之后其余的
    Amazon EC2 实例将进行自动扩展。'
- en: We will be using a combination of Amazon EC2 **Auto Scaling groups** (**ASGs**)
    and launch configurations to manage the deployment of the Amazon EC2 instances,
    which will host the web instances.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用 Amazon EC2 **自动扩展组** (**ASGs**) 和启动配置的组合来管理 Amazon EC2 实例的部署，这些实例将托管 Web
    实例。
- en: Amazon **Elastic File System** (**EFS**) is the service that will provide the
    NFS share hosting of the WordPress installation, which will be shared across all
    of our instances.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon **Elastic File System** (**EFS**) 是提供 WordPress 安装的 NFS 共享托管服务，该服务将在我们所有的实例之间共享。
- en: Amazon **Relational Database Service** (**RDS**) will be used to host the MySQL
    database we will use for WordPress.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon **Relational Database Service** (**RDS**) 将用于托管我们将用于 WordPress 的 MySQL
    数据库。
- en: Amazon **Virtual Private Cloud** (**VPC**) is the underlying network service
    that hosts the services that will be deployed throughout this chapter. There are
    a few different services that come under this umbrella, and those will be covered
    in more detail when we do a deep dive into the Ansible code in the next section.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊**虚拟私有云**（**VPC**）是承载本章将要部署服务的底层网络服务。这个服务下涵盖了几种不同的服务，具体内容将在下一节深入讲解Ansible代码时详细介绍。
- en: Now that we have an idea of the services we are going to be using and also which
    part of the WordPress deployment they will be hosting, we can start to look at
    how we approach the project using Ansible – this time going in into a little more
    detail than we did in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying
    to* *Microsoft Azure*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了将要使用的服务，以及它们在WordPress部署中所承担的角色，我们可以开始着手使用Ansible来进行项目部署——这一次我们会比在[*第4章*](B19537_04.xhtml#_idTextAnchor151)《部署到*Microsoft
    Azure*》中讲解的更为详细。
- en: Ansible – writing the code and deploying our infrastructure
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible – 编写代码并部署我们的基础设施
- en: In [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying to Microsoft
    Azure*, we briefly covered the Ansible code to deploy our Azure environment. Let’s
    take a step back and cover some of the basics we skipped.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B19537_04.xhtml#_idTextAnchor151)《部署到Microsoft Azure》中，我们简要介绍了用Ansible部署Azure环境的代码。现在，让我们回顾一下我们跳过的一些基础知识。
- en: While we can have one big YAML file containing our playbook code, I tend to
    split mine into more manageable chunks using roles. Roles can be used for a few
    things. In some cases, they can be stand-alone distributable tasks that can be
    reused across multiple projects; or, in our case, they can be used to manage more
    complex playbooks.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以将所有playbook代码写在一个大的YAML文件中，但我倾向于将其拆分成更易管理的块，使用角色进行分割。角色有多种用途。在某些情况下，它们可以是独立的可分发任务，可以在多个项目中重复使用；在我们这里，它们则用于管理更复杂的playbook。
- en: 'A copy of the `site.yml` file that will be used to deploy our WordPress environment
    in AWS looks like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将用于在AWS中部署我们的WordPress环境的`site.yml`文件示例：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, there are several roles, all of which I have grouped in the
    logical order we need to deploy our resources.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里有多个角色，我已经按我们需要部署资源的逻辑顺序将它们分组。
- en: 'If you look in one of the role folders, for example, `roles/create-randoms`,
    you will notice that there are several folders and files:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看其中一个角色文件夹，例如`roles/create-randoms`，你会注意到有几个文件夹和文件：
- en: '`defaults`: This is where the default variables for the role are stored. These
    can be overridden by any variables with the same name called in the `vars` folder.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaults`：这是存放角色默认变量的地方。这些变量可以被`vars`文件夹中同名的变量覆盖。'
- en: '`files`: This folder contains any static files we wish to copy to the target
    hosts using the `copy` module.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files`：这个文件夹包含我们希望使用`copy`模块复制到目标主机上的静态文件。'
- en: '`handlers`: These are tasks that are executed once a playbook has been executed,
    for example, restarting services on a target host when a configuration file has
    changed.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handlers`：这些是执行完playbook后运行的任务，例如，当配置文件发生更改时，重新启动目标主机上的服务。'
- en: '`meta`: This folder contains information about the role itself. This information
    would be used if it was ever published to Ansible Galaxy.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta`：这个文件夹包含有关角色本身的信息。如果该角色曾被发布到Ansible Galaxy，这些信息将被使用。'
- en: '`tasks`: This contains the primary set of instructions or actions that will
    be executed on the target hosts. These instructions are usually defined in YAML
    files, including installing packages, creating users, and copying files. Tasks
    can be organized into different files based on their functionality or the specific
    actions they perform. They can also include variables and conditional statements
    to make them more dynamic and flexible.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks`：这里包含了将在目标主机上执行的一组主要指令或操作。这些指令通常以YAML文件的形式定义，包括安装软件包、创建用户、复制文件等。任务可以根据功能或特定操作的不同组织成不同的文件。它们还可以包含变量和条件语句，使其更加动态和灵活。'
- en: '`templates`: This folder contains the Jinja2 templates used by the `template`
    module.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates`：这个文件夹包含`template`模块使用的Jinja2模板。'
- en: '`tests`: If you are publishing your role to Ansible Galaxy, then it is a good
    idea to set up some tests. These are stored here.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests`：如果你打算将你的角色发布到Ansible Galaxy，那么设置一些测试是一个不错的主意。这些测试会存放在这里。'
- en: '`vars`: You can override any of the variables defined in the `default` folder
    using the variables defined here. Variables defined here can also be overridden
    by any variables loaded from the `group_vars` folder at the top level of the playbook.
    These, in turn, can be overridden by variables passed in at runtime using the
    `ansible-playbook` command.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars`：你可以使用这里定义的变量覆盖 `default` 文件夹中定义的任何变量。这里定义的变量也可以被从 playbook 顶部的 `group_vars`
    文件夹加载的任何变量覆盖。反过来，这些变量又可以在运行时通过 `ansible-playbook` 命令传入的变量进行覆盖。'
- en: '`README.md`: This is the file used to create any documentation about the role
    when the role is checked into a service such as GitHub. This is useful when publishing
    the role to Ansible Galaxy.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`：这是用于创建关于角色的文档文件，当角色被检查并推送到像 GitHub 这样的服务时，这个文件会用到。发布角色到 Ansible
    Galaxy 时，这个文件非常有用。'
- en: 'Now that is a lot of folders and files to create when you want to add a role.
    Luckily, the `ansible-galaxy` command can bootstrap a role quickly. To do this,
    simply run the following command in the top level of your `playbook` folder, making
    sure to replace `role-name` with the name you want for your role:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你想添加一个角色时，确实需要创建很多文件夹和文件。幸运的是，`ansible-galaxy` 命令可以快速引导角色创建。为此，只需在 `playbook`
    文件夹的顶级运行以下命令，确保将 `role-name` 替换为你希望的角色名称：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will create the folder and file structure we just covered and is an excellent
    starting point.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们刚才讨论的文件夹和文件结构，是一个很好的起点。
- en: 'Before we dive into the roles, let’s quickly discuss the variables. At the
    top of the `group_vars/aws.yml` file, we have some basic variables defined. These
    are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论角色之前，让我们快速讨论一下变量。在 `group_vars/aws.yml` 文件的顶部，我们定义了一些基本变量。它们如下：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we are defining a top level and have multiple keys and values
    attached to them. So, anywhere in our code, or even in other top-level variables,
    we can simply use something such as `{{ app.name }}`, which will be replaced by
    `iac-wordpress` when our playbook runs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在定义一个顶级变量，并且附加了多个键值对。因此，在我们的代码中，甚至在其他顶级变量中，我们可以简单地使用类似`{{ app.name }}`的内容，当我们的
    playbook 运行时，它将被替换为 `iac-wordpress`。
- en: 'This can be seen when defining the resource names, as these are mostly made
    up of groups of variables defined elsewhere. Take the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在定义资源名称时看到，因为这些名称大多数由在其他地方定义的变量组构成。请看以下示例：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, let’s look at the playbook roles in detail.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细看看 playbook 角色。
- en: Ansible playbook roles
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible playbook 角色
- en: Let’s dive straight in and look at the first role.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接深入，看看第一个角色。
- en: Creating the Randoms role
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Randoms 角色
- en: This role, which we already covered in detail in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*, does the same tasks as covered in that chapter.
    The role was copied straight from the Microsoft Azure deployment folder.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色，我们在 [*第 4 章*](B19537_04.xhtml#_idTextAnchor151)《*部署到微软 Azure*》中已经详细讲解过，执行的任务与该章节中所述相同。该角色直接从微软
    Azure 部署文件夹复制而来。
- en: The AWS Network role
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS 网络角色
- en: 'The primary variable we are defining in `group_vars/aws.yml` for this role
    is a lot more simplistic than the one we defined for the Azure deployment. It
    contains the CIDR range we want to use for our VPC network and nothing else:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `group_vars/aws.yml` 中为这个角色定义的主要变量比我们为 Azure 部署定义的要简单得多。它仅包含我们希望用于 VPC 网络的
    CIDR 范围，没有其他内容：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The tasks we are running in the role take care of the rest of the information
    using some of Ansible’s built-in functions. The first task is a relatively straightforward
    one:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在角色中运行的任务通过一些 Ansible 内建函数处理其余的信息。第一个任务是相对简单的：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, it uses the `amazon.aws.ec2_vpc_net` module from the Amazon
    collection on Ansible Galaxy to create the VPC – so nothing too special or complicated
    there. The output of the task is registered as `vpc`; we will use this output
    register throughout the remainder of the playbook run.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它使用了来自 Ansible Galaxy 上 Amazon 集合的 `amazon.aws.ec2_vpc_net` 模块来创建 VPC——所以没有什么特别或复杂的内容。任务的输出被注册为
    `vpc`；我们将在 playbook 运行的剩余部分使用这个输出注册。
- en: 'The next task gathers some information on the region in which we are going
    to be deploying our workload:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务收集了我们将要部署工作负载的区域信息：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have a few outputs registered, we can add the subnets and start
    doing more exciting things.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经注册了几个输出，我们可以添加子网并开始做一些更有趣的事情。
- en: As part of our deployment, we need to add four subnets – two for the web services
    and two for the database services. Like our Azure deployment, the subnets will
    be /27s, and we will deploy each subnet in different Availability Zones.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们部署的一部分，我们需要添加四个子网——两个用于Web服务，两个用于数据库服务。与我们的Azure部署一样，子网将是`/27`网段，并且我们将每个子网部署在不同的可用区中。
- en: Information
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: When we deployed the Azure version of our WordPress workload, we didn’t have
    to worry about how the subnets were distributed across Availability Zones (which
    are different data centers within a region), as virtual networks in Azure can
    span multiple Availability Zones. However, AWS is different; subnets need to be
    pinned to Availability Zones, meaning you will need to have more than one per
    server role or service function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们部署Azure版本的WordPress工作负载时，我们不必担心子网如何分布在可用区之间（可用区是一个区域内的不同数据中心），因为Azure中的虚拟网络可以跨多个可用区。然而，AWS则不同；子网需要与可用区绑定，这意味着每个服务器角色或服务功能至少需要有一个子网。
- en: 'The task to add the first subnet looks like the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 添加第一个子网的任务如下所示：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Things start simple enough in that we use the output register from when we created
    the VPC to get the ID of the VPC to attach the subnet to by using `"{{` `vpc.vpc.id
    }}"`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 事情从简单开始，我们使用在创建VPC时的输出寄存器，通过`"{{ vpc.vpc.id }}"`获取VPC的ID，以便将子网附加到该VPC。
- en: Next, we use the output register again to get the CIDR range from the VPC output
    register; however, we take that value and use the `ansible.utils.ipsubnet` function
    to work out what the first `/27` in the CIDR range will be.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次使用输出寄存器从VPC输出寄存器获取CIDR范围；但是，我们将该值传递给`ansible.utils.ipsubnet`函数，计算出CIDR范围中的第一个`/27`网段。
- en: As we have passed in `10.0.0.0/24`, running `ansible.utils.ipsubnet(27, 0)`
    should give us `10.0.0.0/27`. The keen-eyed among you may have noticed that we
    passed in `0` rather than `1`. Ansible always counts from 0, so if we had used
    `1`, then we would have gotten `10.0.0.32/27`, which is what we need to use for
    the second subnet.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们传入了`10.0.0.0/24`，运行`ansible.utils.ipsubnet(27, 0)`应该返回`10.0.0.0/27`。细心的你可能已经注意到我们传入了`0`而不是`1`。Ansible的计数从0开始，所以如果我们使用`1`，我们将得到`10.0.0.32/27`，那才是我们需要用于第二个子网的地址。
- en: The second exciting thing we are doing is taking the output of the `zone` register,
    which contains information on the region we are using, including a list of the
    Availability Zones. So, when we use `{{ zones.availability_zones[0].zone_name
    }}`, it is taking the zone name for the first result, that is, `0`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在做的第二件令人兴奋的事情是获取`zone`寄存器的输出，该寄存器包含我们正在使用的区域信息，包括可用区列表。因此，当我们使用`{{ zones.availability_zones[0].zone_name
    }}`时，它是获取第一个结果的可用区名称，即`0`。
- en: The advantage of this approach in populating information for the CIDR and Availability
    Zone for the subnet is that we do not have to hardcode those details as variables.
    If we change the CIDR range or regions, the information would be programmatically
    generated to consider those changes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种为子网填充CIDR和可用区信息的方法的优点在于，我们不需要将这些细节作为变量硬编码。如果我们更改CIDR范围或区域，信息将根据这些更改自动生成。
- en: When you write your Ansible playbooks, anything you can do to have your playbook
    adapt to user input or change dynamically is considered a best practice as it
    not only simplifies the information your consumers need to know but also makes
    the code reusable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写Ansible剧本时，任何能够使剧本根据用户输入或动态变化来调整的操作，都是最佳实践。这不仅简化了用户需要了解的信息，而且使代码具有可重用性。
- en: The rest of the task is populated using mostly static variables, so less interesting
    than what we have just covered.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的其余部分主要使用静态变量，因此比我们刚才讲解的内容要简单得多。
- en: This is then repeated for the second web subnet and the two subnets used with
    Amazon RDS – all we do is increment the numbers being passed to `ansible.utils.ipsubnet`
    and `zones.availability_zones`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，这个过程将针对第二个Web子网和两个用于Amazon RDS的子网重复进行——我们所做的只是递增传递给`ansible.utils.ipsubnet`和`zones.availability_zones`的数字。
- en: Once the subnets have been defined, we create an internet gateway using `amazon.aws.ec2_vpc_igw`.
    Following that, we create a route table to take advantage of the gateway using
    `amazon.aws.ec2_vpc_route_table`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了子网，我们通过`amazon.aws.ec2_vpc_igw`创建一个互联网网关。接着，我们创建一个路由表来利用该网关，使用`amazon.aws.ec2_vpc_route_table`。
- en: This is attached to the two web subnets and forwards all outgoing traffic to
    our internet gateway.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子网连接到两个Web子网，并将所有出站流量转发到我们的互联网网关。
- en: The next batch of tasks creates three security groups using the `amazon.aws.ec2_security_group`
    module.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的任务批次使用`amazon.aws.ec2_security_group`模块创建了三个安全组。
- en: The first of the three security groups will be assigned to the admin/web EC2
    instances and the elastic load balancer. It opens ports `80` and `22` to the world,
    making them publicly accessible.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 三个安全组中的第一个将分配给管理/Web EC2 实例和弹性负载均衡器。它将端口`80`和`22`开放给全世界，使其公开可访问。
- en: Information
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: For ease of use, I am opening port `22` to the world. In your production deployments,
    you should not do this and lock access down to one or more trusted IP addresses.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便使用，我将端口`22`开放给全世界。在你的生产部署中，不应该这么做，应该将访问限制为一个或多个可信 IP 地址。
- en: The next two security groups will be attached to the Amazon RDS and EFS services.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个安全组将附加到 Amazon RDS 和 EFS 服务。
- en: However, rather than defining source IP range(s), we are passing in the ID of
    the first security group we created, which means that ports `3306` (MySQL) and
    `2049` (NFS) will only be access to resources, which in our case is going to be
    the admin and web EC2 instances. The first security group attached will be able
    to access those services.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，和定义源 IP 范围不同，我们传入的是我们创建的第一个安全组的 ID，这意味着端口`3306`（MySQL）和`2049`（NFS）将仅允许访问资源，在我们的案例中，这些资源将是管理和
    Web EC2 实例。附加的第一个安全组将能够访问这些服务。
- en: 'The final two tasks configure and launch the application load balancer. The
    first of the following two tasks is shown here and creates an empty ELB target
    group:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两个任务是配置并启动应用负载均衡器。下面的两个任务中的第一个在这里展示，它创建了一个空的 ELB 目标组：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On the face of it, there does not appear to be anything too special about that,
    so why have I called it out?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，似乎没有什么特别之处，那么为什么我特别提到这一点呢？
- en: At the time of writing, there is no module for creating an ELB target group
    using the `amazon.aws` collection; so instead, we have switched to using the `community.aws`
    collection. The developers use this collection as a staging ground for new features,
    and we will bounce between these two collections throughout the playbook.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`amazon.aws`集合中没有创建 ELB 目标组的模块；因此，我们改用了`community.aws`集合。开发人员使用此集合作为新特性的试验场，我们将在整个剧本中在这两个集合之间切换。
- en: Information
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: As modules may be promoted from being hosted in the `community.aws` collection
    to the `amazon.aws` collection in the future, please refer to the code in the
    GitHub repository that accompanies this book for the most recent updates.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块可能会从`community.aws`集合提升到`amazon.aws`集合，请参考本书附带的 GitHub 仓库中的代码，以获取最新的更新。
- en: The final task of the role is to create the application load balancer. Here,
    we use the `amazon.aws.elb_application_lb` module and several output registers
    we have created so far in the playbook run.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该角色的最终任务是创建应用负载均衡器。在这里，我们使用`amazon.aws.elb_application_lb`模块以及我们在剧本运行过程中创建的几个输出寄存器。
- en: That concludes all the tasks we need to run to deploy the underlying network
    and supporting services. Now that we have those resources in place, we can deploy
    the storage for our WordPress installation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们部署基础网络和支持服务所需运行的所有任务。现在这些资源已经到位，我们可以开始部署 WordPress 安装的存储。
- en: The AWS Storage role
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS 存储角色
- en: 'This is a simple role that contains a single task:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的角色，只包含一个任务：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, it uses the `community.aws.efs` module to create the Amazon
    EFS share, creating a target endpoint in our two web subnets. This step is important
    as EFS has a different DNS endpoint in each availability zone, so without this,
    we would be unable to connect to the NFS share in both of our web subnets.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它使用`community.aws.efs`模块来创建 Amazon EFS 共享，在我们的两个 Web 子网中创建一个目标端点。这个步骤很重要，因为
    EFS 在每个可用区有不同的 DNS 端点，如果没有这个步骤，我们将无法连接到我们两个 Web 子网中的 NFS 共享。
- en: The AWS Database role
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS 数据库角色
- en: Before we launch our EC2 instances, we need to have the MySQL Amazon RDS instance
    ready. This role contains two tasks – the first of which creates an RDS subnet
    group using the `amazon.aws.rds_subnet_group` module. Once we have the subnet
    group, the `amazon.aws.rds_instance` module is then used to create the RDS instance
    itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 EC2 实例之前，我们需要准备好 MySQL Amazon RDS 实例。这个角色包含两个任务——第一个任务使用`amazon.aws.rds_subnet_group`模块创建一个
    RDS 子网组。一旦我们有了子网组，`amazon.aws.rds_instance`模块将被用来创建 RDS 实例本身。
- en: There isn’t much to this role, but we now have an Amazon RDS instance and can
    start deploying our EC2 instances.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色的内容并不复杂，但我们现在已经有了一个 Amazon RDS 实例，可以开始部署我们的 EC2 实例了。
- en: The AWS VM Admin role
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS VM管理员角色
- en: Like in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying to Microsoft
    Azure*, we will deploy a single instance using a `cloud-init` script to bootstrap
    our WordPress installation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[*第4章*](B19537_04.xhtml#_idTextAnchor151)中提到的，*部署到Microsoft Azure*，我们将使用`cloud-init`脚本部署单个实例来引导我们的WordPress安装。
- en: 'The variables that we are going to be using for both this role and the next,
    which configures the ASG-managed EC2 instances, are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于当前角色和下一个角色（配置ASG管理的EC2实例）的变量如下：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first task that we will perform is generating a temporary file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行的第一个任务是生成一个临时文件：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will render the template file in `templates/vm-cloud-init-admin.yml.j2`
    and place the rendered contents in the temporary file we just created:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将渲染`templates/vm-cloud-init-admin.yml.j2`中的模板文件，并将渲染后的内容放入我们刚刚创建的临时文件中：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the `cloud-init` file prepared, we can move on to the next step: figure
    out the ID of the **Amazon Machine Image** (**AMI**) we need to use:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好`cloud-init`文件后，我们可以进入下一步：找出需要使用的**Amazon Machine Image**（**AMI**）的ID：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As the AMI’s maintainer, **Canonical**, which also develops Ubuntu, keeps the
    AMI up to date with patches and so on, a long list of AMIs will be returned as
    there are multiple versions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 作为AMI的维护者，**Canonical**（也开发Ubuntu）会保持AMI的更新，修补漏洞等，因此会返回一长串AMI，因为有多个版本。
- en: 'Our next task sorts that list and takes the last item:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是对该列表进行排序，并获取最后一项：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see in the preceding code snippet, we are using the `sort` function
    to sort the list, which is JSON, by the `creation_date` attribute and then taking
    the `last` result. This leaves us with the details of the most recent AMI that
    Canonical has published.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的代码片段中看到的，我们使用`sort`函数根据`creation_date`属性对列表（这是JSON格式）进行排序，然后获取`last`结果。这将给我们带来Canonical发布的最新AMI的详细信息。
- en: 'Now we have everything we need to launch our admin EC2 instance:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有启动管理员EC2实例所需的一切：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, most all the information needed to deploy the instance is a
    variable, either a hardcoded one, such as `instance_type`, or one that is an output
    variable, like the one for `image_id`, which is the one we just gathered the information
    for.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，部署实例所需的大部分信息都是变量，要么是硬编码的，例如`instance_type`，要么是输出变量，如我们刚才收集的信息中的`image_id`。
- en: For `user_data`, we are using the `lookup` function to read the contents of
    the temporary file we populated with the `cloud-init` script, which we will talk
    about in a moment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`user_data`，我们使用`lookup`函数读取我们用`cloud-init`脚本填充的临时文件的内容，稍后我们会讨论这个文件。
- en: Now that we have an EC2 instance, we need to register it in the ELB target group
    we created in the Network role, but we can only do this if the instance has a
    state of `running`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了EC2实例，我们需要将其注册到我们在网络角色中创建的ELB目标组，但只有在实例状态为`running`时才能进行注册。
- en: Our Ansible playbook can progress a little too quickly, and the instance may
    not yet have entered that state, so we need to create a bit of logic that will
    pause the playbook execution and wait for the instance to have the correct state
    before progressing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Ansible剧本可能执行得太快，实例可能还未达到目标状态，因此我们需要创建一些逻辑，使剧本暂停执行，并等待实例达到正确状态后再继续。
- en: 'We can do this with the following task:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下任务来实现这一点：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The task itself is quite simple; it uses the `amazon.aws.ec2_instance_info`
    module to gather information on the EC2 instance we have just launched.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 任务本身非常简单；它使用`amazon.aws.ec2_instance_info`模块收集我们刚刚启动的EC2实例的信息。
- en: On its own, this task would be pretty useless as it would gather the information
    once and then move on. The three lines at the end are bits that add the logic
    we need.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，这个任务几乎没有用，因为它只会收集一次信息，然后继续执行。最后三行代码是增加所需逻辑的部分。
- en: 'Using the `until` function, we take our output register, `admin_ec2_instance_state`,
    and check whether `state.name` is equal to `running`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`until`函数，我们获取输出寄存器`admin_ec2_instance_state`，并检查`state.name`是否等于`running`：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the `state.name` variable does not equal `running`, then retry 50 times
    every 5 seconds:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`state.name`变量不等于`running`，则每隔5秒重试50次：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Continue until `state.name` equals `running`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 继续直到`state.name`等于`running`。
- en: 'Once this condition is met, we know it will be safe to move on to the next
    task, and we won’t get any errors because the state of the instance is incorrect:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦满足此条件，我们就知道可以安全地进行下一任务，并且不会因为实例状态不正确而出现错误：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, we now have our admin EC2 instance running and registered with the ELB
    target group and the `cloud-init` script running. Well, sort of – we need to make
    a few adjustments to the `cloud-init` script from when we last looked at it in
    [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying to Microsoft Azure*.
    Most of it is as we used it when deploying to Azure, with one additional piece
    of logic we needed to build in:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的管理员 EC2 实例已启动并注册到 ELB 目标组，并且 `cloud-init` 脚本正在运行。嗯，算是吧——我们需要对 `cloud-init`
    脚本进行一些调整，从我们最后一次查看它时在 [*第 4 章*](B19537_04.xhtml#_idTextAnchor151)，*部署到 Microsoft
    Azure* 时做的修改。大部分内容与我们在部署到 Azure 时使用的相同，只有一个我们需要添加的逻辑：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see from the preceding code snippet, there is a change to the line
    that mounts the NFS share provided by the Amazon EFS service – why have we needed
    to make this change?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段可以看到，我们对挂载 Amazon EFS 服务提供的 NFS 共享的那一行做了更改——我们为什么需要做这个更改？
- en: If you remember, back when we launched the Amazon EFS service, we talked about
    the unique DNS endpoints being registered automatically in each subnet. To get
    around having to build the logic into our deployment to figure out which availability
    zone we are running our instances in so we can use the right DNS name for our
    Amazon EFS endpoint, a generic endpoint, `CNAME`, is created, which resolves to
    the appropriate endpoint for the subnet.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在我们启动 Amazon EFS 服务时，我们提到过每个子网中自动注册的唯一 DNS 端点。为了避免在部署中构建逻辑来找出我们正在运行实例的可用区，从而使用正确的
    DNS 名称来访问我们的 Amazon EFS 端点，我们创建了一个通用的端点 `CNAME`，它解析为子网的适当端点。
- en: Great, you might be thinking that that saves us the hassle of having to code
    something to take this into account – and you would be correct, but it can take
    a while for this DNS alias to propagate.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，你可能在想，这样我们就不用编写代码来考虑这个问题了——你是对的，但这个 DNS 别名的传播可能需要一段时间。
- en: As the `cloud-init` script is running completely independently of our Ansible
    playbook run, we can’t use a conditional like the one that we just discussed for
    waiting, for instance, to have the correct state before progressing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `cloud-init` 脚本与我们的 Ansible playbook 运行完全独立，因此我们不能像刚才讨论的那样使用条件来等待某个正确的状态，然后再继续进行。
- en: 'So, to get around this, we are adding the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了绕过这个问题，我们正在添加以下内容：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is the Bash equivalent of the condition we added before. It will run the
    netcat (`nc`) command to see whether `somedns.domain.com` is responding on port
    `2049`. If it isn’t, it will wait for two seconds using the `sleep` command and
    then repeat until we get the correct response.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前添加的条件的 Bash 等价物。它会运行 netcat (`nc`) 命令，检查 `somedns.domain.com` 是否在端口 `2049`
    上响应。如果没有，它会使用 `sleep` 命令等待两秒钟，然后重复直到得到正确的响应。
- en: You may have also noticed that we are using another Ansible function to get
    the details on the Amazon EFS endpoint from our output register.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到，我们正在使用另一个 Ansible 函数来从输出注册表中获取 Amazon EFS 端点的详细信息。
- en: By default, if we were to just use `{{ efs.efs.filesystem_address }}`, it would
    return the fully qualified domain name for our Amazon EFS endpoint with the filesystem
    path appended to the end of it, which in our case is `:/`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果我们仅使用 `{{ efs.efs.filesystem_address }}`，它将返回我们 Amazon EFS 端点的完全限定域名，并将文件系统路径附加到末尾，在我们的例子中就是
    `:/`。
- en: 'This is not a valid address for the `nc` command to use, so we need to remove
    the `:/` from the address. To do this, we can use Ansible’s `regex_replace` function,
    as we want to remove everything that isn’t a regular character, dot, or hyphen.
    Then, this looks like the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是 `nc` 命令可用的有效地址，因此我们需要从地址中移除 `:/`。为此，我们可以使用 Ansible 的 `regex_replace` 函数，因为我们要移除所有不是常规字符、点或连字符的部分。这样做后，看起来会是这样的：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code should leave us with, for example, `somedns.domain.com` rather than
    `somedns.domain.com:/`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该会让我们得到类似 `somedns.domain.com` 而不是 `somedns.domain.com:/` 的结果。
- en: The rest of the script remains intact. We also must use the same logic as previously
    for the cut-down version of the `cloud-init` script being used for the web EC2
    instances being deployed using the ASG, which we will look at next.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的脚本保持不变。对于通过 ASG 部署的 Web EC2 实例使用的简化版 `cloud-init` 脚本，我们也必须使用与之前相同的逻辑，接下来我们会详细查看。
- en: The AWS ASG role
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS ASG 角色
- en: 'This role follows a similar pattern to the AWS VM Admin role, starting with
    generating the `cloud-init` script:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色遵循与 AWS VM 管理员角色类似的模式，首先生成 `cloud-init` 脚本：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then need to create a launch configuration:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要创建一个启动配置：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, this uses the `community.aws.autoscaling_launch_config` module
    as there is currently no official support in the `amazon.aws` collection for the
    creation of launch configurations.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里使用了`community.aws.autoscaling_launch_config`模块，因为目前`amazon.aws`集合中没有官方支持用于创建启动配置。
- en: 'The final task in the role, and also the final one where we will target AWS
    directly, is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 角色中的最后一个任务，也是我们直接针对AWS的最后一个任务如下所示：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This creates the ASG, which will immediately start to launch however many instances
    we have defined in the `{{ ec2.asg.desired_capacity }}` variable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建ASG，它将立即开始启动我们在`{{ ec2.asg.desired_capacity }}`变量中定义的实例数量。
- en: All values are again filled using hardcoded variables like the one we just mentioned
    or output registers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所有值再次使用硬编码变量填充，比如我们刚才提到的变量或输出寄存器。
- en: The Output role
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出角色
- en: 'All that is left now is to print some information to the terminal containing
    the URL we need to open to visit our WordPress installation and the credentials
    needed to log in:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是在终端打印一些信息，其中包含我们需要打开的URL，以访问我们的WordPress安装以及登录所需的凭据：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That concludes our Ansible playbook, so let’s look at executing it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的Ansible playbook的结尾，接下来我们来看一下如何执行它。
- en: Running the Ansible playbook
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行Ansible playbook
- en: 'The command to run the playbook is the same as we used in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to* *Microsoft Azure*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 运行playbook的命令与我们在[*第4章*](B19537_04.xhtml#_idTextAnchor151)中用于*部署到Microsoft Azure*时的相同：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once finished, you should see something like the following output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该能看到如下输出：
- en: '![Figure 5.4 – The last few lines of the playbook run output](img/Figure_5.04_B19537.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – playbook运行输出的最后几行](img/Figure_5.04_B19537.jpg)'
- en: Figure 5.4 – The last few lines of the playbook run output
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – playbook运行输出的最后几行
- en: 'If you were watching the output, you might have noticed where we put in the
    logic to wait for the admin EC2 instances to enter the `running` state. Those
    lines can be found in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在查看输出时，可能已经注意到我们放置的逻辑，用来等待admin EC2实例进入`running`状态。那些行可以在以下截图中找到：
- en: '![Figure 5.5 – Waiting for the instance to have a state of running](img/Figure_5.05_B19537.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 等待实例进入运行状态](img/Figure_5.05_B19537.jpg)'
- en: Figure 5.5 – Waiting for the instance to have a state of running
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 等待实例进入运行状态
- en: You can now follow the URL in the output and take a look at your WordPress installation.
    It should look like the Azure installation did in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*, and the AWS resources in the AWS Management Console
    at [http://console.aws.amazon.com](http://console.aws.amazon.com).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以跟随输出中的URL，查看你的WordPress安装。它应该看起来像[*第4章*](B19537_04.xhtml#_idTextAnchor151)中Azure的安装，并且在AWS管理控制台中的AWS资源可以在[http://console.aws.amazon.com](http://console.aws.amazon.com)查看。
- en: 'Once you are finished looking around, you can terminate all of the resources
    launched by the playbook by running the following command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你浏览完毕，可以通过运行以下命令来终止playbook启动的所有资源：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You may notice that a lot more is happening, as seen in the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，发生的事情更多了，正如以下输出所示：
- en: '![Figure 5.6 – Deleting all of the resources](img/Figure_5.06_B19537.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 删除所有资源](img/Figure_5.06_B19537.jpg)'
- en: Figure 5.6 – Deleting all of the resources
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 删除所有资源
- en: In fact, there are nearly 20 tasks compared to the small handful when we ran
    the same playbook in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying
    to Microsoft Azure*; why is that?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，与我们在[*第4章*](B19537_04.xhtml#_idTextAnchor151)中运行同一个playbook时相比，这里几乎有20个任务，而不是几个任务；为什么会这样呢？
- en: This is another difference between Microsoft Azure and AWS. When we deployed
    the resources in Microsoft Azure, we deployed them to a single resource group,
    which acts as a logical container for your workload, collecting all its resources
    together.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Microsoft Azure和AWS之间的另一个区别。当我们在Microsoft Azure中部署资源时，我们将它们部署到一个单独的资源组中，该资源组充当你的工作负载的逻辑容器，将所有资源集中在一起。
- en: When we came to terminate our Microsoft Azure deployment, we had to remove the
    resource group and all the resources contained within it in a single task.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们终止Microsoft Azure部署时，我们必须在一个任务中删除资源组及其包含的所有资源。
- en: However, AWS is very different, and we need to build a playbook to terminate
    the resources in the reverse order in which we deployed them.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，AWS非常不同，我们需要构建一个playbook，以相反的顺序终止我们部署的资源。
- en: Some of the tasks used in the `destroy.yml` file reuse a little of the logic
    we used in the roles to deploy the resources, so before we look at using Terraform
    in AWS, let’s quickly discuss the `destroy.yml` playbook, starting with the Auto
    Scaling group which will remove the instances we have launched.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`destroy.yml`文件中使用的一些任务重用了我们在部署资源时在角色中使用的一些逻辑，因此在我们开始使用Terraform在AWS中操作之前，让我们快速讨论一下`destroy.yml`剧本，首先是自动扩展组，它将移除我们已经启动的实例。
- en: Auto Scaling group
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动扩展组
- en: There are three tasks that deal with removing the ASG; the first task uses the
    `amazon.aws.autoscaling_group_info` module to get information on the ASG.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个任务涉及移除ASG；第一个任务使用`amazon.aws.autoscaling_group_info`模块获取ASG的信息。
- en: 'The second task uses the `amazon.aws.autoscaling_group` module with just enough
    configuration to allow us to set `state` to `absent` – but only when there are
    more than 0 results returned from the previous task. To do this, we use the following
    line:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个任务使用`amazon.aws.autoscaling_group`模块，并进行了足够的配置，使我们能够将`state`设置为`absent`——但仅在前一个任务返回的结果大于0时才会执行。为了实现这一点，我们使用了以下这一行：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This means that the task will be skipped if the ASG has been removed, but we
    need to rerun the playbook because of another failed task. We will be using this
    logic throughout this playbook.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果ASG已经被移除，任务将被跳过，但由于另一个任务失败，我们需要重新运行剧本。我们将在整个剧本中使用这种逻辑。
- en: The final of the three tasks removes the launch configuration using the `community.aws.autoscaling_launch_config`
    module.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 三个任务中的最后一个使用`community.aws.autoscaling_launch_config`模块移除启动配置。
- en: EC2 instance
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EC2实例
- en: Just the two tasks are required here, one that uses `amazon.aws.ec2_instance_info`
    to get information on our EC2 instances, and the second that uses `amazon.aws.ec2_instance`
    to set `state` to `absent` if the first task returns a result.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只需要完成两个任务，第一个任务使用`amazon.aws.ec2_instance_info`获取我们EC2实例的信息，第二个任务使用`amazon.aws.ec2_instance`将`state`设置为`absent`，当第一个任务返回结果时执行。
- en: RDS instance
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RDS实例
- en: There are three tasks here. The first gets information, the second terminates
    the RDS instance, and the third removes the RDS subnet group.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个任务，第一个获取信息，第二个终止RDS实例，第三个移除RDS子网组。
- en: EFS instance
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EFS实例
- en: Just a single task is required here; it uses `community.aws.efs` to ensure that
    any resources matching `{{ efs_name }}` in the region defined by `{{ region }}`
    are absent.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只需要一个任务；它使用`community.aws.efs`确保在`{{ region }}`定义的区域中，任何与`{{ efs_name }}`匹配的资源都不存在。
- en: Elastic load balancer
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弹性负载均衡器
- en: Here we have two more simple tasks that use `amazon.aws.elb_application_lb`
    and `community.aws.elb_target_group` to set our `state` resource to `absent`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个简单的任务，分别使用`amazon.aws.elb_application_lb`和`community.aws.elb_target_group`将我们的`state`资源设置为`absent`。
- en: Security groups
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全组
- en: If you remember, when we added the security groups, we used the ID of the Web
    security group to allow access to the RDS and EFS resources. Also, as we discussed
    when launching the EC2 instance, the Ansible playbook can sometimes be a little
    ahead of the AWS API when it comes to completing tasks, meaning that Ansible could
    be trying to move on to the next task before AWS has completed processing an earlier
    task.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，在我们添加安全组时，我们使用了Web安全组的ID来允许访问RDS和EFS资源。同时，正如我们在启动EC2实例时讨论的那样，Ansible剧本有时会比AWS
    API更快完成任务，也就是说，Ansible可能会在AWS完成先前任务之前就开始执行下一个任务。
- en: Because of this, there is the risk that either the RDS or EFS security group
    may not be fully removed before the playbook attempts to remove the web security
    group, which would result in a dependency error.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，存在这样的风险：在剧本尝试移除Web安全组之前，RDS或EFS安全组可能没有完全移除，这将导致依赖错误。
- en: 'To avoid this, we have a little checking built into the task:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们在任务中内置了一些检查：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, we are using `with_items` to loop through our three security
    groups and set their `state` to `absent`. We also have an `until` set, which will
    repeat whichever part of the loop fails until it has successfully removed the
    security group:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了`with_items`来循环遍历我们的三个安全组，并将它们的`state`设置为`absent`。我们还设置了`until`，该参数将重复执行失败的循环部分，直到成功移除安全组：
- en: '![Figure 5.7 – Setting the state of the security groups to absent](img/Figure_5.07_B19537.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 将安全组的状态设置为absent](img/Figure_5.07_B19537.jpg)'
- en: Figure 5.7 – Setting the state of the security groups to absent
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 将安全组的状态设置为absent
- en: It will allow for 25 failures and will try every 10 seconds. As you can see
    from the preceding screenshot, it should only fail once or twice before moving
    on.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 它将允许25次失败，并每10秒尝试一次。如前面的截图所示，它应该只会失败一两次，然后继续执行。
- en: Virtual Private Cloud
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟私有云
- en: The remaining tasks all work in the same pattern as we defined previously, apart
    from the route table. Like other resources, we use a module, `amazon.aws.ec2_vpc_route_table_info`
    in this case, to get information on the route tables. However, the difference
    here is that it will return the default route table, which was created when we
    first launched the VPC. This one will error if we try to remove it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的任务都按照我们之前定义的相同模式进行，除了路由表。像其他资源一样，我们使用一个模块，在这个案例中是`amazon.aws.ec2_vpc_route_table_info`，来获取路由表的信息。然而，这里的不同之处在于它将返回在首次启动VPC时创建的默认路由表。如果我们尝试删除它，将会报错。
- en: 'To get around this, we have to extend the `when` clause in the task:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须在任务中的`when`子句进行扩展：
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, this will remove the route table if there are more than zero
    of them listed and it is not the `main` association. This looks something like
    the following when run:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果列出了多个路由表并且它不是`main`关联，它将删除路由表。运行时看起来像下面这样：
- en: '![Figure 5.8 – Removing our custom route table but skipping the main one](img/Figure_5.08_B19537.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 移除自定义路由表但跳过主路由表](img/Figure_5.08_B19537.jpg)'
- en: Figure 5.8 – Removing our custom route table but skipping the main one
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 移除自定义路由表但跳过主路由表
- en: The remaining tasks follow the same patterns we used elsewhere in the chapter
    when we launched the resources.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的任务遵循我们在本章其他地方启动资源时使用的相同模式。
- en: Information
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Remember to make sure that all the resources have been removed by checking to
    see whether they are still listed in the AWS Management Console at [http://console.aws.amazon.com](http://console.aws.amazon.com),
    as you could incur unexpected costs if the preceding playbook failed for any reason.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 记得确保通过检查AWS管理控制台中的资源是否仍然列出，来确认所有资源已被移除。访问[http://console.aws.amazon.com](http://console.aws.amazon.com)，如果前面的剧本由于任何原因失败，可能会产生意外费用。
- en: That is the end of the playbook, which removes the resources and concludes our
    deep dive into running Ansible on AWS.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是剧本的结尾，它移除了资源并结束了我们对在AWS上运行Ansible的深入探讨。
- en: Now it is time to move on to Terraform.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候继续进行Terraform了。
- en: Terraform – reviewing the code and deploying our infrastructure
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform – 审查代码并部署我们的基础设施
- en: As we did a deep dive into Terraform in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*, we aren’t going to dig too deep into the code
    here, and instead will just highlight any considerations we need to make when
    targeting AWS or if there is a function we didn’t use when deploying our workload
    to Microsoft Azure.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[*第4章*](B19537_04.xhtml#_idTextAnchor151)《部署到微软Azure》中深入探讨Terraform时所做的那样，*我们不会深入讨论代码*，而是将重点介绍在针对AWS时需要考虑的事项，或者在将工作负载部署到微软Azure时未使用的功能。
- en: Walk-through of Terraform files
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform文件的逐步解析
- en: What follows is a walk-through of each of the Terraform files. Just as we did
    for Microsoft Azure, I have grouped each logical group of resources in its own
    `.``tf` file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是对每个Terraform文件的逐步解析。正如我们对微软Azure所做的那样，我将每组逻辑资源放在一个单独的`.tf`文件中。
- en: Setup
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: 'This is not too dissimilar to the one we defined for Azure. There are a few
    obvious differences – the biggest of which is that we are using the AWS provider:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们为Azure定义的差别不大。有一些明显的区别——其中最大的区别是我们使用了AWS提供程序：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Also, we are hardcoding the region we want to launch our resources in as a
    provider configuration option:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将区域硬编码为要启动资源的提供程序配置选项：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are a few omissions in that we are not loading any helper providers or
    modules to assist us with resource naming; that is going to be up to us to define
    as we launch our resources.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些遗漏，因为我们没有加载任何辅助提供程序或模块来帮助我们进行资源命名；这将由我们在启动资源时定义。
- en: Networking
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络
- en: 'There are several tasks here:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个任务：
- en: '`resource "aws_vpc" "vpc"`, which launches the VPC'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_vpc" "vpc"`，该代码启动VPC'
- en: '`resource "aws_subnet" "web01"`, which adds the `web01` subnet'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_subnet" "web01"`，该代码将添加`web01`子网'
- en: '`resource "aws_subnet" "web02"`, which adds the `web02` subnet'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_subnet" "web02"`，该代码将添加`web02`子网'
- en: '`resource "aws_subnet" "rds01"`, which adds the `rds01` subnet'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_subnet" "rds01"`，该代码将添加`rds01`子网'
- en: '`resource "aws_subnet" "rds02"`, which adds the `rds02` subnet'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_subnet" "rds02"`，该代码将添加`rds02`子网'
- en: 'The four subnet tasks all look similar:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 四个子网任务都很相似：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, there is a slight difference in the way we are defining the
    CIDR range for each subnet; rather than hardcode it as we did for Microsoft Azure,
    we are following a similar pattern as we did when using Ansible and are using
    a Terraform function called `cidrsubnet` to generate the correct CIDR range for
    us.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在定义每个子网的 CIDR 范围时略有不同；与我们在 Microsoft Azure 上硬编码 CIDR 范围的做法不同，我们遵循与使用 Ansible
    时类似的模式，使用 Terraform 函数 `cidrsubnet` 来生成正确的 CIDR 范围。
- en: The only other to note is that we are taking the list of `default_tags` we are
    defining in our `tfvars` file and merging it with a map we are dynamically creating
    using the `tomap` function. This map name contains the `Name` tag. We will be
    reusing this approach throughout the remainder of the deployment.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要注意的是，我们将定义在 `tfvars` 文件中的 `default_tags` 列表与我们通过 `tomap` 函数动态创建的映射合并。该映射名称包含
    `Name` 标签。我们将在剩余的部署过程中重复使用这种方法。
- en: 'The remaining tasks are very similar to the ones we performed when deploying
    using Ansible:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的任务与我们使用 Ansible 部署时执行的任务非常相似：
- en: '`resource "aws_internet_gateway" "vpc_igw"`, which deploys an internet gateway.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_internet_gateway" "vpc_igw"`，用于部署互联网网关。'
- en: '`resource "aws_route_table" "vpc_igw_route"`, which adds a route table to route
    all outgoing traffic to the internet gateway.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_route_table" "vpc_igw_route"`，用于添加路由表，将所有外向流量路由到互联网网关。'
- en: '`resource "aws_route_table_association" "rta_subnet_public01"`, which associates
    the route table we just created with the `web01` subnet.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_route_table_association" "rta_subnet_public01"`，用于将我们刚创建的路由表与
    `web01` 子网关联。'
- en: '`resource "aws_route_table_association" "rta_subnet_public02"`, which associates
    the route table we just created with the `web02` subnet.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_route_table_association" "rta_subnet_public02"`，用于将我们刚创建的路由表与
    `web02` 子网关联。'
- en: '`resource "aws_security_group" "sg_vms"`, which creates a security group opening
    ports `80` and `22` to everyone, that is, `0.0.0.0/0`.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_security_group" "sg_vms"`，用于创建一个安全组，开放端口 `80` 和 `22` 给所有人，也就是
    `0.0.0.0/0`。'
- en: '`resource "aws_security_group" "sg_efs"`, which adds the EFS security group
    opening port `2049` to any resource with the web security group attached.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_security_group" "sg_efs"`，用于添加 EFS 安全组，打开端口 `2049`，以允许任何附加了
    Web 安全组的资源访问。'
- en: '`resource "aws_security_group" "sg_rds"`, which creates the RDS security group
    opening port `3306` to any resource with the web security group attached.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_security_group" "sg_rds"`，用于创建 RDS 安全组，打开端口 `3306`，允许任何附加了 Web
    安全组的资源访问。'
- en: '`resource "aws_lb" "lb"`, which creates an elastic load balancer with a type
    of `application`.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_lb" "lb"`，用于创建类型为 `application` 的弹性负载均衡器。'
- en: '`resource "aws_lb_target_group" "front_end"`, which creates the target group
    we will be registering our EC2 instances with.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_lb_target_group" "front_end"`，用于创建目标组，我们将注册我们的 EC2 实例。'
- en: '`resource "aws_lb_listener" "front_end"`, which configures the frontend listener
    for port `80` on the elastic load balancer. When we launched our workload using
    Ansible, this was defined in line when creating the ELB resource.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_lb_listener" "front_end"`，用于配置弹性负载均衡器上端口 `80` 的前端监听器。当我们使用 Ansible
    启动工作负载时，这一项是在线定义的。'
- en: That is all the network resources we need to launch and configure to support
    the remaining services for our workload. Now we can start defining the resources
    themselves.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是我们启动并配置以支持工作负载其余服务所需的所有网络资源。现在我们可以开始定义这些资源本身。
- en: Storage
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储
- en: 'There are three tasks in this file, which are as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件中有三个任务，分别如下：
- en: '`resource "aws_efs_file_system" "efs"`, which creates the Amazon EFS volume'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_efs_file_system" "efs"`，用于创建 Amazon EFS 卷'
- en: '`resource "aws_efs_mount_target" "efs_mount_targets01"`, which creates the
    mount target in the `web01` subnet'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_efs_mount_target" "efs_mount_targets01"`，用于在 `web01` 子网中创建挂载目标'
- en: '`resource "aws_efs_mount_target" "efs_mount_targets02"`, which creates the
    mount target in the `web02` subnet'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_efs_mount_target" "efs_mount_targets02"`，用于在 `web02` 子网中创建挂载目标'
- en: Now that our storage is in place, we can move into the Amazon RDS instance.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的存储已经到位，我们可以进入 Amazon RDS 实例。
- en: Database
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库
- en: 'Again, we have just three tasks defined here to configure and launch our Amazon
    RDS instance. They are as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们在此只定义了三个任务来配置并启动我们的 Amazon RDS 实例。它们如下：
- en: '`resource "aws_db_subnet_group" "database"`, which creates the subnet group
    so that our Amazon RDS instance is accessible from within our VPC'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_db_subnet_group" "database"`，用于创建子网组，使我们的 Amazon RDS 实例可以从我们的
    VPC 内部访问。'
- en: '`resource "random_password" "database_password"`, which randomly generates
    the password we will be using when launching the Amazon RDS service'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "random_password" "database_password"`，它会随机生成我们在启动 Amazon RDS 服务时使用的密码'
- en: '`resource "aws_db_instance" "database"`, which deploys the Amazon RDS instance
    into the subnet group we defined and configures it per the variables we have defined
    in the `variables` file'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource "aws_db_instance" "database"`，它将 Amazon RDS 实例部署到我们定义的子网组中，并按照 `variables`
    文件中定义的变量进行配置'
- en: As you already know, as we are following the steps we took when launching the
    workload with Ansible, it is now time to launch the Admin EC2 instance and bootstrap
    WordPress.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经知道的，既然我们正在按照使用 Ansible 时启动工作负载的步骤，现在是时候启动 Admin EC2 实例并引导 WordPress 了。
- en: Virtual machine (admin)
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟机（管理员）
- en: 'First of all, we need to find the right AMI to use. This slightly differs from
    how we achieved this using Ansible, as Terraform can pick the latest one for us
    as part of the task execution:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到合适的 AMI 来使用。这与使用 Ansible 时有所不同，因为 Terraform 可以在任务执行时为我们选择最新的 AMI：
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, we are setting the `most_recent` key to be the value of the
    `var.ami_most_recent` variable, which by default is set to `true`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将 `most_recent` 键的值设置为 `var.ami_most_recent` 变量的值，默认情况下它被设置为 `true`。
- en: 'Before we launch the EC2 instance, we have one last bit of housekeeping to
    do, and that is to create the WordPress admin password:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 EC2 实例之前，我们还需要做最后一项准备工作，那就是创建 WordPress 管理员密码：
- en: '[PRE37]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we have everything we need to launch our EC2 instance. To start, we define
    the basics needed to launch the instance:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有了启动 EC2 实例所需的一切。首先，我们定义启动实例所需的基本信息：
- en: '[PRE38]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next part of the task is where the user data is defined. More on that in
    a second:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的下一部分是定义用户数据。稍后会详细介绍：
- en: '[PRE39]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we define the tags, which include the resource name:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义标签，其中包括资源名称：
- en: '[PRE40]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, we are using a similar logic to when we launched the workload
    in Microsoft Azure when injecting `user_data` by using the `templatefile` function.
    However, we are not having to Base64 encode it this time around.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了与在 Microsoft Azure 中启动工作负载时类似的逻辑，通过使用 `templatefile` 函数注入 `user_data`。不过这次我们不需要对其进行
    Base64 编码。
- en: The template for the `cloud-init` file contains the same changes we made when
    launching the workload using Ansible, again using `nc` to check that the DNS endpoint
    for the NFS share is responding on port `2048` before mounting the volume. The
    only other differences are related to the templating functions between the two
    tools.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`cloud-init` 文件的模板包含我们在使用 Ansible 启动工作负载时所做的相同更改，再次使用 `nc` 检查 NFS 共享的 DNS 端点是否在
    `2048` 端口上响应，然后才挂载卷。唯一的其他差异与两者之间的模板化功能有关。'
- en: 'The final task, like Ansible, is to register the newly launched EC2 instance
    with our ELB target group:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的任务，像 Ansible 一样，是将新启动的 EC2 实例注册到我们的 ELB 目标组中：
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The final difference between using Terraform and Ansible is that we do not have
    to build the logic to wait for the EC2 instance to have a state of `running` in
    our code, as Terraform continues to poll the state of the EC2 instance until it
    is as desired – which by default is `running`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Terraform 和 Ansible 之间的最终区别在于，我们不需要在代码中构建等待 EC2 实例达到 `running` 状态的逻辑，因为 Terraform
    会继续轮询 EC2 实例的状态，直到其达到期望状态——默认情况下是 `running`。
- en: Any dependencies on the EC2 task, like our `"aws_lb_target_group_attachment"
    "admin"` task, will not error as the Ansible deployment did because the deployment
    won’t progress until the state is met.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 任何依赖于 EC2 任务的操作，比如我们的 `"aws_lb_target_group_attachment" "admin"` 任务，都不会像 Ansible
    部署时那样报错，因为部署不会在满足条件之前继续推进。
- en: Auto Scaling group (web)
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动扩展组（web）
- en: As with Ansible, the final set of AWS resources we will launch is the ASG for
    the web servers.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Ansible 一样，我们将启动的最后一组 AWS 资源是 web 服务器的 ASG。
- en: 'Again, we start with a launch configuration:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们从启动配置开始：
- en: '[PRE42]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Like when we deployed in Microsoft Azure, the only variable we needed to pass
    into the template file was the DNS endpoint for the Amazon EFS endpoint.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 Microsoft Azure 中部署时一样，我们只需要传递一个变量——Amazon EFS 端点的 DNS 端点——到模板文件中。
- en: 'Now that the launch configuration is in place, we can create the ASG, which
    will immediately launch the number of EC2 instances we have defined in the `var.min_number_of_web_servers`
    variable:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动配置已到位，我们可以创建 ASG，它将立即启动我们在 `var.min_number_of_web_servers` 变量中定义的 EC2 实例数量：
- en: '[PRE43]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With that task in place, we have everything needed to launch the workload, apart
    from the output, which tells us how to access WordPress.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此任务后，我们已经拥有了启动工作负载所需的一切，除了输出，它告诉我们如何访问 WordPress。
- en: Output
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出
- en: 'There are three outputs defined here – one of which is being marked as `sensitive`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义了三个输出，其中一个被标记为`sensitive`：
- en: '[PRE44]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will give you the URL you can use to access your WordPress site, along
    with the username and password. Now we can run our Terraform script.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出您可以用来访问 WordPress 网站的 URL，以及用户名和密码。现在我们可以运行我们的 Terraform 脚本了。
- en: Deploying the environment
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署环境
- en: 'To deploy the environment, we simply need to run the following commands:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署环境，我们只需运行以下命令：
- en: '[PRE45]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Answering `yes` when prompted after running `terraform apply` will proceed
    with the deployment, and once complete, you should see something like the following
    screen:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`terraform apply`后，提示时回答`yes`将继续部署，完成后，您应该会看到类似以下的屏幕：
- en: '![Figure 5.9 – Deploying the environment using Terraform](img/Figure_5.09_B19537.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 使用 Terraform 部署环境](img/Figure_5.09_B19537.jpg)'
- en: Figure 5.9 – Deploying the environment using Terraform
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 使用 Terraform 部署环境
- en: Again, like we did when deploying to Microsoft Azure, running `terraform output
    -json` will show the content of the `sensitive` value, meaning you can browse
    and log in to WordPress and review the resources in the AWS Management Console.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，就像我们在部署到 Microsoft Azure 时做的那样，运行`terraform output -json`将显示`sensitive`值的内容，这意味着您可以浏览并登录到
    WordPress，并在 AWS 管理控制台中查看资源。
- en: 'When you have finished, you just need to run the following command:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，只需运行以下命令：
- en: '[PRE46]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will remove all the resources that we created using the `terraform apply`
    command. As always, double-check in the AWS Management Console that all of the
    resources have been removed correctly, as you do not want to incur any unexpected
    costs.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除我们使用`terraform apply`命令创建的所有资源。和往常一样，请在 AWS 管理控制台中再次检查，确保所有资源都已正确删除，以避免产生意外费用。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have done a deep dive into using Ansible to deploy our WordPress
    environment in AWS.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了如何使用 Ansible 在 AWS 中部署我们的 WordPress 环境。
- en: After discussing what our deployment looks like, we walked through the Ansible
    playbook and expanded on the quick overview that we had in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151),
    *Deploying to Microsoft Azure*. We discussed Ansible roles and how to bootstrap
    one using the `ansible-galaxy` `init` command.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了我们的部署情况后，我们回顾了 Ansible playbook，并扩展了我们在[*第 4 章*](B19537_04.xhtml#_idTextAnchor151)中对*部署到
    Microsoft Azure*的快速概述。我们讨论了 Ansible 角色以及如何使用`ansible-galaxy` `init`命令引导一个角色。
- en: We discussed some of the built-in functions and utilities, such as `ipsubnet`,
    `sort`, and `regex_replace`, which we used to manipulate hardcoded and output
    variables. We also covered a few different approaches for building logic into
    our playbook tasks using functions such as `until` to make sure that our playbook
    does not error both when launching the resources and, just as importantly, when
    terminating resources. After all, we don’t want stray resources hanging around
    and costing money.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了一些内置函数和工具，如`ipsubnet`、`sort`和`regex_replace`，这些我们用来操作硬编码和输出变量。我们还介绍了几种不同的方法，通过使用`until`等函数将逻辑构建到我们的
    playbook 任务中，以确保我们的 playbook 在启动资源时不出错，并且同样重要的是，在终止资源时也不会出错。毕竟，我们不希望留下无用资源而浪费金钱。
- en: We then took a quick look at how we would deploy the same resources using Terraform,
    as we had already done a deeper dive into Terraform, highlighting some additional
    approaches we can take when deploying resources.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们简要查看了如何使用 Terraform 部署相同的资源，因为我们已经深入探讨过 Terraform，突出了在部署资源时可以采用的一些额外方法。
- en: Throughout both walk-throughs, we also discussed the differences in the approach
    we needed to take to deploy our workload in AWS as opposed to Microsoft Azure.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个演练中，我们还讨论了在 AWS 和 Microsoft Azure 中部署工作负载时所需采取的方法差异。
- en: Feel free to play around with both the Ansible and Terraform code; for example,
    try and update the number of servers being launched, update the various SKUs,
    change the network addressing, and so on, and see what effects your changes have
    on the deployment.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 随意修改 Ansible 和 Terraform 代码；例如，尝试更新启动的服务器数量、更新各种 SKU、更改网络地址等，看看您的更改对部署的影响。
- en: In the next chapter, we will expand on what we have covered in this chapter
    and [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying to Microsoft Azure*,
    by looking further at how the two cloud-agnostic tools we have been looking at
    work and what considerations we need to make when approaching the cloud providers.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展本章内容，并通过进一步探讨我们一直在查看的两个云中立工具的工作原理以及在接触云服务提供商时需要考虑的因素，来深入了解[*第4章*](B19537_04.xhtml#_idTextAnchor151)，*部署到微软
    Azure*。
- en: We will also examine how we can make our Ansible and Terraform code more reusable.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨如何使我们的 Ansible 和 Terraform 代码更具可重用性。
- en: Further reading
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more details on the services and documentation we have mentioned
    in this chapter at the following URLs:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下网址找到本章中提到的服务和文档的更多细节：
- en: 'Amazon services:'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon 服务：
- en: 'Amazon ELB: [https://aws.amazon.com/elasticloadbalancing/](https://aws.amazon.com/elasticloadbalancing/)'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Amazon ELB: [https://aws.amazon.com/elasticloadbalancing/](https://aws.amazon.com/elasticloadbalancing/)'
- en: 'Amazon EC2: [https://aws.amazon.com/ec2/](https://aws.amazon.com/ec2/)'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Amazon EC2: [https://aws.amazon.com/ec2/](https://aws.amazon.com/ec2/)'
- en: 'Amazon EFS: [https://aws.amazon.com/efs/](https://aws.amazon.com/efs/)'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Amazon EFS: [https://aws.amazon.com/efs/](https://aws.amazon.com/efs/)'
- en: 'Amazon RDS: https://aws.amazon.com/rds/'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Amazon RDS: https://aws.amazon.com/rds/'
- en: 'Amazon VPC: [https://aws.amazon.com/vpc/](https://aws.amazon.com/vpc/)'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Amazon VPC: [https://aws.amazon.com/vpc/](https://aws.amazon.com/vpc/)'
- en: 'Amazon EC2 ASGs: [https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-groups.html](https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-groups.html)'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Amazon EC2 ASGs: [https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-groups.html](https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-groups.html)'
- en: 'Ansible collections:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 集合：
- en: 'Amazon AWS collection: [https://galaxy.ansible.com/amazon/aws](https://galaxy.ansible.com/amazon/aws)'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Amazon AWS 集合: [https://galaxy.ansible.com/amazon/aws](https://galaxy.ansible.com/amazon/aws)'
- en: 'Community AWS collection: [https://galaxy.ansible.com/community/aws](https://galaxy.ansible.com/community/aws)'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '社区 AWS 集合: [https://galaxy.ansible.com/community/aws](https://galaxy.ansible.com/community/aws)'
- en: 'Terraform provider:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 提供者：
- en: 'HashiCorp AWS: [https://registry.terraform.io/providers/hashicorp/aws/](https://registry.terraform.io/providers/hashicorp/aws/)'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'HashiCorp AWS: [https://registry.terraform.io/providers/hashicorp/aws/](https://registry.terraform.io/providers/hashicorp/aws/)'
