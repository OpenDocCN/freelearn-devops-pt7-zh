- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Collaborative Development with Git
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Git 进行协作开发
- en: '[*Chapter 2*](B21194_02.xhtml#_idTextAnchor028)*, Developing with Git*, and
    [*Chapter 3*](B21194_03_split_000.xhtml#_idTextAnchor049)*, Managing Your Worktrees*,
    taught you how to make new contributions to a project, but limited this information
    to affecting only your own clone of the project’s repository on your computer.
    [*Chapter 2*](B21194_02.xhtml#_idTextAnchor028) described how to commit new revisions,
    while [*Chapter 3*](B21194_03_split_000.xhtml#_idTextAnchor049) showed you how
    Git can help you prepare it.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第2章*](B21194_02.xhtml#_idTextAnchor028)，*使用 Git 开发*，以及[*第3章*](B21194_03_split_000.xhtml#_idTextAnchor049)，*管理工作树*，教你如何对项目做出新贡献，但这些内容仅限于影响你自己电脑上项目仓库的克隆。[*第2章*](B21194_02.xhtml#_idTextAnchor028)描述了如何提交新修订，而[*第3章*](B21194_03_split_000.xhtml#_idTextAnchor049)则展示了
    Git 如何帮助你准备这些修订。'
- en: This chapter and [*Chapter 7*](B21194_07.xhtml#_idTextAnchor172)*,* *Publishing
    Your* *Changes*, present a bird’s-eye view of the various ways to collaborate
    with others, showing centralized and distributed workflows. These two chapters
    will focus on the repository-level interactions in collaborative development,
    while the patterns of branches used will be covered in [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196),
    *Advanced* *Branching Techniques*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以及[*第7章*](B21194_07.xhtml#_idTextAnchor172)，*发布你的更改*，为你提供了一个全景视图，展示了与他人协作的不同方式，涵盖了集中式和分布式工作流。这两章将重点介绍协作开发中的仓库级交互，而使用的分支模式将在[*第8章*](B21194_08_split_000.xhtml#_idTextAnchor196)，*高级分支技术*中进行讲解。
- en: This chapter describes different collaborative workflows, explaining the advantages
    and disadvantages of each one. You will also learn about the chain of trust concept
    and how to use **signed tags**, **signed merges**, and **signed commits**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了不同的协作工作流，解释了每种工作流的优缺点。你还将了解信任链概念，以及如何使用**签名标签**、**签名合并**和**签名提交**。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Centralized and distributed workflows, and bare repositories
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式和分布式工作流，以及裸仓库
- en: Managing remotes and one-off single-shot collaboration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理远程仓库和一次性协作
- en: How versions are addressed—the chain of trust
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本如何被处理——信任链
- en: Tagging; lightweight tags versus signed tags
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签；轻量标签与签名标签
- en: Signed tags, signed merges, and signed commits
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名标签、签名合并和签名提交
- en: Collaborative workflows
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协作工作流
- en: There are various levels of engagement while using a version control system.
    One might, for example, only be interested in using Git to examine how the project
    came to be. [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083), *Exploring Project
    History*, and [*Chapter 5*](B21194_05.xhtml#_idTextAnchor113), *Searching Through
    the Repository*, covered this use of Git. Of course, examining a project’s history
    is an important part of development, too.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用版本控制系统时有不同的参与层次。例如，有些人可能仅对使用 Git 查看项目是如何发展的感兴趣。[*第4章*](B21194_04.xhtml#_idTextAnchor083)，*探索项目历史*，以及[*第5章*](B21194_05.xhtml#_idTextAnchor113)，*浏览仓库*，讲解了如何使用
    Git 来进行这种操作。当然，查看项目的历史也是开发中的一个重要部分。
- en: 'One might use version control for one’s private development, using it for a
    single developer project, on a single machine. [*Chapter 2*](B21194_02.xhtml#_idTextAnchor028),
    *Developing with Git*, and [*Chapter 3*](B21194_03_split_000.xhtml#_idTextAnchor049),
    *Managing Your* *Worktrees*, show how to do this with Git. Of course, people usually
    don’t work in isolation, but in a team: one’s own development is usually part
    of a collaboration.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能仅为私人开发使用版本控制，在单一机器上进行单人项目开发。[*第2章*](B21194_02.xhtml#_idTextAnchor028)，*使用
    Git 开发*，以及[*第3章*](B21194_03_split_000.xhtml#_idTextAnchor049)，*管理工作树*，展示了如何在 Git
    中进行这种操作。当然，人们通常不是单独工作，而是以团队形式进行开发：个人开发通常是协作的一部分。
- en: But one of the main goals of version control systems is to help multiple developers
    work together on a project, collaboratively. Version control makes it possible
    for them to work simultaneously on a given piece of software in an effective way,
    ensuring that their changes do not conflict with each other, and thus helping
    with merging those changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但版本控制系统的一个主要目标是帮助多个开发人员协作完成项目。版本控制使得他们能够高效地在同一软件上同时工作，确保他们的更改互不冲突，从而帮助合并这些更改。
- en: 'One might work on a project together with a few other developers, or with many.
    One might be a contributor, or a project maintainer. Maybe the project is so large
    that it needs subsystem maintainers. One might work in tight software teams, or
    one might want to make it easy for external contributors to provide proposed changes
    (for example, to fix bugs, or fix an error in the documentation). Various workflows
    might be best suited for those different situations:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能和几个开发者一起合作一个项目，或者与很多人一起合作。你可能是贡献者，也可能是项目维护者。也许项目太大，需要子系统维护者。你可能在紧密的软件团队中工作，或者可能希望让外部贡献者更容易地提供建议的更改（例如，修复bug或修正文档中的错误）。对于这些不同的情况，可能有多种工作流程更为适合：
- en: Centralized workflow
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中化工作流
- en: Peer-to-peer workflow
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点对点工作流
- en: Maintainer workflow
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护者工作流
- en: Hierarchical workflow
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层工作流
- en: Bare repositories
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 裸仓库
- en: 'There are two types of repositories:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的仓库：
- en: One with a working directory, and a staging area (**non-bare**)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有工作目录和暂存区的仓库（**非裸仓库**）
- en: A **bare repository**, without the working directory
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**裸仓库**，没有工作目录'
- en: The former type is meant for private solo development, and creating new history,
    while the latter is intended for collaboration and synchronizing development results.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前者类型用于私人单人开发并创建新历史，而后者则用于协作和同步开发结果。
- en: By convention, `.git` extension—for example, `project.git`—while `project` (with
    the administrative area and the local repository in `project/.git`).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，`.git`扩展名——例如，`project.git`——而`project`（其中包含行政区域和本地仓库在`project/.git`中）。
- en: You can usually omit this extension when cloning the repository, pushing to
    it, or fetching from it; using either `https://github.com/git/git.git` as the
    repository URL or [https://github.com/git/git](https://github.com/git/git) will
    work the same.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆仓库、推送到仓库或从仓库获取时，通常可以省略此扩展名；无论是使用`https://github.com/git/git.git`作为仓库URL，还是[https://github.com/git/git](https://github.com/git/git)，都能正常工作。
- en: 'To create the bare repository, you need to add the `--bare` option to the `git
    init` or `git clone` commands, as in the following example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建裸仓库，你需要在`git init`或`git clone`命令中添加`--bare`选项，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Interacting with other repositories
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他仓库交互
- en: 'After creating a set of revisions and extending the project’s history, you
    usually need to share it with other developers. You need to synchronize with other
    repository instances: publish your changes, and get changes from others.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一组修订并扩展项目历史后，你通常需要与其他开发者共享这些更改。你需要与其他仓库实例同步：发布你的更改，并获取他人的更改。
- en: From the perspective of the local repository instance – your own clone of the
    repository – you need to **push** your changes to the repository meant for publishing
    changes and **fetch** changes from other repositories. Often the only repository
    you need to interact with is simply the repository you cloned from. [*Chapter
    7*](B21194_07.xhtml#_idTextAnchor172), *Publishing Your Changes,* will describe
    this process (and its alternatives) in more detail.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从本地仓库实例——即你自己的仓库克隆——的角度来看，你需要将更改**推送**到用于发布更改的仓库，并从其他仓库**获取**更改。通常，你只需要与从中克隆的仓库进行交互。[*第7章*](B21194_07.xhtml#_idTextAnchor172)，*发布你的更改*，将更详细地描述此过程（及其替代方案）。
- en: After fetching changes, you sometimes need to incorporate them into your work
    by **merging** two lines of development (or **rebasing**)—which you can do in
    one operation with **pull**. Merging and rebasing operations will be described
    in more detail in [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229), *Merging* *Changes
    Together*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 获取更改后，有时需要通过**合并**两条开发线（或**变基**）将它们合并到你的工作中——你可以通过**pull**操作在一次操作中完成合并。合并和变基操作将在[*第9章*](B21194_09.xhtml#_idTextAnchor229)中更详细地描述，*合并更改*。
- en: Git assumes that you don’t want your local repository to be visible to the public,
    because these repositories are intended for private work (which helps to keep
    work not yet ready for the public from being visible).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Git假设你不希望本地仓库对外公开，因为这些仓库是用于私人工作（有助于将尚未准备好公开的工作保持不被外界看到）。
- en: 'This means that there is an additional step required to make your finished
    work available: you need to `git` `push` command.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着需要额外的步骤来使你的完成工作可用：你需要执行`git push`命令。
- en: The diagram in *Figure 6**.1*, which is an extension of the one in *Figure 2**.2*
    in [*Chapter 2*](B21194_02.xhtml#_idTextAnchor028), *Developing with Git*, demonstrates
    the steps one can take when creating and publishing commits. The arrows in this
    diagram show the Git commands used to copy contents from one place to another,
    including to and from the remote repository.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.1*中的图表，延伸自[*第 2 章*](B21194_02.xhtml#_idTextAnchor028)中的*图 2.2*，*使用 Git
    开发*，展示了创建和发布提交时可以采取的步骤。该图中的箭头表示用于将内容从一个地方复制到另一个地方的 Git 命令，包括从远程仓库到本地仓库。'
- en: '![Figure 6.1 – Creating commits, publishing commits, and fetching changes published
    by other developers into your local repository](img/B21194_06_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 创建提交、发布提交以及将其他开发者发布的更改获取到本地仓库](img/B21194_06_01.jpg)'
- en: Figure 6.1 – Creating commits, publishing commits, and fetching changes published
    by other developers into your local repository
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 创建提交、发布提交以及将其他开发者发布的更改获取到本地仓库
- en: Now, let us understand the centralized workflow.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们理解一下集中式工作流。
- en: The centralized workflow
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中式工作流
- en: 'With distributed version control systems, you can use different collaboration
    models, some more distributed, some less distributed. In a **centralized workflow**,
    there is one central hub: a shared repository, usually bare, that everyone uses
    to synchronize their work.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分布式版本控制系统时，可以使用不同的协作模式，有些更加分布式，有些则不那么分布式。在**集中式工作流**中，有一个中心枢纽：一个共享仓库，通常是裸仓库，所有人都用它来同步工作。
- en: '![Figure 6.2 – Centralized workflow – the shared repository is bare](img/B21194_06_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 集中式工作流 – 共享仓库为空](img/B21194_06_02.jpg)'
- en: Figure 6.2 – Centralized workflow – the shared repository is bare
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 集中式工作流 – 共享仓库为空
- en: In this workflow, each developer has their own **non-bare clone** of the central
    shared repository, which they use to develop new revisions of software. When changes
    are ready, they push those changes to the central repository, and fetch (or pull)
    changes from other developers from it. One might have to merge changes before
    being able to push. In this workflow integration of changes is distributed. This
    workflow is shown in *Figure 6**.2*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种工作流中，每个开发者都有自己**非裸的克隆**，用于开发软件的新版本。当更改准备好时，他们将这些更改推送到中央仓库，并从中获取（或拉取）其他开发者的更改。推送前可能需要先合并更改。在这种工作流中，变化的集成是分布式的。这种工作流如*图
    6.2*所示。
- en: Let us now look into the advantages and disadvantages of a *centralized workflow*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看*集中式工作流*的优缺点。
- en: Advantages of a centralized workflow
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集中式工作流的优点
- en: 'Some of the key advantages of centralized workflows include the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式工作流的一些主要优点包括以下几点：
- en: This workflow has a simple setup; it is a familiar paradigm for people coming
    from centralized version control systems and used to working with centralized
    management. It provides centralized access control and easy backups.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种工作流有一个简单的设置；它是那些来自集中式版本控制系统并习惯于集中式管理的人熟悉的范式。它提供了集中的访问控制和便捷的备份。
- en: It makes it easy to set up **continuous** **integration** (**CI**).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得设置**持续集成**（**CI**）变得容易。
- en: The process of merging changes is shared among developers, with no person solely
    responsible for integrating changes.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并更改的过程是由开发人员共同承担的，没有单个人负责集成更改。
- en: It might be a good setup for a private project with a small team, or where all
    developers are trusted and capable.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能是一个适合小型团队的私人项目的好设置，或者适合所有开发人员都值得信赖并具备能力的情况。
- en: Disadvantages of a centralized workflow
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集中式工作流的缺点
- en: 'Some of the disadvantages of centralized workflows are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式工作流的一些缺点如下：
- en: 'The shared repository is a single point of failure: if there are problems with
    the central repository, then there is no way to synchronize changes.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享仓库是单点故障：如果中央仓库出现问题，那么就无法同步更改。
- en: Each developer pushing changes (making them available for other developers)
    might require updating one’s own repository first, and merging changes from others.
    Shared integration means that each developer needs to know how to do it.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个开发者推送更改（使其对其他开发者可用）可能需要先更新自己的仓库，并合并其他人的更改。共享集成意味着每个开发者都需要知道如何操作。
- en: You also need to trust developers with access to the shared repository in this
    setup, or to provide access controls.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种设置中，你还需要信任开发人员能够访问共享仓库，或者提供访问控制。
- en: The peer-to-peer or forking workflow
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点对点或分叉工作流
- en: The opposite of a centralized workflow is a **peer-to-peer** or **forking workflow**.
    Instead of using a single central shared public repository, each developer has
    a public repository (which is bare), in addition to a private working repository
    (with a working directory), like in the *Figure 6**.3*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式工作流的对立面是**点对点**或**分支工作流**。与使用单一的中央共享公共仓库不同，每个开发者都有一个公共仓库（该仓库为空仓库），以及一个私人工作仓库（带有工作目录），如*图
    6.3*所示。
- en: '![Figure 6.3 – Peer-to-peer workflow – here, lines pointing up represent push
    operation, while lines pointing down represent fetch/pull operation](img/B21194_06_03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 点对点工作流 – 这里，指向上的线表示推送操作，而指向下的线表示拉取/获取操作](img/B21194_06_03.jpg)'
- en: Figure 6.3 – Peer-to-peer workflow – here, lines pointing up represent push
    operation, while lines pointing down represent fetch/pull operation
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 点对点工作流 – 这里，指向上的线表示推送操作，而指向下的线表示拉取/获取操作
- en: When the changes are ready, developers push to their own public repositories.
    To incorporate changes from other developers, one needs to fetch them from the
    public repositories of each of the other developers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当更改准备好后，开发者将更改推送到自己的公共仓库。为了合并来自其他开发者的更改，需要从其他开发者的公共仓库中获取它们。
- en: 'The advantages and disadvantages of this rarely used peer-to-peer workflow,
    also called forking workflow, are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种很少使用的点对点工作流，也叫做分支工作流，其优缺点如下：
- en: Advantages of the peer-to-peer workflow
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点对点工作流的优点
- en: One advantage of the forking workflow is that contributions can be integrated
    without the need for a central repository; it is a fully distributed workflow
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支工作流的一个优点是可以在不需要中央仓库的情况下进行贡献集成；它是一个完全分布式的工作流。
- en: Another advantage is that you are not forced to integrate if you want to publish
    your changes; you can merge at your leisure
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个优点是，如果你想发布你的更改，你不必强制进行集成；你可以随时进行合并。
- en: It is a good workflow for organic teams without requiring much setup
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个适用于有机团队的良好工作流，无需过多的设置
- en: Disadvantages of the peer-to-peer workflow
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点对点工作流的缺点
- en: The disadvantages are a lack of the canonical version, no centralized management,
    and the fact that in the basic form of this workflow you need to interact with
    many repositories. Though the **git remote update** or **git fetch --multiple**
    commands can help here by doing multiple fetches with a single command.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其缺点是缺乏规范版本、没有集中管理，并且在这种工作流的基本形式中，你需要与多个仓库进行交互。尽管**git remote update**或**git
    fetch --multiple**命令可以通过单个命令进行多次获取操作来帮助解决这一问题。
- en: Setting up this workflow requires developers’ public repositories to be reachable
    from other developers’ workstations, which might not be as easy as using one’s
    own machine as a server for one’s public repositories
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置此工作流需要确保开发者的公共仓库能够从其他开发者的工作站访问，这可能不像将自己的机器作为公共仓库的服务器那么简单。
- en: Also, as can be seen in *Figure 6**.3*, collaboration gets more complicated
    with the growing number of developers; this workflow does not scale well
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如*图 6.3*所示，随着开发者数量的增加，协作变得更加复杂；这种工作流的扩展性较差。
- en: The maintainer or integration manager workflow
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成经理或维护者工作流
- en: One of the problems with peer-to-peer workflows is that there is no canonical
    version of a project, something that non-developers can use. Another is that each
    developer has to do their own integration (which was also the case for the centralized
    workflow). If we promote one of the public repositories in *Figure 6**.3* to be
    the canonical (official) repository and make one of the developers responsible
    for integration, we arrive at the **integration manager workflow** (or **maintainer
    workflow**). The following diagram shows this workflow, with bare repositories
    at the top and non-bare at the bottom.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 点对点工作流的一个问题是没有项目的规范版本，非开发者无法使用。另外，每个开发者都必须自己进行集成（这在集中式工作流中也是如此）。如果我们将*图 6.3*中的某个公共仓库提升为规范（官方）仓库，并让其中一个开发者负责集成，那么我们就得到了**集成经理工作流**（或**维护者工作流**）。以下图展示了这种工作流，其中上方是空仓库，下方是非空仓库。
- en: '![Figure 6.4 – Integration-manager (maintainer) workflow – lines pointing up
    are push operations, while lines pointing down are fetch operations](img/B21194_06_04.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 集成经理（维护者）工作流 – 指向上的线为推送操作，而指向下的线为获取操作](img/B21194_06_04.jpg)'
- en: Figure 6.4 – Integration-manager (maintainer) workflow – lines pointing up are
    push operations, while lines pointing down are fetch operations
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 集成经理（维护者）工作流 – 向上的线表示推送操作，而向下的线表示拉取操作
- en: In this workflow, when changes are ready, the developer pushes those changes
    to their own public repository and tells the maintainer (for example, via a **pull
    request**) that they are ready. The **maintainer** pulls changes from the developer’s
    repository into their own working repository and integrates the changes. Then
    the maintainer pushes the merged changes to the **“blessed” repository**, for
    all to see, making them available to be fetched.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种工作流中，当更改准备好时，开发者将更改推送到自己的公共代码库，并通知维护者（例如，通过**拉取请求**）表示已准备好。然后，**维护者**从开发者的代码库拉取更改到自己的工作代码库并进行集成。接着，维护者将合并后的更改推送到**“受祝福的”代码库**，供所有人查看，并可以被获取。
- en: 'The advantages and disadvantages are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 优点和缺点如下：
- en: Advantages of the integration manager workflow
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成经理工作流的优点
- en: The advantages are having an official version of a project, and that developers
    can continue to work without doing or waiting for integration, as maintainers
    can pull their changes at any time.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种工作流的优点是拥有项目的官方版本，并且开发者可以继续工作，而无需进行集成或等待集成，因为维护者随时可以拉取他们的更改。
- en: It is a good workflow for a large organic team, as in open source projects.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种工作流适用于大型的有机团队，例如开源项目。
- en: The fact that the blessed repository is decided by social consensus makes it
    easy to switch to other maintainers, either temporarily (for example, when one
    maintainer takes some time off) or permanently (such as when forking a project),
    without the need to hand out access rights.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于“受祝福的”代码库是由社会共识决定的，这使得在不需要分配访问权限的情况下，能够轻松地切换到其他维护者，无论是暂时的（例如，当某个维护者需要休假时），还是永久的（例如，在进行项目分叉时）。
- en: This setup makes it easy for a smaller group of developers to collaborate by
    simply denoting one of the repositories in the group as the one to fetch from.
    The dotted line in *Figure 6**.4* shows this possibility of fetching from a non-official
    repository.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种设置使得一个较小的开发者团队通过简单地指定一个小组中的代码库作为拉取源，从而更容易地协作。*图6.4*中的虚线展示了从非官方代码库拉取的可能性。
- en: Disadvantages of the integration manager workflow
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成经理工作流的缺点
- en: The primary disadvantage is that the ability of the maintainer to integrate
    changes can be a bottleneck (as opposed to the centralized workflow, with distributed
    integration).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要的缺点是，维护者整合更改的能力可能成为瓶颈（与集中式工作流中的分布式集成相对）。
- en: This can happen especially for large teams and large projects. Thus, for very
    large organic teams, such as in Linux kernel development, it is better to use
    the hierarchical workflow, described in the next section.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尤其是对于大型团队和大规模项目，这种情况可能会发生。因此，对于非常大的有机团队，例如 Linux 内核开发，最好使用层级工作流，在下一节中将描述该工作流。
- en: There needs to be dedicated person that does the merging and is responsible
    for the state of the “*blessed*” repository.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要有专门的人员负责合并操作，并且对“*受祝福的*”代码库的状态负责。
- en: Another disadvantage is that it is more difficult to set up continuous integration
    than in the centralized repository workflow.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个缺点是，设置持续集成比在集中式代码库工作流中更为困难。
- en: The hierarchical or dictator-and-lieutenants workflow
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层级或独裁者与副手工作流
- en: The **hierarchical workflow** is a variant of the blessed repository workflow,
    generally used in huge projects with hundreds of collaborators. In this workflow,
    the project maintainer (sometimes called the **benevolent dictator**) is accompanied
    by additional integration managers, usually in charge of certain parts of the
    repository (subsystems). They are called **lieutenants**. The benevolent dictator’s
    public repository serves as the *blessed* reference repository from which all
    the collaborators need to pull. Lieutenants pull from developers and the maintainer
    pulls from the lieutenants, as shown in *Figure 6**.5*. (Note that in the following
    diagram, repositories shown with dashed patterns are actually pairs of private
    and public repositories of a developer or a lieutenant).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**分层工作流**是受认可仓库工作流的一个变体，通常用于有数百个合作者的巨大项目中。在这种工作流中，项目维护者（有时称为**仁慈的独裁者**）有多个额外的集成管理者，通常负责仓库的某些部分（子系统）。他们被称为**副手**。仁慈的独裁者的公共仓库作为*受认可*的参考仓库，所有合作者需要从中拉取更新。副手从开发者那里拉取更新，维护者从副手那里拉取更新，如*图
    6.5*所示。（请注意，在以下图示中，用虚线表示的仓库实际上是开发者或副手的私有仓库和公共仓库的配对）。'
- en: '![Figure 6.5 – Dictator and lieutenants workflow (hierarchical workflow)](img/B21194_06_05.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 独裁者和副手工作流（分层工作流）](img/B21194_06_05.jpg)'
- en: Figure 6.5 – Dictator and lieutenants workflow (hierarchical workflow)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 独裁者和副手工作流（分层工作流）
- en: In a **dictator** **and** **lieutenants** workflow, there is a hierarchy (a
    network) of repositories. Before starting work, either development or merging,
    one would usually pull updates from the canonical **(blessed) repository** for
    a project.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在**独裁者**与**副手**工作流中，存在一个仓库的层级（网络）。在开始工作之前，无论是开发还是合并，通常会从项目的规范**（受认可的）仓库**拉取更新。
- en: '**Developers** prepare changes in their own private repository, then send changes
    to an appropriate subsystem maintainer (lieutenant).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者**在自己的私有仓库中准备更改，然后将更改发送给合适的子系统维护者（副手）。'
- en: Changes can be sent as patches in email, or by pushing them to the **developer’s**
    public repository and sending a pull request to an appropriate integration manager
    (appropriate subsystem maintainer).
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更改可以通过电子邮件发送为补丁，或者通过将它们推送到**开发者**的公共仓库并向合适的集成管理者（合适的子系统维护者）发送拉取请求来进行。
- en: '**Lieutenants** are responsible for merging changes in their respective areas
    of responsibility.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**副手**负责合并他们各自负责区域的更改。'
- en: The master maintainer (**dictator**) pulls from the lieutenants (and occasionally
    directly from developers). The **dictator** is also responsible for pushing merged
    changes to the reference (canonical) repository, and usually also for release
    management (for example, creating tags for releases).
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主维护者（**独裁者**）从副手那里拉取更新（偶尔直接从开发者那里拉取）。**独裁者**还负责将合并后的更改推送到参考（规范）仓库，通常也负责发布管理（例如，为发布创建标签）。
- en: An overview of the advantages and disadvantages of this workflow follows.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这种工作流的优缺点概述。
- en: Advantages of the hierarchical workflow
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分层工作流的优点
- en: The advantage of this workflow is that it allows the project leader (the dictator)
    to delegate much of the integration work.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种工作流的优点是，它允许项目负责人（独裁者）将大部分集成工作委派出去。
- en: This can be useful in very big projects (concerning the number of developers
    and/or changes), or in highly hierarchical environments. Such a workflow is used,
    for example, to develop the Linux kernel.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种工作流在非常大的项目中（涉及开发者和/或更改的数量）或高度分层的环境中非常有用。例如，Linux 内核的开发就使用了这种工作流。
- en: Disadvantages of the hierarchical workflow
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分层工作流的缺点
- en: Its complicated setup is a disadvantage of this workflow. It is usually overkill
    for an ordinary project.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种工作流的复杂设置是它的一个缺点。它通常对普通项目来说是过度设计。
- en: Almost all other disadvantages of the integration manager workflow are present
    in this workflow, which is its more complex variant.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成管理者工作流几乎所有的其他缺点在这种工作流中都有体现，这也是它更复杂的变体。
- en: Which workflow to choose, and how to set up repositories, depend on how the
    project is developed. You need to decide which drawbacks are acceptable and which
    advantages matter most.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 选择哪种工作流以及如何设置仓库，取决于项目的开发方式。你需要决定哪些缺点是可以接受的，哪些优势最为重要。
- en: Managing remote repositories
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理远程仓库
- en: When collaborating on any project managed with Git, you will interact often
    with a constant set of other repositories. For example, using the integration-manager
    workflow will involve (at least) the canonical blessed repository of a project.
    In many cases, you will interact with more than one remote repository.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在与任何使用Git管理的项目协作时，你将经常与一组固定的其他仓库进行交互。例如，使用集成管理器工作流时，至少会涉及到项目的规范仓库。在很多情况下，你将与多个远程仓库交互。
- en: Git allows us to save the information about a remote repository (or just `git`
    `remote` command.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Git 允许我们保存关于远程仓库的信息（或仅仅是`git remote`命令）。
- en: Legacy mechanisms for storing remote repository information
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 存储远程仓库信息的遗留机制
- en: There are also two legacy mechanisms to store the information about remote repositories.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种遗留机制用于存储远程仓库的信息。
- en: This first is a named file in **.git/remotes**—the name of this file will be
    the nickname of the remote. This file can contain information about the URL or
    URLs, and fetch and push refspecs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是**.git/remotes**中的一个命名文件——这个文件的名称也将是远程的别名。该文件可以包含关于URL或URLs，以及fetch和push的refspecs信息。
- en: The second is a named file in **.git/branches**—the name of this file will also
    be the nickname of the remote. The contents of this file are just a URL for the
    repository, optionally followed by **#** and the branch name.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是**.git/branches**中的一个命名文件——这个文件的名称也将是远程的别名。该文件的内容仅仅是仓库的 URL，后面可以选择跟随**#**和分支名称。
- en: Neither of those mechanisms is likely to be found in modern repositories. See
    the *Remotes* section in the **git-fetch(1)** manpage for more details.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机制在现代代码库中不太可能被发现。详情请见**git-fetch(1)**手册中的*远程*部分。
- en: The “origin” remote
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “origin”远程
- en: When cloning a repository, Git will create one remote for you—the **origin remote**,
    which stores information about where you cloned from—that is the origin of your
    copy of the repository (hence the name). You can use this remote to fetch updates.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当克隆一个仓库时，Git 会为你创建一个远程——**origin远程**，它存储关于你从哪里克隆的仓库的信息——也就是你仓库副本的起源（因此得名）。你可以使用这个远程来获取更新。
- en: This is the default remote; for example, `git fetch` without the remote name
    will use the origin remote. You can change this using the `remote.default` configuration
    variable on a per-repository basis, or you can set up a default remote differently
    for a given branch with `branch.<branchname>.remote`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认的远程；例如，`git fetch`命令没有指定远程名称时，将使用origin远程。你可以通过在每个仓库中设置`remote.default`配置变量来更改此设置，或者为特定分支设置不同的默认远程，方法是使用`branch.<branchname>.remote`。
- en: Listing and examining remotes
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出并检查远程仓库
- en: 'To see which remote repositories you have configured, you can run the `git
    remote` command. It lists the short names of each remote you’ve got. In a cloned
    repository you will have at least one remote named `origin`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你已配置的远程仓库，可以运行`git remote`命令。它会列出你所有远程仓库的简短名称。在克隆的仓库中，你至少会有一个名为`origin`的远程：
- en: '[PRE1]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To see the URL together with remotes, you can use the `-v` or `--``verbose`
    options:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看URL及远程仓库信息，可以使用`-v`或`--verbose`选项：
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the output of this command, you can easily guess that the fetch and push
    URLs can be different (in a so-called **triangular workflow**).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个命令的输出中，你可以很容易猜测，fetch和push的URL可以不同（在所谓的**三角工作流**中）。
- en: 'If you want to inspect remotes to see more information about a particular remote,
    you can use the `git remote show <``remote>` subcommand:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看更多关于某个远程的信息，可以使用`git remote show <remote>`子命令：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Git will consult the remote configuration, the branch configuration, and the
    remote repository itself (for an up-to-date status). If you want to skip contacting
    the remote repository and use cached information instead, add the `-n` option
    to `git remote show`. If there is no internet connection,and you did not use `'-n'`
    option, Git will tell you that it was unable to contact the repository.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Git 将参考远程配置、分支配置以及远程仓库本身（以获取最新状态）。如果你希望跳过联系远程仓库并使用缓存信息，可以在`git remote show`命令中添加`-n`选项。如果没有互联网连接，并且你没有使用`'-n'`选项，Git
    将告诉你无法联系到仓库。
- en: 'As the information about remotes is stored in the repository configuration
    file, you can simply examine `.git/config`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关于远程的信息存储在仓库配置文件中，你可以直接查看`.git/config`：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The difference between local and remote branches (and `+refs/heads/*:refs/remotes/origin/*`
    . You can see it in the second line in the preceding example.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本地分支和远程分支之间的区别（以及`+refs/heads/*:refs/remotes/origin/*`）。你可以在前面的示例的第二行看到它。
- en: Adding a new remote
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新的远程
- en: 'To add a new remote Git repository and to store its information under a short
    name, run `git remote add <``shortname> <URL>`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个新的远程 Git 仓库，并以简短名称存储其信息，请运行 `git remote add <``shortname> <URL>`：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Adding remote doesn’t fetch from it automatically—you need to use the `-f` option
    for that (or run `git fetch <``shortname>` afterwards).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 添加远程不会自动从中获取数据——你需要使用 `-f` 选项来实现（或者之后运行 `git fetch <``shortname>`）。
- en: This command has a few options that affect how Git creates a new remote. You
    can select which branches in the remote repository you are interested in with
    the `-t <branch>` option. You can change which branch is the default one in the
    remote repository (and which you can refer to by the remote name) using the `-m
    <branch>` option; otherwise, it would be the current branch in the remote repository.
    You can fetch all tags or no tags with `--tags` or `--no-tags`, respectively;
    otherwise, only tags on fetched branches would be imported. Or you can configure
    the remote repository for mirroring rather than for collaboration with `--mirror=push`
    or `--mirror=fetch`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令有一些选项会影响 Git 如何创建一个新的远程。你可以通过 `-t <branch>` 选项选择你感兴趣的远程仓库中的分支。你可以通过 `-m
    <branch>` 选项更改远程仓库中默认的分支（以及可以通过远程名称引用的分支）；否则，它将是远程仓库中的当前分支。你可以使用 `--tags` 或 `--no-tags`
    来获取所有标签或不获取标签；否则，只有获取分支上的标签才会被导入。或者你可以将远程仓库配置为镜像而非协作，使用 `--mirror=push` 或 `--mirror=fetch`。
- en: 'For example, running the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，运行以下命令：
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'will result in the following configuration of the remote:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将会导致远程配置如下：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Updating information about remotes
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新关于远程的信息
- en: 'The information about the remote repository is stored in three places:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 关于远程仓库的信息存储在三个地方：
- en: 'In the remote configuration: **remote.<remote** **name>**,'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程配置中：**remote.<remote** **name>**，
- en: In remote-tracking branches and in the remote-HEAD (**refs/remotes/<remote name>/HEAD**)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程跟踪分支和远程-HEAD（**refs/remotes/<remote name>/HEAD**）中
- en: 'And optionally, in the per-branch configuration: **branch.<branch name>**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，也存储在每个分支的配置中：**branch.<branch name>**
- en: The remote-HEAD is a symbolic reference (`symref`) that defines the `<remote
    name>` refers to when used as a branch name, such as in the command `'git log
    <``remote name>'`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: remote-HEAD 是一个符号引用（`symref`），它定义了当作为分支名称使用时，`<remote name>` 所引用的内容，例如在命令 `'git
    log <``remote name>'` 中。
- en: You could manipulate this information directly—either by editing the appropriate
    files or using manipulation commands such as `git config` and `git symbolic-ref`—but
    Git provides various `git remote` subcommands for this.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接操作这些信息——无论是通过编辑适当的文件，还是使用诸如 `git config` 和 `git symbolic-ref` 之类的命令——但
    Git 提供了各种 `git remote` 子命令来处理这些。
- en: Renaming remotes
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重命名远程
- en: Renaming the remote—that is, changing its nickname—is quite a complicated operation.
    Running `git remote rename <old> <new>` will not only change the section name
    in `remote.<old>`, but also the remote-tracking branches and accompanying `refspec`,
    their reflogs (if there are any—see the `core.logAllRefUpdates` configuration
    variable), and the respective branch configurations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名远程——即更改其昵称——是一个相当复杂的操作。运行 `git remote rename <old> <new>` 不仅会更改 `remote.<old>`
    中的部分名称，还会更改远程跟踪分支和相关的 `refspec`，它们的 reflogs（如果有的话——见 `core.logAllRefUpdates` 配置变量）以及相应的分支配置。
- en: Changing the remote URLs
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改远程 URL
- en: You can add or replace the URL for a remote with `git remote set-url`, but it
    is also quite easy to simply directly edit the configuration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `git remote set-url` 来添加或替换远程的 URL，但直接编辑配置也是相当简单的。
- en: 'You can also use the `insteadOf` (and `pushInsteadOf`) configuration variables.
    This can be useful if you want to temporarily use another server, for example,
    if the canonical repository is temporarily down. Say that you want to fetch Git
    from the repository on GitHub, because [https://www.kernel.org](https://www.kernel.org)
    that you cloned Git from is down. You can do this by adding the following text
    to the config file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `insteadOf`（和 `pushInsteadOf`）配置变量。如果你暂时想使用另一个服务器，这会很有用。例如，如果你克隆 Git
    时从 [https://www.kernel.org](https://www.kernel.org) 下载 Git，但该网站暂时无法访问，你可以通过将以下内容添加到配置文件来实现：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Another use case for this feature is handling repository migration. You can
    use `insteadOf` rewriting in the per-user configuration file, that is, in `~/.gitconfig`
    (or `~/.config/git/config`), without having to change the URL in each and every
    repository’s `.git/config` file. In the case of more than one match, the longest
    match is used.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能的另一个应用场景是处理仓库迁移。你可以在每个用户的配置文件中使用`insteadOf`重写，位于`~/.gitconfig`（或`~/.config/git/config`），无需更改每个仓库的`.git/config`文件中的
    URL。如果有多个匹配项，最长的匹配项将被使用。
- en: Tip – multiple URLs for a remote
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 – 远程的多个 URL
- en: You can set multiple URLs for a remote. Git will try all these URLs sequentially
    when fetching and use the first one that works. When pushing, Git will publish
    to all URLs (all servers) simultaneously.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为一个远程设置多个 URL。Git 会按顺序尝试这些 URL，获取时使用第一个有效的 URL，推送时则会同时向所有 URL（所有服务器）发布。
- en: Changing the list of branches tracked by remote
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改远程跟踪分支列表
- en: A similar situation to changing the URL occurs when changing the list of branches
    tracked by a remote (that is, the contents of `fetch` lines). You can use `git
    remote set-branches` (with a sufficiently modern Git client) or edit the config
    file directly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 更改远程跟踪分支列表时，情况类似于更改 URL（即更改 `fetch` 行的内容）。你可以使用`git remote set-branches`（需要使用较新的
    Git 客户端）或者直接编辑配置文件。
- en: Note – stale remote-tracking branches
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 – 过时的远程跟踪分支
- en: Freeing a branch in a remote repository from being tracked does not remove the
    remote-tracking branch—the latter is simply no longer updated on fetch. This is
    explained in more detail in the *Deleting remote-tracking branches and remotes*
    section later in this chapter, which describes how to prune remote-tracking branches
    that correspond to branches deleted in remote the repository.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将远程仓库中的分支从跟踪中移除并不会删除远程跟踪分支——后者只是不会在获取时被更新。关于此操作的详细解释，请参阅本章后面的*删除远程跟踪分支和远程仓库*部分，里面描述了如何修剪与远程仓库中已删除分支对应的远程跟踪分支。
- en: Setting the default branch of the remote
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置远程的默认分支
- en: Having a `origin`) instead of a specific remote-tracking branch (for example,
    `origin/master`). This information is stored in the symbolic ref `<remote name>/HEAD`
    (for example, `origin/HEAD`).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`origin`而不是特定的远程跟踪分支（例如`origin/master`）。该信息存储在符号引用`<remote name>/HEAD`中（例如`origin/HEAD`）。
- en: 'You can set this with `git remote set-head` command. The `--auto` option does
    that based on what the current branch in the remote repository is:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`git remote set-head`命令来设置此项。`--auto`选项根据远程仓库当前分支来设置：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can delete the default branch on the remote with the `--``delete` option.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`--delete`选项删除远程的默认分支。
- en: Deleting remote-tracking branches and remotes
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除远程跟踪分支和远程仓库
- en: When a public branch is deleted in the remote repository, Git nevertheless keeps
    the corresponding remote-tracking branch. It does that because you might want
    to do, or might have already done, your own work on top of it. You can, however,
    delete the remote-tracking branch with `git branch -r -d`, or you can ask Git
    to prune all stale remote-tracking branches under the remote with `git remote
    prune`. You can configure Git to do this automatically on every fetch, as if `git
    fetch` were run with the `--prune` option, by setting the `fetch.prune` and/or
    `remote.<name>.prune` configuration variables (the latter on a per-remote basis).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当远程仓库中删除了公共分支时，Git 仍然保留相应的远程跟踪分支。这样做是因为你可能希望在其基础上进行工作，或者已经进行了工作。然而，你可以通过`git
    branch -r -d`命令删除远程跟踪分支，或者使用`git remote prune`命令要求 Git 修剪所有过时的远程跟踪分支。你还可以通过设置`fetch.prune`和/或`remote.<name>.prune`配置变量（后者是针对每个远程的配置）来让
    Git 在每次获取时自动执行此操作，仿佛是使用了`git fetch --prune`选项。
- en: You can check which remote-tracking branches are stale with the `--dry-run`
    option to `git remote prune`, or with the `git remote` `show` command.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`git remote prune`命令的`--dry-run`选项，或使用`git remote show`命令来检查哪些远程跟踪分支已过时。
- en: Deleting remote is as simple as running `git remote delete` (or its alias, `git
    remote rm`). It also removes remote-tracking branches for the deleted remote.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 删除远程仓库非常简单，只需运行`git remote delete`（或其别名`git remote rm`）。该命令还会删除已删除远程的远程跟踪分支。
- en: Support for triangular workflows
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持三角形工作流
- en: In many collaborative workflows, such as the maintainer (or integration manager)
    workflow, you fetch from one URL (from the blessed repository), but push to another
    URL (to your own public repository).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多协作工作流中，例如维护者（或集成经理）工作流，你可能从一个 URL（来自受信任的仓库）获取代码，但将代码推送到另一个 URL（推送到你自己的公共仓库）。
- en: 'As shown in *Figure 6**.4*, the developer interacts with three repositories:
    they fetch from the **blessed** repository (top left) into their own private repository
    (darker, at the bottom), then push their work into their own public repository
    (lighter, at the top).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 6.4*所示，开发者与三个仓库进行交互：他们从**受信**仓库（左上方）拉取到自己的私有仓库（下方较暗），然后将自己的工作推送到自己的公共仓库（上方较亮）。
- en: 'In such a `origin` remote (or `remote.default`). One option for configuring
    which repository you push to is to add this repository as a separate remote, and
    perhaps also set it up as the default with `remote.pushDefault`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的 `origin` 远程（或 `remote.default`）中，配置推送到哪个仓库的一个选项是将该仓库作为一个独立的远程添加，并可能将其设置为默认值，使用
    `remote.pushDefault`：
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You could also set it as `pushRemote` in the per-branch configuration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在每个分支的配置中将其设置为 `pushRemote`：
- en: '[PRE11]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another option is to use a single remote (perhaps even `origin`) but set it
    up with a separate `pushurl`. This solution, however, has the slight disadvantage
    that you don’t have separate remote-tracking branches for the push repository
    (and thus there is no support `@{push}` notation in addition to having `@{upstream}`
    as a shortcut for specifying the appropriate remote-tracking branches):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用单一远程（可能是 `origin`），但为其设置一个独立的 `pushurl`。然而，这种解决方案有一个轻微的缺点，那就是你没有为推送仓库设置独立的远程追踪分支（因此除了有
    `@{upstream}` 作为快捷方式外，无法使用 `@{push}` 表示法来指定相应的远程追踪分支）：
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Having separate remote-tracking branches for the push repository allows you
    to track which branches were pushed to the push remote, and which have local unpublished
    changes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为推送仓库设置独立的远程追踪分支，可以让你跟踪哪些分支已推送到推送远程，哪些有本地未发布的更改。
- en: Chain of trust
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信任链
- en: 'An important part of collaborative efforts during the development of a project
    is ensuring the quality of its code. This includes protection against the accidental
    corruption of the repository, and also from **malicious intent**—a task that the
    version control system can help with. Git needs to ensure trust in the repository
    contents: both your own and other developers’ (especially trust in the canonical
    repository of the project).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 项目开发过程中，协作工作的一个重要部分是确保代码的质量。这包括防止仓库意外损坏，也包括防止**恶意意图**——这是版本控制系统可以帮助完成的任务。Git
    需要确保对仓库内容的信任：不仅是你自己的内容，还有其他开发者的内容（特别是项目的规范仓库）。
- en: Content-addressed storage
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容寻址存储
- en: In [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083), *Exploring Project History*,
    in the *SHA-1 and the shortened SHA-1 identifier* section, we learned that Git
    currently uses SHA-1 hashes as a native identifier of commit objects (which represent
    revisions of the project and form the project’s history). This mechanism makes
    it possible to generate commit identifiers in a distributed way, taking a cryptographic
    hash of the commit object. This hash is then used to link to the previous commit
    (to the parent commit or commits).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B21194_04.xhtml#_idTextAnchor083)《探索项目历史》中的*SHA-1 和缩短的 SHA-1 标识符*一节中，我们了解到
    Git 当前使用 SHA-1 哈希作为提交对象的本地标识符（提交对象表示项目的修订并构成项目的历史）。这种机制使得能够以分布式的方式生成提交标识符，通过对提交对象进行加密哈希处理。然后，这个哈希值被用来链接到上一个提交（父提交或多个父提交）。
- en: Moreover, all other data stored in the repository (including the file contents
    in the revision represented by the blob objects, and the file hierarchy represented
    by the tree objects) also use the same mechanism. All types of object are addressed
    by their contents, or to be more accurate, the hash function of the object. You
    can say that the base of a Git repository is the *content-addressed* *object database*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，仓库中存储的所有其他数据（包括由 Blob 对象表示的修订中的文件内容，以及由 Tree 对象表示的文件层次结构）也使用相同的机制。所有类型的对象都是通过它们的内容来寻址，或者更准确地说，是通过对象的哈希函数来寻址。可以说，Git
    仓库的基础是*内容寻址的* *对象数据库*。
- en: Thus, Git provides a built-in **trust chain** through secure SHA-1 hashes, via
    a kind of a hash tree, also known as a Merkle tree. In one dimension, the SHA-1
    hash of a commit depends on its contents, which includes the SHA-1 hash of the
    parent commit or commits, which depends on the contents of the parent commit,
    and so forth down to the initial root commit. In the other dimension, the content
    of a commit object includes the SHA-1 hash of the tree representing the top directory
    of a project, which in turn depends on its contents, and these contents include
    the SHA-1 hash of the subdirectory trees and blobs of file contents, and so forth
    down to the individual files.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Git 通过安全的 SHA-1 哈希提供了内建的**信任链**，通过一种哈希树，也称为 Merkle 树。在一个维度上，提交的 SHA-1 哈希取决于其内容，其中包括父提交或多个父提交的
    SHA-1 哈希，父提交的哈希又取决于父提交的内容，依此类推，直到初始根提交。在另一个维度上，提交对象的内容包括表示项目顶层目录的树的 SHA-1 哈希，而这个哈希又依赖于其内容，这些内容包括子目录树和文件内容的
    SHA-1 哈希，依此类推，直到单个文件。
- en: "![Figure 6.6 – Hash tree of a short history of a project, with a tag, two commits,\
    \ and their contents. The SHA-1 hashes, shown in shortened form, \uFEFFdepending\
    \ on their contents](img/B21194_06_06.jpg)"
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 项目简短历史的哈希树，包含一个标签、两个提交及其内容。SHA-1 哈希以简化形式显示，取决于其内容](img/B21194_06_06.jpg)'
- en: Figure 6.6 – Hash tree of a short history of a project, with a tag, two commits,
    and their contents. The SHA-1 hashes, shown in shortened form, depending on their
    contents
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 项目简短历史的哈希树，包含一个标签、两个提交及其内容。SHA-1 哈希以简化形式显示，取决于其内容
- en: All of this allows SHA-1 hashes to be used to verify whether objects obtained
    from a (potentially untrusted) source have been corrupted or modified since they
    were created.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都使得可以使用 SHA-1 哈希来验证从（潜在不可信的）来源获取的对象自创建以来是否已被篡改或修改。
- en: Lightweight, annotated, and signed tags
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轻量、注释和签名标签
- en: 'The trust chain allows us to verify the contents but does not verify the identity
    of the person who created the content (the author and committer name are fully
    configurable and under user control). This is the task for GPG/PGP signatures:
    signed tags, signed commits, and signed merges.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 信任链允许我们验证内容，但不验证创建内容的人的身份（作者和提交者的名字是完全可配置的，由用户控制）。这是 GPG/PGP 签名的任务：签名标签、签名提交和签名合并。
- en: Since Git version 2.34, you can also use SSH keys for signing by setting the
    `gpg.format` configuration variable to the value `ssh`, for example with `git
    config gpg.format ssh` (you may also need to use your public key as the configuration
    value for the `user.signingKey` configuration variable).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Git 版本 2.34 开始，你还可以通过将 `gpg.format` 配置变量设置为 `ssh` 来使用 SSH 密钥进行签名，例如使用 `git
    config gpg.format ssh`（你可能还需要将公钥用作 `user.signingKey` 配置变量的配置值）。
- en: Lightweight tags
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轻量标签
- en: 'Git uses two types of tags: lightweight tags and annotated tags (there are
    also signed tags, which are a special case of annotated tags).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Git 使用两种类型的标签：轻量标签和注释标签（还有签名标签，它是注释标签的一种特殊情况）。
- en: A `refs/tags/` namespace rather than in `refs/heads/`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `refs/tags/` 命名空间，而不是在 `refs/heads/` 中。
- en: Annotated tags
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释标签
- en: '`refs/tags/` namespace) points to a tag object, which in turn points to a commit.
    Tag objects contain a creation date, the tagger identity (name and e-mail), and
    a tagging message. You create an annotated tag with `git tag -a` (or `--annotate`).
    If you don’t specify a message for an annotated tag on the command line (for example,
    with `-m "<message>"`), Git will launch your editor so you can enter it.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`refs/tags/` 命名空间指向一个标签对象，而该标签对象又指向一个提交。标签对象包含创建日期、标签创建者的身份（姓名和电子邮件）以及标签信息。你可以通过
    `git tag -a`（或 `--annotate`）来创建注释标签。如果你没有在命令行中为注释标签指定信息（例如，使用 `-m "<message>"`），Git
    会启动编辑器让你输入信息。'
- en: 'You can view the tag data along with the tagged commit with the `git show`
    command as follows (commit skipped):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `git show` 命令查看标签数据及其对应的提交（跳过提交）：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Signed tags
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 签名标签
- en: Signed tags are annotated tags with a clear text PGP signature (or, with modern
    Git, an SSH signature) of the tag data attached. You can create them with `git
    tag -s` (which uses your committer identity to select the signing key, or `user.signingKey`
    if set), or with `git tag -u <key-id>`; both versions assume that you have a `gpg
    --gen-key`).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 签名标签是带有明文 PGP 签名（或者，在现代 Git 中，是带有 SSH 签名）的注释标签。你可以通过 `git tag -s` 创建它们（该命令使用你的提交者身份来选择签名密钥，或者如果已设置，则使用
    `user.signingKey`），或者使用 `git tag -u <key-id>`；这两种方式假设你已经使用 `gpg --gen-key` 生成了密钥。
- en: Lightweight tags versus annotated and signed tags
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量标签与注释标签和签名标签的区别
- en: Annotated or signed tags are meant for marking a release, while lightweight
    tags are meant for private or temporary revision labels. For this reason, some
    Git commands (such as **git describe**) will ignore lightweight tags by default.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注释标签或签名标签用于标记发布，而轻量标签则用于私人或临时修订标签。出于这个原因，某些 Git 命令（如**git describe**）默认会忽略轻量标签。
- en: Of course in collaborative workflows, it is important that the signed tag is
    *made public*, and that there is a way to *verify it*; both of those operations
    will be described in the following sections.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在协作工作流中，重要的是签名标签需要被*公开*，并且要有一种方式来*验证它*；这两个操作将在以下章节中描述。
- en: Publishing tags
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布标签
- en: 'Git does not push tags by default: you need to do it explicitly. One solution
    is to individually `git push <remote> tag <tag-name>` (here, `tag <tag>` is equivalent
    to the longer `refs/tags/<tag>:refs/tags/<tag>`); however, if you don’t have the
    naming conflict between a branch and a tag (i.e., you don’t have branch and tag
    with the same name), then you can skip the word `tag` here in this operation.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Git 默认不推送标签：你需要明确地推送。一个解决方法是单独使用 `git push <remote> tag <tag-name>`（这里，`tag
    <tag>` 相当于更长的 `refs/tags/<tag>:refs/tags/<tag>`）；然而，如果你的分支和标签之间没有命名冲突（即，分支和标签没有相同的名称），你就可以省略这条命令中的
    `tag` 关键字。
- en: 'Another solution is to push tags en masse: either all the tags—both lightweight
    and annotated—with the use of the `--tags` option, or just all annotated tags
    that point to pushed commits with `--follow-tags`. This explicitness allows you
    to re-tag (using `git tag -f`) with impunity if it turns out that you tagged the
    wrong commit, or there is a need for a last-minute fix—but only if the tag was
    not made public. Git does not (and should not) change tags behind the user’s back;
    thus, if you pushed the wrong tag, you need to ask others to delete this old tag
    to change it.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方法是批量推送标签：使用 `--tags` 选项推送所有标签—包括轻量标签和注释标签，或者仅推送所有指向已推送提交的注释标签，使用 `--follow-tags`。这种明确性允许你在发现标签错误或需要最后时刻修复时重新标记（使用
    `git tag -f`），但前提是标签尚未公开。如果标签已推送，Git 不会（也不应该）在用户不知情的情况下更改标签；因此，如果你推送了错误的标签，需要请求其他人删除该旧标签以进行更改。
- en: When fetching changes, Git automatically **follows tags**, downloading annotated
    tags that point to fetched commits. This means that downstream developers will
    automatically get signed tags, and will be able to verify releases.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取变更时，Git 会自动**跟随标签**，下载指向已获取提交的注释标签。这意味着下游开发者将自动获得签名标签，并能够验证发布版本。
- en: Tag verification
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签验证
- en: To verify a signed tag, you use `git tag --verify <tag-name>` (or `-v` for short).
    You need the signer’s `gpg --import` or `gpg --keyserver <key-server> --recv-key
    <key-id>`), and of course the tagger’s key needs to be vetted in your chain of
    trust. For `gpg.ssh.allowedSignersFile` configuration variable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证签名标签，可以使用 `git tag --verify <tag-name>`（或者使用简写 `-v`）。你需要导入签名者的 `gpg --import`
    或 `gpg --keyserver <key-server> --recv-key <key-id>`，当然，标签创建者的密钥也需要在你的信任链中经过验证。对于
    `gpg.ssh.allowedSignersFile` 配置变量。
- en: '[PRE14]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Signed commits
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签名提交
- en: Signed tags are a good solution for users and developers to verify that the
    tagged release was created by the maintainer. But how do we make sure that a commit
    purporting to be by somebody named Jane Doe, with the `jane@company.com` e-mail,
    is *actually* a commit from her? How can we make it so anybody can check this?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 签名标签是用户和开发者验证标记发布是否由维护者创建的一个好方法。但我们如何确保一条声称是由名为 Jane Doe、邮箱为 `jane@company.com`
    的人提交的提交，*实际上*是她的提交呢？我们如何确保任何人都能检查这一点？
- en: 'One possible solution is to sign individual commits. You can do this with `git
    commit` `--gpg-sign[=<keyid>]` (or `-S` for short). The key identifier is optional—without
    this, Git would use your identity as the author. Note that `-S` (capital *S*)
    is different from `-s` (small *s*); the latter adds a *Signed-off-by* line at
    the end of the commit message for the *Digital Certificate* *of Ownership*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是签署单个提交。你可以使用 `git commit` 的 `--gpg-sign[=<keyid>]`（或简写 `-S`）来完成。密钥标识符是可选的—如果没有提供，Git
    会使用你的身份作为作者。请注意，`-S`（大写 *S*）与 `-s`（小写 *s*）不同；后者会在提交信息的末尾添加一个 *Signed-off-by* 行，表示*数字所有权证书*：
- en: '[PRE15]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To make commits available for verification, just push them. Anyone can then
    verify them with the `--show-signature` option to `git log` (or `git show`), or
    with one of the `%Gx` placeholders in `git` `log --format=<format>`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使提交可供验证，只需将它们推送出去。任何人都可以使用 `git log`（或 `git show`）的 `--show-signature` 选项，或者在
    `git log --format=<format>` 中使用 `%Gx` 占位符来验证它们：
- en: '[PRE16]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can also use the `git verify-commit` command for this.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`git verify-commit`命令来完成这项工作。
- en: Merging signed tags (merge tags)
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并签名标签（合并标签）
- en: The *signed commit* mechanism, described in the previous section, may be useful
    in some workflows, but it is inconvenient in an environment where you push commits
    out early, and only after a while do you decide whether they are worth including
    in the upstream. In such cases, you would want to sign only those parts that are
    ready to be published.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中描述的*签名提交*机制，在某些工作流中可能有用，但在一个提前推送提交的环境中并不方便，只有在一段时间后你才决定是否将它们纳入主干。在这种情况下，你可能只想签名那些准备好发布的部分。
- en: This situation can happen if you follow the recommendations in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping History Clean*; you know only after the fact (long after the commit was
    created) that the given iteration of the commit series passes code review. Commits
    need to be signed at commit creation time, but you can create a signed tag after
    the fact, after the series of commits gets accepted.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循了[*第10章*](B21194_10_split_000.xhtml#_idTextAnchor247)，《保持历史整洁》的建议，这种情况可能会发生；你在事后（很久以后）才知道给定的提交系列通过了代码审查。提交必须在创建时进行签名，但你可以在事后创建签名标签，在提交系列被接受后再进行签名。
- en: 'You can deal with this issue by rewriting the whole commit series after its
    shape is finalized (after passing the review), signing each rewritten commit,
    or just by amending and signing only the top commit. Both of those solutions would
    require a forced push to replace the old history where commits were not signed.
    You can always sign every commit, or you can create an empty commit (with `--allow-empty`),
    sign it, and push it on top of the series. But there is a better solution: requesting
    the pull of a signed tag.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在提交系列的形态定型后（通过审查）重写整个提交系列来处理这个问题，签署每个重写的提交，或者仅修改并签署顶部提交。这两种解决方案都需要强制推送，以替换没有签名的旧历史。你始终可以对每个提交进行签名，或者创建一个空提交（使用`--allow-empty`），签署它，并将其推送到系列的顶部。但有一个更好的解决方案：请求拉取一个签名标签。
- en: 'In this workflow, you work on your changes and, when they are ready, you create
    and push a signed tag (tagging the last commit in the series). You don’t have
    to push your working branch—pushing the tag is enough. If the workflow involves
    sending a pull request to the integrator, you create it using a signed tag instead
    of the end commit:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个工作流中，你需要进行更改，当更改准备好后，创建并推送一个签名标签（标记系列中的最后一个提交）。你不需要推送你的工作分支——推送标签就足够了。如果工作流涉及向集成者发送拉取请求，你应当使用签名标签来创建拉取请求，而不是使用最终提交：
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The signed tag message is shown between the dashed lines in the pull request,
    which means that you may want to explain your work in the tag message when creating
    the signed tag. The maintainer, after receiving such a pull request, can copy
    the repository line from it, fetching and integrating the named tag. When recording
    the merge result of pulling the named tag, Git will open an editor and ask for
    a commit message. The integrator will see a template starting with the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 签名标签消息会显示在拉取请求的虚线之间，这意味着你可能在创建签名标签时想要在标签消息中解释你的工作。维护者在收到这样的拉取请求后，可以从中复制仓库行，获取并集成命名标签。当记录拉取命名标签的合并结果时，Git会打开编辑器并要求输入提交消息。集成者将看到一个以以下内容为开头的模板：
- en: '[PRE18]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This commit template includes the commented-out output of the verification of
    the signed tag object being merged (so it won’t be in the final merge commit message).
    The tag message helps describe the merge better.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该提交模板包括合并签名标签对象验证的注释输出（因此它不会出现在最终的合并提交消息中）。标签消息有助于更好地描述合并内容。
- en: The signed tag being pulled is *not* stored in the integrator’s repository,
    not as a tag object. Its content is stored, hidden, in a merge commit. This is
    done to avoid polluting the tag namespace with a large number of such working
    tags. The developer can safely delete the tag (`git push public-repo --delete
    1252-for-maintainer`) after it gets integrated.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 被拉取的签名标签*不会*存储在集成者的仓库中，不作为标签对象存储。其内容被存储在一个隐藏的合并提交中。这么做是为了避免将大量类似的工作标签污染标签命名空间。开发者在集成后可以安全地删除该标签（`git
    push public-repo --delete 1252-for-maintainer`）。
- en: 'Recording the signature inside the merge commit allows for after-the-fact verification
    with the `--``show-signature` option:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并提交中记录签名允许在事后使用`--show-signature`选项进行验证：
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Through this chapter, we learned how to use Git for collaborative development
    and how to work together in a team on a project. We got to know different collaborative
    workflows, that is, different ways of setting up repositories for collaboration.
    Which one to use depends on circumstances: how large the team is, how diverse,
    and so on. This chapter focuses on repository-to-repository interaction; the interplay
    between branches and remote-tracking branches in those repositories is left for
    [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196), *Advanced* *Branching
    Techniques*.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们学习了如何使用 Git 进行协作开发，如何在团队中共同进行项目工作。我们了解了不同的协作工作流，也就是设置仓库进行协作的不同方式。选择哪种方式取决于具体情况：团队的大小、团队的多样性等。本章重点讨论了仓库与仓库之间的交互；这些仓库中分支与远程跟踪分支的相互作用将在
    [*第8章*](B21194_08_split_000.xhtml#_idTextAnchor196) 中讨论，*高级* *分支技术*。
- en: We learned how Git can help manage information about remote repositories involved
    in the chosen workflow. We were shown how to store, view, and update this information.
    This chapter explains how one can manage triangular workflows, in which you fetch
    from one repository (canonical), and push to the other (public).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了 Git 如何帮助管理与选定工作流相关的远程仓库的信息。我们学习了如何存储、查看和更新这些信息。本章解释了如何管理三角形工作流，其中你从一个仓库（规范仓库）获取数据，并推送到另一个仓库（公开仓库）。
- en: 'We learned about the chain of trust: how to verify that a release comes from
    the maintainer, how to sign your work so that the maintainer can verify that it
    comes from you, and how the Git architecture helps with this.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了信任链：如何验证发布来自维护者，如何签署你的工作以便维护者能够验证它确实来自你，以及 Git 架构如何帮助实现这一点。
- en: 'The next chapter, namely [*Chapter 7*](B21194_07.xhtml#_idTextAnchor172), *Publishing
    Your* *Changes*, will talk about how to get your contribution to other remote
    repositories. The two further following chapters will expand on the topic of collaboration:
    [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196), *Advanced Branching
    Techniques*, will explore relations between local branches and branches in a remote
    repository and how to set up branches for collaboration, while [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229),
    *Merging Changes Together*, will talk about the opposite issue—how to join the
    results of parallel work.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，也就是 [*第7章*](B21194_07.xhtml#_idTextAnchor172)，*发布你的* *更改*，将讨论如何将你的贡献推送到其他远程仓库。接下来的两章将进一步展开协作主题：[*第8章*](B21194_08_split_000.xhtml#_idTextAnchor196)，*高级分支技术*，将探讨本地分支与远程仓库中分支之间的关系，以及如何为协作设置分支；而
    [*第9章*](B21194_09.xhtml#_idTextAnchor229)，*合并更改*，将讨论相反的问题——如何将平行工作的结果合并起来。
- en: Questions
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下问题测试你对本章的理解：
- en: What operation do you need to publish your changes to your public remote repository,
    and what operation do you need to get changes from a remote?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要什么操作才能将更改发布到你的公共远程仓库？你需要什么操作才能从远程获取更改？
- en: What is the difference between **git fetch** and **git pull**?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**git fetch** 和 **git pull** 有什么区别？'
- en: How can you remove stale remote-tracking branches (that is, remote-tracking
    branches where the corresponding branch on the remote was deleted)?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何删除过期的远程跟踪分支（即，远程仓库中对应分支已删除的远程跟踪分支）？
- en: Answers
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to the questions given above:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是上述问题的答案：
- en: Use **git push** to publish your changes, and use **git fetch** or **git pull**
    (or **git remote update**) to get changes from the remote repository.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **git push** 发布你的更改，使用 **git fetch** 或 **git pull**（或 **git remote update**）从远程仓库获取更改。
- en: The **fetch** operation only downloads changes and updates the remote-tracking
    branches, while the **pull** operation also tries to update the current branch
    with **merge** or **rebase** (if it is configured as tracking some branch in the
    remote repository).
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**fetch** 操作只下载更改并更新远程跟踪分支，而 **pull** 操作还会尝试通过 **merge** 或 **rebase** 更新当前分支（如果它被配置为跟踪远程仓库中的某个分支）。'
- en: You can use **git branch -d -r** to delete individual remote-tracking branches,
    or **git remote prune** to delete all stale remote-tracking branches.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 **git branch -d -r** 删除单个远程跟踪分支，或者使用 **git remote prune** 删除所有过期的远程跟踪分支。
- en: Further reading
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解更多本章讨论的内容，请查看以下资源：
- en: 'Scott Chacon and Ben Straub: *Pro Git, 2nd Edition* (2014) [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Scott Chacon 和 Ben Straub: *Pro Git, 第二版* (2014) [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)'
- en: '*Chapter 5.1 Distributed Git -* *Distributed Workflows*'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第5.1章 分布式Git -* *分布式工作流*'
- en: '*Chapter 2.5 Git Basics - Working* *with Remotes*'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第2.5章 Git基础 - 与远程仓库* *合作*'
- en: '*Chapter 7.4 Git Tools - Signing* *Your Work*'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第7.4章 Git工具 - 签名* *你的工作*'
- en: 'Ryan Brown: *gpg-sign releases* (2014) [https://gitready.com/advanced/2014/11/02/gpg-sign-releases.html](https://gitready.com/advanced/2014/11/02/gpg-sign-releases.html)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ryan Brown: *gpg签名发布* (2014) [https://gitready.com/advanced/2014/11/02/gpg-sign-releases.html](https://gitready.com/advanced/2014/11/02/gpg-sign-releases.html)'
- en: 'Danilo Bargen: *Signing Git Commits with SSH Keys* (2021) https://blog.dbrgn.ch/2021/11/16/git-ssh-signatures/'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Danilo Bargen: *使用SSH密钥签名Git提交* (2021) https://blog.dbrgn.ch/2021/11/16/git-ssh-signatures/'
- en: 'Carl Tashian: *SSH Tips & Trick* – *Add a second factor to your SSH login*
    (2020) [https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh](https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Carl Tashian: *SSH技巧与窍门* – *为你的SSH登录添加第二因素* (2020) [https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh](https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh)'
- en: 'Junio C Hamano: *Git Blame: Fun (?) with GnuPG* (2014) [https://git-blame.blogspot.com/2014/09/fun-with-gnupg.html](https://git-blame.blogspot.com/2014/09/fun-with-gnupg.html)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Junio C Hamano: *Git Blame: 与GnuPG的趣味(?)* (2014) [https://git-blame.blogspot.com/2014/09/fun-with-gnupg.html](https://git-blame.blogspot.com/2014/09/fun-with-gnupg.html)'
