- en: Chapter 1. Getting Started with Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章：开始使用 Ansible
- en: ICT is often described as a fast-growing industry. I think the best quality
    of the ICT industry is not related to its ability to grow at a super high speed,
    but to its ability to revolutionize itself and the rest of the world at an astonishing
    speed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 信息与通信技术（ICT）常被描述为一个快速增长的行业。我认为 ICT 行业的最佳品质与其能以超高速度增长无关，而在于其能以惊人的速度革新自己和整个世界。
- en: Every 10 to 15 years there are major shifts in how this industry works and every
    shift solves problems that were very hard to manage up to that point, creating
    new challenges. Also, at every major shift, many best practices of the previous
    iteration are classified as anti-patterns and new best practices are created.
    Although it might appear that those changes are impossible to predict, this is
    not always true. Obviously, it is not possible to know exactly what changes will
    occur and when they will take place, but looking at companies with a large number
    of servers and many lines of code usually reveals what the next steps will be.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每隔 10 到 15 年，这个行业就会发生重大变化，每一次变化都解决了之前很难管理的问题，同时创造了新的挑战。此外，在每次重大变化中，许多前一轮的最佳实践被视为反模式，新的最佳实践则应运而生。尽管这些变化看似难以预测，但事实并非总是如此。显然，我们无法精确知道会发生什么变化，也无法预知这些变化何时发生，但观察拥有大量服务器和代码行数的公司，通常能揭示下一步会是什么。
- en: The current shift has already happened in big companies like Amazon Web Services,
    Facebook, and Google. It is the implementation of IT automation systems to create
    and manage servers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的转变已经在像亚马逊 Web 服务、Facebook 和 Google 这样的公司中发生。这就是实施 IT 自动化系统来创建和管理服务器的过程。
- en: 'In this chapter we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: IT automation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IT 自动化
- en: What is Ansible?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Ansible？
- en: The secure shell
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全外壳
- en: Installing Ansible
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Ansible
- en: Creating a test environment with QEMU and KVM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 QEMU 和 KVM 创建测试环境
- en: Version control system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制系统
- en: Using Ansible with Git
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 与 Git
- en: IT automation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IT 自动化
- en: IT automation is in its larger sense—the processes and software that help with
    the management of the IT infrastructure (servers, networking, and storage). In
    the current shift, we are assisting to a huge implementation of such processes
    and software.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: IT 自动化广义上是指帮助管理 IT 基础设施（服务器、网络和存储）的过程和软件。在当前的转变中，我们正在见证这种过程和软件的巨大实施。
- en: The history of IT automation
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IT 自动化的历史
- en: At the beginning of IT history, there were very few servers and a lot of people
    were needed to make them work properly, usually more than one person for each
    machine. Over the years, servers became more reliable and easier to manage so
    it was possible to have multiple servers managed by a single system administrator.
    In that period, the administrators manually installed the software, upgraded the
    software manually, and changed the configuration files manually. This was obviously
    a very labor-intensive and error-prone process, so many administrators started
    to implement scripts and other means to make their life easier. Those scripts
    were (usually) pretty complex and they did not scale very well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IT 历史的早期，服务器数量很少，通常需要大量的人力来使它们正常工作，通常每台机器需要一个以上的人来操作。随着时间的推移，服务器变得更加可靠且易于管理，因此单个系统管理员可以管理多个服务器。在那一时期，管理员手动安装软件，手动升级软件，并手动更改配置文件。显然，这是一项劳动密集型且容易出错的过程，因此许多管理员开始实施脚本和其他手段来简化工作。这些脚本（通常）相当复杂，且不太具备可扩展性。
- en: In the early years of this century, data centers started to grow a lot due to
    companies' needs. Virtualization helped in keeping prices low and the fact that
    many of these services were web services, meant that many servers were very similar
    to each other. At this point, new tools were needed to substitute the scripts
    that were used before, the configuration management tools.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本世纪初，随着企业需求的增长，数据中心开始迅速扩展。虚拟化有助于保持低成本，而许多服务是 Web 服务，这意味着许多服务器彼此非常相似。此时，需要新的工具来替代之前使用的脚本，即配置管理工具。
- en: '**CFEngine** was one of the first tools to demonstrate configuration management
    capabilities way back in the 1990s; more recently, there has been Puppet, Chef,
    and Salt, besides Ansible.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**CFEngine** 是上世纪90年代最早展示配置管理能力的工具之一；最近出现了 Puppet、Chef、Salt，以及 Ansible。'
- en: Advantages of IT automation
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IT 自动化的优势
- en: 'People often wonder if IT automation really brings enough advantages considering
    that implementing it has some direct and indirect costs. The main advantages of
    IT automation are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常常会疑惑，考虑到实施IT自动化会有一些直接和间接的成本，是否真的带来了足够的好处。IT自动化的主要优点是：
- en: Ability to provision machines quickly
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够快速配置机器
- en: Ability to recreate a machine from scratch in minutes
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在几分钟内从头创建一台机器
- en: Ability to track any change performed on the infrastructure
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够追踪基础设施上执行的任何更改
- en: For these reasons, it's possible to reduce the cost of managing the IT infrastructure
    by reducing the repetitive operations often performed by system administrators.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过减少系统管理员经常执行的重复性操作，可以降低管理IT基础设施的成本。
- en: Disadvantages of IT automation
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IT自动化的缺点
- en: 'As with any other technology, IT automation does come with some disadvantages.
    From my point of view these are the biggest disadvantages:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他技术一样，IT自动化也有一些缺点。依我看，这些是最大的缺点：
- en: Automating all of the small tasks that were once used to train new system administrators
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化所有曾经用于培训新系统管理员的小任务
- en: If an error is performed, it will be propagated everywhere
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发生错误，它将被传播到各个地方
- en: The consequence of the first is that new ways to train junior system administrators
    will need to be implemented.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个后果是，需要实施新的方式来培训初级系统管理员。
- en: Limiting the possible damages of an error propagation
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制错误传播可能带来的损害
- en: 'The second one is trickier. There are a lot of ways to limit this kind of damage,
    but none of those will prevent it completely. The following mitigation options
    are available:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题更棘手。有很多方法可以限制这种损害，但没有任何方法可以完全防止它。以下是可用的缓解选项：
- en: '**Always have backups**: Backups will not prevent you from nuking your machine;
    they will only make the restore process possible.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终有备份**：备份不能防止你摧毁机器，它们只是让恢复过程成为可能。'
- en: '**Always test your infrastructure code (playbooks/roles) in a non-production
    environment**: Companies have developed different pipelines to deploy code and
    those usually include environments such as dev, test, staging, and production.
    Use the same pipeline to test your infrastructure code. If a buggy application
    reaches the production environment it could be a problem. If a buggy playbook
    reaches the production environment, it could be catastrophic.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终在非生产环境中测试你的基础设施代码（剧本/角色）**：公司已经开发了不同的流水线来部署代码，这些流水线通常包括开发、测试、预发布和生产等环境。使用相同的流水线来测试你的基础设施代码。如果一个有问题的应用程序进入生产环境，可能会出现问题。如果一个有问题的剧本进入生产环境，可能会造成灾难。'
- en: '**Always peer-review your infrastructure code**: Some companies have already
    introduced peer-reviews for the application code, but very few have introduced
    it for the infrastructure code. As I was saying in the previous point, I think
    infrastructure code is way more critical than application code, so you should
    always peer-review your infrastructure code, whether you do it for your application
    code or not.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终进行基础设施代码的同行评审**：一些公司已经为应用程序代码引入了同行评审，但很少有公司为基础设施代码引入同行评审。正如我在前面提到的，我认为基础设施代码比应用程序代码更为关键，所以无论是否对应用程序代码进行同行评审，你都应该始终进行基础设施代码的同行评审。'
- en: '**Enable SELinux**: SELinux is a security kernel module that is available on
    all Linux distributions (it is installed by default on Fedora, Red Hat Enterprise
    Linux, CentOS, Scientific Linux, and Unbreakable Linux). It allows you to limit
    users and process powers in a very granular way. I suggest using SELinux instead
    of other similar modules (such as AppArmor) because it is able to handle more
    situations and permissions. SELinux will prevent a huge amount of damage because,
    if correctly configured, it will prevent many dangerous commands from being executed.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用SELinux**：SELinux是一个安全内核模块，适用于所有Linux发行版（在Fedora、Red Hat Enterprise Linux、CentOS、Scientific
    Linux和Unbreakable Linux中默认安装）。它允许你以非常细粒度的方式限制用户和进程的权限。我建议使用SELinux，而不是其他类似模块（如AppArmor），因为它能处理更多的情况和权限。SELinux将防止大量的损害，因为如果正确配置，它将防止许多危险命令的执行。'
- en: '**Run the playbooks from a limited account**: Even though user and privilege
    escalation schemes have been in UNIX code for more than 40 years, it seems as
    if not many companies use them. Using a limited user for all your playbooks, and
    escalating privileges only for commands that need higher privileges will help
    prevent you nuking a machine while trying to clean an application temporary folder.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从有限账户运行playbook**：尽管用户和权限提升方案在UNIX代码中已经存在了40多年，但似乎并不是很多公司在使用它们。为所有playbook使用一个有限用户，并且只为需要更高权限的命令提升权限，将有助于在尝试清理应用程序临时文件夹时防止误操作导致机器毁灭。'
- en: '**Use horizontal privilege escalation**: The `sudo` is a well-known command but
    is often used in its more dangerous form. The `sudo` command supports the ''`-u`''
    parameter that will allow you to specify a user that you want to impersonate.
    If you have to change a file that is owned by another user, please do not escalate
    to `root` to do so, just escalate to that user. In Ansible, you can use the `become_user`
    parameter to achieve this.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用水平权限提升**：`sudo`是一个众所周知的命令，但通常以更危险的形式使用。`sudo`命令支持`-u`参数，允许你指定要模拟的用户。如果你必须更改由另一个用户拥有的文件，请不要升级为`root`，而是升级为那个用户。在Ansible中，你可以使用`become_user`参数来实现这一点。'
- en: '**When possible, don''t run a playbook on all your machines at the same time**:
    Staged deployments can help you detect a problem before it''s too late. There
    are many problems that are not detectable in a dev, test, staging, and qa environment.
    The majority of them are related to load that is hard to emulate properly in those
    non-production environments. A new configuration you have just added to your Apache
    HTTPd or MySQL servers could be perfectly OK from a syntax point of view, but
    disastrous for your specific application under your production load. A staged
    deployment will allow you to test your new configuration on your actual load without
    risking downtime if something was wrong.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可能时，不要同时在所有机器上运行playbook**：分阶段部署可以帮助你在为时已晚之前检测到问题。有许多问题在开发、测试、暂存和质量保证环境中无法检测到。其中大多数与很难在这些非生产环境中正确模拟的负载相关。你刚刚添加到Apache
    HTTPd或MySQL服务器的新配置在语法上可能完全正确，但在生产负载下可能对你的特定应用程序造成灾难性影响。分阶段部署将允许你在实际负载下测试新配置，而不会在出现问题时面临停机风险。'
- en: '**Avoid guessing commands and modifiers**: A lot of system administrators will
    try to remember the right parameter and try to guess if they don''t remember it
    exactly. I''ve done it too, a lot of times, but this is very risky. Checking the
    man page or the online documentation will usually take you less than two minutes
    and often, by reading the manual, you''ll find interesting notes you did not know.
    Guessing modifiers is dangerous because you could be fooled by a non-standard
    modifier (that is, `-v` is not the verbose mode for `grep` and `-h` is not the `help`
    command for the MySQL CLI).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免猜测命令和修改器**：许多系统管理员会试图记住正确的参数，如果记不清楚就会猜测。我也经常这样做，但这是非常危险的。查看手册页或在线文档通常不会花费超过两分钟的时间，并且经常通过阅读手册，你会发现一些有趣的注记你之前并不知道。猜测修改器是危险的，因为你可能会被非标准的修改器愚弄（比如，`-v`不是`grep`的详细模式，`-h`不是MySQL
    CLI的帮助命令）。'
- en: '**Avoid error-prone commands**: Not all commands have been created equally.
    Some commands are (way) more dangerous than others. If you can assume a `cat` command
    safe, you have to assume that a `dd` command is dangerous, since `dd` perform
    copies and conversion of files and volumes. I''ve seen people using `dd` in scripts
    to transform DOS files to UNIX (instead of `dos2unix`) and many other, very dangerous,
    examples. Please, avoid such commands, because they could result in a huge disaster
    if something goes wrong.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免容易出错的命令**：并非所有命令都是平等的。有些命令比其他命令（要）危险得多。如果你认为`cat`命令是安全的，那么你必须认为`dd`命令是危险的，因为`dd`用于复制和转换文件和卷。我见过很多人在脚本中使用`dd`来将DOS文件转换为UNIX（而不是使用`dos2unix`），还有其他很多非常危险的例子。请避免使用这些命令，因为如果出现问题，可能会造成巨大的灾难。'
- en: '**Avoid unnecessary modifiers**: If you need to delete a simple file, use `rm
    ${file}` not `rm -rf ${file}`. The latter is often performed by users that have
    learned that; "to be sure, always use `rm -rf`", because at some time in their
    past, they have had to delete a folder. This will prevent you from deleting an
    entire folder if the `${file}` variable is set wrongly.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免不必要的修饰符**：如果你需要删除一个简单的文件，请使用`rm ${file}`而不是`rm -rf ${file}`。后者通常是那些学会了"为了保险起见，总是使用`rm
    -rf`"的用户执行的，因为在他们的过去，可能需要删除一个文件夹。这将防止你在`${file}`变量设置错误时误删整个文件夹。'
- en: '**Always check what could happen if a variable is not set**: If you want to
    delete the contents of a folder and you use the `rm -rf ${folder}/*` command,
    you are looking for trouble. If the `${folder}` variable is not set for some reason,
    the shell will read a `rm -rf /*` command, which is deadly (considering the fact
    that the `rm -rf /` command will not work on the majority of current OSes because
    it requires a `--no-preserve-root` option, while `rm -rf /*` will work as expected).
    I''m using this specific command as an example because I have seen such situations:
    the variable was pulled from a database which, due to some maintenance work, was
    down and an empty string was assigned to that variable. What happened next is
    probably easy to guess. In case you cannot prevent using variables in dangerous
    places, at least check them to see if they are not empty before using them. This
    will not save you from every problem but may catch some of the most common ones.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终检查如果变量未设置可能发生的情况**：如果你想删除文件夹中的内容，并使用`rm -rf ${folder}/*`命令，可能会遇到麻烦。如果由于某种原因，`${folder}`变量没有设置，shell会读取`rm
    -rf /*`命令，这将非常危险（考虑到`rm -rf /`命令在大多数当前操作系统上不起作用，因为它需要`--no-preserve-root`选项，而`rm
    -rf /*`命令则会按预期工作）。我使用这个特定的命令作为例子，因为我曾经见过类似的情况：变量是从数据库中提取的，由于某些维护工作，数据库出现故障，导致该变量被赋值为空字符串。接下来发生的事情可能很容易猜到。如果你无法避免在危险的地方使用变量，至少在使用之前检查它们是否为空。这不能解决所有问题，但可以捕获一些最常见的问题。'
- en: '**Double check your redirections**: Redirections (along with pipes) are the
    most powerful elements of Linux shells. They could also be very dangerous: a `cat
    /dev/rand > /dev/sda` command can destroy a disk even if a `cat` command is usually
    overlooked because it''s not usually dangerous. Always double-check all commands
    that include a redirection.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仔细检查你的重定向**：重定向（以及管道）是Linux Shell中最强大的元素。它们也可能非常危险：一个`cat /dev/rand > /dev/sda`命令可以摧毁一个磁盘，即使`cat`命令通常是被忽略的，因为它通常不危险。始终仔细检查所有包含重定向的命令。'
- en: '**Use specific modules wherever possible**: In this list I''ve used shell commands
    because many people will try to use Ansible as if it''s just a way to distribute
    them: it''s not. Ansible provides a lot of modules and we''ll see them in this
    book. They will help you create more readable, portable, and safe playbooks.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽可能使用特定模块**：在这个列表中，我使用了Shell命令，因为许多人会尝试将Ansible当作仅仅是分发Shell命令的工具来使用：它不是。Ansible提供了很多模块，我们将在本书中看到它们。它们将帮助你创建更加可读、可移植和安全的Playbooks。'
- en: Types of IT automation
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IT自动化类型
- en: There are a lot of ways to classify IT automation systems, but by far the most
    important is related to how the configurations are propagated. Based on this,
    we can distinguish between agent-based systems and agent-less systems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法来分类IT自动化系统，但最重要的还是与配置如何传播有关。基于此，我们可以区分基于代理的系统和无代理的系统。
- en: Agent-based systems
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于代理的系统
- en: 'Agent-based systems have two different components: a **server** and a client
    called **agent**.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基于代理的系统有两个不同的组件：一个**服务器**和一个叫做**代理**的客户端。
- en: There is only one server and it contains all of the configuration for your whole
    environment, while the agents are as many as the machines in the environment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个服务器，它包含了整个环境的所有配置，而代理的数量与环境中的机器数量相同。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In some cases, more than one server could be present to ensure high availability,
    but treat it as if it's a single server, since they will all be configured in
    the same way.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，为了确保高可用性，可能会有多个服务器，但请将其视为单一服务器，因为它们将以相同的方式进行配置。
- en: Periodically, client will contact the server to see if a new configuration for
    its machine is present. If a new configuration is present, the client will download
    it and apply it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端会定期联系服务器，以查看是否有新的配置文件。如果有新的配置，客户端将下载并应用它。
- en: Agent-less systems
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无代理的系统
- en: In agent-less systems, no specific agent is present. Agent-less systems do not
    always respect the server/client paradigm, since it's possible to have multiple
    servers and even the same number of servers and clients . Communications are initialized
    by the server that will contact the client(s) using standard protocols (usually
    via SSH and PowerShell).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在无代理系统中，不存在特定的代理。无代理系统并不总是遵循服务器/客户端范式，因为可以有多个服务器，甚至服务器和客户端的数量相同。通信由服务器初始化，服务器将使用标准协议（通常是
    SSH 或 PowerShell）联系客户端。
- en: Agent-based versus Agent-less systems
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于代理与无代理系统
- en: Aside from the differences outlined above, there are other contrasting factors
    which arise because of those differences.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述差异外，还有其他一些因为这些差异而产生的对比因素。
- en: From a security standpoint, an agent-based system can be less secure. Since
    all machines have to be able to initiate a connection to the server machine, this
    machine could be attacked more easily than in an agent-less case where the machine
    is usually behind a firewall that will not accept any incoming connections.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，基于代理的系统可能不如无代理的系统安全。由于所有机器都必须能够发起与服务器机器的连接，因此该机器可能比无代理系统更容易受到攻击，因为无代理系统中的机器通常位于防火墙后面，防火墙不会接受任何传入连接。
- en: From a performance point of view, agent-based systems run the risk of having
    the server saturated and therefore the roll-out could be slower. It also needs
    to be considered that, in a pure agent-based system, it is not possible to force-push
    an update immediately to a set of machines. It will have to wait until those machines
    check-in. For this reason, multiple agent-based systems have implemented out-of-bands
    wait to implement such feature. Tools such as Chef and Puppet are agent-based
    but can also run without a centralized server to scale a large number of machines,
    commonly called **Serverless Chef** and **Masterless Puppet**, respectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能角度来看，基于代理的系统存在服务器饱和的风险，因此部署可能会变慢。此外，还需要考虑到，在纯粹的基于代理的系统中，无法立即强制推送更新到一组机器。它必须等到那些机器检查到更新后才能应用。因此，多个基于代理的系统已经实现了带外等待以实现这一功能。像
    Chef 和 Puppet 这样的工具是基于代理的，但也可以在没有中央服务器的情况下运行，从而扩展大量的机器，通常被称为 **无服务器 Chef** 和 **无主
    Puppet**。
- en: An agent-less system is easier to integrate in an infrastructure that is already
    present, since it will be seen by the clients as a normal SSH connection and therefore
    no additional configuration is needed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 无代理系统更容易集成到现有基础架构中，因为它将被客户端视为普通的 SSH 连接，因此不需要额外的配置。
- en: What is Ansible?
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Ansible？
- en: 'Ansible is an agent-less IT automation tool developed in 2012 by *Michael DeHaan*,
    a former Red Hat associate. The Ansible design goals are for it to be: minimal,
    consistent, secure, highly reliable, and easy to learn. The Ansible company has
    recently been bought out by Red Hat and now operates as part of Red Hat, Inc.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一款无需代理的 IT 自动化工具，于 2012 年由 *Michael DeHaan*（前 Red Hat 员工）开发。Ansible
    的设计目标是：简洁、一致、安全、高度可靠且易于学习。Ansible 公司最近被 Red Hat 收购，现在作为 Red Hat, Inc. 的一部分运营。
- en: Ansible primarily runs in push mode using SSH, but you can also run Ansible
    using `ansible-pull`, where you can install Ansible on each agent, download the
    playbooks locally, and run them on individual machines. If there is a large number
    of machines (large is a relative term; in our view, greater than 500 and requiring
    parallel updates), and you plan to deploy updates to the machines in parallel,
    this might be the right way to go about it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 主要通过 SSH 以推送模式运行，但你也可以使用 `ansible-pull` 来运行 Ansible，方法是在每个代理上安装 Ansible，下载本地的
    playbook，并在单独的机器上运行它们。如果有大量的机器（“大量”是一个相对概念；在我们看来，大于 500 并且需要并行更新的机器），并且你计划对这些机器进行并行更新，那么这种方式可能是最合适的选择。
- en: Secure Shell (SSH)
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全外壳（SSH）
- en: '**Secure Shell** (also known as **SSH**) is a network service that allows you
    to login and access a shell remotely in a fully encrypted connection. The SSH
    daemon is today, the standard for UNIX system administration, after having replaced
    the unencrypted telnet. The most frequently used implementation of the SSH protocol
    is OpenSSH.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全外壳**（也称为 **SSH**）是一种网络服务，允许你通过完全加密的连接远程登录并访问一个 shell。SSH 守护进程如今已经成为 UNIX
    系统管理的标准，取代了未加密的 telnet。SSH 协议最常用的实现是 OpenSSH。'
- en: In the last few months, Microsoft has shown an implementation (at the time of
    writing) of OpenSSH for Windows.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几个月中，微软展示了 OpenSSH 在 Windows 上的实现（截至本文写作时）。
- en: Since Ansible performs SSH connections and commands in the same way any other
    SSH client would do, no specific configuration has been applied to the OpenSSH
    server.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Ansible 执行 SSH 连接和命令的方式与其他任何 SSH 客户端相同，因此对 OpenSSH 服务器没有做特殊配置。
- en: To speed up default SSH connections, you can always enable `ControlPersist`
    and the pipeline mode, which makes Ansible faster and secure.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加速默认的 SSH 连接，你可以始终启用 `ControlPersist` 和管道模式，这样可以使 Ansible 更快且更安全。
- en: Why Ansible?
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Ansible？
- en: We will try and compare Ansible with Puppet and Chef during the course of this
    book since many people have good experience with those tools. We will also point
    out specifically how Ansible would solve a problem compared to Chef or Puppet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将尝试将 Ansible 与 Puppet 和 Chef 进行比较，因为许多人对这些工具有很好的使用经验。我们还将特别指出 Ansible
    相对于 Chef 或 Puppet 解决问题的方法。
- en: Ansible, as well as Puppet and Chef, are declarative in nature and are expected
    to move a machine to the desired state specified in the configuration. For example,
    in each of these tools, in order to start a service at a point in time and start
    it automatically on restart, you would need to write a declarative block or module;
    every time the tool runs on the machine, it will aspire to obtain the state defined
    in your **playbook** (Ansible), **cookbook** (Chef), or **manifest** (Puppet).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible、Puppet 和 Chef 都是声明性的，旨在将机器移到配置中指定的期望状态。例如，在这些工具中，为了在某个时间点启动服务并在重启时自动启动，你需要编写一个声明性块或模块；每次工具在机器上运行时，它都会努力实现你在
    **playbook**（Ansible）、**cookbook**（Chef）或 **manifest**（Puppet）中定义的状态。
- en: The difference in the toolset is minimal at a simple level but as more situations
    arise and the complexity increases, you will start finding differences between
    the different toolsets. In Puppet, you need to take care of the order, and the
    Puppet server will create the sequence of instructions to execute every time you
    run it on a different box. To exploit the power of Chef, you will need a good
    Ruby team. Your team needs to be good at the Ruby language to customize both Puppet
    and Chef, and there will be a bigger learning curve with both of the tools.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单层面上，工具集之间的差异是最小的，但随着情况的增加和复杂性的提高，你将开始发现不同工具集之间的差异。在 Puppet 中，你需要注意顺序，每次在不同的主机上运行时，Puppet
    服务器都会创建执行指令的顺序。为了充分利用 Chef 的功能，你需要一个优秀的 Ruby 团队。你的团队需要精通 Ruby 语言，才能定制 Puppet 和
    Chef，这两款工具的学习曲线都较大。
- en: With Ansible, the case is different. It uses the simplicity of Chef when it
    comes to the order of execution, the top-to-bottom approach, and allows you to
    define the end state in YAML format, which makes the code extremely readable and
    easy for everyone, from development teams to operations teams, to pick up and
    make changes. In many cases, even without Ansible, operations teams are given
    playbook manuals to execute instructions from, whenever they face issues. Ansible
    mimics that behavior. Do not be surprised if you end up having your project manager
    change the code in Ansible and check it into Git because of its simplicity!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ansible 的情况有所不同。它在执行顺序上借鉴了 Chef 的简洁性，采用自上而下的方式，并允许你以 YAML 格式定义最终状态，这使得代码非常易读，开发团队到运维团队的每个人都能轻松理解并做出修改。在许多情况下，甚至没有
    Ansible 时，运维团队也会得到 playbook 手册，以便在遇到问题时执行指令。Ansible 模拟了这种行为。如果你发现你的项目经理因为其简洁性而修改
    Ansible 代码并将其提交到 Git，不要感到惊讶！
- en: Installing Ansible
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Ansible
- en: Installing Ansible is rather quick and simple. You can use the source code directly,
    by cloning it from the GitHub project ([https://github.com/ansible/ansible](https://github.com/ansible/ansible)),
    install it using your system's package manager, or use Python's package management
    tool (**pip**). You can use Ansible on any Windows, Mac, or UNIX-like system.
    Ansible doesn't require any databases and doesn't need any daemons running. This
    makes it easier to maintain Ansible versions and upgrade without any breaks.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Ansible 既快速又简单。你可以直接使用源代码，通过从 GitHub 项目中克隆它（[https://github.com/ansible/ansible](https://github.com/ansible/ansible)），使用系统的包管理器进行安装，或者使用
    Python 的包管理工具（**pip**）。你可以在任何 Windows、Mac 或类 UNIX 系统上使用 Ansible。Ansible 不需要任何数据库，也不需要运行任何守护进程。这使得维护
    Ansible 版本和升级变得更加轻松，不会出现中断。
- en: We'd like to call the machine where we will install Ansible our Ansible workstation.
    Some people also refer to it as the command center.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装 Ansible 的机器称为我们的 Ansible 工作站。有些人也称其为指挥中心。
- en: Installing Ansible using the system's package manager
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用系统的包管理器安装 Ansible
- en: It is possible to install Ansible using the system's package manager and in
    my opinion this is the preferred option if your system's package manager ships
    at least Ansible 2.0\. We will look into installing Ansible via **Yum**, **Apt**,
    **Homebrew**, and **pip**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过系统的包管理器安装 Ansible 是可行的，我个人认为，如果你的系统的包管理器提供至少 Ansible 2.0 的版本，这是首选方案。我们将探讨如何通过
    **Yum**、**Apt**、**Homebrew** 和 **pip** 安装 Ansible。
- en: Installing via Yum
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 Yum 安装
- en: 'If you are running a Fedora system you can install Ansible directly, since
    from Fedora 22, Ansible 2.0+ is available in the official repositories. You can
    install it as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行 Fedora 系统，你可以直接安装 Ansible，因为从 Fedora 22 开始，Ansible 2.0+ 已经可以在官方仓库中找到。你可以按如下方式安装：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For RHEL and RHEL-based (CentOS, Scientific Linux, Unbreakable Linux) systems,
    versions 6 and 7 have Ansible 2.0+ available in the EPEL repository, so you should
    ensure that you have the EPEL repository enabled before installing Ansible as
    follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 RHEL 和基于 RHEL 的系统（CentOS、Scientific Linux、Unbreakable Linux），版本 6 和 7 在 EPEL
    仓库中提供 Ansible 2.0+，因此你应确保在安装 Ansible 之前已启用 EPEL 仓库，如下所示：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Cent 6 or RHEL 6, you have to run the command `rpm -Uvh`. Refer to [http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm](http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm)
    for instructions on how to install EPEL.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cent 6 或 RHEL 6 上，你必须运行命令`rpm -Uvh`。有关如何安装 EPEL 的说明，请参阅[http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm](http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm)。
- en: Installing via Apt
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 Apt 安装
- en: 'Ansible is available for Ubuntu and Debian. To install Ansible on those operating
    systems, use the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 可用于 Ubuntu 和 Debian。要在这些操作系统上安装 Ansible，请使用以下命令：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing via Homebrew
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 Homebrew 安装
- en: 'You can install Ansible on Mac OS X using Homebrew, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 Homebrew 在 Mac OS X 上安装 Ansible，如下所示：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Installing via pip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 pip 安装
- en: 'You can install Ansible via pip. If you don''t have pip installed on your system,
    install it. You can use pip to install Ansible on Windows too, using the following
    command line:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 pip 安装 Ansible。如果你的系统没有安装 pip，请先安装它。你也可以使用 pip 在 Windows 上安装 Ansible，使用以下命令行：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can now install Ansible using `pip`, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用`pip`安装 Ansible，如下所示：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once you''re done installing Ansible, run `ansible --version` to verify that
    it has been installed:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，运行`ansible --version`来验证是否已安装：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will get the following output from the preceding command line:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从前面的命令行获得以下输出：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Installing Ansible from source
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从源代码安装 Ansible
- en: 'In case the previous methods do not fit your use case, you can install Ansible
    directly from the source. Installing from source does not require any root permissions.
    Let''s clone a repository and activate `virtualenv`, which is an isolated environment
    in Python where you can install packages without interfering with the system''s
    Python packages. The command and the resulting output for the repository is as
    follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前的方法不适合你的使用场景，你可以直接从源代码安装 Ansible。源代码安装不需要任何管理员权限。让我们克隆一个仓库并激活`virtualenv`，这是
    Python 中的一个隔离环境，你可以在其中安装包而不会干扰系统的 Python 包。以下是克隆仓库的命令及其输出：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Ansible needs a couple of Python packages, which you can install using `pip`.
    If you don''t have pip installed on your system, install it using the following
    command. If you don''t have `easy_install` installed, you can install it using
    Python''s `setuptools` package on Red Hat systems, or by using Brew on the Mac:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 需要一些 Python 包，你可以使用`pip`安装。如果你的系统没有安装 pip，可以使用以下命令安装它。如果没有安装`easy_install`，你可以通过
    Red Hat 系统上的 Python `setuptools` 包或通过 Mac 上的 Brew 安装它：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once you have installed `pip`, install the `paramiko`, `PyYAML`, `jinja2`,
    and `httplib2` packages using the following command lines:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了 `pip`，使用以下命令安装 `paramiko`、`PyYAML`、`jinja2` 和 `httplib2` 包：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'By default, Ansible will be running against the development branch. You might
    want to check out the latest stable branch. Check what the latest stable version
    is using the following command line:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible 将运行在开发分支上。你可能想查看最新的稳定分支。使用以下命令行检查最新稳定版本：
- en: '**$ git branch -a**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ git branch -a**'
- en: 'Copy the latest version you want to use. Version 2.0.2 was the latest version
    available at the time of writing. Check the latest version using the following
    command lines:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 复制你想使用的最新版本。2.0.2 版本是撰写本文时可用的最新版本。使用以下命令检查最新版本：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You now have a working setup of Ansible ready. One of the benefits of running
    Ansible from source is that you can enjoy the new features immediately, without
    waiting for your package manager to make them available for you.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有一个工作中的 Ansible 设置了。运行 Ansible 从源代码的好处之一是，你可以立即享受新特性，而无需等待包管理器为你提供它们。
- en: Creating a test environment with QEMU and KVM
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 QEMU 和 KVM 创建测试环境
- en: To be able to learn Ansible, we will need to make quite a few playbooks and
    run them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够学习 Ansible，我们需要制作相当多的 playbook 并运行它们。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Doing it directly on your computer will be very risky. For this reason, I would
    suggest using virtual machines.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在你的电脑上操作会非常危险。因此，我建议使用虚拟机。
- en: It's possible to create a test environment with cloud providers in a few seconds,
    but often it is more useful to have those machines locally. To do so, we will
    use **Kernel-based Virtual Machine** (**KVM**) with **Quick Emulator** (**QEMU**).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在几秒钟内使用云服务提供商创建测试环境，但通常更有用的是在本地拥有这些机器。为此，我们将使用**基于内核的虚拟机**（**KVM**）和**快速模拟器**（**QEMU**）。
- en: 'The first thing will be installing `qemu-kvm` and `virt-install`. On Fedora
    it will be enough to run:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是安装`qemu-kvm`和`virt-install`。在 Fedora 上，只需要运行：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On Red Hat/CentOS/Scientific Linux/Unbreakable Linux it will be enough to run:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Red Hat/CentOS/Scientific Linux/Unbreakable Linux 上，只需运行：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you use Ubuntu, you can install it using:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Ubuntu，你可以通过以下方式安装：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On Debian, you''ll need to execute:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Debian 上，你需要执行：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For our examples, I''ll be using CentOS 7\. This is for multiple reasons; the
    main ones are:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我将使用 CentOS 7。这有多个原因，主要有以下几点：
- en: CentOS is free and 100% compatible with Red Hat, Scientific Linux, and Unbreakable
    Linux
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CentOS 是免费的，并且与 Red Hat、Scientific Linux 和 Unbreakable Linux 完全兼容。
- en: Many companies use Red Hat/CentOS/Scientific Linux/Unbreakable Linux for their
    servers
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多公司使用 Red Hat/CentOS/Scientific Linux/Unbreakable Linux 来运行他们的服务器。
- en: Those distributions are the only ones with SELinux support built in, and as
    we have seen earlier, SELinux can help you make your environment much more secure
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些发行版是唯一内建 SELinux 支持的，正如我们之前看到的，SELinux 可以帮助你使环境更加安全。
- en: 'At the time of writing this book, the most recent CentOS cloud image is [http://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud-1603.qcow2](http://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud-1603.qcow2),
    So let''s download this image with the help of the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，最新的 CentOS 云镜像是 [http://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud-1603.qcow2](http://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud-1603.qcow2)，所以让我们使用以下命令下载这个镜像：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since we will probably need to create many machines, it''s better if we create
    a copy of it so the original one will not be modified:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能需要创建许多机器，因此最好创建它的副本，以免修改原始版本：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since the `qcow2` images will run `cloud-init` to set up the networking, users,
    and so on, we will need to provide a couple of files. Let''s start by creating
    a metadata file for networking:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`qcow2`镜像将运行 `cloud-init` 来设置网络、用户等，我们需要提供几个文件。让我们从创建一个网络配置的元数据文件开始：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To find your virtual bridge data, you have to look for a device that has the
    name `virbrX` or something similar, in my case it is `virtbr0`, so I can find
    all of its information using the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找你的虚拟桥接数据，你需要寻找一个名称为`virbrX`或类似名称的设备，在我的情况下是`virtbr0`，所以我可以使用以下命令查找它的所有信息：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The previous command will give this as an output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出如下：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, for me the meta-data file looks like the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，对我来说，元数据文件看起来像这样：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This file will set up the `eth0` interface of the virtual machine at boot time.
    We also need another file (user-data) to set up the `users` properly:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件将在虚拟机启动时设置 `eth0` 接口。我们还需要另一个文件（user-data）来正确设置 `users`：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For me, the file looks like the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，文件看起来像这样：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To provide those files at boot time, we will need to create an ISO file containing
    them:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在启动时提供这些文件，我们需要创建一个包含它们的 ISO 文件：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After the ISO file is ready, we can instruct `virt-install` to actually create
    the virtual machine:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ISO 文件准备好后，我们可以指示`virt-install`来实际创建虚拟机：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since our network configuration is in the ISO file, we will need it at every
    boot. Sadly, by default this does not happen, so we will need to do a few more
    steps. Firstly, run `virsh`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的网络配置在 ISO 文件中，我们在每次启动时都需要它。遗憾的是，默认情况下不会发生这种情况，因此我们需要做一些额外的步骤。首先，运行`virsh`：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At this point, a `virsh` shell should appear with an output like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，应该出现一个 `virsh` 命令行，输出如下：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This means that we switched from bash (or your shell, if you are not using
    bash) to the virtualization shell. Issue the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们从bash（或者如果你没有使用bash的话，你的shell）切换到了虚拟化shell。请输入以下命令：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'By doing this we will be able to tweak the configuration of the `CentOS_1`
    machine. In the disk section, you''ll need to find the `cdrom` device that should
    look like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将能够调整`CentOS_1`机器的配置。在磁盘部分，你需要找到应该如下所示的`cdrom`设备：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You''ll need to change it to the following as highlighted in bold:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将其更改为如下所示，已加粗的部分：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At this point, our virtual machine will always start with the ISO file mounted
    as a `cdrom` and therefore `cloud-init` will be able to correctly initiate the
    networking.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的虚拟机将始终以挂载ISO文件作为`cdrom`启动，因此`cloud-init`将能够正确初始化网络。
- en: Version control system
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制系统
- en: In this chapter, we have already encountered the expression *infrastructure
    code* to describe the Ansible code that will create and maintain your infrastructure.
    We use the expression infrastructure code to distinguish it from the application
    code, which is the code that composes your applications, websites, and so on.
    This distinction is needed for clarity, but in the end, both types are a bunch
    of text files that the software will be able to read and interpret.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经遇到过表达式*基础设施代码*，用来描述将创建和维护你的基础设施的Ansible代码。我们使用“基础设施代码”这个术语，以便与应用程序代码区分开来，应用程序代码是构成你的应用、网站等的代码。这样的区分是为了清晰起见，但最终这两者都是一些文本文件，软件可以读取并解释它们。
- en: 'For this reason, a version control system will help you a lot. Its main advantages
    are:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，版本控制系统将对你大有帮助。它的主要优点包括：
- en: Ability to have multiple people working simultaneously on the same project.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够让多人同时在同一个项目上工作。
- en: Ability to perform code reviews in a simple way.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够以简单的方式进行代码审查。
- en: Ability to have multiple branches for multiple environments (that is, dev, test,
    qa, staging, and production).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够为多个环境（即开发、测试、质量保证、预发布和生产）创建多个分支。
- en: Ability to track a change so we know when it was introduced, and who introduced
    it. This makes it easier to understand why that piece of code is there, years
    (or months) later.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够追踪一个变更，以便我们知道它是什么时候引入的，以及是谁引入的。这使得我们在几年（或几个月）后，理解那段代码为何存在变得更加容易。
- en: Those advantages are provided to you by the majority of version control systems
    out there.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优点是大多数版本控制系统所提供的。
- en: 'Version control systems can be divided into three major groups based on the
    three different models that they can implement:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统可以根据它们能够实现的三种不同模型，分为三个主要类别：
- en: Local data model
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地数据模型
- en: Client-server model
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器模型
- en: Distributed model
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式模型
- en: The first category, the local data model, is the oldest (circa 1972) approach
    and is used for very specific use cases. This model requires all users to share
    the same filesystem. Famous examples of it are the **Revision Control System**
    (**RCS**) and **Source Code Control System** (**SCCS**).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类，本地数据模型，是最古老的（大约1972年）方法，通常用于非常具体的应用场景。此模型要求所有用户共享相同的文件系统。著名的例子有**修订控制系统**（**RCS**）和**源代码控制系统**（**SCCS**）。
- en: The second category, the client-server model, arrived later (circa 1990) and
    tried to solve the limitations of the local data model, creating a server that
    respected the local data model and a set of clients that dealt with the server
    instead of with the repository itself. This additional layer allowed multiple
    developers to use local files and synchronize them with a centralized server.
    Famous examples of this approach are Apache **Subversion** (**SVN**), and **Concurrent
    Versions System** (**CVS**).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第二类，即客户端-服务器模型，稍晚出现（大约在1990年），旨在解决本地数据模型的局限性，创建了一个遵循本地数据模型的服务器，并设立了一组客户端与服务器交互，而不是直接与仓库本身交互。这一附加层使得多个开发人员能够使用本地文件，并将其与集中式服务器进行同步。此方法的著名例子有Apache
    **Subversion**（**SVN**）和**并行版本控制系统**（**CVS**）。
- en: The third category, the distributed model, arrived at the beginning of the twenty-first
    century and tried to solve the limitations of the client-server model. In fact,
    in the client-server mode, you could work on the code offline, but you needed
    to be *online* to commit the changes. The distributed model allows you to handle
    everything on your local repository (like the local data model), and to merge
    different repositories on different machines in an easy way. In this new model,
    it's possible to perform all actions as in the client-server model, with the added
    benefits of being able to work completely offline as well as the ability to merge
    changes between peers without passing by the centralized server. Examples of this
    model are BitKeeper (proprietary software), Git, GNU Bazaar, and Mercurial.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第三类模型，分布式模型，在二十一世纪初出现，试图解决客户端-服务器模型的局限性。事实上，在客户端-服务器模式下，你可以离线工作，但需要*在线*才能提交更改。分布式模型允许你在本地仓库（如本地数据模型）上处理所有内容，并能轻松地合并不同机器上的不同仓库。在这个新模型中，所有操作都可以像在客户端-服务器模型中一样执行，且增加了能够完全离线工作以及在不经过集中式服务器的情况下合并对等节点间更改的优势。此模型的例子有
    BitKeeper（专有软件）、Git、GNU Bazaar 和 Mercurial。
- en: 'There are some additional advantages that will be provided by only the distributed
    model, such as:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 只有分布式模型才能提供的一些额外优势包括：
- en: Possibility of making commits, browsing history, and performing any other action
    even if the server is not available
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使服务器不可用，也能进行提交、浏览历史记录和执行任何其他操作的可能性
- en: Easier management of multiple branches for different environments
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易管理不同环境的多个分支
- en: When it comes to infrastructure code, we have to consider that, frequently,
    the infrastructure that retains and manages your infrastructure code is kept in
    the infrastructure code itself. This is a recursive situation that can create
    problems. In fact, until you have your code server in place you cannot deploy
    your Ansible, and until you have your Ansible in place, you cannot deploy your
    code server. A distributed version control system will prevent this problem.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到基础设施代码时，我们必须考虑到，通常，保存和管理基础设施代码的基础设施本身也包含在基础设施代码中。这是一个递归的情况，可能会导致问题。事实上，在没有代码服务器之前，你无法部署你的
    Ansible，而在没有 Ansible 之前，你无法部署你的代码服务器。分布式版本控制系统将避免这个问题。
- en: As for the simplicity of managing multiple branches, even if this is not a hard
    rule, often distributed version control systems have much better merge handling
    than the other kinds of version control systems.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 至于管理多个分支的简易性，尽管这不是硬性规则，但通常分布式版本控制系统比其他版本控制系统具有更好的合并处理能力。
- en: Using Ansible with Git
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 与 Git
- en: For the reasons that we have just seen and because of its huge popularity, I
    suggest always using Git for your Ansible repositories.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们刚刚看到的原因以及其巨大的流行性，我建议始终在你的 Ansible 仓库中使用 Git。
- en: 'There are a few suggestions that I always provide to the people I talk to,
    so Ansible gets the best out of Git:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常给我所谈论的人提供一些建议，以便 Ansible 能从 Git 中获得最大收益：
- en: '**Create environment branches**: Creating environment branches such as dev,
    prod, test, and stg, will allow you to easily keep track of the different environments
    and their respective update statuses. I often suggest keeping the master branch
    for the development environment, since I find many people are used to pushing
    new changes directly to the master. If you use a master for a production environment,
    people can inadvertently push changes in the production environment while they
    wanted to push them in a development environment.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建环境分支**：创建诸如 dev、prod、test 和 stg 等环境分支，可以帮助你轻松追踪不同环境及其各自的更新状态。我常建议将 master
    分支用于开发环境，因为我发现很多人习惯直接将新更改推送到 master。如果你将 master 用作生产环境，可能会不小心将更改推送到生产环境，而原本想推送到开发环境。'
- en: '**Always keep environment branches stable**: One of the big advantages of having
    environment branches is the possibility of destroying and recreating any environment
    from scratch at any given moment. This is only possible if your environment branches
    are in a stable (not broken) state.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终保持环境分支的稳定性**：拥有环境分支的一个大优势是，可以随时从零开始销毁并重新创建任何环境。这只有在环境分支处于稳定（未损坏）状态时才可能实现。'
- en: '**Use feature branches**: Using different branches for specific long-development
    features (such as a refactor or some other big changes) will allow you to keep
    your day-to-day operations while your new feature is in the Git repository (so
    you''ll not lose track of who did what and when they did it).'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用特性分支**：为特定的大型开发特性（如重构或其他大改动）使用不同的分支，将使你能够在 Git 仓库中保留你的日常操作，同时进行新特性的开发（这样你就不会失去对谁做了什么、什么时候做的记录）。'
- en: '**Push often**: I always suggest that people *push commits* as often as possible.
    This will make Git work as both a version control system and a backup system.
    I have seen laptops broken, lost, or stolen with days or weeks of unpushed work
    on them far too often. Don''t waste your time, push often. Also, by pushing often,
    you''ll detect merge conflicts sooner, and conflicts are always easier to handle
    when they are detected early, instead of waiting for multiple changes.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频繁推送**：我总是建议人们尽可能频繁地*推送提交*。这将使 Git 同时充当版本控制系统和备份系统。我曾多次看到笔记本电脑损坏、丢失或被盗，而上面有几天甚至几周没有推送的工作。不要浪费时间，频繁推送。另外，频繁推送还能让你更早发现合并冲突，而冲突在被及时发现时更容易处理，而不是等到有多个更改后再去解决。'
- en: '**Always deploy after you have made a change**: I have seen times when a developer
    has created a change in the infrastructure code, tested in the dev and test environments,
    pushed to the production branch, and then went to have lunch before deploying
    the changes in production. His lunch did not end well. One of his colleagues deployed
    the code to production inadvertently (he was trying to deploy a small change he
    had made in the meantime) and was not prepared to handle the other developer''s
    deployment. The production infrastructure broke and they lost a lot of time figuring
    out how it was possible that such a small change (the one the person who made
    the deployment was aware of) created such a big mess.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每次做出更改后都要部署**：我曾见过有开发者在基础设施代码中做了更改，在开发和测试环境中进行测试，推送到生产分支后去吃午餐，却没有立即在生产环境中部署更改。结果他的午餐没有吃好。因为他的同事不小心将代码部署到了生产环境（他当时正尝试部署自己所做的小改动），并且没有准备好处理另一个开发者的部署。生产环境出现了问题，他们花了大量时间搞清楚为什么一个这么小的更改（部署者知道的那个）会导致如此大的麻烦。'
- en: '**Choose multiple small changes rather than a few huge changes**: Making small
    changes, whenever possible, will make debugging easier. Debugging an infrastructure
    is not very easy. There is no compiler that will allow you to see *obvious problems* (even
    though Ansible performs a syntax check of your code, no other test is performed),
    and the tools for finding something that is broken are not always as good as you
    would imagine. The infrastructure as a code paradigm is new and tools are not
    yet as good as the ones for the application code.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择多个小改动，而不是几个大改动**：尽可能进行小改动，将使调试更容易。调试基础设施并不容易。没有编译器可以帮助你发现*明显的问题*（即使 Ansible
    会对代码进行语法检查，也不会执行其他测试），而且用来查找问题的工具并不像你想象的那样好。基础设施即代码的理念还很新，相关工具还不如应用代码的工具那么成熟。'
- en: '**Avoid binary files as much as possible**: I always suggest keeping your binaries
    outside your Git repository, whether it is an application code repository or an
    infrastructure code repository. In the application code example, I think it is
    important to keep your repository light (Git as well as the majority of the version
    control systems, do not perform very well with binary blobs), while for the infrastructure
    code example, it is vital because you''ll be tempted to put a huge number of binary
    blobs in it, since very often it is easier to put a binary blob in the repository
    than to find a cleaner (and better) solution.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽量避免二进制文件**：我总是建议将二进制文件保存在 Git 仓库之外，无论是应用程序代码仓库还是基础设施代码仓库。在应用程序代码的例子中，我认为保持仓库轻便非常重要（Git
    以及大多数版本控制系统在处理二进制大块数据时表现不佳），而在基础设施代码的例子中尤为关键，因为你会很容易将大量二进制文件放入仓库，因为很多时候将二进制文件放进仓库比找到一个更清洁（更好的）解决方案更为简便。'
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen what IT automation is, it's advantages, disadvantages,
    what kind of tools you can find, and how Ansible fits into this big picture. We
    have also seen how to install Ansible and how to create a KVM-based virtual machine.
    In the end, we analyzed the version control systems and spoke about the advantages
    Git brings to Ansible if used properly.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了什么是IT自动化、它的优点和缺点、可以找到哪些工具，以及Ansible在这一大框架中的作用。我们还了解了如何安装Ansible以及如何创建基于KVM的虚拟机。最后，我们分析了版本控制系统，并讨论了如果正确使用，Git为Ansible带来的优势。
- en: In the next chapter, we will start looking at the infrastructure code that we
    mentioned in this chapter without explaining exactly what it is and how to write
    it. Also in the next chapter, we'll see how to automate simple operations that
    you probably perform every single day, such as managing users, managing files,
    and file content.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将开始探讨本章提到的基础设施代码，虽然我们还没有解释它是什么以及如何编写。此外，在下一章中，我们还将学习如何自动化一些你可能每天都会执行的简单操作，比如管理用户、管理文件以及文件内容。
