- en: Managing Containers with OpenShift
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenShift 管理容器
- en: 'Using a comprehensive suite of some of the best and most resilient open source
    tooling available, Kubernetes is rapidly changing the way that software applications
    are being built and deployed across organizations and in the cloud. Kubernetes
    brings with it lessons learned from deploying a containerized infrastructure across
    a company with one of the largest and most robust infrastructure footprints: Google.
    As we saw in the previous chapter, Kubernetes is an incredibly flexible and reliable
    platform for deploying containers at a very high scale, bringing with it the features
    and functionality to deploy highly available applications across clusters of servers,
    by running on top of native container engines such as `Docker`, `rkt`, and `Runc`.
    However, with the great power and flexibility Kubernetes brings, also comes great
    complexity. Arguably, one of the biggest downsides to deploying a containerized
    infrastructure using Kubernetes is the high degree of knowledge regarding the
    Kubernetes architecture that one must acquire prior to migrating workloads over
    to Kubernetes.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一套综合工具，涵盖了市面上最优秀、最具韧性的开源工具之一，Kubernetes 正在迅速改变软件应用的构建和部署方式，无论是在组织内部还是在云端。Kubernetes
    带来了从部署容器化基础设施中获得的经验教训，而这一基础设施出自拥有全球最大且最强大基础设施之一的公司：Google。正如我们在上一章所看到的，Kubernetes
    是一个极其灵活且可靠的平台，可以在非常大规模下部署容器，并带有一系列特性和功能，能够在集群服务器上部署高可用性应用，通过运行在原生容器引擎如 `Docker`、`rkt`
    和 `Runc` 上实现。然而，Kubernetes 所带来的强大功能和灵活性，也伴随着极大的复杂性。可以说，使用 Kubernetes 部署容器化基础设施的最大缺点之一，就是需要在迁移工作负载到
    Kubernetes 之前，掌握大量关于 Kubernetes 架构的知识。
- en: There is a solution to the high degree of overhead and technical complexity
    that puts Kubernetes out of the reach of many organizations today. In recent years,
    Red Hat has developed an answer to the problem of simplifying Kubernetes concepts
    and making the platform more accessible for software developers and DevOps engineers
    to quickly deploy and rapidly build upon. OpenShift is a suite of tools developed
    by Red Hat that runs on top of the Red Hat distribution of Kubernetes that provides
    a sophisticated, yet easy to understand platform for automating and simplifying
    the deployment of containerized applications. The aim of OpenShift is to provide
    a reliable and secure Kubernetes environment that provides users with a streamlined
    web interface and command-line tool used for deploying, scaling, and monitoring
    applications running in Kubernetes. Furthermore, OpenShift is the second of the
    major cloud providers currently supported by the Ansible Container project (Kubernetes
    and OpenShift).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 针对 Kubernetes 当前面临的高开销和技术复杂性，Red Hat 提供了一个解决方案，使其能够被更多组织所使用。近年来，Red Hat 开发了一个简化
    Kubernetes 概念并使其更加易于访问的解决方案，从而使软件开发人员和 DevOps 工程师能够快速部署并快速构建。OpenShift 是 Red Hat
    开发的一套工具，它基于 Red Hat 版本的 Kubernetes，提供一个既复杂又易于理解的平台，用于自动化和简化容器化应用程序的部署。OpenShift
    的目标是提供一个可靠、安全的 Kubernetes 环境，向用户提供一个流畅的 web 界面和命令行工具，用于部署、扩展和监控运行在 Kubernetes
    中的应用程序。此外，OpenShift 是目前由 Ansible 容器项目支持的第二大云平台（Kubernetes 和 OpenShift）。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: What is OpenShift?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 OpenShift？
- en: Installing Minishift locally
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地安装 Minishift
- en: Deploying containers from the web interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 web 界面部署容器
- en: OpenShift web interface tips
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenShift web 界面提示
- en: An introduction to the OpenShift CLI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenShift CLI 介绍
- en: OpenShift and Ansible Container
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenShift 和 Ansible 容器
- en: What is OpenShift?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 OpenShift？
- en: 'OpenShift is a suite of products available from Red Hat for building a production-ready,
    reliable, and secure Kubernetes platform. Using OpenShift, developers have a tremendous
    amount of freedom when deploying containerized applications using the OpenShift
    API, or accessing the Kubernetes API to fine-tune functionality and features.
    Since OpenShift uses the same underlying container runtime environments, Docker
    containers can be developed locally and deployed to OpenShift, which leverages
    all of the Kubernetes primitives, such as namespaces, pods, and deployments, to
    expose services to the outside world. At the time of writing, Red Hat offers the
    OpenShift platform with the following configuration options:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 是由 Red Hat 提供的一套产品，用于构建生产就绪、可靠且安全的 Kubernetes 平台。使用 OpenShift，开发人员在使用
    OpenShift API 部署容器化应用程序或访问 Kubernetes API 调整功能和特性时，拥有极大的自由度。由于 OpenShift 使用相同的底层容器运行时环境，因此可以在本地开发
    Docker 容器并将其部署到 OpenShift，后者利用 Kubernetes 的所有基本元素，如命名空间、Pod 和部署，将服务暴露给外部世界。撰写本文时，Red
    Hat 提供了具有以下配置选项的 OpenShift 平台：
- en: '**OpenShift Origin**: A fully free and open source version of OpenShift that
    is community-supported. OpenShift Origin can be deployed locally using a project
    known as **Minishift**.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenShift Origin**：一个完全免费的开源版本的 OpenShift，由社区支持。OpenShift Origin 可以通过一个名为
    **Minishift** 的项目在本地部署。'
- en: '**OpenShift Online**: OpenShift Online is a fully hosted public cloud offering
    from Red Hat that allows individuals and organizations to take advantage of OpenShift
    Origin without committing hardware resources to deploying OpenShift on-premise.
    Users can sign up for OpenShift online free-tier accounts that allow for application
    deployments up to 1 gigabyte of RAM, and two vCPUs.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenShift Online**：OpenShift Online 是 Red Hat 提供的一个完全托管的公共云服务，允许个人和组织在不投入硬件资源的情况下，利用
    OpenShift Origin。用户可以注册 OpenShift Online 免费账户，允许最多 1GB 的内存和两个 vCPU 的应用程序部署。'
- en: '**OpenShift Dedicated/Container Platform**: OpenShift Dedicated and the OpenShift
    Container Platform provide robust and scalable deployments of OpenShift that are
    managed and supported by Red Hat either on-premises or through public cloud providers
    such as Google Cloud, Azure, or AWS.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenShift Dedicated/Container Platform**：OpenShift Dedicated 和 OpenShift
    Container Platform 提供由 Red Hat 管理并支持的 OpenShift 部署，可以部署在本地或通过 Google Cloud、Azure
    或 AWS 等公共云服务提供商进行部署。'
- en: Throughout the course of this chapter, and going forward into the next chapters,
    we will be using the fully free and open source OpenShift Origin to deploy a local
    Minishift cluster. Unlike the previous chapter, the free-tier version of OpenShift
    is unfortunately too limited to cover the breadth of examples this chapter is
    going to cover. In an effort to fully demonstrate the capabilities of OpenShift,
    I have opted to walk the user through a local installation of Minishift that is
    only limited by the hardware running on your local workstation. If you have been
    tracking with us thus far, Minishift is not much more complicated to set up on
    VirtualBox than the local Vagrant lab environment we have been using. However,
    if you want to use the free tier of OpenShift Online, most of these examples can
    replicated there, albeit in a more limited way than running Minishift in your
    local environment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及接下来的章节中，我们将使用完全免费的开源 OpenShift Origin 来部署本地 Minishift 集群。与上一章不同，OpenShift
    的免费版由于限制较多，无法涵盖本章将要介绍的广泛示例。为了全面展示 OpenShift 的功能，我选择引导用户完成 Minishift 的本地安装，只有运行在本地工作站的硬件资源限制了其能力。如果你一直跟进到这里，Minishift
    在 VirtualBox 上的设置并不比我们之前使用的本地 Vagrant 实验环境复杂。然而，如果你想使用 OpenShift Online 的免费版，大部分示例仍然可以在其中复制，尽管它的功能有限，无法像在本地环境中运行
    Minishift 那样灵活。
- en: Installing Minishift locally
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地安装 Minishift
- en: Minishift is a local OpenShift cluster that can be downloaded and run on your
    local PC to function as a development environment. The primary use case for Minishift
    is to provide a sandbox that gives developers a functional development environment
    that can be launched on your laptop. Minishift is also fully compatible with the
    **OpenShift Client** (**OC**) CLI that is used to work with OpenShift clusters
    using a command-line interface. In this portion of the chapter, we will learn
    how to install Minishift and the OC in order to get it running in your local environment.
    Before proceeding, you need to have VirtualBox installed on your PC; it will function
    as a hypervisor for launching the Minishift VM. For the purposes of this demonstration,
    we will be using Minishift version 1.7.0\. Since the time of writing, newer versions
    of Minishift will have undoubtedly been released. To have the best experience
    working with Minishift, I would suggest you download the 1.7.0 release, although
    newer releases will most likely work just as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Minishift 是一个本地 OpenShift 集群，可以在您的本地 PC 上下载并运行，作为开发环境使用。Minishift 的主要用途是提供一个沙盒环境，为开发人员提供一个功能齐全的开发环境，该环境可以在您的笔记本电脑上启动。Minishift
    还与 **OpenShift 客户端** (**OC**) CLI 完全兼容，您可以使用命令行界面与 OpenShift 集群进行交互。在本章的这一部分，我们将学习如何安装
    Minishift 和 OC，以便在您的本地环境中运行它。在继续之前，您需要确保您的 PC 上安装了 VirtualBox，它将作为启动 Minishift
    虚拟机的虚拟化程序。为了演示目的，我们将使用 Minishift 版本 1.7.0。由于本文撰写时，Minishift 已发布了更新的版本，建议您下载 1.7.0
    版本，尽管更新版本很可能也能同样良好地工作。
- en: 'Furthermore, Minishift and the OC are available cross-platform on Windows,
    Linux, and macOS. This example is going to demonstrate downloading and installing
    Minishift on Linux. For more information about installing Minishift on other platforms,
    I have provided the following link: [https://docs.openshift.org/latest/minishift/getting-started/installing.html](https://docs.openshift.org/latest/minishift/getting-started/installing.html).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Minishift 和 OC 可跨平台支持 Windows、Linux 和 macOS。此示例将演示如何在 Linux 上下载并安装 Minishift。如需了解在其他平台上安装
    Minishift 的更多信息，您可以访问以下链接：[https://docs.openshift.org/latest/minishift/getting-started/installing.html](https://docs.openshift.org/latest/minishift/getting-started/installing.html)。
- en: Installing the Minishift binaries
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Minishift 二进制文件
- en: 'The proceeding steps should be executed on your local workstation (not the
    Vagrant lab VM) to install Minishift locally:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤应在您的本地工作站上执行（而非 Vagrant 实验室虚拟机）以在本地安装 Minishift：
- en: '**Download the Minishift binary**: The Minishift 1.7.0 binary can be downloaded
    from the following GitHub URL for all platforms ([https://github.com/minishift/minishift/releases/tag/v1.7.0](https://github.com/minishift/minishift/releases/tag/v1.7.0)).
    You may download this binary using a web browser, or by using `wget` as in this
    example:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载 Minishift 二进制文件**：Minishift 1.7.0 二进制文件可以从以下 GitHub URL 下载，适用于所有平台（[https://github.com/minishift/minishift/releases/tag/v1.7.0](https://github.com/minishift/minishift/releases/tag/v1.7.0)）。您可以使用网页浏览器下载该二进制文件，或者使用
    `wget`，例如在本示例中的做法：'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Unpack the Minishift archive**: Minishift comes packaged in an archive format
    compatible with your operating system. For Linux and OSX, this is a zipped tarball.
    For Windows, the format is a zipped archive:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解压 Minishift 压缩包**：Minishift 以与您的操作系统兼容的归档格式打包。对于 Linux 和 OSX，这是一个压缩的 tarball
    文件。对于 Windows，则是一个压缩归档文件：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Copy the Minishift binary to your executable path**: Copying the Minishift
    binary to your local executable path will ensure the `minishift` command can be
    executed from your command line in any context. In Linux, a common path location
    is `/usr/local/bin`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将 Minishift 二进制文件复制到可执行路径**：将 Minishift 二进制文件复制到您的本地可执行路径将确保可以在任何上下文中从命令行执行
    `minishift` 命令。在 Linux 中，常见的路径位置是 `/usr/local/bin`：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may need to check the permissions on the binary to ensure they are set to
    executable, for example, `chmod +x /usr/local/bin/minishift`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要检查二进制文件的权限，以确保它们设置为可执行，例如，`chmod +x /usr/local/bin/minishift`。
- en: '**Validate the installation**: Executing the `minishift version` command should
    return the relevant Minishift version details, in this case, 1.7.0:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验证安装**：执行 `minishift version` 命令应该返回相关的 Minishift 版本信息，在此例中为 1.7.0：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Download the OC binary**: The OC can be downloaded for Windows, macOS, or
    Linux at the following URL: [https://mirror.openshift.com/pub/openshift-v3/clients/3.6.173.0.5/](https://mirror.openshift.com/pub/openshift-v3/clients/3.6.173.0.5/).
    For this demonstration, we will be using version 3.6 of the OC client. Similar
    to MiniShift, newer versions might have been released since the time of writing.
    For maximum compatibility with the examples, I suggest you use version 3.6:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载OC二进制文件**：OC可以在以下网址下载适用于Windows、macOS或Linux的版本：[https://mirror.openshift.com/pub/openshift-v3/clients/3.6.173.0.5/](https://mirror.openshift.com/pub/openshift-v3/clients/3.6.173.0.5/)。在本示例中，我们将使用版本3.6的OC客户端。与MiniShift类似，可能自编写时以来已经发布了更新版本。为了与示例最大兼容，建议您使用版本3.6：'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Extract the OC client archive**: After extracting this archive, a single
    binary, `oc`, will be extracted. This is the executable binary for the OC:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解压OC客户端归档**：解压此归档后，会提取出一个二进制文件`oc`。这是OC的可执行二进制文件：'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Copy the OC to your executable path**: Similar to the Minishift installation,
    we will copy the OC binary to an executable path location:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将OC复制到可执行路径**：与Minishift安装类似，我们将OC二进制文件复制到可执行路径位置：'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Validate installation**: Execute the `oc version` command to ensure the OC
    has been installed successfully and to return the relevant version details:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验证安装**：执行`oc version`命令以确保OC已成功安装并返回相关版本信息：'
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Start the Minishift cluster**: Now that Minishift and the OC are installed,
    we start the Minishift cluster using the `minishift start` command. By default,
    Minishift will start by expecting to use the KVM hypervisor and approximately
    2 GB of memory. We are going to modify this slightly to use the VirtualBox hypervisor,
    8 GB of RAM, and 50 GB of storage. Once the Minishift cluster has launched, it
    will return a URL you can use to access the OpenShift console:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启动Minishift集群**：现在Minishift和OC已经安装完成，我们通过`minishift start`命令启动Minishift集群。默认情况下，Minishift将期望使用KVM虚拟化程序，并分配大约2
    GB的内存。我们将稍作修改，改为使用VirtualBox虚拟化程序、8 GB的RAM和50 GB的存储。一旦Minishift集群启动，它将返回一个URL，您可以通过这个URL访问OpenShift控制台：'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you do not have enough resources to allocate 8 GB of RAM to the Minishift
    deployment, most of these examples can be run using the default 2 GB of RAM.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的资源不足以为Minishift部署分配8 GB的RAM，大多数示例可以使用默认的2 GB RAM运行。
- en: '**Relax the default security permissions**: On the backend, OpenShift is a
    highly secured Kubernetes cluster that does not allow containers to run a local
    root user. Before we dive into our new Minishift installation, we need to first
    relax the default security context constraints so that we can run any Docker image.
    Since this is a development environment, this will give us more freedom to explore
    the platform and run different workloads. In order to do this, we will use the
    OC to log in as the system administrator. From there, we can use the `oc adm`
    command to add the `anyuid` security context constraint to all authenticated OpenShift
    users:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**放宽默认安全权限**：在后台，OpenShift是一个高度安全的Kubernetes集群，不允许容器运行本地root用户。在我们深入了解新的Minishift安装之前，我们需要首先放宽默认的安全上下文约束，以便我们可以运行任何Docker镜像。由于这是一个开发环境，这将为我们提供更多的自由来探索平台并运行不同的工作负载。为此，我们将使用OC以系统管理员身份登录。从那里，我们可以使用`oc
    adm`命令将`anyuid`安全上下文约束添加到所有经过身份验证的OpenShift用户：'
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is always a best practice to not modify the OpenShift security context constraints
    in a production deployment. Container images should always be running as their
    own user inside of a Docker container. The unfortunate truth is that many developers
    use the default root user to build and deploy applications. We are relaxing the
    security permissions just so we can explore the platform more freely without the
    limitation of only running containers built and run using a dedicated user.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产部署中，最好不要修改OpenShift安全上下文约束。容器镜像应始终以自己的用户身份在Docker容器内运行。遗憾的事实是，许多开发人员使用默认的root用户来构建和部署应用程序。我们放宽安全权限仅仅是为了让我们可以更自由地探索平台，而不受仅能运行由专用用户构建和运行的容器的限制。
- en: 'When you have finished working in the Minishift environment, make sure you
    stop the Minishift VM using the `minishift stop` command, as shown in the following
    snippet. Unlike destroying your local Vagrant lab, the Minishift instance will
    retain running deployments and service artifacts the next time the VM is started:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成在Minishift环境中的工作时，请确保使用`minishift stop`命令停止Minishift虚拟机，如下所示。与销毁本地Vagrant实验室不同，Minishift实例将在下次启动虚拟机时保留运行中的部署和服务工件：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Deploying containers using the web interface
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网页界面部署容器
- en: 'As you may have noticed, when the `minishift start` command completed, it provided
    an IP address that you can use to access the web user interface. One of the biggest
    benefits of using OpenShift over standard Kubernetes is that OpenShift exposes
    almost all of Kubernetes'' core functionality through an intuitive web interface.
    The OpenShift console works in a similar way to other cloud or service dashboards
    you have used in the past. At a glance, you can see which deployments are running,
    triggered alarms caused by failed pods, or even new deployments that other users
    have triggered in the project. To access the web interface, simply copy and paste
    the IP address in the output of the `minishift start` command in any modern web
    browser installed on your local machine. You may then have to accept the self-signed
    SSL certificate that comes with Minishift by default, after which you will be
    prompted with a login screen similar to the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当 `minishift start` 命令完成后，它提供了一个可以用来访问网页用户界面的 IP 地址。使用 OpenShift 相较于标准
    Kubernetes 的最大优势之一是，OpenShift 通过直观的网页界面暴露了 Kubernetes 几乎所有的核心功能。OpenShift 控制台的工作方式类似于你过去使用过的其他云或服务仪表板。你可以一眼看出哪些部署正在运行、由于
    pod 失败而触发的警报，甚至是其他用户在项目中触发的新部署。要访问网页界面，只需将 `minishift start` 命令输出中的 IP 地址复制并粘贴到你本地机器上任何现代网页浏览器中。然后，你可能需要接受
    Minishift 默认提供的自签名 SSL 证书，之后你将看到类似以下截图的登录界面：
- en: '![](img/15cb9fbf-7a8b-4b31-a7c3-ae53f29d09e7.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15cb9fbf-7a8b-4b31-a7c3-ae53f29d09e7.png)'
- en: 'Figure 1: OpenShift login page'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：OpenShift 登录页面
- en: The default credentials to access Minishift are the username `developer` and
    any password you want. It is not important to remember the password you enter,
    as each time you authenticate as the developer user, you can simply supply any
    password. Upon successfully logging in, you will be asked to access a project.
    The default project that Minishift provides for you is called My Project. For
    the sake of simplicity, we will use this project for the following lab examples,
    which you can follow along with.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Minishift 的默认凭据是用户名 `developer` 和你选择的任何密码。你输入的密码并不重要，因为每次以开发者用户身份进行身份验证时，你都可以随便输入任何密码。成功登录后，你将被要求访问一个项目。Minishift
    为你提供的默认项目名为 My Project。为了简单起见，我们将在接下来的实验示例中使用这个项目，你可以跟着一起操作。
- en: 'The web interface is laid out by two primary navigation bars along the left
    and top of the screen, while the central portion of the interface is reserved
    for showing details about the environment you are currently accessing, modifying
    settings, or deleting resources:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 网页界面由屏幕左侧和顶部的两个主要导航栏布局，而界面的中央部分则保留用于显示你当前访问的环境的详细信息、修改设置或删除资源：
- en: '![](img/e1a7b9ed-939f-42d8-94c7-d1b1d71f686b.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1a7b9ed-939f-42d8-94c7-d1b1d71f686b.png)'
- en: 'Figure 2: Initial OpenShift project'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：初始 OpenShift 项目
- en: 'Now that you are familiar with the OpenShift user interface, let''s create
    a deployment and see what it looks like when pods are running in the cluster.
    The functionality for creating new pods and deployments can be found towards the
    top of the screen by selecting the Add to Project drop-down box:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 OpenShift 用户界面，让我们创建一个部署，并查看当 pod 在集群中运行时的样子。创建新 pod 和部署的功能可以在屏幕顶部通过选择“添加到项目”下拉框找到：
- en: '![](img/46e15305-d61e-4472-911b-5656098738d2.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46e15305-d61e-4472-911b-5656098738d2.png)'
- en: 'Figure 3: Adding services to your project'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3：向项目添加服务
- en: 'We can create a new deployment in a variety of different ways. The default
    options OpenShift provides is to browse a catalog of pre-built images and services,
    deploy an image based on a container registry URL, or importing a YAML or JSON
    manifest that describes the services we are building. Let''s deploy one of the
    catalog services found in the web interface. Selecting the Browse Catalog option
    from the Add to Project drop-down will open a screen for the OpenShift catalog.
    Any of the OpenShift examples found in the catalog will run well in OpenShift,
    but for demonstration purposes let''s deploy the framework for a simple Python
    application. To do this, click on the catalog option for Python, then the Python
    3.5 Source Code Application:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种不同方式创建新的部署。OpenShift 提供的默认选项是浏览预构建的镜像和服务目录、基于容器注册表 URL 部署镜像，或导入描述我们构建的服务的
    YAML 或 JSON 清单。我们可以在 Web 界面中部署一个目录中的服务。选择“添加到项目”下拉菜单中的“浏览目录”选项，将打开 OpenShift 目录的界面。目录中找到的任何
    OpenShift 示例都能在 OpenShift 中良好运行，但为了演示，我们部署一个简单 Python 应用程序的框架。为此，点击 Python 选项卡，然后选择
    Python 3.5 源代码应用程序：
- en: '![](img/715072cf-e8de-4da9-9397-2f8e44f58a93.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/715072cf-e8de-4da9-9397-2f8e44f58a93.png)'
- en: 'Figure 4: Creating a simple Python service from the OpenShift catalog'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4：从 OpenShift 目录创建一个简单的 Python 服务
- en: 'On the next screen, OpenShift will prompt you for options to deploy your application
    with, namely a source code repository, which contains Python source code, and
    an application name. You can choose any name for the Python application. For this
    example, I will name mine `oc-test-deployment`. Since we do not have a pre-developed
    Python application, we can click on the Try It link below the Git Repository URL
    textbox to use the demo application provided by OpenShift:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，OpenShift 会提示你选择部署应用程序的选项，包括一个包含 Python 源代码的源代码仓库和一个应用程序名称。你可以为 Python
    应用程序选择任何名称。在这个示例中，我将它命名为 `oc-test-deployment`。由于我们没有预先开发好的 Python 应用程序，可以点击 Git
    仓库 URL 文本框下方的“尝试它”链接，使用 OpenShift 提供的示例应用程序：
- en: '![](img/544fad49-bc55-467e-a7c2-714fbe326997.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/544fad49-bc55-467e-a7c2-714fbe326997.png)'
- en: 'Figure 5: Modifying the attributes of the Python application'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5：修改 Python 应用程序的属性
- en: If you are a Python developer and have a Django application you would like to
    deploy instead, feel free to use another Git repository in place of the demo one!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是 Python 开发者，且希望部署一个 Django 应用程序，可以随意使用另一个 Git 仓库来替代示例仓库！
- en: 'Clicking on the blue Create button will initiate the deployment and launch
    the container. Depending on the specifications of your workstation, it might take
    a while for the service to fully deploy. While it is deploying, you can watch
    the various stages of the deployment by clicking through the pages of the user
    interface. For example, clicking on Pods in the sidebar will show pods as they
    are created and go through the various stages to become available in Kubernetes.
    OpenShift shows circular graphs that describe the state of the resources that
    are running. Pods that are healthy, responding to requests, and running as intended
    are shown by blue circles. Other Kubernetes resources that might not be running
    as intended, throwing errors or warnings instead, are represented by yellow or
    red circles. This provides an intuitive way to understand how the services are
    running at a glance:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 点击蓝色的“创建”按钮将启动部署并启动容器。根据你工作站的规格，服务完全部署可能需要一段时间。在部署过程中，你可以通过点击用户界面的各个页面来观察部署的不同阶段。例如，点击侧边栏中的
    Pods，将显示 Pods 在创建过程中所经历的各个阶段，直到它们在 Kubernetes 中可用。OpenShift 会显示描述正在运行的资源状态的圆形图。健康、响应请求并按预期运行的
    Pods 会以蓝色圆圈显示。而其他可能没有按预期运行、抛出错误或警告的 Kubernetes 资源，则会用黄色或红色圆圈表示。这提供了一种直观的方式，让你一目了然地了解服务的运行状态：
- en: '![](img/916fb49b-38b7-49a9-98ff-b4a160403352.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/916fb49b-38b7-49a9-98ff-b4a160403352.png)'
- en: 'Figure 6: A successfully created test Python application'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6：成功创建的测试 Python 应用程序
- en: 'Once the service has been deployed fully, OpenShift will provide a link to
    access the service. In OpenShift vernacular, this is known as a **route**. Routes
    function in a similar way to exposed services in Kubernetes, with the exception
    that they leverage `nip.io` DNS forwarding by default. You might notice that the
    service route pointing to the service we just created has the fully qualified
    domain name `servicename.ipaddress.nip.io`. This provides the user with routable
    access to reach the Kubernetes cluster without the hassle of configuring external
    load balancers or service proxies. Accessing that URL in a web browser should
    open a page that looks similar to the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务完全部署，OpenShift 会提供一个链接以访问该服务。在 OpenShift 术语中，这被称为 **路由**。路由的功能类似于 Kubernetes
    中暴露的服务，不同之处在于，它们默认使用 `nip.io` DNS 转发。你可能会注意到，指向我们刚刚创建的服务的路由，其完全限定的域名是 `servicename.ipaddress.nip.io`。这为用户提供了可路由的访问路径，以便在不需要配置外部负载均衡器或服务代理的情况下访问
    Kubernetes 集群。通过 Web 浏览器访问该 URL 应该会打开一个类似于以下内容的页面：
- en: '![](img/8526b6f0-3366-4ef2-b012-d0d266af1974.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8526b6f0-3366-4ef2-b012-d0d266af1974.png)'
- en: 'Figure 7: Python application test page'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7：Python 应用程序测试页面
- en: 'This is the default Python-Django index page for this simple demo application.
    If we click back on the OpenShift console, we can go into more detail regarding
    the pods that are running in this deployment. Similar to kubectl, OpenShift can
    give us details about the deployment, including running pods, log events, and
    even allow us to customize the deployment from the web user interface. To view
    these details, select Applications | Deployments and click on the deployment you
    wish to look up. In this case, we will look at the details of the only running
    deployment we have, `oc-test-deployment`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此简单示例应用程序的默认 Python-Django 索引页面。如果我们点击返回 OpenShift 控制台，我们可以更详细地了解在此部署中运行的
    pod。与 kubectl 类似，OpenShift 可以为我们提供有关部署的详细信息，包括运行中的 pod、日志事件，甚至允许我们从 Web 用户界面自定义部署。要查看这些详细信息，选择应用程序
    | 部署并点击你希望查看的部署。在此案例中，我们将查看我们唯一运行的部署 `oc-test-deployment` 的详细信息：
- en: '![](img/e02c7343-5efb-44fc-ae88-b16c5444282c.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e02c7343-5efb-44fc-ae88-b16c5444282c.png)'
- en: 'Figure 8: OpenShift deployments page'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8：OpenShift 部署页面
- en: 'From this page, we can view the history of containers, modify the configuration,
    check or change environment variables, and view the most recent event logs from
    the deployment. In the upper-right corner of the screen, the Actions drop-down
    box gives us even more options for adding storage, autoscaling rules, and even
    modifying the Kubernetes manifest used to deploy this service:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从此页面，我们可以查看容器历史、修改配置、检查或更改环境变量，并查看来自部署的最新事件日志。在屏幕的右上角，操作下拉框为我们提供了更多选项，可以添加存储、自动扩展规则，甚至修改用于部署该服务的
    Kubernetes 清单：
- en: '![](img/2e966335-4c18-499b-a38f-eeba5190afb9.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e966335-4c18-499b-a38f-eeba5190afb9.png)'
- en: 'Figure 9: Managing OpenShift applications and deployments'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9：管理 OpenShift 应用程序和部署
- en: OpenShift provides a great interface for tweaking manifests and experimenting
    with changes in real time. The OpenShift user interface will give you feedback
    on changes you make and let you know when there are potential problems.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 提供了一个非常好的界面，用于实时调整清单并实验更改。OpenShift 用户界面会反馈你所做的更改，并在出现潜在问题时提醒你。
- en: 'Information related to the running pods within the deployment can also be accessed
    through the web user interface. From the Applications menu, select Pods and click
    on the pod you wish to view information for. In this case, we have a single running
    pod, `oc-test-deployment-1-l18l8`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关运行中 pod 的信息也可以通过 Web 用户界面访问。从应用程序菜单中选择 Pods，并点击你希望查看的 pod。在这种情况下，我们有一个正在运行的
    pod，`oc-test-deployment-1-l18l8`：
- en: '![](img/b49c4dbd-c722-4075-acd8-74720f610a54.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b49c4dbd-c722-4075-acd8-74720f610a54.png)'
- en: 'Figure 10: Viewing pods within application deployments'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10：查看应用程序部署中的 pod
- en: 'On this page, we can view almost any pertinent detail regarding the pods that
    are running within any of our deployments. From this screen you can view environment
    configurations, access container logs in real time, and even log into containers
    through a fully functional terminal emulator:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在此页面上，我们可以查看关于运行在任何部署中的 pod 的几乎所有相关细节。从此界面，你可以查看环境配置、实时访问容器日志，甚至通过一个完全功能的终端模拟器登录到容器：
- en: '![](img/4e53f306-aab2-4a46-b24b-f98576bb09a2.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e53f306-aab2-4a46-b24b-f98576bb09a2.png)'
- en: 'Figure 11: Viewing pod-specific details in OpenShift'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11：在 OpenShift 中查看 pod 特定的详细信息
- en: Similar to the Deployments menu, we can select the Actions drop-down menu from
    this screen as well to modify container settings in the YAML editor, or mount
    storage volumes inside the container.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于部署菜单，我们也可以从这个页面的操作下拉菜单中选择，修改 YAML 编辑器中的容器设置，或将存储卷挂载到容器内。
- en: 'Finally, using the OpenShift web interface, we can delete deployments and pods.
    Since OpenShift is essentially a layer that functions on top of Kubernetes, we
    need to apply many of the same concepts. In order to delete pods, we must first
    delete the deployment in order to set a new desired state within the Kubernetes
    API. Within OpenShift this can be accomplished by selecting Applications | Deployments
    | Your Deployment (oc-test-deployment). From the Actions drop-down menu, select
    Delete Deployment. OpenShift will prompt you to make sure this is something you
    really want to do; click Delete to finalize the operation:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过使用 OpenShift 的 Web 界面，我们可以删除部署和 Pod。由于 OpenShift 本质上是运行在 Kubernetes 之上的一层，我们需要应用许多相同的概念。为了删除
    Pod，我们必须首先删除部署，以便在 Kubernetes API 中设置新的期望状态。在 OpenShift 中，这可以通过选择应用程序 | 部署 | 你的部署（oc-test-deployment）来完成。从操作下拉菜单中，选择删除部署。OpenShift
    会提示你确认是否真想执行此操作；点击删除以最终确定操作：
- en: '![](img/741a8898-5e82-46a9-9346-399fea7c69d7.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/741a8898-5e82-46a9-9346-399fea7c69d7.png)'
- en: 'Figure 12: Deleting deployments in OpenShift'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12：在 OpenShift 中删除部署
- en: In a similar fashion, you will have to go to Applications | Service and then Applications |
    Routes in order to delete the services and routes that OpenShift created for the
    service. Once this is complete, the screen produced by clicking on the Overview
    button in the left menu bar will once again be blank, showing that nothing is
    currently running in the OpenShift cluster.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，你需要前往应用程序 | 服务，然后前往应用程序 | 路由，以删除 OpenShift 为该服务创建的服务和路由。完成后，点击左侧菜单栏中的概览按钮所产生的屏幕将再次为空，显示当前在
    OpenShift 集群中没有任何运行的内容。
- en: OpenShift web user interface tips
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenShift Web 用户界面 提示
- en: 'The preceding example walked the user through some of the major OpenShift and
    Kubernetes workflow steps for creating a new deployment, managing the deployment,
    and ultimately deleting the deployment and other resources. OpenShift exposes
    far more functionality through the web user interface than this book has time
    to delve into; I suggest you take time to explore the web interface for yourself
    to truly become familiar with the features that OpenShift provides. For the sake
    of not being monotonous, I have provided a few key features to keep your eyes
    open for in the OpenShift web interface:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例引导用户完成了一些主要的 OpenShift 和 Kubernetes 工作流步骤，包括创建新部署、管理部署，最终删除部署和其他资源。OpenShift
    通过 Web 用户界面暴露了比本书所能深入探讨的更多功能；我建议你花时间自己探索 Web 界面，真正熟悉 OpenShift 提供的功能。为了避免单调，我提供了一些关键功能，供你在
    OpenShift Web 界面中留意：
- en: '**Overview dashboard**: The Overview dashboard can be accessed from the navigation
    bar on the left side of the screen. The overview dashboard shows information about
    the most recent activity inside the OpenShift cluster. This is useful for accessing
    the latest deployments and having single-click access to various cluster resources.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概览仪表板**：概览仪表板可以通过屏幕左侧的导航栏访问。概览仪表板显示关于 OpenShift 集群内最近活动的信息。它对于访问最新的部署并能单击访问各种集群资源非常有用。'
- en: '**Applications menu**: The Applications menu is a single location to view or
    modify any deployments or pods that are running across the OpenShift cluster.
    From Applications, you can access information related to deployments, pods, stateful
    sets, services, and routes. Think of the Applications menu as a single stop for
    anything related to the configuration of containers running within the cluster.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序菜单**：应用程序菜单是查看或修改 OpenShift 集群中运行的任何部署或 Pod 的单一位置。在应用程序中，你可以访问与部署、Pod、有状态集合、服务和路由相关的信息。可以将应用程序菜单视为与集群中运行的容器配置相关的一站式入口。'
- en: '**Builds dashboard**: The Builds dashboard features a light **continuous integration**
    **continuous** **delivery** (**CICD**) workflow for Kubernetes. This is useful
    for triggering image builds, establishing Jenkins-enabled workflow pipelines,
    and building automation into OpenShift projects.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建仪表板**：构建仪表板展示了一个轻量的 **持续集成** **持续交付** (**CICD**) 工作流，用于 Kubernetes。这对于触发镜像构建、建立
    Jenkins 启用的工作流管道以及将自动化集成到 OpenShift 项目中非常有用。'
- en: '**Resources menu**: The Resources menu is used primarily to define quotas and
    user account privileges used to manage access and limits for users and projects
    within the OpenShift cluster. Also defined here is a lightweight secret storage
    interface, as well as config map options to define the configurations for containers
    within OpenShift projects.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源菜单**：资源菜单主要用于定义配额和用户帐户权限，管理OpenShift集群内用户和项目的访问权限及限制。此处还定义了一个轻量级的机密存储界面，以及配置映射选项，用于定义OpenShift项目内容器的配置。'
- en: '**Storage dashboard**: The Storage dashboard is used to display information
    regarding persistent volume claims used by containers and deployments on the underlying
    hardware or VM OpenShift is running on. Volume claims can be created or deleted
    from this portion of the web interface, as well as managed or modified depending
    on new or changing requirements.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储仪表盘**：存储仪表盘用于显示有关容器和部署所使用的持久卷声明的信息，卷声明存储在OpenShift所运行的底层硬件或虚拟机上。可以通过该网页界面部分创建或删除卷声明，也可以根据新的或变化的需求进行管理或修改。'
- en: '**Monitoring dashboard**: Finally, the Monitoring dashboard provides the user
    with details about running pods, triggered events, as well as the historical context
    regarding the changes in the environment leading up to the events listed. Monitoring
    can be easily tied to build a pipeline or even used to report on configured service
    health checks.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控仪表盘**：最后，监控仪表盘为用户提供有关运行中Pods的详细信息、触发的事件，以及与事件相关的环境变化的历史背景。监控可以轻松与构建管道结合使用，甚至用于报告已配置的服务健康检查。'
- en: Leveraging the robust suite of tools provided by OpenShift helps to abstract
    and simplify many of the Kubernetes concepts we learned about in [Chapter 5](ccc07e61-25e7-4984-953b-586b28b12aab.xhtml), *Containers
    at Scale with Kubernetes*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 利用OpenShift提供的强大工具套件，有助于抽象和简化我们在[第5章](ccc07e61-25e7-4984-953b-586b28b12aab.xhtml)《使用Kubernetes进行大规模容器管理》中学到的许多Kubernetes概念。
- en: An introduction to the OpenShift CLI
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenShift CLI简介
- en: 'The second primary way that users can interact with the OpenShift platform
    is through the OpenShift command-line interface, OC (short for OpenShift Client).
    The OpenShift command-line interface uses many of the same concepts we explored
    in [Chapter 5](ccc07e61-25e7-4984-953b-586b28b12aab.xhtml), *Containers at Scale
    with Kubernetes*, using the `kubectl` command line interface for managing pods,
    deployments, and exposing services. However, the OpenShift client also supports
    many of the features that are specific to OpenShift, such as creating routes to
    expose deployments and working with integrated security context constraints for
    access control. Throughout this section, we will look at how to use the OC to
    accomplish some of the basic workflow concepts we explored through the web user
    interface, such as creating deployments, creating routes, and working with running
    containers. Finally, we will look at some tips for diving deeper with the OC and
    some of the more advanced features that are available. Before proceeding, ensure
    the OC is installed (see the beginning of this chapter for installation details):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 用户与OpenShift平台交互的第二种主要方式是通过OpenShift命令行接口，简称OC（OpenShift客户端）。OpenShift命令行接口使用了我们在[第5章](ccc07e61-25e7-4984-953b-586b28b12aab.xhtml)《使用Kubernetes进行大规模容器管理》中探索的许多相同概念，利用`kubectl`命令行接口来管理pods、部署和暴露服务。然而，OpenShift客户端还支持许多特定于OpenShift的功能，例如创建路由以暴露部署和使用集成的安全上下文约束进行访问控制。在本节中，我们将展示如何使用OC完成一些基本的工作流概念，这些概念在通过网页用户界面时已经有所探索，例如创建部署、创建路由以及操作运行中的容器。最后，我们将探讨一些OC的深入使用技巧以及一些可用的高级功能。在继续之前，请确保已安装OC（有关安装详情，请参阅本章开头部分）：
- en: '**Logging into OpenShift**: Similar to the web user interface, we can use the
    CLI to log into our local OpenShift cluster using the `oc login` command. The
    basic syntax for this command is `oc login URL:PORT`, where the user replaces
    the URL and port with the URL and port number of the OpenShift environment they
    are logging into. Upon successful login, the prompt will return `Login Successful`
    and grant you access to your default project. In this case, we will log into our
    local environment at `192.168.99.100`, using the `developer` username and anything
    as the password:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**登录到 OpenShift**：与 Web 用户界面类似，我们可以使用 CLI 通过 `oc login` 命令登录到本地 OpenShift 集群。此命令的基本语法为
    `oc login URL:PORT`，其中用户需要将 URL 和端口替换为他们登录的 OpenShift 环境的 URL 和端口号。登录成功后，提示符将返回
    `Login Successful`，并授予你访问默认项目的权限。在此情况下，我们将使用 `developer` 用户名和任意密码登录到 `192.168.99.100`
    本地环境：'
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Check status using OC status**: The `oc status` command is used in a similar
    way to the Overview dashboard in the web user interface to show critical services
    deployed in the environment, running pods, or anything in the cluster that might
    be triggering an alarm. Simply typing `oc status` will not return anything, since
    we deleted the deployments, routes, and services we created through the web user
    interface:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 OC status 检查状态**：`oc status` 命令的使用方式与 Web 用户界面中的概览仪表盘相似，用于显示环境中部署的关键服务、正在运行的
    pod 或集群中可能触发警报的任何内容。仅输入 `oc status` 不会返回任何内容，因为我们删除了通过 Web 用户界面创建的部署、路由和服务：'
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Create an OpenShift deployment**: Deployments and other cluster resources
    can easily be created using the `oc create` command. Similar to `kubectl`, you
    can create deployments by using the `oc create deployment` command and referencing
    the name of the container image you wish to use. It should be noted that deployment
    names are sensitive to using special characters such as underscores and dashes.
    For the purposes of simplicity, let''s re-create our example from [Chapter 5](ccc07e61-25e7-4984-953b-586b28b12aab.xhtml), *Containers
    at Scale with Kubernetes*, and create a simple NGINX pod using the official NGINX
    Docker image using the `oc create` command and specifying the object as `deployment`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建 OpenShift 部署**：可以使用 `oc create` 命令轻松创建部署和其他集群资源。与 `kubectl` 类似，你可以通过使用
    `oc create deployment` 命令并引用你希望使用的容器镜像名称来创建部署。需要注意的是，部署名称对于使用下划线和连字符等特殊字符非常敏感。为了简化操作，让我们重新创建[第5章](ccc07e61-25e7-4984-953b-586b28b12aab.xhtml)中的示例，*大规模容器与
    Kubernetes*，并使用官方 NGINX Docker 镜像通过 `oc create` 命令创建一个简单的 NGINX pod，并指定对象为 `deployment`：'
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Another similarity to kubectl is that OpenShift supports creating deployments
    based on Kubernetes manifest files using the `-f` option.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与 kubectl 相似之处是，OpenShift 支持使用 `-f` 选项基于 Kubernetes 清单文件创建部署。
- en: '**List pods and view the OC status**: Now that we have a deployment and pod
    running in the OpenShift cluster, we can view running pods using the `oc get pods`
    command, and check the output of the `oc status` command to see an overview of
    the running pods in our cluster:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**列出 pod 并查看 OC 状态**：现在我们在 OpenShift 集群中有一个正在运行的部署和 pod，我们可以使用 `oc get pods`
    命令查看正在运行的 pod，并检查 `oc status` 命令的输出，以查看集群中正在运行的 pod 概览：'
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**View verbose output using** `oc describe`: Aside from simply listing objects
    that are created and available in the OpenShift cluster, verbose details about
    specific objects can be viewed using the `oc describe` command. Similar to `kubectl
    describe`, `oc describe` allows us to view pertinent details about almost any
    object defined in the cluster. For example, we can use the `oc describe deployment`
    command to view verbose details about the web server deployment we just created:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用 `oc describe` 查看详细输出**：除了简单列出在 OpenShift 集群中创建并可用的对象外，还可以使用 `oc describe`
    命令查看有关特定对象的详细信息。与 `kubectl describe` 类似，`oc describe` 允许我们查看集群中几乎所有定义对象的相关详细信息。例如，我们可以使用
    `oc describe deployment` 命令查看刚才创建的 Web 服务器部署的详细信息：'
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Create an OpenShift service**: In order to expose pods that are running in
    the OpenShift cluster, we must first create a service. You may remember from [Chapter
    5](ccc07e61-25e7-4984-953b-586b28b12aab.xhtml), *Containers at Scale with Kubernetes*,
    that Kubernetes services are abstractions that work in a similar way to internal
    load balancers inside of the Kubernetes cluster. Essentially, we are creating
    a single internal (or external) IP address from which traffic from other pods
    or services can access any number of pods matched to a given selector. In OpenShift,
    we will create a service simply called `webserver` that will use an internally
    routed cluster IP address to intercept web server traffic and forward it to the
    web server pod we created as apart of our deployment. By naming our service `webserver`,
    it will by default use a selector criteria that matches the label `app=webserver`.
    This label was created by default when we created the deployment in OpenShift.
    Any number of labels or selector criteria can be created, which allows Kubernetes
    and OpenShift to select pods to load-balance traffic against. For the purposes
    of this example, we will use an internal cluster IP and map the selector criteria
    based on naming our service with the same name we named our deployment. Finally,
    we will select the ports we want to forward from our service externally, to the
    ports the service is listening on inside the container. To keep things simple,
    we will forward traffic destined to port `80` to the pod port `80`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个 OpenShift 服务**：为了暴露正在 OpenShift 集群中运行的 pods，我们必须首先创建一个服务。你可能还记得在[第 5
    章](ccc07e61-25e7-4984-953b-586b28b12aab.xhtml)中提到的*使用 Kubernetes 扩展容器*，Kubernetes
    服务是一种抽象，它的工作方式类似于 Kubernetes 集群内的内部负载均衡器。基本上，我们是创建一个单一的内部（或外部）IP 地址，其他 pods 或服务可以通过该
    IP 地址访问任何符合给定选择器的 pod。在 OpenShift 中，我们将创建一个名为 `webserver` 的服务，它将使用内部路由的集群 IP 地址来拦截
    Web 服务器流量并将其转发到我们在部署过程中创建的 Web 服务器 pod。通过将服务命名为 `webserver`，它将默认使用匹配标签 `app=webserver`
    的选择器标准。这个标签是在我们创建 OpenShift 部署时默认创建的。可以创建任意数量的标签或选择器标准，这使得 Kubernetes 和 OpenShift
    可以选择 pod 来进行流量负载均衡。为了这个示例，我们将使用内部集群 IP，并基于命名我们的服务与我们命名部署相同的名称来映射选择器标准。最后，我们将选择从外部转发到服务的端口，并映射到容器内服务监听的端口。为了简化操作，我们将把目标端口
    `80` 的流量转发到 pod 的 `80` 端口：'
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can check the service configuration using the `oc get services` command.
    We can see that our service was created with an internally routed cluster address
    of `172.30.136.131`. Yours will most likely differ as these addresses are pulled
    from the CNI subnet within Kubernetes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `oc get services` 命令检查服务配置。我们可以看到我们的服务已经创建，内部路由的集群地址是 `172.30.136.131`。你的地址很可能会不同，因为这些地址是从
    Kubernetes 中的 CNI 子网中获取的：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Create a route to enable access**: Finally, we can create a route to access
    our service using the `oc expose` command, followed by the service name we are
    exposing (`webserver`). To make this routable from our workstation, OpenShift
    uses the `nip.io` DNS forwarding based on the IP address of the VM. We can enable
    this by specifying the `--hostname` flag to be any name we want the service to
    be accessed by, followed by the IP address of the VM, concluding with the suffix `nip.io`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个路由以启用访问**：最后，我们可以使用 `oc expose` 命令创建一个路由，以便访问我们的服务，后面跟上我们要暴露的服务名称（`webserver`）。为了使其能够从我们的工作站进行路由，OpenShift
    使用基于虚拟机 IP 地址的 `nip.io` DNS 转发。我们可以通过指定 `--hostname` 参数来启用此功能，该参数后跟我们希望服务被访问时的名称，最后加上虚拟机的
    IP 地址，并以后缀 `nip.io` 结尾：'
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Executing the `oc get routes` command will display the route we just created:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `oc get routes` 命令将显示我们刚刚创建的路由：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To ensure the route is working, we can use a web browser and navigate to the
    forwarded DNS address we assigned to the route. If everything is working, we will
    be able to see the NGINX welcome screen:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保路由正常工作，我们可以使用 Web 浏览器并导航到我们为路由分配的转发 DNS 地址。如果一切正常，我们将能够看到 NGINX 欢迎屏幕：
- en: '![](img/6706d81d-e841-4cca-94d7-d6012a7e7492.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6706d81d-e841-4cca-94d7-d6012a7e7492.png)'
- en: Feel free to continue on deploying more complex containerized applications using
    your local Minishift cluster. When you are finished, make sure you stop the Minishift
    instance using the `minishift stop` command.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以继续使用本地 Minishift 集群部署更复杂的容器化应用程序。当你完成后，确保使用 `minishift stop` 命令停止 Minishift
    实例。
- en: OpenShift and Ansible Container
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenShift 和 Ansible 容器
- en: As we have seen throughout this chapter, OpenShift is a rich platform that provides
    valuable abstractions on top of Kubernetes. As such, Ansible Container provides
    ample support for deploying and running containerized application life cycles
    through OpenShift. Since OpenShift and Ansible Container are both products of
    the same parent company, Red Hat, it is apparent that OpenShift and Ansible Container
    will have excellent compatibility. So far, we have primarily discussed building
    containers using Ansible Container and running them locally on a Docker host.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中所看到的，OpenShift 是一个丰富的平台，提供了 Kubernetes 之上的有价值的抽象。因此，Ansible Container
    提供了充足的支持，可以通过 OpenShift 部署和运行容器化应用程序的生命周期。由于 OpenShift 和 Ansible Container 都是同一母公司
    Red Hat 的产品，因此显然 OpenShift 和 Ansible Container 具有出色的兼容性。到目前为止，我们主要讨论了如何使用 Ansible
    Container 构建容器，并在 Docker 主机上本地运行它们。
- en: Now that we have a firm foundation from which to understand Kubernetes and OpenShift,
    we can combine the knowledge we have gained so far with Ansible Container to learn
    how to use Ansible Container as a true end-to-end production-ready deployment
    and life cycle management solution. Things are about to get interesting!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经拥有了理解 Kubernetes 和 OpenShift 的坚实基础，可以将迄今为止获得的知识与 Ansible Container 相结合，学习如何将
    Ansible Container 作为一个真正的端到端生产就绪部署和生命周期管理解决方案来使用。接下来的内容将变得更加有趣！
- en: References
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '**OpenShift project**: [https://www.openshift.com/](https://www.openshift.com/)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenShift 项目**: [https://www.openshift.com/](https://www.openshift.com/)'
- en: '**MiniShift project**: [https://www.openshift.org/minishift/](https://www.openshift.org/minishift/)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MiniShift 项目**: [https://www.openshift.org/minishift/](https://www.openshift.org/minishift/)'
- en: '**Installing MiniShift**: [https://docs.openshift.org/latest/minishift/getting-started/installing.html](https://docs.openshift.org/latest/minishift/getting-started/installing.html)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装 MiniShift**: [https://docs.openshift.org/latest/minishift/getting-started/installing.html](https://docs.openshift.org/latest/minishift/getting-started/installing.html)'
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Container orchestration platforms such as Kubernetes and OpenShift are rapidly
    being adopted by organizations to ease the complex process of scaling out applications,
    deploying updates, and ensuring maximum reliability. With the increasing popularity
    of these platforms, it is even more important that we understand the implications
    of adopting these technologies in order to support the organizational and cultural
    shift of mentality these technologies bring to the table.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Kubernetes 和 OpenShift 这样的容器编排平台正在被组织迅速采用，以简化扩展应用程序、部署更新并确保最大可靠性的复杂过程。随着这些平台的日益流行，我们更需要理解采用这些技术的影响，以支持这些技术带来的组织和文化思维转变。
- en: OpenShift is a platform built on top of the Red Hat distribution of Kubernetes
    that aims to provide the best experience for working with Kubernetes. At the beginning
    of the chapter we learned what OpenShift is, and the various capabilities that
    Red Hat is working to deliver with the OpenShift platform. Next, we learned how
    to install the Minishift project, which is a developer-oriented solution for deploying
    OpenShift locally.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 是建立在 Red Hat 分发版 Kubernetes 之上的平台，旨在提供最佳的 Kubernetes 使用体验。在本章开始时，我们了解了
    OpenShift 是什么，以及 Red Hat 正在通过 OpenShift 平台交付的各种功能。接下来，我们学习了如何安装 Minishift 项目，这是一个面向开发者的解决方案，用于在本地部署
    OpenShift。
- en: Once we had Minishift installed and working locally, we learned how to run pods,
    deployments, services, and routes from the Minishift web user interface. Finally,
    we learned about the OpenShift command-line interface, OC, and how it functions
    in a similar capacity to kubectl to provide CLI access to OpenShift and the innovative
    functionality that OpenShift builds on top of Kubernetes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装并本地运行了 Minishift，我们就学会了如何通过 Minishift 的 Web 用户界面运行 pods、deployments、services
    和 routes。最后，我们了解了 OpenShift 命令行界面 OC，并学习了它如何类似于 kubectl，提供对 OpenShift 的 CLI 访问以及
    OpenShift 在 Kubernetes 之上构建的创新功能。
- en: In the next chapter, my aim is to tie our knowledge of OpenShift and Kubernetes
    back into Ansible Container to learn about the final step in the Ansible Container
    workflow, deployment. The deployment functionality sets Ansible Container apart
    as a truly robust tool for not only building and testing container images, but
    also for deploying them all the way through to containerized production environments
    running on Kubernetes and OpenShift.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我的目标是将我们对 OpenShift 和 Kubernetes 的知识与 Ansible Container 相结合，学习 Ansible
    Container 工作流中的最后一步——部署。部署功能使 Ansible Container 成为一个真正强大的工具，不仅可以构建和测试容器镜像，还可以将它们部署到运行
    Kubernetes 和 OpenShift 的容器化生产环境中。
