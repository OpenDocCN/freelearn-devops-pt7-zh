- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Merging Changes Together
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并更改
- en: The previous chapter, *Advanced Branching Techniques*, described how to use
    branches effectively for collaboration and development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章《*高级分支技术*》介绍了如何有效地使用分支进行协作和开发。
- en: This chapter will teach you how to integrate changes from different parallel
    lines of development together (that is, branches) by creating a merge commit,
    or by reapplying changes with the rebase operation. Here, the concepts of merge
    and rebase are explained, including the differences between them and how they
    can be used. This chapter will also explain the different types of merge conflicts
    and teach you how to avoid them, examine them, and resolve them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何通过创建合并提交，或通过变基操作重新应用更改，将来自不同并行开发线（即分支）的更改合并在一起。在这里，将解释合并和变基的概念，包括它们之间的区别以及如何使用它们。本章还将解释不同类型的合并冲突，并教你如何避免、检查和解决这些冲突。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: Merging, merge strategies, and merge drivers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并、合并策略和合并驱动程序
- en: Cherry-picking and reverting a commit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 樱桃挑选和撤销提交
- en: Applying a patch and a patch series
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用补丁和补丁系列
- en: Rebasing a branch and replaying its commits
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变基分支并重放其提交
- en: A merge algorithm at file and contents level
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于文件和内容层面的合并算法
- en: Three stages in the index
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引中的三个阶段
- en: Merge conflicts – how to examine and resolve them
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并冲突 – 如何检查和解决它们
- en: Reusing recorded **[conflict]** resolutions with **git rerere**
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **git rerere** 重用已记录的 **[冲突]** 解决方案
- en: An external tool – **git-imerge**
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部工具 – **git-imerge**
- en: Methods of combining changes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并更改的方法
- en: Now that you have changes from other people in the remote-tracking branches
    (or in the series of emails), you need to combine them, perhaps also with your
    changes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经有了来自远程跟踪分支（或一系列电子邮件）的其他人更改，你需要将它们合并，可能还包括你自己的更改。
- en: Alternatively, your work on a new feature, created and performed on a separate
    topic branch, is now ready to be included in the long-lived development branch
    and made available to other people. Maybe you have created a bug fix and want
    to include it in all the long-lived graduation branches. In short, you want to
    join two divergent lines of development by integrating their changes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你在一个独立的主题分支上创建并执行的新功能工作现在已经准备好可以合并到长期开发分支中，并让其他人可以使用。也许你已经创建了一个 bug 修复，并想将其包括到所有长期维护的分支中。简而言之，你想通过整合它们的更改将两条不同的开发线合并在一起。
- en: Git provides a few different methods to combine changes and variations of these
    methods. One of these methods is a *merge* operation, joining two lines of development
    with a two-parent commit. Another way to copy introduced work from one branch
    to another is via cherry-picking, which is creating a new commit with the same
    changeset on another line of development (this is sometimes necessary to use).
    Alternatively, you can reapply changes, transplanting one branch on top of another
    with *rebase*. We will now examine all these methods and their variants, see how
    they work, and when they can be used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Git 提供了几种不同的方法来合并更改，以及这些方法的变体。其中一种方法是*合并*操作，将两个开发线与一个双父提交连接起来。另一种将工作从一个分支复制到另一个分支的方法是通过樱桃挑选（cherry-picking），即在另一条开发线创建一个新的提交，包含相同的更改集（有时需要使用此方法）。另外，你可以重新应用更改，通过*变基*将一个分支移植到另一个分支之上。我们将现在详细探讨这些方法及其变体，看看它们如何工作，以及何时可以使用它们。
- en: In many cases, Git will be able to combine changes automatically; the next section
    will talk about what you can do if it fails and if there are merge conflicts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，Git 会自动合并更改；下一节将讨论如果合并失败以及发生合并冲突时该怎么办。
- en: Merging branches
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并分支
- en: 'The `git` `merge` command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`git` `merge` 命令：'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we first switched to a branch we want to merge into (in this example,
    `master`) and then provided the branch to be merged (here, `bugfix123`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先切换到一个要合并到的分支（在这个示例中是`master`），然后指定要合并的分支（这里是`bugfix123`）。
- en: No divergence – fast-forward and up-to-date cases
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无分歧 – 快进和最新状态的情况
- en: Let’s say that you need to create a fix for a bug somebody found. Let’s assume
    that you have followed the recommendations of the topic branch workflow from [*Chapter
    8*](B21194_08_split_000.xhtml#_idTextAnchor196), *Advanced Branching Techniques*,
    and created a separate bugfix branch, named `i18n`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要为别人发现的一个 bug 创建修复。假设你已经遵循了《*第8章*》中主题分支工作流的建议，[*高级分支技术*]，并创建了一个名为 `i18n`
    的独立 bugfix 分支。
- en: 'In such cases, there is often no real divergence, which means that there were
    no commits on the maintenance branch (the branch we are merging into), since a
    bugfix branch was created. Because of this, Git would, by default, simply move
    the branch pointer of the current branch forward:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通常没有真正的分歧，这意味着在维护分支（我们合并到的分支）上没有任何提交，因为已经创建了一个 bugfix 分支。由于这个原因，Git 默认会简单地将当前分支的指针向前移动：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You have probably seen this `git pull`, when there are no changes on the branch
    you pull into. The fast-forward merge situation is shown in *Figure 9**.1*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经见过 `git pull`，当你拉取的分支没有任何变化时。快进合并的情况如 *图 9.1* 所示。
- en: '![Figure 9.1 – The master branch is fast-forwarded to i18n during the merge](img/B21194_09_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 主分支在合并时被快进到 i18n](img/B21194_09_01.jpg)'
- en: Figure 9.1 – The master branch is fast-forwarded to i18n during the merge
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 主分支在合并时被快进到 i18n
- en: This case is important for the centralized and the peer-to-peer workflows (described
    in [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140), *Collaborative Development
    with Git*), as it is the fast-forward merge that allows you to ultimately push
    your changes forward.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况对于集中式和对等式工作流非常重要（在 [*第 6 章*](B21194_06.xhtml#_idTextAnchor140)中有描述，*使用 Git
    进行协作开发*），因为正是快进合并使你能够最终将更改推进。
- en: In some cases, that is not what you want. For example, note that after the fast-forward
    merge in *Figure 9**.1*, we have lost the information that the `i18n` topic branch.
    We can force the creation of a merge commit (which is described in the next section),
    even in a case where there are no changes to the current branch, using the `git
    merge --no-ff` command. The default is `--ff`; to fail instead of creating a merge
    commit, you can use `--ff-only` (ensuring fast-forward only).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这并不是你想要的。例如，注意到在 *图 9.1* 中进行快进合并后，我们失去了 `i18n` 主题分支的信息。即便当前分支没有任何更改，我们也可以强制创建一个合并提交（将在下一节中描述），方法是使用
    `git merge --no-ff` 命令。默认情况下是 `--ff`；如果想要避免创建合并提交，可以使用 `--ff-only`（确保仅进行快进合并）。
- en: '![Figure 9.2 – The master branch is up to date with respect to the i18n branch
    (i.e., it includes it)](img/B21194_09_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 主分支与 i18n 分支是最新的（即，已包含该分支）](img/B21194_09_02.jpg)'
- en: Figure 9.2 – The master branch is up to date with respect to the i18n branch
    (i.e., it includes it)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 主分支与 i18n 分支是最新的（即，已包含该分支）
- en: 'There is another situation where the head (tip) of one branch is the ancestor
    of the other – namely, the up-to-date scenario where the branch we try to merge
    is already included (merged) in the current branch (*Figure 9**.2*). Git doesn’t
    need to do anything in this case; it just informs the user about it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种情况，其中一个分支的头（tip）是另一个分支的祖先——即，分支我们试图合并的分支已经包含（合并）到当前分支中的最新场景（*图 9.2*）。在这种情况下，Git
    不需要做任何操作；它只会告知用户：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating a merge commit
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个合并提交
- en: When you are merging fully fledged feature branches, rather than merging bugfix
    branches as in the previous section, the situation is usually different from the
    previously described fast-forward case. In the case of feature branch workflow,
    the development of the feature branch and integration branch would usually have
    diverged.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你合并完全成熟的功能分支时，情况通常与前面描述的快进合并有所不同，而不是像上一节中那样合并 bugfix 分支。在功能分支工作流的情况下，功能分支和集成分支的开发通常会发生分歧。
- en: 'Suppose that you have decided that your work on a feature (for example, work
    on adding support for internationalization on the `i18n` topic branch) is complete
    and ready to be included in the master stable branch. In order to do so with a
    merge operation, you need to first check out the branch you want to merge into
    and then run the `git merge` command, with the branch being merged as a parameter:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经决定完成了某个功能的工作（例如，在 `i18n` 主题分支上添加对国际化的支持），并准备将其包含到主稳定分支中。为了通过合并操作做到这一点，你需要首先检出你想要合并到的分支，然后运行
    `git merge` 命令，指定待合并的分支作为参数：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because the top commit on the branch you are on (and merging into) is not a
    direct ancestor or a direct descendant of the branch you merge in, Git has to
    do more work than just moving the branch pointer. In this case, Git does a merge
    of changes since the divergence and stores it as a **merge commit** on the current
    branch. This commit has two parents, denoting that it was created based on more
    than one commit (more than one branch); the first parent is the previous tip of
    the current branch, and the second parent is the tip of the branch you merge in.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你当前所在的分支（以及合并到的分支）的最新提交既不是你正在合并的分支的直接祖先，也不是其直接后代，Git 必须执行比仅仅移动分支指针更多的操作。在这种情况下，Git
    会合并自分支分歧以来的所有变更，并将其存储为当前分支上的**合并提交**。这个提交有两个父提交，表示它是基于多个提交（多个分支）创建的；第一个父提交是当前分支的前一个提交，第二个父提交是你正在合并的分支的最新提交。
- en: Note that Git does start committing the result of merge if it can be done automatically,
    and if there are no conflicts. However, the fact that the merge succeeded at the
    text level doesn’t necessarily mean that the merge result is correct. You can
    either ask Git to not automatically commit a merge with `git merge --no-commit`
    to examine it first, or you can examine the merge commit and then use the `git
    commit --amend` command if it is incorrect (see *Figure 2**.4*).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果 Git 能够自动完成合并且没有冲突，它会开始提交合并结果。然而，合并在文本层面成功并不一定意味着合并结果是正确的。你可以使用`git merge
    --no-commit`命令要求 Git 不自动提交合并，以便先进行检查，或者在检查合并提交后，如果发现问题，可以使用`git commit --amend`命令进行修正（见*图
    2.4*）。
- en: '![Figure 9.3 – Three revisions used in a typical merge and the resulting merge
    commit](img/B21194_09_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 在典型合并中使用的三个修订和结果合并提交](img/B21194_09_03.jpg)'
- en: Figure 9.3 – Three revisions used in a typical merge and the resulting merge
    commit
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 在典型合并中使用的三个修订和结果合并提交
- en: Git creates contents of a merge commit (`git` `merge-base` command).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Git 创建合并提交的内容（`git` `merge-base` 命令）。
- en: A very important issue is that Git creates the merge commit contents based usually
    only on the three revisions – merged into (*ours*), merged in (*theirs*), and
    the common ancestor (*merge base*). It does not examine what happened on the divergent
    parts of the branches; this is what makes merging fast. However, because of this,
    Git also does not know about the cherry-picked or reverted changes on the branches
    being merged, which might lead to surprising results (see, for example, the section
    about reverting merges in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping* *History Clean*).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常重要的问题是，Git 通常仅基于三个修订来创建合并提交内容——合并进来的（*ours*）、合并出去的（*theirs*）以及共同祖先（*merge
    base*）。它不会检查分支的分歧部分发生了什么变化；这使得合并过程非常迅速。然而，正因为如此，Git 也无法得知在被合并的分支上进行的樱桃挑选或回退的更改，这可能会导致一些意外的结果（例如，参见
    [*第 10 章*](B21194_10_split_000.xhtml#_idTextAnchor247) 中关于回退合并的部分，*保持历史清晰*）。
- en: Merge strategies and their options
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并策略及其选项
- en: In the merge message, we have seen that it was made by the **‘ort’** strategy
    (known as **recursive** in older Git). The **merge strategy** is an algorithm
    that Git uses to compose the result of joining two or more lines of development.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并信息中，我们可以看到它是通过 **‘ort’** 策略（在旧版本 Git 中称为 **recursive**）进行的。**合并策略** 是 Git
    用来组合两个或多个开发分支的结果的算法。
- en: There are a few merge strategies that you can select to use with the `--strategy`/`-s`
    option to the `git merge` command. By default, Git uses the *ort* merge strategy
    when joining two branches and a very simple *octopus* merge strategy when joining
    more than two branches. You can also choose the *resolve* merge strategy if the
    default one fails; it is fast and safe, although less capable of merging.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择几种合并策略，通过 `git merge` 命令的 `--strategy`/`-s` 选项来使用。默认情况下，Git 在合并两个分支时使用
    *ort* 合并策略，在合并多个分支时使用非常简单的 *octopus* 合并策略。如果默认策略失败，你还可以选择 *resolve* 合并策略；它速度较快且安全，尽管合并能力较弱。
- en: The two remaining merge strategies are special-purpose algorithms. The *ours*
    merge strategy can be used when we want to abandon changes in the merged-in branch
    but keep them in the history of the merged-into branch – for example, for documentation
    purposes. This strategy simply repeats the current snapshot (the *ours* version)
    as a merge commit. Note that this merge strategy, invoked with `--strategy=ours`
    or `-s ours`, should be not confused with the *ours* option to the default *ort*
    merge strategy, `--strategy=ort --strategy-option=ours`, or just *-Xours*, which
    means something different.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两种合并策略是特殊用途的算法。*ours*合并策略可以在我们想要放弃合并分支中的更改，但保留它们在目标分支历史中的情况下使用——例如，用于文档目的。此策略仅仅将当前快照（*ours*版本）重复作为一个合并提交。请注意，这种合并策略，通过`--strategy=ours`或`-s
    ours`调用时，不应与默认*ort*合并策略的*ours*选项混淆，`--strategy=ort --strategy-option=ours`，或者只是*-Xours*，它们的含义不同。
- en: The *subtree* merge strategy can be used for subsequent merges from an independent
    project into a subdirectory (subtree) in a main project. It automatically figures
    out where the subproject was put. This topic, and the concept of subtrees, will
    be described in more detail in [*Chapter 11*](B21194_11.xhtml#_idTextAnchor270),
    *Managing Subprojects*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*子树*合并策略可以用于将一个独立项目的内容合并到主项目中的子目录（子树）中。它会自动确定子项目的位置。此主题以及子树的概念将在[*第11章*](B21194_11.xhtml#_idTextAnchor270)中详细描述，*管理子项目*。'
- en: The default **ort** (**Ostensibly Recursive’s Twin**) merge strategy, and its
    predecessor, the *recursive* merge strategy, are named after how such a strategy
    deals with multiple merge bases and criss-cross merges. In the case of more than
    one merge base (which means that there is more than one common ancestor that can
    be used for a three-way merge), such a strategy creates a merge tree (conflicts
    and all) from the ancestors as a merge base – that is, it merges recursively.
    Of course, again, these common ancestors being merged can have more than one merge
    base.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的**ort**（**表面递归的双胞胎**）合并策略及其前身*递归*合并策略，得名于该策略如何处理多个合并基和交叉合并。在存在多个合并基的情况下（这意味着有多个可以用作三方合并的共同祖先），该策略会从这些祖先创建一个合并树（包括冲突），作为合并基——也就是说，它会递归地合并。当然，这些被合并的共同祖先也可以有多个合并基。
- en: Some strategies are customizable and have their own options. You can pass an
    option to a merge algorithm with `-X<option>` (or `--strategy-option=<option>`)
    on the command line, or set it with the appropriate configuration variables. You
    will discover more about merge options in the section *Resolving merge conflicts*,
    when we will discuss solving merge conflicts.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一些策略是可定制的，并且有自己的选项。你可以通过命令行中的`-X<option>`（或`--strategy-option=<option>`）将选项传递给合并算法，或者通过适当的配置变量进行设置。你将在*解决合并冲突*部分中了解更多合并选项，在该部分我们将讨论如何解决合并冲突。
- en: A reminder – merge drivers
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提醒——合并驱动程序
- en: '[*Chapter 3*](B21194_03_split_000.xhtml#_idTextAnchor049)*, Managing Your*
    *Worktrees*, introduced git attributes – among others, **merge drivers**. These
    *drivers* are user-defined and deal with merging file contents if there is a conflict,
    replacing the default three-way file-level merge. Merge *strategies*, in contrast,
    deal with DAG-level merging (and tree-level – that is, merging directories), and
    you can only choose from the built-in options.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第3章*](B21194_03_split_000.xhtml#_idTextAnchor049)*，管理你的* *工作树*，介绍了git属性——其中包括**合并驱动程序**。这些*驱动程序*是用户自定义的，处理在发生冲突时合并文件内容，替代了默认的三方文件级合并。相比之下，合并*策略*处理DAG级别的合并（以及树级别——即，合并目录），并且你只能从内置选项中选择。'
- en: A reminder – signing merges and merging tags
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提醒——签名合并和合并标签
- en: In [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140), *Collaborative Development
    with Git*, you learned about signing your work. While using merge to join two
    lines of development, you can either merge a signed tag, sign a merge commit,
    or both. Signing a merge commit is done with the `-S` / `--gpg-sign` option to
    use the `git merge` or `git commit` command; the latter is used if there are conflicts,
    or if the `--no-commit` option was used while merging.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B21194_06.xhtml#_idTextAnchor140)，*使用Git的协同开发*中，你学到了如何对你的工作进行签名。在使用合并将两条开发线路连接时，你可以合并一个已签名的标签，签名一个合并提交，或者两者都做。签名一个合并提交可以通过在使用`git
    merge`或`git commit`命令时使用`-S` / `--gpg-sign`选项来完成；如果存在冲突，或者在合并时使用了`--no-commit`选项，后者会被使用。
- en: Copying and applying a changeset
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制和应用变更集
- en: The merging operation is about joining two lines of development (two branches),
    including all the changes since their divergence. This means, as described in
    [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196), *Advanced Branching
    Techniques*, that if there is one commit on the less stable branch (for example,
    `master`) that you want to have also in a more stable branch (for example, `maint`),
    you cannot use the merge operation. You need to create a copy of such a commit.
    A situation such as this should be avoided (using topic branches), but it can
    happen, and handling it is sometimes necessary.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 合并操作是将两条开发线（两条分支）合并，包括自它们分歧以来的所有变更。正如在[*第 8 章*](B21194_08_split_000.xhtml#_idTextAnchor196)《高级分支技术》中所描述的那样，如果在较不稳定的分支（例如，`master`）上有一个提交，你希望它也出现在一个更稳定的分支（例如，`maint`）上，那么你不能使用合并操作。你需要创建该提交的副本。像这样的情况应尽量避免（使用主题分支），但它有时会发生，处理这种情况有时是必要的。
- en: Sometimes, the changes that need to be applied come not from the repository
    (as a revision in the DAG to be copied) but in the form of a patch – that is,
    a unified diff or an email generated with `git format-patch` (with a patch, plus
    a commit message).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，需要应用的变更不是来自仓库（作为要复制的 DAG 中的修订），而是以补丁的形式出现——也就是说，一个统一的 diff 或使用 `git format-patch`
    生成的邮件（包括补丁和提交信息）。
- en: Git includes the `git am` tool to handle the mass application of commit-containing
    patches.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Git 包含 `git am` 工具，用于处理大规模应用包含提交的补丁。
- en: Both of these commands are useful on their own, but understanding these methods
    of getting changes is also useful to understand how cherry-picking and rebasing
    work.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令本身都是有用的，但理解这些获取变更的方法也有助于理解 cherry-pick 和 rebase 的工作原理。
- en: Cherry-pick – creating a copy of a changeset
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cherry-pick – 创建变更集的副本
- en: You can create a copy of a commit (or a series of commits) with the `cherry-pick`
    command. Given a series of commits (usually just a single commit), it applies
    the changes each one introduces, recording a new commit for each change.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `cherry-pick` 命令创建一个提交（或一系列提交）的副本。给定一系列提交（通常只是一个提交），它会应用每个提交所引入的变更，为每个变更记录一个新的提交。
- en: '![Figure 9.4 – Cherry-picking the C4 commit from master to maint](img/B21194_09_04.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 将 C4 提交从 master 分支 cherry-pick 到 maint 分支](img/B21194_09_04.jpg)'
- en: Figure 9.4 – Cherry-picking the C4 commit from master to maint
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 将 C4 提交从 master 分支 cherry-pick 到 maint 分支
- en: An example of a cherry-pick operation is shown in *Figure 9**.4*. (Note that
    here the thick dotted arrow from **C4** to **C4’** denotes a copy; it is not a
    reference.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9.4* 中展示了一个 cherry-pick 操作的示例。（注意，这里从**C4**到**C4’**的粗虚线箭头表示的是复制操作；它不是引用。）'
- en: The copying of changes does not mean that the snapshot (that is, the state of
    a project) is the same in the original (**C4** in *Figure 9**.4*) and in the copy
    (**C4’** in *Figure 9**.4*); the latter will include other changes while missing
    others. Also, while the changes will usually be the same (as they are in *Figure
    9**.4*, where the difference between **C3** and **C4** and the diff between **C7**
    and **C4’** is the same), they can also be different – for example, if part of
    the changes was already present in the earlier commits.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 变更的复制并不意味着原始快照（即项目的状态）在原始位置（*图 9.4* 中的 **C4**）和复制位置（*图 9.4* 中的 **C4’**）是相同的；后者将包含其他变更，同时缺少一些变更。而且，虽然变更通常是相同的（如
    *图 9.4* 中所示，**C3** 与 **C4** 之间的差异和 **C7** 与 **C4’** 之间的 diff 是相同的），它们也可以是不同的——例如，如果部分变更已经出现在早期的提交中。
- en: Note that, by default, Git does not save information about where the cherry-picked
    commit came from. You can append this information to an original commit message,
    as a `git cherry-pick -x <commit>`. This is only done for cherry-picks without
    conflicts. Remember that this information is only useful if you have access to
    the copied commit. Do not use it if you are copying commits from the private branch,
    as other developers won’t be able to make use of that information.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，Git 不会保存关于 cherry-pick 提交来源的信息。你可以将此信息附加到原始提交信息中，例如 `git cherry-pick
    -x <commit>`。这仅适用于没有冲突的 cherry-pick 操作。记住，这些信息只有在你可以访问被复制的提交时才有用。如果你是从私有分支复制提交，请不要使用此信息，因为其他开发者将无法使用这些信息。
- en: Revert – undoing the effect of a commit
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Revert – 撤销提交的影响
- en: Sometimes, it will turn out that, even with a code review, there will be some
    bad commits that you need to reverse (perhaps one turned out to be a not-so-good
    idea, or it contains bugs). If the commit is already made public, you cannot simply
    remove it; you need to undo its effects. This issue will be explained in detail
    in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247), *Keeping* *History
    Clean*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，即使经过代码审查，仍会发现一些错误的提交需要撤销（可能是某个提交原来是个不太好的想法，或者它包含了错误）。如果提交已经公开，你不能简单地删除它；你需要撤销它的效果。这个问题将在
    [*第 10 章*](B21194_10_split_000.xhtml#_idTextAnchor247) *保持历史清洁* 中详细解释。
- en: This “undoing of a commit” can be done by creating a commit with a reversal
    of changes, something like cherry-picking but applying the reversal of changes.
    This is done with the `revert` command (see *Figure 9**.5*).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“撤销提交”可以通过创建一个反向变更的提交来实现，类似于 cherry-pick，但应用的是变更的反向。这可以通过`revert`命令完成（见*图
    9.5*）。
- en: "![Figure 9.5 – The effect of using \uFEFF'git revert master^' on a \uFEFF'master'\
    \ branch – creating a new commit, denoted !C3, that undoes changes in \uFEFFthe\
    \ C3 commit](img/B21194_09_05.jpg)"
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 使用 ''git revert master^'' 在 ''master'' 分支上的效果 – 创建一个新的提交，标记为 !C3，撤销
    C3 提交中的变更](img/B21194_09_05.jpg)'
- en: Figure 9.5 – The effect of using 'git revert master^' on a 'master' branch –
    creating a new commit, denoted !C3, that undoes changes in the C3 commit
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 使用 'git revert master^' 在 'master' 分支上的效果 – 创建一个新的提交，标记为 !C3，撤销 C3 提交中的变更
- en: The name of this operation might be misleading. If you want to revert all the
    changes made to the whole working area, you can use `git reset` (in particular,
    with the `--hard` option). If you want to revert changes made to a single file,
    use `git checkout <file>` or `git restore <file>`. Both of these are explained
    in detail in [*Chapter 3*](B21194_03_split_000.xhtml#_idTextAnchor049), *Managing
    Your* *Worktrees*. The `git revert` command records a new commit to reverse the
    effect of the earlier commit (often, a faulty one).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的名称可能会让人产生误解。如果你想撤销对整个工作区所做的所有更改，可以使用 `git reset`（特别是使用 `--hard` 选项）。如果你想撤销对单个文件所做的更改，可以使用
    `git checkout <file>` 或 `git restore <file>`。这两者在 [*第 3 章*](B21194_03_split_000.xhtml#_idTextAnchor049)
    *管理你的工作区* 中有详细解释。`git revert` 命令会记录一个新提交，撤销之前提交的效果（通常是一个有问题的提交）。
- en: Applying a series of commits from patches
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用一系列的补丁提交
- en: Some collaborative workflows include exchanging the changes as patches via email
    (or another communication medium). This workflow is often encountered in open
    source projects; it is often easier for a new or a sporadic contributor to create
    a specially crafted email (for example, with `git format-patch`) and send it to
    a maintainer or a mailing list, rather than setting up a public repository and
    sending a pull request.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一些协作工作流包括通过电子邮件（或其他通信媒介）交换变更作为补丁。这种工作流通常出现在开源项目中；对于新贡献者或偶尔贡献者来说，创建一封特别制作的电子邮件（例如，使用`git
    format-patch`）并将其发送给维护者或邮件列表，往往比设置一个公共仓库并发送拉取请求更为简单。
- en: You can apply a series of patches from a mailbox (in the `mbox` or `maildir`
    format; the latter is just a series of files) with the `git am` command. If these
    emails (or files) were created from the `git format-patch` output, you can use
    `git am --3way` to use the three-way file merge if there are conflicts. Resolving
    conflicts will be discussed in in the section, *Resolving* *merge conflicts*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `git am` 命令，从邮箱（采用 `mbox` 或 `maildir` 格式；后者只是一个文件系列）应用一系列补丁。如果这些电子邮件（或文件）是从
    `git format-patch` 输出创建的，你可以使用 `git am --3way` 来使用三方文件合并，如果有冲突的话。解决冲突将在*解决* *合并冲突*
    部分中讨论。
- en: You can find both tools to help use the patch submission process by sending
    a series of patches – for example, from the pull request on GitHub (e.g., the
    *GitGitGadget* GitHub app, or the older *submitGit* web app, to submit patches
    from GitHub’s pull request to the Git project mailing list) – and tools that track
    web page patches sent to a mailing list (for example, the *patchwork* tool).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到一些工具，帮助通过发送一系列补丁来使用补丁提交过程——例如，从 GitHub 上的拉取请求（例如，*GitGitGadget* GitHub
    应用，或较老的 *submitGit* 网页应用，将补丁从 GitHub 的拉取请求提交到 Git 项目的邮件列表）——以及一些工具，用于跟踪发送到邮件列表的网页补丁（例如，*patchwork*
    工具）。
- en: Cherry-picking and reverting a merge
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择性提交和撤销合并
- en: This is all good, but what happens if you want to cherry-pick or revert a merge
    commit? Such commits have more than one parent; thus, they have more than one
    change associated with them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这都没问题，但如果你想要选择性提交或撤销一个合并提交怎么办？这种提交有多个父提交，因此，它们与多个变更相关联。
- en: In this case, you have to tell Git which change you want to pick up (in the
    case of cherry-pick), or back out (in the case of revert) with the `-m <parent
    number>` option – for example, `-m1`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要告诉 Git 你希望采用哪个更改（在 cherry-pick 的情况下），或者撤销哪个更改（在 revert 的情况下），并使用 `-m
    <parent number>` 选项——例如，`-m1`。
- en: Note that reverting a merge undoes the changes, but it does not remove the merge
    from the history of the project. See the section on reverting merges in [*Chapter
    10*](B21194_10_split_000.xhtml#_idTextAnchor247), *Keeping* *History Clean*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，撤销合并操作会撤销更改，但不会从项目历史中删除合并记录。有关撤销合并的更多信息，请参见[*第 10 章*](B21194_10_split_000.xhtml#_idTextAnchor247)，*保持历史清晰*部分。
- en: Rebasing a branch
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重置分支
- en: Besides merging, Git supports an additional way to integrate changes from one
    branch into another – namely, the **rebase operation**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了合并，Git 还支持一种将一个分支的更改集成到另一个分支中的额外方式——即**rebase 操作**。
- en: Like a merge, it deals with the changes since the point of divergence (at least,
    by default). However, while a merge creates a new commit by joining two branches,
    rebase takes the new commits from one branch (i.e., takes the commits since the
    divergence) and reapplies them on top of the other branch – see *Figure 9**.6*
    for an example.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 像合并一样，它处理自分叉点以来的变化（至少是默认情况下）。然而，虽然合并通过连接两个分支来创建一个新的提交，rebase 则是将一个分支的新提交（即，自分叉以来的提交）重新应用到另一个分支上——具体示例如*图
    9.6*。
- en: '![Figure 9.6 – The effects of the rebase operation](img/B21194_09_06.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – Rebase 操作的效果](img/B21194_09_06.jpg)'
- en: Figure 9.6 – The effects of the rebase operation
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – Rebase 操作的效果
- en: 'With merge, you first switch to the branch to be merged and then use the merge
    command to select a branch to merge in. With rebase, it is a bit different. First,
    you select a branch to rebase (i.e., the changes to reapply) and then use the
    rebase command to select where to put it. In both cases, you first check out the
    branch to be modified, where a new commit or commits would be (a merge commit
    in the case of merging, and a replay of commits in the case of rebasing):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用合并时，你首先切换到要合并的分支，然后使用合并命令选择要合并的分支。使用 rebase 时，则有些不同。首先，你选择一个要重置的分支（即要重新应用的更改），然后使用
    rebase 命令选择应用的位置。在这两种情况下，你首先会检出要修改的分支，在该分支上会有一个新的提交或多个提交（合并的情况下是合并提交，rebase 的情况下是提交的重新应用）：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Alternatively, you can use `git rebase master i18n` as a shortcut. In this form,
    you can easily see that the rebase operation takes the `master..i18n` range of
    revisions (this notation is explained in [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083),
    *Exploring Project History*), replays it on top of `master`, and finally, points
    `i18n` to the replayed commits.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以使用 `git rebase master i18n` 作为快捷方式。在这种形式下，你可以很容易看到，rebase 操作将 `master..i18n`
    范围的修订（这种表示法在[*第 4 章*](B21194_04.xhtml#_idTextAnchor083)，*探索项目历史*中有解释）重新应用到 `master`
    上，最后将 `i18n` 指向重新应用的提交。
- en: Note that old versions of commits don’t vanish, at least not immediately. They
    will be accessible via a reflog (and `ORIG_HEAD`) for a grace period. This means
    that it is not that hard to check how replaying changed the snapshots of a project
    and, with a bit more effort, how changesets themselves have changed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，旧版本的提交不会立即消失，至少不会立刻。它们会在一段宽限期内通过 reflog（和 `ORIG_HEAD`）访问。这意味着，查看重新应用操作如何改变项目快照并不困难，通过更多的努力，你也能看到变更集本身是如何变化的。
- en: Merge versus rebase
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并与 rebase
- en: We have these two ways of integrating changes – merge and rebase. How do they
    differ, and what are their advantages and disadvantages? We can see by comparing
    *Figure 9**.2* in the *Creating a merge commit* section with *Figure 9**.5* in
    the *Rebasing a* *branch* section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有这两种集成更改的方法——合并和 rebase。它们有什么不同，优缺点分别是什么？我们可以通过比较*图 9.2*（*创建合并提交*部分）和*图 9.5*（*重置分支*部分）来一探究竟。
- en: First, merge doesn’t change history (see [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping History Clean*). It creates and adds a new commit (unless it is a fast-forward
    merge; then, it just advances the branch head), but the commits that were reachable
    from the branch remain reachable. This is not the case with rebase. Commits get
    rewritten, old versions are forgotten, and the DAG of revisions changes. What
    was once reachable might no longer be reachable. This means that you should not
    rebase published branches.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，合并（merge）不会改变历史（见 [*第10章*](B21194_10_split_000.xhtml#_idTextAnchor247)，*保持历史清晰*）。它会创建并添加一个新的提交（除非是快进合并；此时，它只是前移分支头部），但从分支上可达的提交仍然是可达的。这与
    rebase 不同。提交会被重写，旧版本会被遗忘，修订的有向无环图（DAG）也会发生变化。曾经可以到达的提交可能不再可达。这意味着你不应对已发布的分支进行
    rebase。
- en: Secondly, merge is a one-step operation, with one place to resolve merge conflicts.
    The rebase operation is multi-step; the steps are smaller (if you follow the recommended
    practices and keep changes small – see [*Chapter 15*](B21194_15.xhtml#_idTextAnchor371),
    *Git Best Practices*), but there are more of them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，合并是一个一步操作，只需要解决一次合并冲突。而 rebase 操作是多步的；每一步较小（如果你遵循推荐的实践并保持更改较小——见 [*第15章*](B21194_15.xhtml#_idTextAnchor371)，*Git
    最佳实践*），但步骤更多。
- en: Linked to this is the fact that the merge result is based (usually) on three
    commits only, and that it does not take into account what happens on either of
    the branches that are integrated step by step; only the endpoints matter. Conversely,
    rebase reapplies each commit individually, so the road to the final result matters
    here.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相关的是，合并结果通常仅基于三个提交，并且它不考虑在逐步集成的任一分支上发生的事情；只有端点是重要的。相反，rebase 会单独重新应用每个提交，因此到达最终结果的过程是很重要的。
- en: Third, the history looks different; you get a simple linear history with rebase,
    while using the merge operation leads to a complex history, with the lines of
    development forking and joining. The history is simpler for rebase, but you lose
    the information that the changes were developed on a separate branch and that
    they were grouped together, which you get with merge (at least with `--no-ff`).
    There is even the `git-resurrect` script in the Git contrib tools that uses the
    information stored in the commit messages of the merge commits to resurrect the
    old, long-deleted feature branches.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，历史看起来不同；使用 rebase，你将得到一个简单的线性历史，而使用合并操作则会导致一个复杂的历史，开发线路会分叉和合并。对于 rebase，历史更简单，但你失去了有关更改是在独立分支上开发并且被组合在一起的信息，这是使用合并时能够获得的（至少在使用
    `--no-ff` 时）。Git contrib 工具中甚至有一个 `git-resurrect` 脚本，它利用合并提交信息中的数据恢复已删除的旧特性分支。
- en: The last difference is that, because of the underlying mechanism, rebase does
    not, by default, preserve merge commits while reapplying them. You need to explicitly
    use the `--rebase-merges` option. The merge operation does not change the history,
    so merge commits are left as they are.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个区别是，由于底层机制的原因，rebase 默认不会保留合并提交。在重新应用时，必须明确使用 `--rebase-merges` 选项。合并操作不会改变历史，因此合并提交会保持原样。
- en: Rebase backends
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rebase 后端
- en: The previous section described two mechanisms to copy or apply changes – the
    `git cherry-pick` command and the pipeline from `git format-patch` to `git am
    --3way`. Either of them can be used by `git rebase` to reapply commits.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节描述了两种复制或应用更改的机制——`git cherry-pick` 命令和从 `git format-patch` 到 `git am --3way`
    的管道。它们中的任意一种都可以被 `git rebase` 用来重新应用提交。
- en: The default is to use the merge-based workflow, as if `git rebase` was called
    with the `--merge` option. The default `'ort'` merge strategy allows rebase to
    be aware of the renames on the upstream side (where we put the replayed commits).
    With this option, you can also select a specific merge strategy and pass options
    to it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下使用基于合并的工作流，就像是调用了带有 `--merge` 选项的 `git rebase`。默认的 `'ort'` 合并策略使得 rebase
    能够感知上游端（我们放置回放提交的地方）上的重命名。使用此选项，你还可以选择特定的合并策略并将选项传递给它。
- en: To switch to a patch-based strategy, use `git rebase --apply`. In this case,
    you can pass some options to `git am` that does the actual replaying of changesets.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 若要切换到基于补丁的策略，请使用 `git rebase --apply`。在这种情况下，你可以传递一些选项给执行实际变更回放的 `git am`。
- en: These options will be described later when we discuss conflicts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项将在稍后讨论冲突时描述。
- en: There is also an interactive rebase with its own set of options. This is one
    of the main tools in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping History Clean*. It can be used to execute tests after each replayed commit
    to check that the replay is correct.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种交互式变基，它有一组自己的选项。这是[*第10章*](B21194_10_split_000.xhtml#_idTextAnchor247)《保持历史整洁》中的主要工具之一。它可以用于在每次重放提交后执行测试，检查重放是否正确。
- en: Advanced rebasing techniques
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级变基技巧
- en: You can also have your rebase operation replay on something other than the target
    branch of the rebase with `--``onto <newbase>`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以让你的变基操作在目标分支以外的分支上重放，方法是使用`--onto <newbase>`。
- en: Let’s assume that your `featureA` topic branch is based on the unstable development
    branch named `next`, as it is dependent on some feature that is not yet ready
    and not yet present in the stable branch (master). If the functionality on which
    `featureA` depends is deemed stable and merged into master, you would want to
    move this branch from being forked from `next` to being forked from `master`.
    Alternatively, perhaps you started the `server` branch from the related `client`
    branch, but you want to make it more obvious that they are independent.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的`featureA`主题分支基于不稳定的开发分支`next`，因为它依赖于一些尚未准备好并且尚未出现在稳定分支（master）中的功能。如果`featureA`依赖的功能被认为是稳定的，并且已经合并到
    master 中，你可能希望将此分支从基于`next`改为基于`master`。或者，也许你从相关的`client`分支开始了`server`分支，但你希望更明显地表示它们是独立的。
- en: You can do this with `git rebase --onto master next featureA` in the first case,
    and `git rebase --onto master server client` in the second one (which is shown
    in *Figure 9**.7*).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，你可以使用`git rebase --onto master next featureA`，而在第二种情况下（如*图 9.7*所示），你可以使用`git
    rebase --onto master server client`。
- en: '![Figure 9.7 – The rebasing branch, moving it from one branch to another](img/B21194_09_07.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 重新基准化分支，将其从一个分支移动到另一个分支](img/B21194_09_07.jpg)'
- en: Figure 9.7 – The rebasing branch, moving it from one branch to another
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 重新基准化分支，将其从一个分支移动到另一个分支
- en: Alternatively, perhaps you want to rebase only a part of the branch. You can
    do this with `git rebase --interactive`, but you can also use `git rebase --onto
    <new base> <starting point> <branch>`. You can even choose to rebase the whole
    branch (usually, an orphan branch) with the `--root` option. In this case, you
    would replay the whole branch and not just a selected subset of it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也许你只想变基分支的一部分。你可以使用`git rebase --interactive`来做到这一点，但你也可以使用`git rebase --onto
    <new base> <starting point> <branch>`。你甚至可以选择用`--root`选项变基整个分支（通常是孤立分支）。在这种情况下，你将重放整个分支，而不仅仅是其中的一个子集。
- en: You can also keep the base commit as is with `--keep-base`, instead of following
    the upstream. With the `--fork-point` option, you can make Git find a better common
    ancestor using reflog (to find where the branch was created) if it is possible.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`--keep-base`选项保持基础提交不变，而不是跟随上游。使用`--fork-point`选项时，如果可能，Git 会通过 reflog（找出分支的创建位置）找到更合适的共同祖先。
- en: Squash merge
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Squash 合并
- en: If the changes made on a branch are not worth preserving in detail and only
    their result is, you can use **squash merge** as a way to integrate them as a
    single commit. This can happen if the branch you want to integrate is full of
    temporary, work-in-progress commits.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个分支上的更改不值得详细保留，而只需要保留它们的结果，你可以使用**squash 合并**将它们作为一个单独的提交进行整合。如果你要整合的分支充满了临时的、工作中的提交，情况就会是这样。
- en: With `git merge --squash`, Git will produce the same result with respect to
    the working tree (and to the staging area) as if a real merge happened, but it
    will not perform the commit (the `--commit` option to `git merge` is incompatible
    with `--squash`). This is done in such a way that the next git commit will create
    an ordinary commit, not a merge commit. See *Figure 9**.8* for a comparison of
    the merge types.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`git merge --squash`时，Git 会在工作树和暂存区上产生与真正的合并相同的结果，但不会执行提交（`git merge`的`--commit`选项与`--squash`不兼容）。这种方式下，下一次
    git 提交将会创建一个普通提交，而不是合并提交。有关合并类型的对比，请参见*图 9.8*。
- en: '![Figure 9.8 – An ordinary merge versus a squash merge for the same set of
    branches](img/B21194_09_08.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 普通合并与 squash 合并对于相同分支集的对比](img/B21194_09_08.jpg)'
- en: Figure 9.8 – An ordinary merge versus a squash merge for the same set of branches
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 普通合并与 squash 合并对于相同分支集的对比
- en: By default, the commit message of a squashing commit begins with `git log master..i18n`.
    However, note that this technique should be used only if we intend to drop (delete)
    the “merged” branch. This is because Git might have trouble merging any further
    development on the squash-merged branch, as the graph of revisions does not indicate
    that the commit was the result of a merge.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，压缩提交的提交信息以 `git log master..i18n` 开头。但请注意，只有在我们打算丢弃（删除）“合并”分支时，这种技术才应使用。因为
    Git 可能在合并之后的开发过程中遇到麻烦，因为修订图并没有表明该提交是合并的结果。
- en: The alternative is to use the `squash` command of an interactive rebase.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用交互式变基的 `squash` 命令。
- en: Resolving merge conflicts
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决合并冲突
- en: Merging in Git is typically fairly easy. Since Git stores and has access to
    a full graph of revisions, it can automatically find where the branches diverged
    and merge only those divergent parts. This works even in the case of repeated
    merges, so you can keep a very long-lived branch up to date by repeatedly merging
    into it or rebasing it on top of new changes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Git 中的合并通常相对简单。由于 Git 存储并可以访问完整的修订图，它可以自动找到分支分歧的地方，并仅合并那些分歧的部分。这在重复合并的情况下也有效，因此你可以通过不断地将更改合并或将其变基到新的更改上，保持长期存在的分支与时俱进。
- en: However, it is not always possible to automatically combine changes. There are
    problems that Git cannot solve because, for example, there were different changes
    to the same area of a file on different branches. These problems are called **merge
    conflicts**. Similarly, there can be problems while reapplying changes, although
    you would still get merge conflicts in case of problems.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非总是可以自动合并更改。有些问题 Git 无法解决，例如在不同的分支上对文件的相同区域进行了不同的更改。这些问题被称为**合并冲突**。同样，在重新应用更改时，也可能会出现问题，尽管如果有问题，你仍然会遇到合并冲突。
- en: The three-way merge
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三方合并
- en: Unlike some other version control systems, Git does not try to be overly clever
    about merge conflict resolutions and try to solve them all automatically. Git’s
    philosophy is to be smart about determining the cases when a merge can be easily
    done automatically (for example, taking renames into account) and, if automatic
    resolution is not possible, to not be overly clever about trying to resolve it.
    It is better to bail out and ask users to resolve a merge, perhaps unnecessary
    with a smart algorithm, than to automatically create an incorrect one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些版本控制系统不同，Git 不会过于智能地处理合并冲突并尝试自动解决它们。Git 的哲学是智能地判断哪些情况下合并可以轻松自动完成（例如，考虑重命名），如果无法自动解决，则不会过于复杂地尝试解决。比起自动创建一个错误的合并，Git
    更倾向于中止并要求用户手动解决合并，这样可能不需要一个复杂的算法。
- en: 'Git uses the **three-way merge algorithm** to come up with the result of the
    merge, comparing the common ancestors (*base*), the side merged in (*theirs*),
    and the side merged into (*ours*). This algorithm is very simple, at least at
    the tree level – that is, the granularity level of files. The following table
    explains the rules of the algorithm:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Git 使用**三方合并算法**来得出合并结果，比较共同的祖先（*base*）、合并进来的版本（*theirs*）和合并的目标版本（*ours*）。这个算法非常简单，至少在树的层级上——也就是说，文件级别的粒度。下表解释了该算法的规则：
- en: '| **ancestor (base)** | **HEAD (ours)** | **branch (theirs)** | **result**
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **祖先（base）** | **HEAD（ours）** | **分支（theirs）** | **结果** |'
- en: '| A | A | A | A |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| A | A | A | A |'
- en: '| A | A | B | B |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| A | A | B | B |'
- en: '| A | B | A | B |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| A | B | A | B |'
- en: '| A | B | B | B |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| A | B | B | B |'
- en: '| A | B | C | merge |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| A | B | C | 合并 |'
- en: Table 9.1 – How a three-way merge algorithm works
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 – 三方合并算法的工作原理
- en: 'As shown in the preceding table, the rules for the trivial tree-level three-way
    merges are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如上表所示，树级三方合并的基本规则如下：
- en: If only one side changes a file, take the changed version
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只有一方更改了文件，采用更改后的版本。
- en: If both sides have the same changes, take the changed version
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两边有相同的更改，采用更改后的版本。
- en: If one side has a different change from the other, there is a merge conflict
    at the content level
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一方的更改与另一方不同，则在内容级别发生合并冲突。
- en: It is a bit more complicated if there is more than one ancestor, or if a file
    is not present in all the versions, but usually, it is enough to just know and
    understand these rules.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个祖先，或者文件并非所有版本都有，那么情况会复杂一些，但通常只需要知道并理解这些规则就足够了。
- en: If one side changes a file differently from the other (where the type of the
    change counts – for example, renaming a file on one branch doesn’t conflict with
    the changing contents of the file on the other branch), Git tries to merge the
    files at the content level, using the provided **merge driver** if it is defined,
    and the content-level three-way merge otherwise (for text files).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一方对文件的修改与另一方不同（其中更改的类型很重要——例如，在一个分支上重命名文件并不会与另一个分支上文件内容的更改发生冲突），Git 会在内容层面尝试合并文件，如果定义了**合并驱动程序**，则使用该驱动程序，否则使用内容级三方合并（对于文本文件）。
- en: The three-way file merge examines whether the changes touch different parts
    of a file (different lines are changed, and these changes are well separated by
    more than three lines (the context size) away from each other). If these changes
    are present in different parts of the file, Git resolves the merge automatically
    (and tells us which files are **auto-merged**).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 三方文件合并会检查更改是否涉及文件的不同部分（即更改的是不同的行，并且这些更改相隔超过三行（上下文大小））。如果这些更改位于文件的不同部分，Git 会自动解决合并（并告诉我们哪些文件已**自动合并**）。
- en: 'However, if you change the same part of the same file differently in the two
    branches that you’re merging together, Git won’t be able to merge them cleanly:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在合并的两个分支中分别修改了同一文件的同一部分，Git 将无法干净地合并它们：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This problem (a **merge conflict**) is then left for the user to resolve.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题（**合并冲突**）将由用户来解决。
- en: Examining failed merges
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查失败的合并
- en: If Git is unable to automatically resolve a merge (or if you have passed the
    `--no-commit` option to the `git merge` command), it will not create a merge commit.
    It will pause the process, waiting for you to resolve the conflict.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Git 无法自动解决合并（或者你在 `git merge` 命令中使用了 `--no-commit` 选项），它将不会创建合并提交。它会暂停流程，等待你解决冲突。
- en: You can then always abort the merging process with `git` `merge --abort`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时使用 `git merge --abort` 中止合并过程。
- en: Conflict markers in the working tree
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作树中的冲突标记
- en: 'If you want to see which files are still unmerged at any point after a merge
    conflict, you can run `git status`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看合并冲突后仍未合并的文件，可以运行 `git status`：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Anything that has not been resolved is listed as unmerged. In the case of content
    conflicts, Git uses standard conflict markers, putting them around the place of
    conflict, with the *ours* and *theirs* versions of the conflicted area in question.
    Your file will contain a section that will look somewhat like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 任何未解决的冲突将列为未合并。在内容冲突的情况下，Git 会使用标准的冲突标记，并将它们放置在冲突的位置，标出*ours*和*theirs*版本的冲突区域。你的文件中将包含如下所示的部分：
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This means that the *ours* version on the current branch (`HEAD`) in the `src/rand.c`
    file is there at the top of this block, between the `<<<<<<<` and `=======` markers,
    while the *theirs* version on the `i18n` branch being merged (also from `src/rand.c`)
    is there at the bottom, between the `>>>>>>>` markers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当前分支（`HEAD`）中的*ours*版本位于该块的顶部，位于 `<<<<<<<` 和 `=======` 标记之间，而在要合并的 `i18n`
    分支中的*theirs*版本（也是来自 `src/rand.c` 文件）位于底部，位于 `>>>>>>>` 标记之间。
- en: 'You need to replace this whole block by the resolution of the merge, either
    by choosing one side (and deleting the rest) or combining both changes, for example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要通过解决合并来替换整个块，可以选择其中一方（并删除其余部分）或者将两个更改结合起来，例如：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To help you avoid committing unresolved changes by mistake, Git by default checks
    whether committed changes include something that looks like conflict markers,
    refusing to create a merge commit if it finds them. You can force this check to
    be skipped with the `--``no-verify` option.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你避免错误地提交未解决的更改，Git 默认会检查已提交的更改中是否包含类似冲突标记的内容，如果找到，它会拒绝创建合并提交。你可以使用 `--no-verify`
    选项强制跳过此检查。
- en: 'If you need to examine a common ancestor version to resolve a conflict, you
    can switch to `diff3-` or `zdiff3-`like conflict markers, which have an additional
    block, separated by **|||||||**. This new block shows the common ancestor (*ours*)
    version:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要查看共同祖先版本来解决冲突，可以切换到类似 `diff3-` 或 `zdiff3-` 的冲突标记，这些标记有一个额外的块，用 **|||||||**
    分隔。这个新块显示了共同祖先（*ours*）版本：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can replace merge conflict markers individually on a file-per-file basis
    by rechecking the file again, using the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过重新检查文件，使用以下命令逐个文件地替换合并冲突标记：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you prefer to use this format all the time, you can set it as the default
    for future merge conflicts by setting `merge.conflictStyle` to `diff3` or `zdiff3`
    (from the default of `merge`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢始终使用这种格式，你可以通过将 `merge.conflictStyle` 设置为 `diff3` 或 `zdiff3`（而非默认的 `merge`）来将其设置为未来合并冲突的默认格式。
- en: Three stages in the index
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引中的三个阶段
- en: How does Git keep track of which files are merged and which are not? Conflict
    markers in the working directory files would not be enough. Sometimes, there are
    legitimate contents that look like commit markers (for example, a file that contains
    an example of a merge conflict or files in the AsciiDoc format), and there are
    more conflict types than **CONFLICT(content)**. How does Git, for example, represent
    the case where both sides renamed the file but in a different way, or where one
    side changed the file and the other side removed it?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Git 如何跟踪哪些文件已合并，哪些未合并？仅在工作区文件中使用冲突标记是不够的。有时，有些合法的内容看起来像是提交标记（例如，包含合并冲突示例的文件，或者是
    AsciiDoc 格式的文件），并且冲突类型比 **CONFLICT(content)** 更多。比如，当两个版本都重命名了同一个文件，但重命名方式不同，或者一方修改了文件而另一方删除了文件时，Git
    如何表示这种情况？
- en: It turns out that it is another use for the staging area of the commit (a merge
    commit in this case), which is also known as the index. In the case of conflicts,
    Git stores all of the conflicted file versions in the index under stages; each
    stage has a number associated with it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，这也是提交的暂存区（在此情况下是合并提交）另一个用途，也叫做索引。在冲突的情况下，Git 会在索引下的各个阶段存储所有冲突文件版本；每个阶段都有一个关联的编号。
- en: Stage 1 is the common ancestor (*base*)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阶段 1 是公共祖先（*基准*）
- en: Stage 2 is the merged-into version from **HEAD** – that is, the current branch
    (*ours*)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阶段 2 是来自 **HEAD** 的合并版本——即当前分支（*我们的*）
- en: Stage 3 is from **MERGE_HEAD**, the version you’re merging in (*theirs*)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阶段 3 来自 **MERGE_HEAD**，即你正在合并的版本（*他们的*）
- en: 'You can see these stages for the unmerged files with the low-level (plumbing)
    command, `git ls-files --unmerged` (or for all the files with `git` `ls-files
    --stage`):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过低级（底层）命令 `git ls-files --unmerged` 来查看未合并文件的这些阶段（或者使用 `git ls-files --stage`
    查看所有文件）：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can refer to each version with the `:<stage number>:<pathname>` specifier.
    For example, if you want to view a common ancestor version of `src/rand.c`, you
    can use the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `:<stage number>:<pathname>` 指定符来引用每个版本。例如，如果你想查看 `src/rand.c` 的公共祖先版本，可以使用以下命令：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If there is no conflict, the file is in stage 0 of the index.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有冲突，文件会处于索引的阶段 0。
- en: Examining differences – the combined diff format
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查差异——合并差异格式
- en: You can use the `status` command to find which files are unmerged, and conflict
    markers do a good job of showing conflicts. But how do we see only conflicts before
    we work on them, and how do we see how they were resolved? The answer is `git
    diff`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `status` 命令查找哪些文件尚未合并，冲突标记能很好地显示冲突。但在处理之前，如何只查看冲突？又该如何查看冲突是如何解决的？答案是 `git
    diff`。
- en: 'One thing to remember is that for merges, even merges in progress, Git will
    show the so-called **combined diff** format. It looks like the following (for
    a conflicted file during a merge):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要记住的是，对于合并，即使是在进行中的合并，Git 也会显示所谓的 **合并差异** 格式。它看起来如下（对于合并中的冲突文件）：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see a few differences from the ordinary unified diff format described
    in [*Chapter 2*](B21194_02.xhtml#_idTextAnchor028), *Developing with Git*. First,
    this uses `diff --cc` in the header to denote that it uses the compact combined
    format (it would use `diff --combined` instead if you used the `git diff -c` command).
    The extended header lines, such as `index 293c8fc,4b87d29..0000000`, take into
    account that there is more than one source version. The chunk header, `@@@ -14,16
    -14,13 +14,26 @@@`, is modified (and is different from the one for the ordinary
    patch) to prevent people from trying to apply a combined diff as a unified diff
    – for example, with the `patch -``p1` command.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到与普通统一差异格式（[*第 2 章*](B21194_02.xhtml#_idTextAnchor028)，“使用 Git 开发”）的几个不同之处。首先，它在头部使用
    `diff --cc` 来表示它使用紧凑的合并格式（如果使用 `git diff -c` 命令，它将使用 `diff --combined`）。扩展的头部行，例如
    `index 293c8fc,4b87d29..0000000`，考虑到有多个源版本。块头部 `@@@ -14,16 -14,13 +14,26 @@@`
    被修改（并且与普通补丁的不同），以防止人们将合并差异应用为统一差异——例如，使用 `patch -p1` 命令。
- en: Each line of the `diff` command is prefixed by two or more characters (two in
    the most common cases of merging two branches); the first character informs us
    about the state of the line in the first preimage (*ours*) as compared to the
    result, the second character informs us about the other preimage (*theirs*), and
    so on. For example, `++` means that the line was not present in either of the
    versions being merged (here, in this example, you can find it on the line with
    the conflict marker).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`diff`命令的每一行前面都有两个或更多字符（在最常见的合并两个分支的情况下是两个字符）；第一个字符告诉我们该行在第一个预成像中的状态（*我们的*版本）与结果的对比，第二个字符告诉我们另一个预成像的状态（*他们的*版本），以此类推。例如，`++`表示该行在任何一个合并版本中都不存在（在这个例子中，您可以在冲突标记所在的行上找到它）。'
- en: Examining differences is even more useful for checking the resolution of a merge
    conflict.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 检查差异对于检查合并冲突的解决情况非常有用。
- en: To compare the result (i.e., the current state of the working directory) with
    the version from the current branch (i.e., merged into) – that is, the *ours*
    version – you can use `git diff –ours`. This also applies to the version being
    merged (*theirs*) and the common ancestor version (*base*).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要将结果（即工作目录的当前状态）与当前分支的版本（即合并的版本）进行比较——即*我们的*版本——可以使用`git diff --ours`。这同样适用于正在合并的版本（*他们的*）和公共祖先版本（*基础*）。
- en: How did we get there – git log --merge
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们是如何到达这个结论的——`git log --merge`
- en: Sometimes, we need more context to decide which version to choose or to resolve
    a conflict. One such technique is reviewing a little bit of history, recalling
    why the two lines of development that are merged touched the same area of code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要更多的上下文来决定选择哪个版本或者如何解决冲突。一个有效的方法是回顾一些历史，回忆为什么这两个开发分支会修改同一区域的代码。
- en: 'To get the full list of divergent commits that were included in either branch,
    we can use the triple-dot syntax that you learned about in [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083),
    *Exploring Project History*, adding the `--left-right` option to make Git show
    which side the given commit belongs to:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取包含在任一分支中的所有分歧提交的完整列表，我们可以使用三点符号语法（在[*第4章*](B21194_04.xhtml#_idTextAnchor083)，*探索项目历史*中学过的内容），并添加`--left-right`选项，让Git显示给定提交属于哪一侧：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can further simplify this and limit the output to only those commits that
    touched at least one of the conflicted files, with a `--merge` option to `git
    log`, for example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步简化这一过程，并限制输出仅显示那些修改了至少一个冲突文件的提交，例如使用`--merge`选项与`git log`命令：
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This can be helpful in quickly giving you the context you need to understand
    why something conflicts and how to intelligently resolve it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于快速提供您理解冲突原因和如何智能解决冲突所需的上下文非常有帮助。
- en: Avoiding merge conflicts
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免合并冲突
- en: While Git prefers to fail to auto-merge clearly, rather than trying elaborate
    merge algorithms, there are a few tools and options that you can use to help Git
    avoid merge conflicts.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Git更倾向于明确地在自动合并失败时停止，而不是尝试复杂的合并算法，但仍然有一些工具和选项可以帮助Git避免合并冲突。
- en: Useful merge options
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有用的合并选项
- en: One of the problems while merging branches might be that they use different
    end-of-line normalization or clean/smudge filters (see [*Chapter 3*](B21194_03_split_000.xhtml#_idTextAnchor049),
    *Managing Your* *Worktrees*). This might happen when one branch added such a configuration
    (e.g., changing a git attributes file) and the other did not. In the case of end-of-line
    character configuration changes, you would get a lot of spurious changes, where
    lines differ only in the EOL (end-of-line) characters. In both cases, while resolving
    a three-way merge, you can make Git run a virtual checkout and check-in of all
    three stages of a file. This is done by passing the `renormalize` option to the
    `'ort'` merge strategy (`git merge -Xrenormalize`). This would, as the name suggests,
    normalize end-of-line characters, making them the same for all stages.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 合并分支时可能遇到的问题之一是它们使用了不同的行尾符号规范化或清理/模糊过滤器（参见[*第3章*](B21194_03_split_000.xhtml#_idTextAnchor049)，*管理工作树*）。当一个分支添加了这样的配置（例如，修改了一个git属性文件），而另一个没有时，可能会发生这种情况。在行尾字符配置发生变化的情况下，您会看到很多虚假的更改，其中行只在行尾字符（EOL）上有所不同。在这两种情况下，解决三方合并时，您可以让Git对文件的三个阶段执行虚拟的检出和检查操作。通过将`renormalize`选项传递给`'ort'`合并策略（`git
    merge -Xrenormalize`），就可以实现这一点。正如名称所示，这将规范化行尾字符，使它们在所有阶段中保持一致。
- en: Changing how end of line is defined can contribute to whitespace-related conflicts.
    It’s pretty easy to tell that this is the case when looking at the conflict, as
    every line is removed on one side and added again on the other, and `git diff
    --ignore-whitespace` shows a more manageable conflict (or even a conflict that
    is resolved). If you see that you have a lot of whitespace issues in a merge,
    you can abort and redo it, this time with `-Xignore-all-space`, `-Xignore-space-change`,
    `-Xignore-space-at-eol`, or `-Xignore-cr-at-eol`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 更改如何定义行尾可能会导致与空格相关的冲突。当查看冲突时很容易看出这种情况，因为一侧的每行都被删除，而另一侧则再次添加，`git diff --ignore-whitespace`显示了一个更易管理的冲突（或者甚至是已解决的冲突）。如果您发现合并中有大量空格问题，您可以中止并重新执行，这次使用`-Xignore-all-space`，`-Xignore-space-change`，`-Xignore-space-at-eol`或`-Xignore-cr-at-eol`。
- en: Note that whitespace changes mixed with other changes to a line are not ignored.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，混合其他更改的行的空白更改不会被忽略。
- en: Sometimes, mis-merges occur due to unimportant matching lines (for example,
    braces from distinct functions). You can make Git spend more time minimizing differences
    by selecting `patience`, a `histogram`, or a `minimal` diff algorithm with, `-Xdiff-algorithm=patience`,
    and so on.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，由于不重要的匹配行（例如，来自不同函数的大括号），会发生错误合并。您可以通过选择`patience`，`histogram`或`minimal`的diff算法，并使用`-Xdiff-algorithm=patience`等方法，使Git花费更多时间来最小化差异。
- en: If the problem is mis-detected renamed files, you can adjust the rename threshold
    with `-Xfind-renames=<n>`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题是误检测的重命名文件，您可以使用`-Xfind-renames=<n>`调整重命名阈值。
- en: Rerere – reuse recorded resolutions
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rerere – 重用记录的解决方案
- en: The **rerere** (**reuse recorded resolutions**) functionality is a bit of a
    hidden feature. As the name of the feature implies, it makes Git remember how
    each conflict was resolved chunk by chunk, so that the next time Git sees the
    same conflict, it will be able to resolve it automatically. However, note that
    Git will stop at resolving conflicts and does not automatically commit the said
    rerere-based resolution, even if it resolves it cleanly (if it is superficially
    correct).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**rerere**（**重用记录的解决方案**）功能有点隐藏。正如该功能的名称所暗示的那样，它使Git记住每个冲突是如何逐块解决的，因此下次Git遇到相同的冲突时，它将能够自动解决。但请注意，即使Git可以干净地解决冲突（如果表面上是正确的），Git也会停止解决冲突，并不会自动提交所述的rerere-based解决方案。'
- en: Such a functionality is useful in many scenarios. One example is a situation
    when you want a long-lived (i.e., long development) branch to merge cleanly at
    the end of its cycle, but you do not want to create intermediate merge commits.
    In this situation, you can do **trial merges** (merge, and then delete merge),
    saving information about how merge conflicts were resolved to the rerere cache.
    With this technique, the final merge should be easy, as most of it will be cleanly
    resolved from the resolutions recorded earlier.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的功能在许多场景中都很有用。一个例子是当您希望长期存在（即长期开发）的分支在周期结束时能够干净地合并，但不希望创建中间合并提交时。在这种情况下，您可以进行**试验合并**（合并，然后删除合并），将解决冲突的信息保存到rerere缓存中。借助这种技术，最终的合并应该很容易，因为大部分内容将从先前记录的解决方案中干净解决。
- en: Another situation in which you can make use of the rerere cache is when you
    merge a bunch of topic branches into a testable permanent branch. If the integration
    test for a branch fails, you want to be able to rewind the failed branch but don’t
    want to lose the work spent on resolving a merge.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是您可以利用rerere缓存的情况是将一堆主题分支合并到可测试的永久分支中。如果分支的集成测试失败，您希望能够回退失败的分支，但不希望丢失解决合并工作的时间。
- en: Alternatively, perhaps you have decided that you would rather use rebase than
    merge. The rerere mechanism allows us to translate the merge resolution into the
    rebase resolution.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也许您已经决定更喜欢使用rebase而不是merge。rerere机制允许我们将合并解决方案转换为rebase解决方案。
- en: To enable this functionality, simply set `rerere.enabled` to `true`, or create
    the `.git/` `rr-cache` file.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用此功能，只需将`rerere.enabled`设置为`true`，或创建`.git/rr-cache`文件。
- en: Dealing with merge conflicts
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理合并冲突
- en: Let’s assume that Git was not able to auto-merge cleanly and that there are
    merge conflicts that you need to resolve to be able to create a new merge commit.
    What are your options?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Git无法自动干净地合并，并且存在您需要解决才能创建新合并提交的合并冲突。您有哪些选择？
- en: Aborting a merge
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中止合并
- en: First, let’s cover how to get out of this situation. If you weren’t perhaps
    prepared for conflicts or you don’t know enough about how to resolve them, you
    can simply back out from the merge you started with `git` `merge --abort`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解如何摆脱这种情况。如果您可能没有准备好处理冲突，或者不太了解如何解决冲突，您可以通过`git merge --abort`简单地退出您开始的合并。
- en: This command tries to reset to the state before you started a merge. It might
    be not able to do this if you did not start from a clean state. Therefore, it
    is better to stash away changes, if there are any, before performing a merge operation
    (which you can do with `--autostash`, or the `merge.autoStash`/`rebase.autoStash`
    configuration options).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令尝试将状态重置为您开始合并之前的状态。如果您没有从一个干净的状态开始，它可能无法做到这一点。因此，最好在执行合并操作之前，将所有更改暂存起来（您可以使用`--autostash`，或`merge.autoStash`/`rebase.autoStash`配置选项来做到这一点）。
- en: Selecting the ours or theirs version
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择我们的版本或他们的版本
- en: Sometimes, it is enough to choose one version in the case of conflicts. If you
    want to resolve all the conflicts this way, forcing all the chunks to resolve
    in favor of *ours* or *theirs* version, you can use the `-Xours` or `-Xtheirs`
    merge strategy option, respectively. Note that `-Xours` (the `--strategy=ours`
    (the **merge strategy**); the latter creates a merge commit where the project
    state is the same as the *ours* version, instead of taking the *ours* version
    only for conflicted files.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在冲突的情况下，选择一个版本就足够了。如果您希望以这种方式解决所有冲突，强制所有部分解决为*我们的*版本或*他们的*版本，您可以分别使用`-Xours`或`-Xtheirs`合并策略选项。请注意，`-Xours`（`--strategy=ours`（**合并策略**）；后者创建一个合并提交，其中项目状态与*我们的*版本相同，而不是仅对冲突文件采用*我们的*版本。
- en: If you want to do this only for selected files, you can again check out the
    file with the *ours* or *theirs* version with `git checkout --ours` or `git checkout--theirs`,
    respectively. Note that during the rebase, the *ours* and *theirs* version may
    appear to be swapped.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想对选定的文件进行此操作，您可以再次通过`git checkout --ours`或`git checkout --theirs`分别检查出*我们的*版本或*他们的*版本。请注意，在变基过程中，*我们的*版本和*他们的*版本可能会互换。
- en: You can examine the *base*, *ours*, or *theirs* version with `git show :1:file`,
    `git show:2:file`, or `git show:3:file`, respectively, as described earlier.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`git show :1:file`，`git show :2:file`，或`git show :3:file`分别查看*基础*、*我们的*或*他们的*版本，正如之前所描述的那样。
- en: Scriptable fixes – manual file remerging
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可脚本化修复——手动文件重新合并
- en: There are types of changes that Git can’t handle automatically, but they are
    scriptable fixes. The merge can be done automatically, or at least is much easier,
    if we transform the *ours*, *theirs*, or *base* version first. Renormalization
    after changing how the file is checked out and stored in the repository (i.e.,
    eol and clean/smudge filters) and handling the whitespace change are built-in
    options. Another example, but without built-in support, is changing the encoding
    of a file or another scriptable set of changes, such as renaming variables.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有些类型的更改是Git无法自动处理的，但它们是可以通过脚本修复的。如果我们先转换*我们的*、*他们的*或*基础*版本，合并可以自动完成，或者至少会变得容易得多。更改文件在仓库中如何检查和存储的方式（即，eol和clean/smudge过滤器）以及处理空格更改是内建选项。另一个示例是改变文件的编码或其他可脚本化的更改，如重命名变量，但不带内建支持。
- en: 'To perform a scripted merge, you first need to extract a copy of each of these
    versions of the conflicted file, which can be done with the `git show` command
    and with `:<stage>:<file>`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行脚本化的合并，首先需要提取这些冲突文件的每个版本副本，可以通过`git show`命令和`:<stage>:<file>`来完成：
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that you have in the working area the contents of all three stages of the
    files, you can fix each version individually – for example, with `dos2unix` or
    `iconv`. You can then remerge the contents of the file with the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经将三个阶段的文件内容放入工作区，您可以单独修复每个版本——例如，使用`dos2unix`或`iconv`。然后，您可以使用以下命令重新合并文件内容：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using graphical merge tools
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用图形合并工具
- en: If you want to use a graphical tool to help you resolve merge conflicts, you
    can run `git mergetool`, which fires up a visual merge tool and guides the invoked
    tool through all the merge conflicts.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用图形工具帮助您解决合并冲突，您可以运行`git mergetool`，它将启动一个可视化的合并工具，并引导调用的工具解决所有合并冲突。
- en: It has a wide set of preconfigured support for various graphical merge helpers.
    You can configure which tool you want to use with `merge.tool`. If you don’t do
    this, Git will try all the possible tools in the sequence, which depends on the
    operating system and the desktop environment.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了广泛的预配置支持，适用于各种图形化合并助手。你可以通过 `merge.tool` 配置想要使用的工具。如果不这样做，Git 将按照操作系统和桌面环境的顺序尝试所有可能的工具。
- en: You can also configure a setup for your own tool.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以配置自己的工具设置。
- en: Marking files as resolved and finalizing merges
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记文件为已解决并完成合并
- en: As described earlier, if there is a merge conflict for a file, it will have
    three stages in the index. To mark a file as resolved, you need to put the contents
    of a file into stage 0\. This can be done by simply running `git add <file>` (running
    `git status` will give you this hint).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果文件发生合并冲突，索引中将有三个阶段。要将文件标记为已解决，需要将文件内容放入阶段 0。只需运行 `git add <file>` 即可完成此操作（运行
    `git status` 将给出此提示）。
- en: When all the conflicts are resolved, you need to simply run `git commit` to
    finalize the merge commit (or you can skip marking each file individually as resolved
    and just run `git commit -a`). The default commit message for merge summarizes
    what we merge, including a list of the conflicts, if any were present. You can
    make Git add a shortlog of the merged-in branches with the `--log` option for
    a single merge, or set it up permanently with the `merge.log` configuration variable.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有冲突都解决后，你只需运行 `git commit` 来完成合并提交（或者你可以跳过单独标记每个文件为已解决，直接运行 `git commit -a`）。合并的默认提交消息总结了我们所合并的内容，包括冲突列表（如果有的话）。你可以通过
    `--log` 选项为单次合并添加已合并分支的简短日志，或者通过 `merge.log` 配置变量永久设置此项。
- en: Resolving rebase conflicts
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决 rebase 冲突
- en: When there is a problem with applying a patch or a patch series, cherry-picking
    or reverting a commit, or rebasing a branch, Git will fall back to using the three-way
    merge algorithm. How to resolve such conflicts is described in the earlier sections.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用补丁或补丁系列、挑选提交或重基准化分支时出现问题时，Git 将退回使用三方合并算法。如何解决这些冲突，已在前面章节中描述。
- en: Important note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that when using merging strategies (the default), for technical reasons,
    *ours* is the so-far rebased series – that is, the branch being integrated – while
    *theirs* is the working branch (the branch rebased onto).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在使用合并策略（默认策略）时，由于技术原因，*ours*是到目前为止的重新基准化系列——也就是正在集成的分支——而*theirs*是工作分支（被重新基准化的分支）。
- en: However, for some of these methods, such as rebase, applying a mailbox (`git
    am`), or cherry-picking a series of commits, that are done stage by stage (a sequencer
    operation), there are other issues – namely, what to do if there is a conflict
    during such a stage.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于这些方法中的某些情况，如 rebase、应用邮箱（`git am`）或挑选一系列提交，这些操作是逐步完成的（一个序列操作），还有其他问题——即在这种阶段中发生冲突时该如何处理。
- en: 'You have three options:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你有三种选择：
- en: You can resolve the conflict and continue the operation with the **--continue**
    parameter (or, in the case of **git am**, also **--resolved**)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用**--continue**参数来解决冲突并继续操作（或者在**git am**的情况下，也可以使用**--resolved**）
- en: You can abort the whole operation and reset **HEAD** to the original branch
    with **--abort**
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用**--abort**中止整个操作，并将**HEAD**重置回原始分支。
- en: You can use **--skip** to drop a revision, perhaps because the commit is already
    present in the upstream and we can drop it during replaying
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用**--skip**来跳过某个修订，可能是因为该提交已经在上游存在，且在重放过程中可以跳过它
- en: git-imerge – an incremental merge and rebase for git
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git-imerge —— 一个增量合并和重基准化工具
- en: Both rebase and merge have their disadvantages. With merge, you need to resolve
    one big conflict (although using test merges and rerere to keep up-to-date proposed
    resolutions could help with this) in an all-or-nothing fashion. There is almost
    no way to save partially a done merge or to test it; `git stash` can help, but
    it might be an inadequate solution.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Rebase 和 merge 各有其缺点。使用 merge 时，你需要以“全有或全无”的方式解决一个大的冲突（尽管使用测试合并和 rerere 来保持最新的提议解决方案可能会有所帮助）。几乎没有办法部分保存已完成的合并，也无法对其进行测试；`git
    stash` 可以提供帮助，但它可能是一个不完全的解决方案。
- en: Rebase, conversely, is done in a step-by-step fashion, but it is not ideal for
    collaboration; you should not rebase published parts of the history of the project.
    You can interrupt a rebase, but it leaves you in a strange state (on an anonymous
    branch).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Rebase 是逐步完成的，但它并不适合协作；你不应该重基准化已发布的项目历史部分。你可以中断重基准化，但它会将你置于一个奇怪的状态（在一个匿名分支上）。
- en: That’s why the `git imerge` third-party tool was created. It presents conflicts
    pair-wise in small steps. It records all the intermediate merges in such a way
    that they can be shared, so one person can start merging and the other can finish
    it. The final resolution can be stored as an ordinary merge, an ordinary rebase,
    or a rebase with history.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么创建了`git imerge`这个第三方工具。它以小步骤逐对展示冲突。它记录所有中间的合并操作，使其可以共享，从而一个人可以开始合并，另一个人可以完成合并。最终的解决方案可以存储为普通合并、普通变基或带历史记录的变基。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has shown us how to effectively join two lines of development together,
    combining commits they gathered since their divergence.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何有效地将两条开发线路合并在一起，结合它们自分歧以来所收集的提交记录。
- en: First, we got to know various methods of combining changes – merge, cherry-pick,
    and rebase. This part focused on explaining how these functionalities work at
    higher levels – at the level of the DAG of revisions. You learned how merge and
    rebase work and what the difference is between them. Some of the more interesting
    uses of rebase, such as transplanting a topic branch from one long-lived branch
    to another, were also shown.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们了解了几种合并更改的方法——合并、挑选提交和变基。本部分重点解释了这些功能如何在更高层次上工作——即修订的有向无环图（DAG）层面。您了解了合并和变基如何工作，以及它们之间的区别。还展示了一些更有趣的变基用法，例如将一个主题分支从一个长期存在的分支移植到另一个分支。
- en: Then, you learned what to do if Git is not able to automatically combine changes
    – that is, what can be done in the presence of a merge conflict. The important
    part of this process is to understand how the three-way merge algorithm works,
    as well as how the index and the working area are affected if there are conflicts.
    You now know how to examine failed merges, examine proposed resolutions, avoid
    conflicts, and finally, resolve them and mark them as resolved.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您了解了如果 Git 无法自动合并更改时该怎么办——即在存在合并冲突的情况下可以采取什么措施。这个过程的关键是理解三方合并算法如何工作，以及在发生冲突时索引区和工作区的变化。您现在知道如何检查失败的合并，检查提议的解决方案，避免冲突，最后解决冲突并标记为已解决。
- en: 'The next chapter, *Keeping History Clean*, will explain why we might want to
    rewrite history to keep it clean (and what that means). One of the tools to rewrite
    history is an interactive rebase, a close cousin of an ordinary rebase operation
    described in this chapter. You will learn various methods to rewrite commits:
    how to reorder them, how to split them if they are too large, how to squash the
    fixing commit with the commit it corrects, and how to remove a file from history.
    You will discover what you can do if you cannot rewrite history (understanding
    why rewriting published history is bad) but you still need to correct it, with
    `git replace` and `git notes` commands. We will also discuss other applications
    of these mechanisms.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，*保持历史清晰*，将解释为什么我们可能希望重写历史以保持清晰（以及这意味着什么）。重写历史的工具之一是交互式变基，它与本章中描述的普通变基操作是亲密的伙伴。您将学习重写提交的各种方法：如何重新排序提交，如何拆分过大的提交，如何将修复提交与它修正的提交合并，如何从历史中移除文件。您将了解如果无法重写历史（理解为什么重写已发布的历史是不好的），但仍然需要进行修正时，可以使用`git
    replace`和`git notes`命令来实现。我们还将讨论这些机制的其他应用。
- en: Questions
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试您对本章的理解：
- en: What are the advantages and disadvantages of using merge to integrate changes?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用合并来整合更改有哪些优缺点？
- en: What are the advantages and disadvantages of using rebase to integrate changes?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用变基来整合更改有哪些优缺点？
- en: How do we avoid resolving similar conflicts again and again during a merge or
    rebase?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何避免在合并或变基过程中反复解决类似的冲突？
- en: How can we discover whether we are in the middle of merge or rebase, and remind
    ourselves on how to resolve conflict or abort an operation?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何发现自己是否处于合并或变基的过程中，并提醒自己如何解决冲突或中止操作？
- en: Answers
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to the questions given above:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对上述问题的答案：
- en: With merge, you do the integration in a single step (which can be an advantage
    or disadvantage), and you need to test only a single commit – the result of the
    merge. You can easily see where the branch began and where it ended. The first-parent
    view can serve as a summary of the integrated branches.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用合并时，您只需一步完成整合（这既是优点也可能是缺点），并且只需要测试一个提交——合并后的结果。您可以轻松看到分支从何处开始以及在哪里结束。首父视图可以作为集成分支的摘要。
- en: With rebase, you do the integration step by step (which can be a disadvantage
    or an advantage). Each of the rebased commits might need testing. The resulting
    history is much simpler, more linear, and easier to see. Using **bisection** to
    find regression bugs should be faster with linear history.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用变基（rebase）时，你是一步步地进行整合（这既可以是缺点，也可以是优点）。每个变基后的提交可能需要测试。最终的历史记录会更简洁、更线性、也更容易理解。使用**二分法**来查找回归错误，在线性历史记录下应该会更快。
- en: You can use the rerere mechanism, which automatically reapplies recorded conflict
    resolutions.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 rerere 机制，它会自动重新应用记录下来的冲突解决方案。
- en: Use the **git** **status** command.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**git** **status**命令。
- en: Further reading
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多本章所涉及的主题，请查看以下资源：
- en: 'Scott Chacon, Ben Straub: *Pro Git*, 2nd Edition (2014): [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2):'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Scott Chacon, Ben Straub: *Pro Git*，第2版（2014）：[https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2):'
- en: '*Chapter 3.6*, *Git Branching –* *Rebasing*'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3.6章*，*Git 分支 –* *变基*'
- en: '*Chapter 7.8*, *Git Tools –* *Advanced Merging*'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第7.8章*，*Git 工具 –* *高级合并*'
- en: '*Chapter 7.9*, *Git Tools –* *Rerere*'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第7.9章*，*Git 工具 –* *Rerere*'
- en: 'Julia Evans, *git rebase: what can go wrong?* (2023): [https://jvns.ca/blog/2023/11/06/rebasing-what-can-go-wrong-/](https://jvns.ca/blog/2023/11/06/rebasing-what-can-go-wrong-/)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia Evans，*git rebase：会出什么问题？*（2023）：[https://jvns.ca/blog/2023/11/06/rebasing-what-can-go-wrong-/](https://jvns.ca/blog/2023/11/06/rebasing-what-can-go-wrong-/)
- en: 'Julia Evans, *How git cherry-pick and revert use 3-way merge* (2023): [https://jvns.ca/blog/2023/11/10/how-cherry-pick-and-revert-work/](https://jvns.ca/blog/2023/11/10/how-cherry-pick-and-revert-work/)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia Evans，*git cherry-pick 和 revert 如何使用三方合并*（2023）：[https://jvns.ca/blog/2023/11/10/how-cherry-pick-and-revert-work/](https://jvns.ca/blog/2023/11/10/how-cherry-pick-and-revert-work/)
- en: 'Junio C Hamano, *Where do evil merges come from?* (2013): [https://git-blame.blogspot.com/2013/04/where-do-evil-merges-come-from.html](https://git-blame.blogspot.com/2013/04/where-do-evil-merges-come-from.html)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Junio C Hamano，*恶意合并是从哪里来的？*（2013）：[https://git-blame.blogspot.com/2013/04/where-do-evil-merges-come-from.html](https://git-blame.blogspot.com/2013/04/where-do-evil-merges-come-from.html)
- en: 'Nick Quaranto, *git ready – keep either file in merge conflicts* (2009): [https://gitready.com/advanced/2009/02/25/keep-either-file-in-merge-conflicts.html](https://gitready.com/advanced/2009/02/25/keep-either-file-in-merge-conflicts.html)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nick Quaranto，*git ready – 保留合并冲突中的任意文件*（2009）：[https://gitready.com/advanced/2009/02/25/keep-either-file-in-merge-conflicts.html](https://gitready.com/advanced/2009/02/25/keep-either-file-in-merge-conflicts.html)
- en: '*Learn to use email with* *git!*: [https://git-send-email.io/](https://git-send-email.io/)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学会使用电子邮件与* *git!*：[https://git-send-email.io/](https://git-send-email.io/)'
