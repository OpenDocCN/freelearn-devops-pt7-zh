- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Leveraging CI/CD in the Cloud
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云中利用 CI/CD
- en: We have discovered that **Infrastructure as Code** (**IaC**) has become an essential
    practice for modern development, enabling developers to manage infrastructure
    through code rather than manually configuring it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经发现 **基础设施即代码**（**IaC**）已成为现代开发的必备实践，使得开发者能够通过代码管理基础设施，而不需要手动配置它。
- en: However, deploying our infrastructure from a local machine, which we have been
    doing until now, is no longer sufficient for large-scale systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从本地机器部署我们的基础设施（直到现在我们一直在做的事情）对于大规模系统来说已经不再足够。
- en: This is where **Continuous Integration/Continuous Deployment** (**CI/CD**) comes
    into play; it automates the deployment process and provides consistent and reliable
    infrastructure deployment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这时 **持续集成/持续部署**（**CI/CD**）发挥作用，它自动化了部署过程，并提供一致且可靠的基础设施部署。
- en: This chapter will explore leveraging CI/CD in the cloud to deploy our IaC. We
    will focus on the popular CI/CD tool, **GitHub Actions**, which can run workflows
    triggered by different events, such as pull requests or code commits. We will
    explore how to use GitHub Actions to run Terraform and Ansible code in both public
    clouds we covered in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying
    to Microsoft Azure*, and [*Chapter 5*](B19537_05.xhtml#_idTextAnchor268), *Deploying
    to Amazon* *Web Services*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨如何利用云中的 CI/CD 部署我们的基础设施即代码（IaC）。我们将重点介绍流行的 CI/CD 工具 **GitHub Actions**，该工具可以运行由不同事件触发的工作流，如拉取请求或代码提交。我们将探讨如何使用
    GitHub Actions 在我们在 [*第 4 章*](B19537_04.xhtml#_idTextAnchor151)《部署到 Microsoft
    Azure》和 [*第 5 章*](B19537_05.xhtml#_idTextAnchor268)《部署到亚马逊 Web 服务》中涉及的公共云中运行 Terraform
    和 Ansible 代码。
- en: We will also cover essential security practices such as managing secrets in
    GitHub Actions and monitoring and maintaining the deployment once it runs. By
    the end of this chapter, you will understand how to leverage CI/CD in the cloud
    for your IaC projects using GitHub Actions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将覆盖一些关键的安全实践，如在 GitHub Actions 中管理机密信息以及在部署完成后如何监控和维护部署。通过本章学习后，您将了解如何在云中利用
    CI/CD 进行您的 IaC 项目部署。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将覆盖以下主题：
- en: Introducing GitHub Actions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 GitHub Actions
- en: Running Terraform using GitHub Actions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 运行 Terraform
- en: Running Ansible using GitHub Actions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 运行 Ansible
- en: Security best practices
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全最佳实践
- en: Before we roll our sleeves up and dive into the code, we should discuss the
    CI/CD tool we will use to deploy our infrastructure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们动手开始编写代码之前，我们应该先讨论一下我们将用来部署基础设施的 CI/CD 工具。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available here: [https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter07](https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter07)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在这里获取：[https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter07](https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter07)
- en: Introducing GitHub Actions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 GitHub Actions
- en: So, what is GitHub Actions? GitHub Actions is an automation platform that allows
    developers to create workflows to automate software development tasks, which in
    our case, means managing and deploying our IaC workloads.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是 GitHub Actions？GitHub Actions 是一个自动化平台，允许开发者创建工作流来自动化软件开发任务，在我们这种情况下，意味着管理和部署我们的基础设施即代码工作负载。
- en: The beta of GitHub Actions was first launched in mid-2019\. The initial release
    of GitHub Actions allowed a select number of developers to create and share actions
    that could be used to automate repetitive tasks in their development workflow.
    It was launched as a competitor to other popular automation platforms such as
    Jenkins, Travis CI, and CircleCI.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 的 beta 版本首次发布于 2019 年中期。GitHub Actions 的初始版本允许一小部分开发者创建和分享可以用于自动化开发流程中重复任务的操作。它作为
    Jenkins、Travis CI 和 CircleCI 等其他流行自动化平台的竞争者发布。
- en: 'GitHub Actions is based on several concepts, and the ones which will be covered
    in detail in this chapter are the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 基于几个概念，本章将详细介绍其中的以下几个：
- en: '**Workflows**: These are a series of tasks that are automated using GitHub
    Actions. Workflows are defined in YAML files that are stored in the repository.
    Workflows can be triggered by various events, such as pushing code to the repository,
    creating a pull request, or scheduling a job.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作流**：这些是使用 GitHub Actions 自动化的一系列任务。工作流在 YAML 文件中定义，这些文件存储在代码仓库中。工作流可以通过多种事件触发，例如向仓库推送代码、创建拉取请求或调度任务。'
- en: '**Jobs**: These are the individual units of work performed within a workflow.
    A workflow can have multiple jobs, each running on a different platform or environment.
    Jobs can be run in parallel or sequentially, depending on the workflow requirements.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业**：这些是工作流中执行的单独工作单元。一个工作流可以有多个作业，每个作业可以在不同的平台或环境上运行。作业可以并行运行，也可以按顺序运行，具体取决于工作流的要求。'
- en: '**Steps**: These are the individual tasks that make up a job. Each step can
    be a shell command, a script, or an action. Actions are pre-built units of work
    that can be used to automate everyday development tasks, such as building and
    testing code, deploying applications, and sending notifications.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**：这些是构成作业的单独任务。每个步骤可以是一个 shell 命令、脚本或操作。操作是预构建的工作单元，可用于自动化日常开发任务，如构建和测试代码、部署应用程序和发送通知。'
- en: '**Events**: The trigger workflows and GitHub Actions support many event types,
    including pushes to the repository, pull requests, scheduled events, and manual
    triggers.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：这些是触发工作流的事件类型，GitHub Actions 支持多种事件类型，包括推送到代码库、拉取请求、定时事件和手动触发事件。'
- en: GitHub Actions is a powerful automation platform that allows developers to automate
    many tasks in their development workflow. With its flexible and customizable workflows,
    support for various events, and pre-built actions, GitHub Actions has become an
    essential tool for many teams.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 是一个强大的自动化平台，允许开发人员在开发工作流中自动化许多任务。凭借其灵活和可定制的工作流、对各种事件的支持以及预构建的操作，GitHub
    Actions 已成为许多团队的必备工具。
- en: With its continued development and new features, GitHub Actions is set to establish
    itself as the leading CI/CD automation platform.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着其不断发展和新功能的推出，GitHub Actions 有望成为领先的 CI/CD 自动化平台。
- en: Rather than talking any more about GitHub Actions, let’s roll up our sleeves
    and look at how to run Terraform using it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与其继续谈论 GitHub Actions，不如我们动手实际操作，看看如何使用它运行 Terraform。
- en: Running Terraform using GitHub Actions
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 运行 Terraform
- en: In the last four chapters, we have talked about Terraform a lot – however, we
    are yet to address the elephant in the room – state files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的四章中，我们谈到了很多关于 Terraform 的内容——然而，我们还没有解决一个重要问题——状态文件。
- en: As we have been running Terraform locally, we haven’t really needed to talk
    about state files in too much detail yet, so let’s look at them now before we
    discuss how we can run Terraform using GitHub Actions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们一直在本地运行 Terraform，因此在此之前并没有深入讨论状态文件的问题，接下来我们将详细了解它们，再讨论如何使用 GitHub Actions
    运行 Terraform。
- en: Terraform state files
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform 状态文件
- en: Every time we run Terraform, a file called `terraform.tfstate` is either created,
    updated, or read. It is a JSON formatted file containing information about the
    resources created or modified by Terraform. It includes details such as the IDs,
    IP addresses, and other metadata associated with each resource we manage with
    Terraform.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行 Terraform 时，都会创建、更新或读取一个名为`terraform.tfstate`的文件。它是一个 JSON 格式的文件，包含 Terraform
    创建或修改的资源信息。它包括与每个资源相关的 ID、IP 地址和其他元数据等详细信息。
- en: Terraform uses this file to keep track of the current state of the infrastructure
    to determine what changes must be made when you modify your infrastructure code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 使用此文件跟踪基础设施的当前状态，以便在你修改基础设施代码时确定必须进行哪些更改。
- en: The state file is absolutely critical to the correct operation of Terraform.
    It ensures that Terraform can accurately determine what changes need to be made
    to the infrastructure when you run the `terraform` `apply` command.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 状态文件对于 Terraform 的正确操作至关重要。它确保 Terraform 在运行`terraform` `apply`命令时，能够准确地判断需要对基础设施进行哪些更改。
- en: Without a state file, Terraform would be unable to determine what changes to
    make to your infrastructure, which could result in errors or unexpected behaviors
    – for example, the termination and redeployment of a resource.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 没有状态文件，Terraform 将无法确定应该对你的基础设施做出哪些更改，这可能导致错误或意外行为——例如，终止和重新部署资源。
- en: It is also important to note that a Terraform state file should be treated as
    sensitive information; it contains details about your infrastructure resources
    and also potentially sensitive information, such as passwords if you have used
    Terraform to generate them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同时需要注意的是，Terraform 状态文件应被视为敏感信息；它包含有关你的基础设施资源的详细信息，也可能包含敏感信息，例如如果你使用 Terraform
    生成了密码，它们也会包含在内。
- en: This means we must ensure that the state file is securely stored and only accessible
    to authorized users.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们必须确保状态文件被安全存储，并且只能授权用户访问。
- en: So why are we only talking about this now?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么我们现在才讨论这个呢？
- en: Well, services such as GitHub Actions are designed to provide compute resources
    for a short amount of time to execute a workflow, making them ephemeral, which
    means that there is no fixed underlying storage, so once the workflow has been
    completed, the compute resource is terminated, and everything is lost.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，像 GitHub Actions 这样的服务旨在提供短时间的计算资源以执行工作流，因此它们是临时的，这意味着没有固定的底层存储，所以一旦工作流完成，计算资源就会被终止，所有内容都会丢失。
- en: To support this, Terraform allows you to use backends to store your state files;
    as you may have already guessed, the default storage option is local storage,
    which will store the file in the same folder as the Terraform code you are executing.
    You can also use external blob storage such as Amazon `s3`) or Azure storage accounts
    (`azurerm`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一点，Terraform 允许您使用后端来存储状态文件；正如您可能已经猜到的，默认的存储选项是本地存储，它会将文件存储在与您正在执行的 Terraform
    代码相同的文件夹中。您还可以使用外部 Blob 存储，如 Amazon `s3` 或 Azure 存储账户（`azurerm`）。
- en: 'The following example shows how you would use an Azure storage account called
    `satfbeiac1234` in a resource group called `rg-terraform-state-uks`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在名为 `rg-terraform-state-uks` 的资源组中使用名为 `satfbeiac1234` 的 Azure 存储账户：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `container_name` parameter, in the case of an Azure storage account, is
    the blob container, which, if you were thinking of the Azure storage account as
    a filesystem, then this would be the folder name, and `key` is the name of the
    file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 存储账户的情况下，`container_name` 参数是 Blob 容器，如果你把 Azure 存储账户当作文件系统来看，那么它就是文件夹名称，而
    `key` 则是文件的名称。
- en: 'The configuration for Amazon S3 is not too dissimilar, as you can see from
    the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon S3 的配置并不复杂，您可以从以下示例中看到：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we are letting Terraform know the bucket name, the path to our file, and
    the region in which the Amazon S3 bucket is hosted.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 Terraform 存储桶名称、文件路径以及托管 Amazon S3 存储桶的区域。
- en: One thing that needs to be added to the preceding code is how the Azure storage
    account or Amazon S3 bucket is created in the first place and how Terraform authenticates
    against the cloud provider to be able to read and write to the backend.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加到前面的代码中的一件事是如何首先创建 Azure 存储账户或 Amazon S3 存储桶，以及 Terraform 如何与云服务提供商进行身份验证，以便能够读取和写入后端。
- en: Rather than discuss here, let’s dive into an example GitHub action and find
    out.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与其在这里讨论，不如深入到一个示例 GitHub Action 中看看。
- en: GitHub Actions
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub Actions
- en: I am going to concentrate on Microsoft Azure in this chapter. So, as we are
    not using our locally installed copy of the Azure **command-line interface** (**CLI**),
    we need to generate some credentials to use and grant access to our Azure subscription.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将专注于 Microsoft Azure。因此，由于我们没有使用本地安装的 Azure **命令行界面**（**CLI**），我们需要生成一些凭证，以便使用并授权访问我们的
    Azure 订阅。
- en: Info
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Please note that the **Universally Unique Identifiers** (**UUIDs**) in the following
    list are just examples; please ensure you replace them with your own where prompted.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下列表中的**通用唯一标识符**（**UUIDs**）仅为示例；请确保在提示时用您自己的 UUID 替换它们。
- en: 'To do this, we are going to create a service principal using the following
    command. When you run it, make sure you replace the subscription ID with your
    own subscription ID, which you can find in the Azure portal under **Subscriptions**:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用以下命令创建一个服务主体。运行时，请确保用您自己的订阅 ID 替换命令中的订阅 ID，您可以在 Azure 门户的 **订阅** 部分找到该
    ID：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will give something similar to the following output, which starts with
    an important message:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成类似以下的输出，其中以一条重要消息开头：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As per the preceding message, ensure that you make a note of the output in
    a safe place, as it will be the only time you will be able to get the password
    that is generated:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的消息，确保将输出结果记录在安全的地方，因为这是唯一一次可以获得生成的密码的机会：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have the details and have granted the newly created `Contributor`
    service principal access to our Azure subscription, we can move on to GitHub.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了详细信息，并已将新创建的 `Contributor` 服务主体授予对 Azure 订阅的访问权限，我们可以继续进行 GitHub 设置。
- en: We first need to enter some secrets and variables in the GitHub repository to
    configure the GitHub action.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要在 GitHub 仓库中输入一些密钥和变量，以配置 GitHub action。
- en: I have started with an empty GitHub repository called `Terraform-github-actions-example`;
    if you are following along, I recommend creating a test repo and copying the code
    from the repository accompanying this title across to your repo.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我从一个名为 `Terraform-github-actions-example` 的空 GitHub 仓库开始；如果你在跟随这个教程，我建议你创建一个测试仓库，并将附带本教程的仓库代码复制到你的仓库中。
- en: As mentioned, the first thing we need to do is add the secrets and variables.
    To do this, go to your repo and click on **Settings**. Once the **Settings** page
    is open, you should see **Secrets and variables** in the left-hand side menu;
    when you click on it, it will expand a submenu with **Actions**, **Codespaces**,
    and **Dependabot** listed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，首先我们需要做的是添加密钥和变量。为此，请转到你的仓库并点击**设置**。当**设置**页面打开后，你应该能在左侧菜单中看到**密钥和变量**；点击它后，它会展开一个子菜单，其中列出了**Actions**、**Codespaces**和**Dependabot**选项。
- en: 'As you might have guessed, you need to click on **Actions**. This should present
    you with something that looks like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，你需要点击**Actions**。这应该会呈现出类似如下的内容：
- en: '![Figure 7.1 – The Actions option on the Secrets and variables settings page](img/Figure_7.01_B19537.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 密钥和变量设置页面中的 Actions 选项](img/Figure_7.01_B19537.jpg)'
- en: Figure 7.1 – The Actions option on the Secrets and variables settings page
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 密钥和变量设置页面中的 Actions 选项
- en: 'If you click on the **New repository secret** button and enter the secrets
    detailed in the following table, make sure that you enter the name exactly like
    it is written in the table, as the GitHub action workflow code will reference
    the name when it is executed:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**新建仓库密钥**按钮并输入下表中详细列出的密钥，请确保你输入的名称与表中所写完全一致，因为 GitHub 的动作工作流代码在执行时会引用这些名称：
- en: '| **Name** | **Secret Content** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **密钥内容** |'
- en: '| `ARM_CLIENT_ID` | This is the `appId` value from the output of the command
    that added the service principal. From the example output, this would be `019f16d2-552b-43ff-8eb8-6c87b13d47f9`.
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `ARM_CLIENT_ID` | 这是我们运行添加服务主体命令时输出的 `appId` 值。根据示例输出，它将是 `019f16d2-552b-43ff-8eb8-6c87b13d47f9`。
    |'
- en: '| `ARM_CLIENT_SECRET` | This is the *password* from the output of when we ran
    the command that added the service principal. From the example output, this would
    be `6t3Rq~vT.cL9y7zN_apCvGANvAg7_v6wiBb1eboQ`. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `ARM_CLIENT_SECRET` | 这是我们运行添加服务主体命令时输出的*密码*。从示例输出来看，它将是 `6t3Rq~vT.cL9y7zN_apCvGANvAg7_v6wiBb1eboQ`。
    |'
- en: '| `ARM _SUBSCRIPTION_ID` | This is the *subscription ID* you used as the scope
    to add the service principal. From the example output, this would be `3a52ef17-7e42-4f89-9a43-9a23c517cf1a`.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `ARM_SUBSCRIPTION_ID` | 这是你用作作用域来添加服务主体的*订阅 ID*。从示例输出来看，它将是 `3a52ef17-7e42-4f89-9a43-9a23c517cf1a`。
    |'
- en: '| `ARM_TENANT_ID` | This is the *tenant* from the output of when we ran the
    command that added the service principal. From the example output, this would
    be `8a7e32c4-5732-4e57-8d8c-dfca4b1e4d4a`. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `ARM_TENANT_ID` | 这是我们运行添加服务主体命令时输出的*租户*。从示例输出来看，它将是 `8a7e32c4-5732-4e57-8d8c-dfca4b1e4d4a`。
    |'
- en: 'Once you have entered the four secrets detailed in the preceding table, you
    will use the credentials to authenticate against your Azure account and make changes.
    We can now enter the variables; these detail the storage account and don’t need
    to be stored as secrets:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入了前面表格中详细列出的四个密钥，你将使用这些凭证来验证你的 Azure 账户并进行更改。现在我们可以输入变量；这些变量详细描述了存储账户，并且不需要作为密钥存储：
- en: '| **Name** | **Value Content** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **值内容** |'
- en: '| `BACKEND_AZURE_RESOURCE_GROUP_NAME` | This is the name of the resource group
    that will be created to host the storage account we will use for the Terraform
    state file, for example; `rg-terraform-state-uks`. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `BACKEND_AZURE_RESOURCE_GROUP_NAME` | 这是将创建的资源组的名称，用于托管我们将用于 Terraform 状态文件的存储账户，例如：`rg-terraform-state-uks`。
    |'
- en: '| `BACKEND_AZURE_LOCATION` | The region the resources are going to be launched
    in. For example, `uksouth`. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `BACKEND_AZURE_LOCATION` | 资源将要启动的区域。例如，`uksouth`。 |'
- en: '| `BACKEND_AZURE_STORAGE_ACCOUNT` | The name of the storage account you create
    must be unique across all of Azure; otherwise, you will get an error. For example,
    `satfstate180323`. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `BACKEND_AZURE_STORAGE_ACCOUNT` | 你创建的存储账户名称必须在所有 Azure 中是唯一的；否则你将得到一个错误。例如，`satfstate180323`。
    |'
- en: '| `BACKEND_AZURE_CONTAINER_NAME` | The name of the container where the file
    will be stored, for example, `tfstate`. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `BACKEND_AZURE_CONTAINER_NAME` | 文件将存储的容器名称，例如 `tfstate`。 |'
- en: '| `BACKEND_AZURE_STATE_FILE_NAME` | The name of Terraform state file itself,
    for example, `ghact.tfstate`. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `BACKEND_AZURE_STATE_FILE_NAME` | Terraform 状态文件本身的名称，例如 `ghact.tfstate`。
    |'
- en: So now that we have everything that we need secret- and variable-wise in the
    GitHub repository, we can look at the workflow itself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们已经在 GitHub 仓库中准备好了所有需要的机密和变量，我们可以查看工作流本身。
- en: GitHub action workflows are **YAML Ain’t Markup Language** or **Yet Another
    Markup Language** (**YAML**) files (depending on the explanation you read).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Action 工作流是 **YAML Ain’t Markup Language** 或 **Yet Another Markup Language**（**YAML**）文件（具体取决于你读到的解释）。
- en: Information
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: YAML is a human-readable data serialization format that uses indentation to
    convey structure, popular for configuration files, data exchange, and applications
    requiring simple data representation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 是一种易于人类阅读的数据序列化格式，使用缩进来表达结构，广泛应用于配置文件、数据交换以及需要简单数据表示的应用程序。
- en: 'First, we have some basic configuration; here, we use `name` to name the workflow
    and define `on` to specify on what action the workflow should trigger:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一些基本配置；在这里，我们使用 `name` 来命名工作流，并定义 `on` 来指定工作流应该在什么操作下触发：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the workflow will be triggered as defined in the `on` section
    of the YAML file, on a `push` or `pull_request` to the `main` branch. Now that
    we have defined when the workflow will be triggered, we can now define the three
    jobs that go to make up the workflow, starting with the job that checks the presence
    of the storage account we are going to use for the backend Terraform state file
    – and it if it is not there, create one.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，工作流将根据 YAML 文件中的 `on` 部分定义，在对 `main` 分支执行 `push` 或 `pull_request` 时触发。现在我们已经定义了工作流的触发时机，接下来我们可以定义构成工作流的三个任务，从检查我们将用于后端
    Terraform 状态文件的存储帐户是否存在开始——如果不存在，则创建一个。
- en: Please note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意
- en: Indentation is really important when it comes to the structure of the YAML file;
    however, while working through the structure across the following pages, I will
    be removing some of the indentations to make it more readable – please refer to
    the code in the GitHub repository that accompanies this title for the correct
    format and indentation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进在 YAML 文件的结构中非常重要；然而，在接下来的页面中，我们会去除一些缩进，以提高可读性——请参考附带本书的 GitHub 仓库中的代码，以查看正确的格式和缩进。
- en: 'First, we define the jobs and some basic configurations:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义任务和一些基本配置：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we are giving the job an internal reference, `check_storage_account`, and
    telling it to run on the latest version of Ubuntu and use `bash` as the default
    shell.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为任务提供了一个内部引用 `check_storage_account`，并告诉它在最新版本的 Ubuntu 上运行，并使用 `bash`
    作为默认的 shell。
- en: 'The `check_storage_account` job is made up of two steps, step one being as
    follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_storage_account` 任务由两个步骤组成，第一步如下：'
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we are using the `Azure/login@v1` task to log in to our Azure account using
    the secrets we defined in GitHub. These are referred to by using `${{ secrets.ARM_CLIENT_ID
    }}`. The next step uses the variables we added to GitHub and the `Azure/CLI@v1`
    task to check for the presence of the storage account.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `Azure/login@v1` 任务通过 GitHub 中定义的机密登录到 Azure 帐户。这些机密通过 `${{ secrets.ARM_CLIENT_ID
    }}` 引用。下一步使用我们在 GitHub 中添加的变量以及 `Azure/CLI@v1` 任务来检查存储帐户是否存在。
- en: 'If it is not there, it will be created, and the resources already exist, then
    the task will progress to the next step:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不存在，将会被创建；如果资源已存在，则任务将继续执行到下一步：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As this step is running on the same Ubuntu instance as the first step, which
    logged into Azure, we don’t need to authenticate again – instead, we can just
    run the Azure CLI commands we need:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此步骤在与第一步相同的 Ubuntu 实例上运行，并且该实例已经登录到 Azure，我们无需再次进行身份验证——相反，我们只需运行所需的 Azure
    CLI 命令：
- en: Create or check for the presence of the resource group to host our storage account
    using `az` `group create`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `az` `group create` 创建或检查存储帐户所在的资源组是否存在。
- en: Create or check for the presence of the storage account using `az storage` `account
    create`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `az storage` `account create` 创建或检查存储帐户是否存在。
- en: Create or check for the presence of the container in the storage account using
    `az storage` `container create`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `az storage` `container create` 创建或检查存储帐户中的容器是否存在。
- en: Now that we know we have the storage account in place for the Terraform backend
    state file storage, we can proceed with the next job, which runs the `terraform_plan`
    command and stores the output with the workflow run.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道已经为 Terraform 后端状态文件存储设置好了存储账户，我们可以继续执行下一个任务，运行 `terraform_plan` 命令并将输出存储在工作流运行中。
- en: 'As per the last job, we need to set up some basic configurations, such as the
    job name and reference, what operating system to use, and also some additional
    bits:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 跟上一个任务一样，我们需要设置一些基本配置，例如任务名称和引用、使用的操作系统以及其他一些附加项：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we are setting some environment variables containing the credentials
    needed to log in to Azure; why are we doing that again when we already authenticated
    during the last job?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们设置了一些包含用于登录 Azure 凭据的环境变量；既然我们在上一个任务中已经完成了认证，为什么还要再做一次？
- en: The reason is that once the last task in the last job finished, the compute
    resource running the job was terminated, and when this job started, a new resource
    was spun up, meaning that everything from the last job was lost.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是，一旦上一个任务结束，运行该任务的计算资源就被终止了，而当此任务开始时，又启动了一个新的资源，这意味着上一个任务的所有数据都丢失了。
- en: 'Now that we have defined the basics for the `terraform_plan` job, we can work
    through the steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了 `terraform_plan` 任务的基本内容，我们可以逐步完成操作：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This simple step checks out the repository from which we are running the action;
    the repository contains the Terraform we will execute during the workflow.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的步骤检查出我们正在运行动作的仓库；该仓库包含了我们将在工作流中执行的 Terraform。
- en: 'Now we have the code we need to install Terraform. To do this, we use the `hashicorp/setup-terraform@v2`
    task:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有了安装 Terraform 所需的代码。为此，我们使用 `hashicorp/setup-terraform@v2` 任务：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So far, so good; as per when we were running Terraform on our local machine,
    we now need to run the `terraform` `init` command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利；就像我们在本地机器上运行 Terraform 一样，现在我们需要运行 `terraform` `init` 命令：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we have appended quite a bit to the end of the `terraform init`
    command – this sets up our backend using the variables we defined in GitHub for
    the duration of the job, meaning Terraform will use the remote backend and not
    the local one.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在 `terraform init` 命令的末尾添加了不少内容——这会根据我们在 GitHub 中定义的变量设置后端，意味着 Terraform
    将使用远程后端，而非本地后端。
- en: 'Next up, we need to run the `terraform plan` command to figure out what needs
    to happen during the workflow execution:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行 `terraform plan` 命令，以确定在工作流执行过程中需要发生的操作：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will have noticed that we are wrapping a little logic around the command
    to figure out the exit code. We need to do this because we need to know whether
    we should stop the execution of the workflow if there is an error, which is what
    the final piece of the code in the step does:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们在命令周围加入了一些逻辑，用来判断退出代码。我们需要这样做，因为我们需要知道是否在出现错误时停止工作流的执行，这也是步骤中代码最后一部分的作用：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So now we know whether there are any obvious errors or everything is OK, and
    we have a copy of the Terraform plan file; what’s next?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道是否存在明显的错误，或者一切正常，并且我们已经拥有了 Terraform 计划文件的副本；接下来是什么？
- en: 'As we have already mentioned, when we run the next job, we will be starting
    from scratch, and as we need a copy of the Terraform plan file, we should copy
    it from the compute resource:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，当我们运行下一个任务时，我们将从头开始，并且由于需要一个 Terraform 计划文件的副本，因此我们应当从计算资源中复制它：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are using the `actions/upload-artifact@v3` task to copy the file called `tfplan`
    to the workflow execution as an artifact; in subsequent tasks and jobs, we can
    download the file and use it without committing to the code repo itself.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `actions/upload-artifact@v3` 任务将名为 `tfplan` 的文件复制到工作流执行中作为工件；在后续的任务和工作中，我们可以下载该文件并使用它，而无需将其提交到代码库中。
- en: 'The next task, at first glance, may seem a little redundant:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一任务乍一看可能显得有些多余：
- en: '[PRE16]terraform'' >> $GITHUB_OUTPUT'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]terraform'' >> $GITHUB_OUTPUT'
- en: echo "$TERRAFORM_PLAN" >> $GITHUB_OUTPUT
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: echo "$TERRAFORM_PLAN" >> $GITHUB_OUTPUT
- en: echo '[PRE17]
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: echo '[PRE17]
- en: The task appears to be doing something with the Terraform plan file, but what?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务似乎在处理 Terraform 计划文件，那么它究竟在做什么呢？
- en: One of the advantages of using a system such as GitHub actions is that you can
    publish artifacts and also publish other outputs – in this case, we are taking
    the list of changes logged within the plan file and formatting it for use as a
    workflow summary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 等系统的优势之一是你可以发布工件以及其他输出——在这种情况下，我们从计划文件中提取了变更列表，并将其格式化为工作流摘要。
- en: 'The next and final task within this job is to take the summary we have just
    generated and publish it back to GitHub:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务中的下一个也是最后一个任务是将我们刚刚生成的摘要发布回 GitHub：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, all we have left is to run the `terraform apply` command – this is the
    last job of our workflow, and it shares many of the steps with the previous job.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们剩下的就是运行`terraform apply`命令——这是我们工作流的最后一个任务，它与前一个任务共享许多步骤。
- en: 'However, there are some changes to the configuration that we should highlight:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要强调一些配置更改：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we have added the `if` and `needs` statements. The `if` statement
    verifies that we are 100% working with the correct branch, and the `needs` statement
    ensures that the `terraform_plan` job has been successfully executed, meaning
    that we will have the Terraform plan file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经添加了`if`和`needs`语句。`if`语句验证我们是否 100% 使用正确的分支，而`needs`语句确保`terraform_plan`任务已成功执行，这意味着我们将会有
    Terraform 计划文件。
- en: 'The first three steps are ones that we have already covered, them being the
    following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前三步是我们已经涵盖过的，具体如下：
- en: Check out the code
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看代码
- en: Set up Terraform
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Terraform
- en: '`terraform init`'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`terraform init`'
- en: 'Next, we need to download the Terraform plan file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要下载 Terraform 计划文件：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the plan file downloaded, we can now perform the final task of the workflow,
    which is to run the `terraform apply` command and deploy the changes, if any,
    detailed within the plan file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下载计划文件后，我们现在可以执行工作流的最后一个任务，即运行`terraform apply`命令并部署计划文件中详细的更改（如果有的话）。
- en: 'Given the number of tasks it has taken for us to get to this point, the final
    task is quite simple:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们已经完成的任务数量，最后的任务非常简单：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we run `terraform apply` with the `-auto-approve` flag; if we
    don’t, then Terraform will quite happily sit there for an hour waiting for someone
    to type `Yes`, which will never happen as this is not an interactive terminal.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们以`-auto-approve`标志运行`terraform apply`；如果不这样做，Terraform 会愉快地在那里等待一个小时，等待有人输入`Yes`，但这永远不会发生，因为这不是交互式终端。
- en: We are then telling it to load in the file called `tfplan`, which means that
    we do not need to run the `terraform plan` command for a second time as we already
    know what will change/be applied during the execution.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们告诉它加载名为`tfplan`的文件，这意味着我们无需再次运行`terraform plan`命令，因为我们已经知道在执行过程中会有哪些变化/应用。
- en: So, what changes to our Terraform code are needed for this to work?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为了使其工作，我们的 Terraform 代码需要进行哪些更改？
- en: 'Just the one we need to tweak our code to use the `azurerm` backend; this makes
    the top of our `main.tf` file look like the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就是我们需要调整代码以使用`azurerm`后端；这使得我们`main.tf`文件的顶部如下所示：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The rest of the code remains as is. We then need to take a workflow YAML file
    and place it in a folder called `.github/workflows` at the top level of our repository.
    I have named the file `action.yml`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 其余代码保持不变。然后我们需要创建一个工作流 YAML 文件，并将其放置在仓库顶级的`.github/workflows`文件夹中。我将文件命名为`action.yml`。
- en: Please note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意
- en: In the repo accompanying this title, the folder name purposely has the “`.`”
    removed, so the GitHub action is not registered. When you copy to your repo, please
    ensure you rename the `github` folder to `.github`; otherwise, the action won’t
    be registered, and the workflow will not run.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在随本书附带的仓库中，文件夹名称故意移除了“`.`”，因此 GitHub Action 无法注册。当你将其复制到自己的仓库时，请确保将`github`文件夹重命名为`.github`；否则，Action
    将无法注册，工作流将无法运行。
- en: 'So let’s run it the first time you check in the `action.yml` file. It will
    create the action and run – this can be confirmed by the dot next to the commit
    ID, which in the following example screen is referenced as **b4900e8**:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一次检查`action.yml`文件时让我们运行它。它将创建该 Action 并运行——可以通过提交 ID 旁边的点来确认这一点，在以下示例屏幕中，这个点被标记为**b4900e8**：
- en: '![Figure 7.2 – Checking in and running the workflow](img/Figure_7.02_B19537.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 检查并运行工作流](img/Figure_7.02_B19537.jpg)'
- en: Figure 7.2 – Checking in and running the workflow
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 检查并运行工作流
- en: 'If everything has run as expected, clicking the **Actions** tab at the top
    of the repo page should show you something like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期运行，点击仓库页面顶部的**Actions**标签应该会显示类似以下内容：
- en: '![Figure 7.3 – Viewing the workflow runs](img/Figure_7.03_B19537.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 查看工作流运行情况](img/Figure_7.03_B19537.jpg)'
- en: Figure 7.3 – Viewing the workflow runs
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 查看工作流运行情况
- en: 'Clicking on the workflow run will take you to the execution **Summary** page;
    for me, this looked like the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 点击工作流运行将带你到执行**概览**页面；对我来说，页面看起来如下所示：
- en: '![Figure 7.4 – Reviewing the workflow execution](img/Figure_7.04_B19537.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 查看工作流执行情况](img/Figure_7.04_B19537.jpg)'
- en: Figure 7.4 – Reviewing the workflow execution
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 查看工作流执行情况
- en: 'As you can see, we have the three jobs listed and the artifacts and the custom
    summary we published from the `terraform` `plan` command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们列出了三个作业，以及从`terraform` `plan`命令发布的工件和自定义概览：
- en: '![Figure 7.5 – Viewing the output of Terraform Plan](img/Figure_7.05_B19537.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 查看 Terraform Plan 的输出](img/Figure_7.05_B19537.jpg)'
- en: Figure 7.5 – Viewing the output of Terraform Plan
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 查看 Terraform Plan 的输出
- en: 'Also, if you click on any of the job names, it will show the output of each
    of the tasks:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你点击任何一个作业名称，它会显示每个任务的输出：
- en: '![Figure 7.6 – Viewing the output of Terraform Plan](img/Figure_7.06_B19537.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 查看 Terraform Plan 的输出](img/Figure_7.06_B19537.jpg)'
- en: Figure 7.6 – Viewing the output of Terraform Plan
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 查看 Terraform Plan 的输出
- en: I recommend clicking around and reviewing precisely what the GitHub action workflow
    executed, as it gives pretty detailed information.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议点击四周，仔细查看 GitHub action 工作流执行了什么，因为它提供了相当详细的信息。
- en: 'Finally, if you check the Azure portal, you should see the resource group,
    storage account, and container where there should be a single file called `ghact.tfstate`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你查看 Azure 门户，应该可以看到资源组、存储帐户和容器，其中应该有一个名为`ghact.tfstate`的文件：
- en: '![Figure 7.7 – Checking the Terraform state file in the Azure portal](img/Figure_7.07_B19537.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 在 Azure 门户中查看 Terraform 状态文件](img/Figure_7.07_B19537.jpg)'
- en: Figure 7.7 – Checking the Terraform state file in the Azure portal
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 在 Azure 门户中查看 Terraform 状态文件
- en: That concludes using GitHub actions to run Terraform; before we finish the chapter,
    let’s look at a workflow that runs Ansible.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了使用 GitHub actions 运行 Terraform；在我们结束这一章之前，让我们来看一个运行 Ansible 的工作流。
- en: Running Ansible using GitHub Actions
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 运行 Ansible
- en: Ansible doesn’t have a concept of state files, so this will simplify our GitHub
    action workflow. As we are using Microsoft Azure again, you must set up the `ARM_CLIENT_ID`,
    `ARM_CLIENT_SECRET`, `ARM_SUBSCRIPTION_ID`, and `ARM_TENANT_ID` secrets in your
    GitHub repository as we did in the last section before progressing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 没有状态文件的概念，因此这将简化我们的 GitHub action 工作流。由于我们再次使用 Microsoft Azure，你必须在
    GitHub 仓库中设置`ARM_CLIENT_ID`、`ARM_CLIENT_SECRET`、`ARM_SUBSCRIPTION_ID` 和`ARM_TENANT_ID`密钥，正如我们在上一节中所做的那样。
- en: 'Once they are there, we can move on to the workflow itself; as with the Terraform
    workflow, we start by setting some basic configurations:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它们在那里，我们就可以继续进行工作流本身的操作；与 Terraform 工作流一样，我们从设置一些基本配置开始：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then we define the job; that’s right, there is only one job for this workflow:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义作业；没错，这个工作流只有一个作业：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So far, not much is different, so let’s move on to the steps. First, we check
    out the code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，差别不大，我们继续进行下一步。首先，我们检出代码：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here we hit our first difference; as Ansible is written in Python, we need
    to make sure that Python is installed and reasonably up to date. For this, we
    will use the `actions/setup-python@v4` task:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们遇到了第一个差异；由于 Ansible 是用 Python 编写的，我们需要确保 Python 已安装并且版本较为现代。为此，我们将使用`actions/setup-python@v4`任务：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The next step is to log in to Azure, this is an exact copy of the *Log in to
    Azure using a service principal* step from the Terraform workflow in the previous
    section of this chapter, so I will not repeat the code here.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是登录到 Azure，这与本章上一节 Terraform 工作流中的*使用服务主体登录到 Azure*步骤完全相同，因此我不再重复代码。
- en: 'Next, we need to install Ansible itself – we are doing this using the `pip`
    command; the step looks like the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装 Ansible 本身——我们使用`pip`命令进行安装；这一步看起来像如下所示：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once Ansible is installed, we can then run the `ansible-galaxy` command to
    install the Azure Collection – this step is not too different from when installed
    it locally:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Ansible，我们就可以运行`ansible-galaxy`命令来安装 Azure Collection——这一步与我们本地安装时并没有太大区别：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you may have guessed, once the Azure Collection is installed, we need to
    install the Python modules needed for the collection to function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜测的，一旦安装了 Azure Collection，我们需要安装该集合运行所需的 Python 模块：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once everything we need to run the playbook is installed, we can run the task;
    this step looks like the *Create String Output* step in the Terraform workflow,
    as we want to capture the output of the `ansible-playbook` command and store it
    within the workflow summary:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了运行 Playbook 所需的一切，我们就可以运行任务；这一步看起来像是 Terraform 工作流中的 *创建字符串输出* 步骤，因为我们要捕获
    `ansible-playbook` 命令的输出并将其存储在工作流总结中：
- en: '[PRE30]'' >> $GITHUB_OUTPUT'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]'' >> $GITHUB_OUTPUT'
- en: echo "$ANSIBLE_OUTPUT" >> $GITHUB_OUTPUT
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: echo "$ANSIBLE_OUTPUT" >> $GITHUB_OUTPUT
- en: echo '[PRE31]
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: echo '[PRE31]
- en: 'The final step in the workflow is to publish the summary:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流的最后一步是发布总结：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That is it; as you can see, the workflow has fewer jobs and steps as we don’t
    have to take into consideration either the backend storage or publishing plan
    file as an artifact as we did for the Terraform workflow.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；正如你所看到的，工作流的作业和步骤较少，因为我们不需要像 Terraform 工作流中那样考虑后端存储或将发布计划文件作为工件进行发布。
- en: 'Running the workflow should give you something like the following output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行工作流时，应该会得到如下输出：
- en: '![Figure 7.8 – Running the Ansible Playbook using GitHub Actions](img/Figure_7.08_B19537.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 使用 GitHub Actions 运行 Ansible Playbook](img/Figure_7.08_B19537.jpg)'
- en: Figure 7.8 – Running the Ansible Playbook using GitHub Actions
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 使用 GitHub Actions 运行 Ansible Playbook
- en: Again, the folder name of the repo accompanying this title purposely has the
    `.` character removed from the start of the folder name, so the GitHub action
    is not registered. If you are following along in your repo, per the Terraform
    GitHub Action workflow, you must rename this folder to `.github` when committing
    to your repo to register the action.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，本标题所附的仓库文件夹名称故意将文件夹名称开头的 `.` 字符去掉，以便 GitHub Action 不会注册。如果你在自己的仓库中跟着操作，根据
    Terraform GitHub Action 工作流，在提交到仓库时，必须将该文件夹重命名为 `.github`，以便注册该 Action。
- en: Now that we have run our workflows using Terraform and Ansible, let’s quickly
    discuss some best practices.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经使用 Terraform 和 Ansible 运行了工作流，让我们快速讨论一些最佳实践。
- en: Security best practices
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全最佳实践
- en: When we worked through the Terraform and Ansible workflows, we discussed adding
    repository secrets to our GitHub repository. All sensitive information should
    be stored within secrets outside of using an external source for your secrets,
    such as Azure Key Vault, AWS Secrets Manager, or HashiCorp Vault.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论 Terraform 和 Ansible 工作流时，我们讨论了如何将仓库的机密添加到 GitHub 仓库中。所有敏感信息应存储在机密中，而不是使用外部来源（如
    Azure Key Vault、AWS Secrets Manager 或 HashiCorp Vault）来存储你的机密信息。
- en: The advantage of this is that the secrets will remain hidden, but the code will
    also be able to consume them. Great, you may think to yourself.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是，机密信息会保持隐藏，但代码仍然能够使用它们。你可能会想，这样很好。
- en: But anyone who has been granted write access to the repo will also be able to
    consume them (though not view the contents), so please be careful when granting
    access to your IaC CI/CD pipelines as they will have a high level of access to
    your cloud resource via your workflows, so please ensure that you only grant access
    to trusted members of your teams.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，任何被授予仓库写权限的人也能够使用这些机密（尽管不能查看内容），所以在授予对 IaC CI/CD 流水线的访问权限时要小心，因为他们将通过工作流拥有对你的云资源的高度访问权限，因此请确保只授予可信团队成员访问权限。
- en: Pop quiz
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抢答题
- en: 'Before we finish the chapter, let’s have a quick pop quiz:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束之前，让我们进行一个快速的抢答题：
- en: When writing YAML, what is it essential to keep an eye on?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 YAML 时，必须注意哪些事项？
- en: When it comes to credentials, what should you never do?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于凭据，你绝对不应该做什么？
- en: What is the folder name in which the GitHub action should be stored?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitHub Action 应该存储在哪个文件夹中？
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: While we spent a lot of the initial part of the chapter discussing how Terraform
    works, once we got onto working through the GitHub Actions workflows, I am sure
    that you started to see the benefits of running our IaC from a centrally accessible
    location rather than your local machine.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本章初期花了很多时间讨论 Terraform 的工作原理，但一旦我们开始使用 GitHub Actions 工作流，我相信你已经开始意识到从一个中心位置而非本地机器运行我们的
    IaC 所带来的好处。
- en: Once we discussed Terraform’s requirements, we configured repository secrets
    and variables in GitHub. Then we worked through the various jobs and steps to
    make up the workflow that manages the storage account, where we stored the Terraform
    state and executed the Terraform deployment.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们讨论了 Terraform 的要求，我们在 GitHub 中配置了仓库的机密和变量。接着我们处理了各种作业和步骤，组成了管理存储账户的工作流，在该存储账户中存储了
    Terraform 状态，并执行了 Terraform 部署。
- en: We then took everything we learned and covered in Terraform and applied it to
    Ansible before finally discussing a vital security point – be careful what access
    you give to your IaC GitHub actions!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后将所有在 Terraform 中学到的内容应用到 Ansible 中，最后讨论了一个重要的安全问题——小心赋予你的 IaC GitHub Actions
    过多的访问权限！
- en: There are some points we needed more time to cover, such as monitoring; for
    example, it is relatively straightforward to hook your GitHub Actions into messaging
    services such as Microsoft Teams or Slack to get real-time feedback on workflow
    runs – there are links to the GitHub Actions Marketplace tasks for Microsoft Teams
    and Slack in the further reading section if you want to have a go at hooking your
    workflows into your preferred messaging service.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有些内容我们需要更多时间来讲解，比如监控；例如，将 GitHub Actions 集成到消息服务（如 Microsoft Teams 或 Slack）中，以便获得工作流运行的实时反馈是相对简单的——如果你想尝试将工作流连接到你喜欢的消息服务，可以查看进一步阅读部分中关于
    Microsoft Teams 和 Slack 的 GitHub Actions 市场链接。
- en: This is not only a great way of extending your IaC deployments to other team
    members, but it also works as a system that tracks changes as the workflow runs,
    which contains a summary of each execution that will be stored for a while.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅是将 IaC 部署扩展到其他团队成员的好方法，而且它还能作为一个系统，跟踪工作流运行时的变化，记录每次执行的摘要，并在一段时间内存储这些数据。
- en: In the next and penultimate chapter, we will look at common troubleshooting
    tips and tricks.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节和倒数第二个章节中，我们将探讨一些常见的故障排除技巧和窍门。
- en: Further reading
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more details on the tasks we have used in the steps in this chapter
    at the following URLs:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下网址找到我们在本章节中使用的任务的更多详细信息：
- en: '[https://github.com/marketplace/](https://github.com/marketplace/)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/marketplace/](https://github.com/marketplace/)'
- en: https://github.com/marketplace/actions/azure-login
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://github.com/marketplace/actions/azure-login
- en: '[https://github.com/marketplace/actions/azure-cli-action](https://github.com/marketplace/actions/azure-cli-action)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/marketplace/actions/azure-cli-action](https://github.com/marketplace/actions/azure-cli-action)'
- en: '[https://github.com/marketplace/actions/checkout](https://github.com/marketplace/actions/checkout)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/marketplace/actions/checkout](https://github.com/marketplace/actions/checkout)'
- en: '[https://github.com/marketplace/actions/upload-a-build-artifact](https://github.com/marketplace/actions/upload-a-build-artifact)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/marketplace/actions/upload-a-build-artifact](https://github.com/marketplace/actions/upload-a-build-artifact)'
- en: '[https://github.com/marketplace/actions/download-a-build-artifact](https://github.com/marketplace/actions/download-a-build-artifact)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/marketplace/actions/download-a-build-artifact](https://github.com/marketplace/actions/download-a-build-artifact)'
- en: '[https://github.com/marketplace/actions/setup-python](https://github.com/marketplace/actions/setup-python)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/marketplace/actions/setup-python](https://github.com/marketplace/actions/setup-python)'
- en: '[https://github.com/marketplace/actions/microsoft-teams-deploy-card](https://github.com/marketplace/actions/microsoft-teams-deploy-card)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/marketplace/actions/microsoft-teams-deploy-card](https://github.com/marketplace/actions/microsoft-teams-deploy-card)'
- en: '[https://github.com/marketplace/actions/slack-notify](https://github.com/marketplace/actions/slack-notify)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/marketplace/actions/slack-notify](https://github.com/marketplace/actions/slack-notify)'
- en: Answers
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to the pop quiz:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于突击测试的答案：
- en: When writing YAML, what is it essential to keep an eye on? Indentation! The
    structure of your YAML file is critical – if you get it wrong, even by a single
    character, you will get errors.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 YAML 时，必须特别注意什么？缩进！你的 YAML 文件结构至关重要——即使一个字符错误，也会导致错误。
- en: When it comes to credentials, what should you never do? Embed them into your
    code! You need to use an external secret management system.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当涉及到凭证时，你绝对不应该做什么？将其嵌入到代码中！你需要使用外部的密钥管理系统。
- en: What is the folder name in which the GitHub action should be stored? Your YAML
    files should be stored in the `.``github/workflows` folder.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitHub Actions 应该存储在哪个文件夹中？你的 YAML 文件应该存储在`.github/workflows` 文件夹中。
