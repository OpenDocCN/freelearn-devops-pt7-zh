- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Hardening Your Servers Using Ansible
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible加固你的服务器
- en: One of the advantages of using an orchestration and configuration tool such
    as Ansible is that it can be utilized to generate and deploy a complex set of
    configurations in a repeatable task across many hosts. In this chapter, we will
    look at a tool that scans your hosts using Ansible, dynamically generates a remediation
    playbook, and then runs it for you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Ansible这样的编排和配置工具的一个优势是，它可以在多个主机上以可重复的任务生成并部署一组复杂的配置。在本章中，我们将介绍一个工具，它使用Ansible扫描你的主机，动态生成修复剧本，然后为你执行它。
- en: We will also look at running two different security tools that scan the WordPress
    installation we have used throughout the previous chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍如何运行两个不同的安全工具，它们扫描我们在前几章中使用的WordPress安装。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及以下主题：
- en: The scanning tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描工具
- en: The playbook
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剧本
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Following our excursion into the cloud, we will return to our local machine
    and launch an Ubuntu 22.04 virtual machine using Multipass; as we will be running
    a workload that requires a bit more disk space than we have been used to so far,
    we will be altering the specs of the virtual machine when we launch it to increase
    the disk space and RAM.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成云端的探险后，我们将回到本地机器并使用Multipass启动一个Ubuntu 22.04虚拟机；由于我们将运行一个需要更多磁盘空间的工作负载，因此在启动虚拟机时，我们会调整虚拟机的规格，以增加磁盘空间和内存。
- en: As we will be installing a lot of different software on the virtual machine,
    your Multipass virtual machine will need to be able to download packages from
    the internet; there will be around 3 GB of various packages and configuration
    files to download.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在虚拟机上安装许多不同的软件，你的Multipass虚拟机需要能够从互联网下载包；大约需要下载3GB的各种包和配置文件。
- en: You can find a complete copy of the playbook accompanying this chapter in the
    repository at [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14)的仓库中找到本章附带的完整剧本副本。
- en: The scanning tools
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描工具
- en: Before we dive into the Playbook, let’s quickly look at the three tools we will
    be running, starting with the one that does the most, **OpenSCAP**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入剧本之前，让我们快速了解一下我们将要运行的三个工具，从其中一个做得最多的工具开始，**OpenSCAP**。
- en: OpenSCAP
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenSCAP
- en: First, we will be looking at one of Red Hat’s tools, called OpenSCAP. Before
    we continue, the next section will contain many abbreviations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看Red Hat的一个工具，叫做OpenSCAP。在继续之前，下一节将包含许多缩写。
- en: So, what is SCAP? The **Security Content Automation Protocol** (**SCAP**) is
    an open standard that encompasses several components, all of which are open standards
    themselves, to build a framework that allows you to automatically assess and remediate
    your hosts against the **National Institute of Standards and Technology** (**NIST**)
    *Special* *Publication 800-53*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是SCAP呢？**安全内容自动化协议**（**SCAP**）是一个开放标准，它包含多个组件，每个组件本身也是开放标准，构建一个框架，允许你自动评估和修复你的主机，以符合**国家标准与技术研究院**（**NIST**）的*特别*
    *出版物800-53*。
- en: This publication is a catalog of controls applied to all U.S. federal IT systems,
    apart from those maintained by the **National Security Agency** (**NSA**). These
    controls have been effected to help implement the **Federal Information Security
    Management Act** (**FISMA**) of 2002 across U.S. federal departments.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该出版物是对所有美国联邦IT系统应用的控制的目录，除了由**国家安全局**（**NSA**）维护的系统。这些控制的实施旨在帮助执行2002年《联邦信息安全管理法》（**FISMA**）在美国联邦部门中的应用。
- en: 'SCAP is made up of the following components:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SCAP由以下组件组成：
- en: '**Asset Identification** (**AID**) is a data model used for asset identification.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产识别**（**AID**）是用于资产识别的数据模型。'
- en: '**Asset Reporting Format** (**ARF**) is a vendor-neutral and technology-agnostic
    data model for transporting information on assets between different reporting
    applications and services.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产报告格式**（**ARF**）是一个中立于供应商和技术的数据模型，用于在不同的报告应用程序和服务之间传输资产信息。'
- en: '**Common Configuration Enumeration** (**CCE**) is a standard database of recommended
    configurations for common software. Each recommendation has a unique identifier.
    At the time of writing, the database hadn’t been updated for over a decade.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用配置枚举**（**CCE**）是一个标准数据库，提供常见软件的推荐配置。每个推荐都有一个唯一的标识符。写作时，数据库已经有十多年未更新。'
- en: '**Common Configuration Scoring System** (**CCSS**) is the continuation of CCE.
    It is used for generating a score for various software and hardware configurations
    across all types of deployments.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用配置评分系统**（**CCSS**）是CCE的延续。它用于为各种软件和硬件配置生成评分，适用于所有类型的部署。'
- en: '**Common Platform Enumeration** (**CPE**) identifies hardware assets, operating
    systems, and software in an organization’s infrastructure. Once identified, this
    data can then be used to search other databases to threat-assess the asset.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用平台枚举**（**CPE**）用于识别组织基础设施中的硬件资产、操作系统和软件。一旦识别出这些数据，就可以用于在其他数据库中搜索，进行资产的威胁评估。'
- en: '**Common Weakness Enumeration** (**CWE**) is a common language for dealing
    with and discussing the causes of weaknesses in system architecture, design, and
    code that may lead to vulnerabilities.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用弱点枚举**（**CWE**）是一个通用语言，用于处理和讨论系统架构、设计和代码中可能导致漏洞的弱点原因。'
- en: '**Common Vulnerabilities and Exposures** (**CVE**) is a database of publicly
    acknowledged vulnerabilities. Most system administrators and IT professionals
    will have encountered the CVE database at some point. Each vulnerability receives
    a unique ID; for example, most people will know CVE-2014-0160, also known as **Heartbleed**.
    The Heartbleed vulnerability was a severe security flaw in OpenSSL (a cryptographic
    software library) that allowed attackers to steal sensitive information, such
    as passwords and private keys, from the memory of affected systems by exploiting
    a bug in the OpenSSL’s implementation of the **transport layer security** (**TLS**)/**datagram
    transport layer security** (**DTLS**) heartbeat extension.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用漏洞和曝光**（**CVE**）是一个公开承认的漏洞数据库。大多数系统管理员和IT专业人员都会在某个时刻接触到CVE数据库。每个漏洞都有一个唯一的ID；例如，大多数人都知道CVE-2014-0160，也就是**Heartbleed**。Heartbleed漏洞是OpenSSL（一个加密软件库）中的一个严重安全缺陷，攻击者可以利用该漏洞通过OpenSSL对**传输层安全性**（**TLS**）/**数据报传输层安全性**（**DTLS**）心跳扩展的错误，窃取受影响系统内存中的敏感信息，如密码和私钥。'
- en: '**Common Vulnerability Scoring System** (**CVSS**) is a method that helps capture
    the characteristics of a vulnerability to produce a normalized numerical score,
    which can then be used to describe the impact of a vulnerability, for example,
    low, medium, high, and critical.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用漏洞评分系统**（**CVSS**）是一种方法，用于捕捉漏洞的特征并生成标准化的数值评分，随后可用于描述漏洞的影响，例如低、中、高和严重。'
- en: '**Extensible Configuration Checklist Description Format** (**XCCDF**) is an
    XML format for describing security checklists. It can also be used for configuration
    and benchmarks and provides a common language for all the parts of SCAP.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展配置清单描述格式**（**XCCDF**）是一种用于描述安全清单的XML格式。它也可以用于配置和基准测试，并为SCAP的各个部分提供统一的语言。'
- en: '**Open Checklist Interactive Language** (**OCIL**) is a framework for expressing
    questions to an end user and the procedures to process the responses in a standardized
    way.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放清单互动语言**（**OCIL**）是一个框架，用于向最终用户提问并以标准化方式处理响应的过程。'
- en: '**Open Vulnerability and Assessment Language** (**OVAL**) is defined in XML
    and aims to standardize the transfer of security content across all of the tools
    and services offered by NIST, the MITRE Corporation, the **United States Computer
    Emergency Readiness Team** (**US-CERT**), and the United States **Department of
    Homeland** **Security** (**DHS**).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放漏洞和评估语言**（**OVAL**）定义为XML，旨在标准化通过NIST、MITRE公司、**美国计算机紧急响应小组**（**US-CERT**）以及美国**国土安全部**（**DHS**）提供的所有工具和服务之间的安全内容传输。'
- en: '**Trust Model for Security Automation Data** (**TMSAD**) is an XML document
    that aims to define a common trust model that can be applied to the data being
    exchanged by all components that make up SCAP.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全自动化数据的信任模型**（**TMSAD**）是一个XML文档，旨在定义一个可以应用于SCAP各组件间交换数据的共同信任模型。'
- en: As you can imagine, thousands of man-years have gone into producing SCAP and
    its components to make its foundation. Some of the projects have been around in
    one form or another since the mid-90s, so they are well-established and considered
    the de facto standard when it comes to security best practices; however, I am
    sure you think that it all sounds very complicated – after all, these are standards
    that have been defined and are being maintained by scholars, security professionals,
    and government departments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以想象的那样，数千人的工作年限已经投入到生产SCAP及其组件，以构建它的基础。有些项目自90年代中期以来就以某种形式存在，因此它们已经相当成熟，并被认为是关于安全最佳实践的事实标准；然而，我相信你会觉得这一切听起来很复杂——毕竟，这些标准是由学者、安全专家和政府部门定义并维护的。
- en: This is where OpenSCAP comes in. The OpenSCAP project, maintained by Red Hat
    and certified by NIST for supporting the SCAP standard, allows you to apply all
    the best practices we have discussed using a command-line client.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是OpenSCAP的作用所在。OpenSCAP项目由Red Hat维护，并且通过NIST认证以支持SCAP标准，它允许你使用命令行客户端应用我们所讨论的所有最佳实践。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: The automatic remediation scripts in OpenSCAP are a work in progress, and there
    are known issues that we will address toward the end of the chapter. Because of
    this, your output may differ from that covered in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSCAP中的自动修复脚本仍在进行中，并且存在一些已知问题，我们将在本章的后半部分解决这些问题。因此，您的输出可能与本章所述有所不同。
- en: OpenSCAP, like many Red Hat projects, has support for Ansible, and the current
    release introduces support for automatically generating Ansible playbooks to remediate
    non-conformance discovered during an OpenSCAP scan.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSCAP像许多Red Hat项目一样，支持Ansible，当前版本引入了自动生成Ansible演练手册的功能，用于修复在OpenSCAP扫描过程中发现的不合规项。
- en: The next two tools we will be looking at will be scanning our WordPress site,
    starting with WPScan.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将查看的两个工具将扫描我们的WordPress网站，首先是WPScan。
- en: WPScan
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WPScan
- en: The second tool we will be running is called **WPScan** and we will use it to
    scan our WordPress site. WPScan is a command-line tool that can perform various
    security assessments and vulnerability tests on WordPress installations. It can
    detect common configuration errors, outdated themes, weak passwords, and other
    potential risks. WPScan is easy to install – especially as we will be using the
    container version and running it using Docker, which we will also be going for
    the third and final tool, OWASP ZAP.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行的第二个工具叫做**WPScan**，我们将使用它来扫描我们的WordPress网站。WPScan是一个命令行工具，可以对WordPress安装进行各种安全评估和漏洞测试。它可以检测常见的配置错误、过时的主题、弱密码和其他潜在风险。WPScan易于安装——特别是我们将使用容器版本并通过Docker运行它，而这也是我们将要使用的第三个也是最后一个工具，OWASP
    ZAP。
- en: OWASP ZAP
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OWASP ZAP
- en: Web vulnerabilities such as SQL injection, cross-site scripting, broken authentication,
    and insecure deserialization can threaten our WordPress site’s security and quality.
    To help identify and prioritize such vulnerabilities, we can use **OWASP ZAP**.
    This tool, the third and final one we will cover in the chapter, generates reports,
    alerts, and graphs that assist us in visualizing and addressing the findings.
    Moreover, OWASP ZAP is user-friendly and easy to install, making it a valuable
    resource for enhancing our site’s security and overall quality.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入、跨站脚本攻击、身份验证漏洞和不安全的反序列化等Web漏洞可能威胁到我们WordPress网站的安全性和质量。为了帮助识别和优先处理这些漏洞，我们可以使用**OWASP
    ZAP**。这个工具是我们在本章中讨论的第三个也是最后一个工具，它生成报告、警报和图表，帮助我们可视化并处理发现的问题。此外，OWASP ZAP易于使用且安装简单，是提升我们网站安全性和整体质量的宝贵资源。
- en: The playbook
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演练手册
- en: 'We will split the playbook into a few different roles to run the various scanning
    tools that will be running in the chapter – as you can see from the `site.yml`
    file, we are adding some conditions to the roles containing our tasks. The start
    of the file looks like all of the other playbook files we have been running:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把演练手册拆分为几个不同的角色，用于运行本章中将要运行的各种扫描工具——正如从`site.yml`文件中看到的，我们正在为包含任务的角色添加一些条件。文件的开始部分与我们之前运行的其他演练手册文件相似：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As mentioned, roles are where this playbook starts to differ from the previous
    playbooks we have been running up to this point in the book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，角色是这个演练手册与我们到目前为止运行的前几个演练手册的区别所在。
- en: 'As you can see from the following source, we are defining tags alongside the
    roles themselves:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如从以下源代码中可以看到的，我们在定义角色的同时也定义了标签：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, we are using the `openscap`, `scan`, and `docker` tags followed
    by `wordpress`, which used the roles directly from [*Chapter 5*](B21620_05.xhtml#_idTextAnchor253),
    *Deploying WordPress*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用 `openscap`、`scan` 和 `docker` 标签，后面跟着 `wordpress`，这些角色直接来自于 [*第 5
    章*](B21620_05.xhtml#_idTextAnchor253)，*部署 WordPress*：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we have roles that run `scans` and `openscap`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有运行 `scans` 和 `openscap` 的角色：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, what does this mean? Well, later in the chapter, when it comes to running
    the playbook, we will only be running specific roles; for example, to run OpenSCAP,
    we will use the following commands:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这意味着什么呢？嗯，在本章的后续内容中，当我们运行 playbook 时，我们只会运行特定的角色；例如，要运行 OpenSCAP，我们将使用以下命令：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When running the first command, it will run just the `common` and `openscap`
    roles and run the remediation Ansible Playbook and bash script, both of which
    will be automatically generated during the initial scan – it will also download
    a copy of the results, an implementation guide, a copy of the playbook, and a
    copy of the bash scripts.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 运行第一个命令时，它将只运行 `common` 和 `openscap` 角色，并运行修复 Ansible Playbook 和 bash 脚本，这两个都会在初次扫描期间自动生成——它还会下载结果副本、实施指南、playbook
    副本和 bash 脚本副本。
- en: The second of the two commands will rerun the scan host and download a copy
    of the results again.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 两个命令中的第二个命令将重新扫描主机并再次下载结果副本。
- en: 'Once we have finished running OpenSCAP, we will then redeploy our host and
    run the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了 OpenSCAP 的运行，我们将重新部署主机并运行以下命令：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This, as I am sure you will have guessed, will run the three `wordpress` roles.
    Then, with WordPress installed, we can run the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这，正如你猜到的，运行三个 `wordpress` 角色。然后，安装了 WordPress 后，我们可以运行以下命令：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will execute the `common`, `docker`, and `scan` roles.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行 `common`、`docker` 和 `scan` 角色。
- en: 'We can also run these commands to run just one of the two scanning tools that
    the `scan` role runs:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以运行这些命令，只运行 `scan` 角色运行的两个扫描工具中的一个：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But we are getting ahead of ourselves; let’s work our way through the preceding
    roles before we think about running the playbook.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们现在有些超前了；让我们先处理前面的角色，然后再考虑运行 playbook。
- en: The common role
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共角色
- en: 'This role contains a single task in `roles/common/tasks/main.yml`, and its
    only job is to set a fact containing the current date and time:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色在 `roles/common/tasks/main.yml` 中包含一个单独的任务，其唯一任务是设置一个包含当前日期和时间的事实：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You might think, *“That seems a little basic.”* However, as we will be using
    the `the_date` variable several times throughout the roles in this playbook, we
    only want it to be generated once as it will be used to create file and folder
    names that are then called later in tasks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，*“这看起来有点基础。”* 然而，正如我们将多次在这个 playbook 的角色中使用 `the_date` 变量，我们只希望它在第一次生成时就好，因为它将用于创建文件和文件夹名称，这些名称会在后续任务中被调用。
- en: If we use `{{ lookup('pipe', 'date +%Y-%m-%d-%H%M') }}` to insert the date dynamically
    as part of other variables and tasks, we need to be cautious. This is because
    some parts of the playbook can take several minutes to finish running.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `{{ lookup('pipe', 'date +%Y-%m-%d-%H%M') }}` 来动态插入日期作为其他变量和任务的一部分，我们需要小心。因为
    playbook 的某些部分可能需要几分钟才能完成运行。
- en: For instance, we may create a file called `myfile-2024-02-16-1300.yml` at one
    point in the playbook. However, if we dynamically set the date and time, and several
    tasks later, it takes five minutes for the playbook to get to that task, we could
    reference a file called `myfile-2024-02-16-1305.yml`. This would result in an
    error as the file does not exist. Therefore, we should only use the date and time
    lookup once during the playbook run.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能会在 playbook 中某个位置创建一个名为 `myfile-2024-02-16-1300.yml` 的文件。然而，如果我们动态设置日期和时间，而几项任务后它花了五分钟才到达那个任务，那么我们可能会引用一个名为
    `myfile-2024-02-16-1305.yml` 的文件。这样会导致错误，因为该文件并不存在。因此，我们应该只在 playbook 运行时使用一次日期和时间查找。
- en: The Docker role
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 角色
- en: 'This role contains all of the tasks and variables needed to install and configure
    Docker on our target host, much like the roles discussed in [*Chapter 4*](B21620_04.xhtml#_idTextAnchor202),
    *Deploying a LAMP Stack*, and [*Chapter 5*](B21620_05.xhtml#_idTextAnchor253),
    *Deploying WordPress*; this role uses the `ansible.builtin.apt`, `ansible.builtin.apt_key`,
    and `ansible.builtin.apt_repository` modules to do the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色包含了在目标主机上安装和配置 Docker 所需的所有任务和变量，类似于 [*第 4 章*](B21620_04.xhtml#_idTextAnchor202)，*部署
    LAMP 堆栈*，和 [*第 5 章*](B21620_05.xhtml#_idTextAnchor253)，*部署 WordPress* 中讨论的角色；这个角色使用
    `ansible.builtin.apt`、`ansible.builtin.apt_key` 和 `ansible.builtin.apt_repository`
    模块来完成以下操作：
- en: Download and install the prerequisites required for Docker to run.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装Docker运行所需的前置条件。
- en: Add the **GNU Privacy Guard** (**GPG**) key for the official Docker **advanced
    packaging tool** (**APT**) repository.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加官方Docker **高级包装工具**（**APT**）仓库的**GNU隐私保护**（**GPG**）密钥。
- en: Configure the official Docker APT repository.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置官方Docker APT仓库。
- en: Install Docker itself along with the Docker command-line tool.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Docker本身及Docker命令行工具。
- en: Ensure that Docker is running and set to start on boot.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Docker正在运行并设置为开机启动。
- en: 'To review the full list of tasks and variables for this role, see the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此角色的完整任务和变量列表，请参见以下内容：
- en: '[https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/roles/docker/defaults/main.yml](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/roles/docker/defaults/main.yml)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/roles/docker/defaults/main.yml](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/roles/docker/defaults/main.yml)'
- en: '[https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/roles/docker/tasks/main.yml](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/roles/docker/tasks/main.yml)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/roles/docker/tasks/main.yml](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/roles/docker/tasks/main.yml)'
- en: Next, we have the roles that install WordPress.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有安装WordPress的角色。
- en: The WordPress roles
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WordPress角色
- en: As you have already seen from the `site.yml` file at the start of the Playbook
    section of this chapter, here, we are just reusing the roles that we discussed
    at length in [*Chapter 5*](B21620_05.xhtml#_idTextAnchor253), *Deploying WordPress*.
    If you want to review these, you can see them at [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter05/roles](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter05/roles).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在本章Playbook部分开始时从`site.yml`文件中看到的那样，这里我们只是在重用我们在[*第5章*](B21620_05.xhtml#_idTextAnchor253)中详细讨论的角色，*部署WordPress*。如果你想回顾这些内容，可以访问[https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter05/roles](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter05/roles)。
- en: The scan role
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扫描角色
- en: 'As already mentioned, we will be using Docker to run WPScan and OWASP ZAP;
    this allows us to reuse the same tasks. Let’s look at `roles/scan/tasks/main.yml`;
    first, we need to pull the Docker image or images:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用Docker来运行WPScan和OWASP ZAP；这使我们能够重用相同的任务。让我们来看一下`roles/scan/tasks/main.yml`；首先，我们需要拉取Docker镜像或镜像：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are switching it up slightly in that we are using `loop` rather than `with_items`;
    this gives more control over what happens when looping through. In this task,
    we are using `label` to show which of the scanning tools is currently processing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍微做了一些调整，使用`loop`而不是`with_items`；这样可以更好地控制循环中的行为。在此任务中，我们使用`label`来显示当前正在处理的扫描工具。
- en: You may also notice that we have a `when` condition; this allows us to run both
    of the scans or just one of the two by passing in the name of the scan in the
    `scan_types` variable. When we look at the variables in a moment, you will see
    that by default, we are passing in the names of both scanning tools.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到我们使用了`when`条件；这使我们可以通过传递`scan_types`变量中的扫描名称来运行两个扫描任务中的一个或两个。当我们稍后查看变量时，你会看到默认情况下，我们传递了两个扫描工具的名称。
- en: 'This pattern of `loop`, `loop_control`, and `when` will be repeated throughout
    all the tasks in this role. We have a task that will create a folder on the virtual
    machine; we will be mounting this folder into the container at runtime so that
    we can keep a copy of the scan output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop`、`loop_control`和`when`模式将在该角色的所有任务中重复使用。我们有一个任务将在虚拟机上创建一个文件夹；我们将在运行时将此文件夹挂载到容器中，以便保存扫描输出的副本：'
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, with the container image and folder created, we can run the scan:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，容器镜像和文件夹已经创建，我们可以运行扫描：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, everything is being passed to the container as variables; this
    is how we can run two very different tools with a single common task, and more
    so later when we look at the variables.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有内容都作为变量传递给容器；这就是我们如何通过一个通用任务运行两个非常不同的工具，更多细节稍后会在查看变量时解释。
- en: 'You will have also noted that we are adding a few options to the end of this
    task; these are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到我们在任务末尾添加了一些选项；它们如下：
- en: '`register`: Here, we are just registering the output of the task – nothing
    special here'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register`：在这里，我们只是注册任务的输出——没有什么特别的。'
- en: '`ignore_errors`: This tells Ansible to continue running should it detect an
    error; in our case, the containers we are running will purposely trigger an error
    code as they have been designed to halt and not proceed with any further tasks
    until the scan does not fail'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_errors`：这告诉 Ansible 在检测到错误时继续运行；在我们的情况下，我们运行的容器会故意触发错误代码，因为它们被设计为停止并且在扫描未通过之前不继续执行任何后续任务。'
- en: '`no_log`: This suppresses the output – as we save the output when running the
    scan, we do not need the output printed to the terminal when we run the task'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_log`：这会抑制输出——因为我们在运行扫描时保存了输出，所以我们不需要在终端打印输出。'
- en: 'As we are registering an output, the next task is a debug line. This follows
    the same pattern as debug tasks in other chapters, so we will be moving to the
    task that downloads a copy of the reports:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们注册输出时，接下来的任务是调试行。这与其他章节中的调试任务遵循相同的模式，因此我们将转向下载报告副本的任务：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This uses the `ansible.builtin.fetch` module setting the `flat` option to `true`.
    This option copies the file rather than the full directory path. The final task
    removes the container, meaning that when we next run a scan, it will start from
    scratch and spawn a new container rather than reusing the one we have just finished
    using:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了 `ansible.builtin.fetch` 模块，并将 `flat` 选项设置为 `true`。这个选项会复制文件而不是完整的目录路径。最后一个任务移除了容器，这意味着当我们下次运行扫描时，它将从头开始并启动一个新的容器，而不是重用我们刚刚使用完的那个：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we know what the tasks look like, let us look at the variables, which
    can be found in `roles/scan/defaults/main.yml`. The first variable sets the scan
    we want to run, and as already mentioned, this gives the name of the two scans:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了任务的样子，让我们看看变量，这些变量可以在 `roles/scan/defaults/main.yml` 中找到。第一个变量设置我们要运行的扫描，正如前面提到的，这里给出了两个扫描的名称：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next up in `roles/scan/defaults/main.yml`, we have a block of variables that
    could be commonly used across both scanning tools:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `roles/scan/defaults/main.yml` 中，我们有一个可能在两个扫描工具中都常用的变量块：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we have the primary `scan` variable, which is the one we have been
    looping over; it starts with WPScan:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有主要的 `scan` 变量，这是我们一直在循环使用的那个，它以 WPScan 开头：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The block that follows is the one for OSWAP ZAP:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码块是 OSWAP ZAP 的部分：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we pass in the different container images and commands to run
    the scan while using the same variables. Because of this, we could keep the tasks
    used in the role completely neutral, meaning that we didn’t have to consider anything
    custom to the tool we were running.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们传入不同的容器镜像和运行扫描的命令，同时使用相同的变量。因此，我们可以保持角色中的任务完全中立，意味着我们无需考虑任何与运行的工具相关的自定义内容。
- en: 'That concludes the scan role, leaving us with, as I am sure you will have already
    guessed from how long the tool explanation was at the start of the chapter, the
    most complex role in the playbook: OpenSCAP.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了扫描角色，剩下的正如你从章节开头工具说明的长度中已经猜到的那样，是 Playbook 中最复杂的角色：OpenSCAP。
- en: The OpenSCAP role
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenSCAP 角色
- en: When writing a playbook, it is essential to know how the tool you are automating
    works; given that OpenSCAP is a little complex, let’s review the steps needed
    to manually run a scan and remediate the problems it finds using an automatically
    generated Ansible playbook and a shell script.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Playbook 时，了解你正在自动化的工具如何工作至关重要；鉴于 OpenSCAP 有点复杂，让我们回顾一下手动运行扫描并使用自动生成的 Ansible
    Playbook 和 shell 脚本来修复它发现的问题所需的步骤。
- en: Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While the commands to run OpenSCAP follow, you do not need to follow along;
    these are provided to illustrate the process we need to follow in our Playbook
    role.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然接下来是运行 OpenSCAP 的命令，但你无需跟着执行；这些命令是为了说明我们在 Playbook 角色中需要遵循的过程。
- en: 'First, we need to download and install OpenSCAP itself, along with a few tools
    we will also need:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要下载并安装 OpenSCAP 本身，以及我们还需要的一些工具：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next up, we need to download the actual content – these definitions cover several
    different operating systems and various levels of compliance. The GitHub repository
    for this content can be found at [https://github.com/ComplianceAsCode/content](https://github.com/ComplianceAsCode/content),
    and at the time of writing, the current release is 0.1.71.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要下载实际内容——这些定义涵盖了多个不同的操作系统和不同级别的合规性。该内容的 GitHub 仓库可以在 [https://github.com/ComplianceAsCode/content](https://github.com/ComplianceAsCode/content)
    找到，写作时当前版本是 0.1.71。
- en: 'Get the release URL for the zip file, which contains the files we need from
    the releases page, then download and unzip on the host:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 zip 文件的发布 URL，该文件包含我们需要的文件，从发布页面下载并在主机上解压：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have OpenSCAP and the definition files installed, we can get some
    information on what is available for our Ubuntu 22.04 operating system:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 OpenSCAP 和定义文件，我们可以获取一些关于我们 Ubuntu 22.04 操作系统的可用信息：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will give us the name of the profile we want to use; in our case, it is
    `xccdf_org.ssgproject.content_profile_cis_level1_server`. Once we have this, we
    can run the scan itself:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供我们想要使用的配置文件的名称；在我们的例子中，它是 `xccdf_org.ssgproject.content_profile_cis_level1_server`。一旦我们有了这个，我们就可以运行扫描本身：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will generate two output files: an HTML copy of a report containing everything
    that needs fixing in a nicely digestible format we can read, and a second XML
    file containing the same information in a format OpenSCAP can read.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成两个输出文件：一个 HTML 格式的报告，包含需要修复的所有内容，易于阅读；另一个是 XML 文件，包含相同的信息，以便 OpenSCAP 可以读取。
- en: 'We can then take the XML file and generate a more detailed guide on how we
    could resolve the issues found by running the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以获取 XML 文件，并通过运行以下命令生成一个更详细的指南，告诉我们如何解决扫描中发现的问题：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, as this book is about Ansible, it would be better to have a Playbook
    to fix as many of the issues as possible, and running the following command will
    give us just that:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于本书是关于 Ansible 的，最好有一个 Playbook 来修复尽可能多的问题，运行以下命令将为我们提供这个功能：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, not everything can be resolved using the Playbook method, so having
    a bash script to fix any issues that can’t be resolved by running the playbook
    is also a great idea as it will mean less manual work for us to do:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，并非所有问题都能通过 Playbook 方法解决，因此拥有一个 Bash 脚本来修复任何无法通过运行 Playbook 解决的问题也是一个好主意，因为这将减少我们需要手动处理的工作量：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we have the Playbook and bash script; we need to run them, copy the playbook
    to our local machine, and run it using the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 Playbook 和 Bash 脚本；我们需要运行它们，将 Playbook 复制到本地机器，并使用以下命令运行：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then we go back to the virtual machine, and run the bash script using the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们回到虚拟机，使用以下命令运行 Bash 脚本：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You will have seen a lot of output, but if everything goes as planned when you
    rerun the scan, you should see a lot of issues being reported.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到很多输出，但如果一切按计划进行，当你重新运行扫描时，你应该会看到许多问题被报告。
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code in the repo contains the variables and tasks for a feature we will
    not cover here, as the content we are downloading from GitHub can take up a lot
    of space on your drive. These tasks are included to remove any unneeded files.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库中的代码包含了一些变量和任务，这些任务属于我们这里不涉及的功能，因为我们从 GitHub 下载的内容可能会占用你硬盘上的大量空间。这些任务的目的是删除不需要的文件。
- en: So, now that we have an idea of the steps we need to automate, let’s dive straight
    in.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了需要自动化的步骤的概念，让我们直接开始吧。
- en: First, let’s look at the variables, which can be found in `roles/openscap/default/main.yml`,
    and that we will be using within our tasks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下变量，这些变量可以在 `roles/openscap/default/main.yml` 中找到，并且我们将在任务中使用这些变量。
- en: 'Start with the option that, if set to `true`, will execute the remediation
    Playbook and Bash script:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下选项开始，如果设置为 `true`，将执行修复 Playbook 和 Bash 脚本：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we have the packages needed to run OpenSCAP and OpenSCAP itself:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有运行 OpenSCAP 所需的包和 OpenSCAP 本身：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then we have information to download the content from GitHub; note that we
    are passing the API URL and not the direct download link (more on why later in
    the chapter):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有了从 GitHub 下载内容的信息；请注意，我们传递的是 API URL，而不是直接下载链接（稍后在本章会详细说明为什么这样做）：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we have a long list of filenames and details on the profile we need to
    use:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一长串文件名和我们需要使用的配置文件的详细信息：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that we are trying not to hardcode any values; for example, when referring
    to the operating system, we use `{{ ansible_facts.distribution | lower }}{{ ansible_facts.distribution_version
    | replace('.','') }}`, which, in our case, gives us `ubuntu2204`. This means that
    if OpenSCAP supports it, we can run our Playbook on other Ubuntu distributions
    without making any changes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们尽量不硬编码任何值；例如，在引用操作系统时，我们使用 `{{ ansible_facts.distribution | lower }}{{
    ansible_facts.distribution_version | replace('.','') }}`，在我们的例子中，它给我们的是 `ubuntu2204`。这意味着如果
    OpenSCAP 支持它，我们可以在其他 Ubuntu 发行版上运行我们的 Playbook，而无需做任何更改。
- en: 'The tasks that use these variables can be found in `roles/openscap/tasks/main.yml`;
    we begin with two tasks that install OpenSCAP, the first of which makes sure that
    the APT cache and our operating system are both up to date:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些变量的任务可以在 `roles/openscap/tasks/main.yml` 中找到；我们从两个任务开始安装 OpenSCAP，第一个任务确保
    APT 缓存和我们的操作系统都是最新的：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The tasks immediately after installing OpenSCAP itself and the other packages
    we need:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 OpenSCAP 本身及我们需要的其他软件包的任务：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we create the directory where we will be storing the OpenSCAP content
    we will be downloading from GitHub:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个目录，用于存储我们从 GitHub 下载的 OpenSCAP 内容：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With our destination folder in place, we can now download the content and unarchive
    it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好目标文件夹后，我们现在可以下载内容并解压：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On the face of it, while it looks a little complicated, there is quite a bit
    going on; let’s break down how we are getting the value to populate into the `src`
    key.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，虽然它看起来有点复杂，但实际上有很多内容在运行；让我们拆解一下如何获取值以填充 `src` 键。
- en: 'We use Ansible’s `lookup` plugin to fetch and process data from the GitHub
    API, giving us the latest release information for the OpenSCAP Content GitHub
    repository:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Ansible 的 `lookup` 插件从 GitHub API 获取并处理数据，从而获取 OpenSCAP 内容 GitHub 仓库的最新发布信息：
- en: '`{{ lookup(''url'', ''{{ openscap_download.openscap_github_release_api_url
    }}'', split_lines=false) }}`: The `lookup` plugin is being used here with the
    `url` lookup type, which fetches data from the given URL that is specified by
    the `openscap_download.openscap_github_release_api_url` variable, which points
    to the API endpoint for the latest release of a GitHub repository ([https://api.github.com/repos/ComplianceAsCode/content/releases/latest](https://api.github.com/repos/ComplianceAsCode/content/releases/latest)).
    The `split_lines=false` parameter ensures that the fetched content is not split
    into lines, preserving its JSON structure.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{ lookup(''url'', ''{{ openscap_download.openscap_github_release_api_url
    }}'', split_lines=false) }}`: 这里使用了 `lookup` 插件与 `url` 查找类型，它从由 `openscap_download.openscap_github_release_api_url`
    变量指定的给定 URL 获取数据，该变量指向 GitHub 仓库最新发布的 API 端点（[https://api.github.com/repos/ComplianceAsCode/content/releases/latest](https://api.github.com/repos/ComplianceAsCode/content/releases/latest)）。`split_lines=false`
    参数确保获取的内容不会按行拆分，保持其 JSON 结构。'
- en: '`| from_json`: This part of the code takes the output from the `lookup` plugin,
    which is expected to be a JSON string, and converts it into an Ansible data structure
    (such as a dictionary or a list) that can be further processed.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| from_json`: 这部分代码将 `lookup` 插件的输出（预期为 JSON 字符串）转换为 Ansible 数据结构（例如字典或列表），以便进一步处理。'
- en: '``| json_query(''assets[?content_type==`application/zip`].browser_download_url'')``:
    This uses the `json_query` filter with a JMESPath expression to query the converted
    JSON data. The ``''assets[?content_type==`application/zip`].browser_download_url''``
    query looks for items in the `assets` array where `content_type` is `application/zip`,
    and then extracts `browser_download_url`. This URL is typically used to directly
    download the asset from a browser.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``| json_query(''assets[?content_type==`application/zip`].browser_download_url'')``:
    这使用 `json_query` 过滤器和 JMESPath 表达式来查询转换后的 JSON 数据。``''assets[?content_type==`application/zip`].browser_download_url''``
    查询会查找 `assets` 数组中 `content_type` 为 `application/zip` 的项，然后提取 `browser_download_url`。这个
    URL 通常用于直接从浏览器下载资产。'
- en: '`| last`: Finally, the `last` filter is used to get the last URL from the list
    of URLs returned by the `json_query` filter. We are doing this as there might
    be multiple assets with the `application/zip` content type, but we are only interested
    in the most recent or last one listed.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`| last`: 最后，使用 `last` 过滤器从 `json_query` 过滤器返回的 URL 列表中获取最后一个 URL。这样做是因为可能有多个
    `application/zip` 内容类型的资产，但我们只关心最新或最后一个列出的。'
- en: This means that we do not have to hardcode the version number of the latest
    release into our Playbook, which is helpful as the OpenSCAP `content` repo is
    updated at least once every few weeks.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不需要在 Playbook 中硬编码最新发布的版本号，这一点很有帮助，因为 OpenSCAP `content` 仓库至少每隔几周就会更新一次。
- en: 'The other options we are passing to the `ansible.builtin.unarchive` module
    are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 `ansible.builtin.unarchive` 模块的其他选项如下：
- en: '`dest`: The destination directory on the target machine where the archive will
    be extracted is specified'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dest`: 指定要将归档文件解压到的目标机器上的目标目录。'
- en: '`creates`: This parameter is used as a conditional check to prevent re-downloading
    and extracting the archive if a particular file exists'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`creates`: 该参数作为条件检查，用于在特定文件存在时防止重新下载和解压归档文件。'
- en: '`list_files`: When set to `true`, this option lists all the files in the archive
    file; we will use this list to copy the files to our destination folder'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list_files`: 当设置为 `true` 时，此选项列出归档文件中的所有文件；我们将使用此列表将文件复制到目标文件夹。'
- en: '`remote_src`: Setting this to `true` indicates that the source archive is located
    on a remote server, not on the control machine running Ansible; this is needed
    to download content directly from a URL'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remote_src`: 设置为 `true` 表示源归档文件位于远程服务器上，而不是在运行 Ansible 的控制机器上；这在直接从 URL 下载内容时是必需的。'
- en: 'The following two tasks move the files to the root of `openscap_download.dest`
    as they would have been unarchived to a folder containing the version number –
    which we don’t want to use, as it could change between runs:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个任务将文件移动到 `openscap_download.dest` 的根目录，因为它们会被解压到一个包含版本号的文件夹中——我们不希望使用该文件夹，因为它在不同的执行之间可能会发生变化：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that we are only running these tasks when the task that downloads the files
    has changed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只会在下载文件的任务发生变化时才运行这些任务。
- en: 'The final bit of information we need before we can run the OpenSCAP scan is
    which profile to use. To get this, we need to run the command to print information
    on the profiles available for our operating system:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以运行 OpenSCAP 扫描之前，我们需要的最后一项信息是使用哪个配置文件。为了获取这个信息，我们需要运行命令打印出适用于我们操作系统的配置文件信息：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we have the information on the available profiles registered as `scap_info`,
    we can filter this list based on the contents of `openscap_scan.profile_search`
    and set a fact:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了注册为 `scap_info` 的可用配置文件信息，我们可以根据 `openscap_scan.profile_search` 的内容过滤此列表并设置一个事实：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With the fact set, we can run the scan itself:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好事实后，我们可以运行扫描任务：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, we are suppressing the output by using `no_log: true`; this
    is because we don’t really need to see the output at this stage and can ignore
    errors, like in the previous role where we ran WPScan and OSWAP ZAP.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，我们通过使用 `no_log: true` 来抑制输出；这是因为在此阶段我们不需要查看输出，并且可以忽略错误，就像我们在之前的角色中运行 WPScan
    和 OSWAP ZAP 时一样。'
- en: 'Now that we have the output of the scan, we need to create a folder on our
    Ansible host to copy the output files to the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了扫描的输出，我们需要在我们的 Ansible 主机上创建一个文件夹，将输出文件复制到以下位置：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we are using `delegate_to` to ensure that Ansible runs the task
    on `localhost`, and we are telling it not to become a privileged user.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在使用 `delegate_to` 来确保 Ansible 在 `localhost` 上运行任务，并且我们告诉它不要以特权用户身份运行。
- en: 'Now we can `fetch` the `output.xml` and `report.html` files:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以 `fetch` `output.xml` 和 `report.html` 文件：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we need to generate the guide and remediation files:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要生成指南和修复文件：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You may have noticed we are not saving a file here; we are just registering
    the output. That is because all of the content for the guide is output to the
    screen when the command is run, so rather than direct the output to a file on
    the virtual machine and copy it, we can capture the output and then create a file
    on our local machine that contains this content, essentially a fancy *copy* +
    *paste* from the remote host to our local one:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在这里没有保存文件；我们只是注册了输出。这是因为指南的所有内容都在命令执行时输出到屏幕上，所以我们与其将输出直接写入虚拟机上的文件再复制，不如直接捕获输出，然后在本地机器上创建一个包含这些内容的文件，基本上是将内容从远程主机复制粘贴到本地：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is then repeated for the remediation Ansible Playbook:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于修复的 Ansible Playbook 也是如此：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then again, for the remediation Bash script:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，对于修复的 Bash 脚本：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The remaining tasks in the role deal with the remediation work, starting with
    the playbook:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 角色中的其余任务处理修复工作，从 playbook 开始：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, as we never kept a copy of the bash script on the target virtual machine,
    we need to copy it back there:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，由于我们从未在目标虚拟机上保留过 bash 脚本的副本，我们需要将它复制回去：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once copied, we can run the script:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 文件复制完成后，我们可以运行脚本：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With that task, the role is complete, and we now have all the pieces in place
    to run our playbook.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了该任务后，角色就完成了，现在我们已经准备好运行我们的 playbook。
- en: Running the playbook
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 playbook
- en: 'In [*Chapter 1*](B21620_01.xhtml#_idTextAnchor017), *Installing and Running
    Ansible*, we covered the installation and usage of Multipass; since then, we have
    been launching our local virtual machines using the same commands. In this chapter,
    as we need a little more disk space and RAM, we are going to be adding a few extra
    options when we launch the virtual machine:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 1 章*](B21620_01.xhtml#_idTextAnchor017)《安装与运行 Ansible》中，我们介绍了 Multipass
    的安装和使用；从那时起，我们一直使用相同的命令启动本地虚拟机。在本章中，由于需要更多的磁盘空间和 RAM，我们将在启动虚拟机时添加一些额外的选项：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once the virtual machine has launched, you can get the IP address of the host
    by running the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦虚拟机启动，你可以通过运行以下命令获取主机的 IP 地址：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once you have the IP address, create a copy of `hosts.example`, calling its
    `hosts` and updating the IP address as we have done in previous chapters. Once
    your `hosts` inventory file is in place, we can start to run the playbook, starting
    with the OpenSCAP scan:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了 IP 地址，创建一个 `hosts.example` 的副本，命名为 `hosts` 并更新 IP 地址，正如我们在之前的章节中所做的那样。将
    `hosts` 库文件准备好后，我们可以开始运行剧本，首先进行 OpenSCAP 扫描：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, we are running using the `openscap` tag and setting the `scap_options_remediation`
    variable to `true`; if you recall, the default for this variable is `false`, meaning
    the remediation tasks will be executed during this playbook run.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了 `openscap` 标签，并将 `scap_options_remediation` 变量设置为 `true`；如果你还记得，默认情况下该变量为
    `false`，意味着修复任务将在此剧本运行时执行。
- en: Once completed, you will find several files in the output folder on your local
    machine; if you are not following along, then you can find a copy of the output
    at [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples/01-scap_options_remediation_true](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples/01-scap_options_remediation_true).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你将在本地机器的输出文件夹中找到几个文件；如果你没有跟着操作，你可以在 [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples/01-scap_options_remediation_true](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples/01-scap_options_remediation_true)
    找到输出的副本。
- en: 'As you can see from the following screen, on the initial run, we had 98 failed
    results:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下屏幕可以看到，在初次运行时，我们有 98 个失败的结果：
- en: '![Figure 14.1 – The initial results](img/B21620_14_01.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – 初始结果](img/B21620_14_01.jpg)'
- en: Figure 14.1 – The initial results
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 初始结果
- en: 'As we ran the remediation tasks as part of the playbook run, we know that the
    score should now be improved, so let’s rerun the playbook – this time skipping
    the remediation tasks altogether:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在剧本运行过程中执行了修复任务，所以我们知道分数应该已经提高，因此让我们重新运行剧本——这次完全跳过修复任务：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once completed, you should have another folder of results; again, you can view
    the results at [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples/02-scap_options_remediation_false](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples/02-scap_options_remediation_false):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该会得到一个结果文件夹；同样，你可以在 [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples/02-scap_options_remediation_false](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples/02-scap_options_remediation_false)
    查看结果：
- en: '![Figure 14.2 – The updated results](img/B21620_14_02.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – 更新后的结果](img/B21620_14_02.jpg)'
- en: Figure 14.2 – The updated results
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 更新后的结果
- en: As you can see, this has dramatically improved the score, and we only have six
    failures this time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这显著提高了得分，这次我们只有六个失败。
- en: 'Next, we need to install WordPress; let’s start afresh with that. To make a
    fresh start, run the following commands to terminate the virtual machine and replace
    it with a new one:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装 WordPress；让我们从头开始。为了重新开始，运行以下命令终止虚拟机，并用新虚拟机替换它：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Update the `hosts` file with the new IP address and then run the following
    command to install WordPress:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `hosts` 文件中的新 IP 地址，然后运行以下命令安装 WordPress：
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'With WordPress installed, you can run the WPScan and OSWAP ZAP scans with the
    following command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 WordPress 后，你可以使用以下命令运行 WPScan 和 OSWAP ZAP 扫描：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Once completed, you will have the scan results in the output folder; you can
    find examples of the results at [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples).
    The folder also contains the entire output from each of the playbook runs so far
    up to this point in the chapter.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你将在输出文件夹中找到扫描结果；你可以在[https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter14/examples)找到结果的示例。该文件夹还包含了本章到目前为止每次运行playbook的完整输出。
- en: 'Also, as mentioned at the start of the chapter, you can run each of the scans
    independently of each other using the following commands:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如本章开始时提到的，你可以使用以下命令独立运行每一个扫描：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once you have finished running the playbooks, you can remove the virtual machine
    by running the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了运行playbook的操作，可以通过运行以下命令来删除虚拟机：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With the virtual machine cleaned up, that concludes our look at using Ansible
    to scan and harden our server.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机已清理完毕，这也就结束了我们使用Ansible扫描和加固服务器的过程。
- en: Before we move on to the next chapter, I recommend you look at the remediation
    playbook, which was generated when we first ran OpenSCAP.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一章之前，我建议你查看修复playbook，它是在我们首次运行OpenSCAP时生成的。
- en: It can be found at [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/examples/01-scap_options_remediation_true/ansiblevm-playbook.yml](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/examples/01-scap_options_remediation_true/ansiblevm-playbook.yml),
    and as you can see, it contains over 4,600 lines of code!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在[https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/examples/01-scap_options_remediation_true/ansiblevm-playbook.yml](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/blob/main/Chapter14/examples/01-scap_options_remediation_true/ansiblevm-playbook.yml)找到，正如你所看到的，它包含了超过4,600行代码！
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we generated a playbook to remediate any CIS level-1 non-compliance
    errors found during a scan. As well as being cool, it is also convenient if you
    imagine you are running a few dozen servers that all need to be compliant and
    that all need an entire audit history.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们生成了一个playbook，用来修复在扫描中发现的任何CIS 1级不合规错误。它不仅很酷，而且如果你想象一下自己正在管理几十台需要合规并且都需要完整审计历史的服务器，它也非常方便。
- en: You now have the foundations of a playbook that you can use to target those
    hosts daily, audit them, and store the results away from the host itself. Also,
    if you need to, depending on your configuration, you have a way of automatically
    resolving any non-conformance found during the scan.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个playbook的基础，可以用它每天针对这些主机进行操作、审计它们，并将结果保存在主机本身之外。此外，根据你的配置，如果需要，你也可以自动解决扫描中发现的任何不合规问题。
- en: We also ran scans against our WordPress installation and again stored the results
    away from the host itself – while the WPScan and OSWAP ZAP scans didn’t include
    any remediation, you could quickly review the results and update your WordPress
    deployment script to remediate the issues raised at deployment time.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还对我们的WordPress安装进行了扫描，并将结果存储在主机本身之外——尽管WPScan和OWASP ZAP的扫描没有包括任何修复措施，但你可以快速查看结果，并在部署时更新你的WordPress部署脚本以修复所发现的问题。
- en: So far, we have been running our Ansible Playbooks from our local machine; in
    the next chapter, it is time to move from running our Ansible code from our local
    machines into the cloud and look at how we can use Azure DevOps Pipelines and
    GitHub Actions to execute our playbooks.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在从本地机器运行Ansible Playbook；在下一章，我们将从本地机器运行Ansible代码转移到云端，并了解如何使用Azure
    DevOps Pipelines和GitHub Actions来执行我们的playbook。
