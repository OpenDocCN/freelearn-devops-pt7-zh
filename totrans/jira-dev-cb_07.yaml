- en: Chapter 7. Programming Issues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 编程问题
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating an issue from your plugin
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从插件创建问题
- en: Creating subtasks on an issue
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在问题上创建子任务
- en: Updating an issue
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新问题
- en: Deleting an issue
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除问题
- en: Adding new issue operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的问题操作
- en: Conditions on issue operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题操作的条件
- en: Working with attachments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理附件
- en: Time tracking and worklog management
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间跟踪和工作日志管理
- en: Working with comments on issues
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理问题上的评论
- en: Programming Change Logs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程变更日志
- en: Programming Issue Links
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程问题链接
- en: Validations on issue linking
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题链接验证
- en: Discarding fields while cloning!
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆时丢弃字段！
- en: JavaScript tricks on issue fields
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在问题字段上的JavaScript技巧
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: We have so far seen how to develop custom fields, workflows, Reports & Gadgets,
    JQL functions, and other pluggable things associated with them. In this chapter,
    we will learn about programming "issues", that is, creating, editing, or deleting
    issues, creating new issue operations, and managing the various other operations
    available on issues via JIRA APIs etc.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了如何开发自定义字段、工作流、报告和小工具、JQL函数以及与之相关的其他可插拔组件。在本章中，我们将学习如何编程“问题”，即创建、编辑或删除问题，创建新的问题操作，以及通过JIRA
    API等管理与问题相关的各种操作。
- en: Creating an issue from a plugin
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从插件创建问题
- en: In this recipe, we will see how to create an issue from a plugin programmatically.
    Prior to version 4.1, JIRA used `IssueManager` to create an issue. From JIRA 4.1,
    there is this `IssueService` class that drives the issue operations. Since `IssueService`
    is recommended over `IssueManager`, we will use it in our recipes to create an
    issue.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何通过编程方式从插件创建问题。在4.1版本之前，JIRA使用`IssueManager`来创建问题。从JIRA 4.1开始，推出了`IssueService`类来驱动问题操作。由于`IssueService`被推荐代替`IssueManager`，我们将在本教程中使用它来创建问题。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'The main advantage of `IssueService` over the `IssueManager` class is that
    it takes care of the validation and error handling. The following are the steps
    to create an issue using the `IssueService`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`IssueService`相较于`IssueManager`类的主要优点在于它处理了验证和错误处理。以下是使用`IssueService`创建问题的步骤：'
- en: 'Create an instance of the `IssueService` class. You can either inject it in
    the constructor or get it from the `ComponentManager`, as shown:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`IssueService`类的实例。您可以在构造函数中注入它，或像下面所示通过`ComponentManager`获取它：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create the issue input parameters. In this step, we will set all the values
    that are required to create the issue using the `IssueInputParameters` class.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建问题输入参数。在这一步中，我们将设置所有创建问题所需的值，这些值将通过`IssueInputParameters`类来定义。
- en: Create an instance of the `IssueInputParameters` class.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`IssueInputParameters`类的实例。
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Populate the `IssueInputParameters` with the values required to create the
    issue as shown in the next few lines of code:'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用下几行代码，将所需的值填充到`IssueInputParameters`中，以创建问题：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Make sure all the required values like project, issue type, summary, and other
    mandatory values required when the issue is created using the user interface is
    set on the `IssueInputParameters`.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在通过用户界面创建问题时，所有必填的值（如项目、问题类型、摘要及其他必要的字段）都已设置在`IssueInputParameters`中。
- en: Here, we have used test values, but make sure to replace them with appropriate
    values. For example, the project, issue type ID, priority ID, Fix version IDs,
    reporter, and assignee should have appropriate values.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用了测试值，但请确保将其替换为适当的值。例如，项目、问题类型ID、优先级ID、修复版本ID、报告人和受理人应具有适当的值。
- en: Validate the input parameters using `IssueService`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`IssueService`验证输入参数。
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the `user` is the one creating the issue. The validation is done based
    on the user permissions and the `createValidationResult` variable will have errors
    if the validation fails due to permission issues or due to invalid input parameters!
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`user`是创建问题的用户。验证是基于用户权限进行的，如果由于权限问题或无效的输入参数导致验证失败，`createValidationResult`变量将包含错误！
- en: If the `createValidationResult` is valid, create the issue using `IssueService`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`createValidationResult`有效，则使用`IssueService`创建问题。
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we use the `createValidationResult` object to create the issue, as it
    already has the processed input parameters. If the result is not valid, handle
    the errors as shown in the following code:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用`createValidationResult`对象来创建问题，因为它已经包含了处理过的输入参数。如果结果无效，请按照以下代码中的方式处理错误：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we just print the error to the console if the result is invalid. The `errorMessages`
    will have all non-field-specific errors like permission issue-related errors,
    and so on, but any field-specific errors, like input validation errors, will appear
    in the `errors` map where the key will be the field name. We should handle both
    the error types as appropriate.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，如果结果无效，我们只是将错误打印到控制台。`errorMessages`将包含所有非字段特定的错误，如权限问题相关的错误等，而任何字段特定的错误，如输入验证错误，将出现在`errors`映射中，键将是字段名称。我们应该适当地处理这两种错误类型。
- en: After the creation of an issue, check if the `createResult` is valid or not.
    If not, handle it appropriately. The `createResult` object will have errors only
    if there is a severe problem with JIRA (for example, one can't communicate with
    the DB, the workflow has changed since you invoked validate, and so on).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建问题后，检查`createResult`是否有效。如果无效，适当处理。只有在JIRA出现严重问题时，`createResult`对象才会包含错误（例如，无法与数据库通信，工作流在调用验证后发生变化等）。
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here again, we just print the error to the console.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们再次将错误打印到控制台。
- en: 'If `createResult` is valid, then the issue is created successfully and you
    can retrieve it as:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`createResult`有效，那么问题已成功创建，您可以像下面这样获取它：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: By using `IssueService`, JIRA now validates the inputs we give using the rules
    we have set up in JIRA via the user interfaces, such as the mandatory fields,
    permission checks, individual field validations, and so on. Behind the scenes,
    it still uses the `IssueManager` class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`IssueService`，JIRA现在会根据我们在JIRA界面上设置的规则来验证我们输入的数据，例如强制字段、权限检查、单个字段验证等。幕后，它仍然使用`IssueManager`类。
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: As mentioned before, prior to JIRA 4.1, we need to use the `IssueManager` class
    to create the issues. It can still be used in JIRA 4.1+, but this is not recommended
    as it overrides all the validations. Here is how we do it, if it is required.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在JIRA 4.1之前，我们需要使用`IssueManager`类来创建问题。它在JIRA 4.1及以上版本中仍然可以使用，但不推荐使用，因为它会覆盖所有验证。如果需要，下面是我们如何操作的。
- en: Using IssueManager to create the issue
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`IssueManager`来创建问题
- en: 'Follow these steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Initialize an issue object using the `IssueFactory` class:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`IssueFactory`类初始化问题对象：
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Set all the fields required on the issue object:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置问题对象所需的所有字段：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create the issue using `IssueManager:`
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`IssueManager`创建问题：
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Handle `CreateException` to capture any errors.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理`CreateException`以捕捉任何错误。
- en: Creating subtasks on an issue
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在问题上创建子任务
- en: In this recipe, we will see how to create a subtask on an existing issue programmatically.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何在现有问题上通过编程方式创建子任务。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'There are two steps in creating a subtask:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建子任务的步骤有两个：
- en: Create an issue object. A subtask is nothing but an issue object in the backend.
    The only difference is that it has a parent issue associated with it. So, when
    we create a subtask issue object, we will have to define the parent issue in addition
    to what we normally do while creating a normal issue.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建问题对象。子任务在后台实际上就是一个问题对象。唯一的区别是它有一个关联的父问题。所以，当我们创建子任务问题对象时，我们除了通常创建普通问题时所做的操作外，还需要定义父问题。
- en: Link the newly created subtask issue to the parent issue.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的子任务问题与父问题关联。
- en: 'Let''s see the steps in more detail:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解一下这些步骤：
- en: Create the subtask issue object similar to how we created the issue in the previous
    recipe. Here, the `IssueInputParameters` is constructed (after changing the methods
    like `setIssueTypeId()` appropriately).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建子任务问题对象，类似于我们在前一个示例中创建问题的方式。在这里，构造`IssueInputParameters`（在适当修改`setIssueTypeId()`等方法之后）。
- en: For this issue, we will use the `validateSubTaskCreate` method instead of `validateCreate`,
    which takes an extra parameter `parentId`.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个问题，我们将使用`validateSubTaskCreate`方法，而不是`validateCreate`，该方法多了一个参数`parentId`。
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, parent is the issue object on which we are creating the subtask.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，父项是我们正在创建子任务的父问题对象。
- en: Create an issue after checking for errors, as we have seen before.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查错误后创建问题，正如我们之前所看到的。
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a link between the newly created subtask issue and the parent issue:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新创建的子任务问题与父问题之间的链接：
- en: Get an instance of `SubTaskManager`. You can either inject it in the constructor
    or get it from `ComponentManager`.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`SubTaskManager`的实例。您可以通过构造函数注入它，也可以从`ComponentManager`中获取它。
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create the subtask link.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建子任务链接。
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The subtask should now be created with a link back to the original parent issue.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子任务现在应该已创建，并且与原始父问题相关联。
- en: See also
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*Creating an Issue from your plugin*'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从插件创建问题*'
- en: Updating an issue
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新问题
- en: In this recipe, let's look at editing an existing issue.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，让我们看看如何编辑现有问题。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行此操作...
- en: 'Let''s assume that we have an existing issue object. We will just modify the
    `Summary` to a new summary. Following are the steps to do the same:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个现有的问题对象。我们只需将`Summary`修改为一个新的摘要。以下是执行相同操作的步骤：
- en: 'Create the `IssueInputParameters` object with the input fields that need to
    be modified:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用需要修改的输入字段创建`IssueInputParameters`对象：
- en: '[PRE15]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In JIRA 4.1.x version, there is a bug, because of which we need to populate
    `IssueInputParameters` with all the current fields on the issue along with the
    modified field to make sure the existing values are not lost in an update. However,
    it is resolved in JIRA 4.2+ and hence the previous code is enough to modify the
    summary alone.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在JIRA 4.1.x版本中，由于一个错误，我们需要用所有当前的字段填充`IssueInputParameters`，并与修改过的字段一起，以确保在更新时不会丢失现有值。然而，在JIRA
    4.2+版本中，该问题已解决，因此前面的代码仅用于修改摘要即可。
- en: 'Still, if you do not want to retain the existing values and just want the summary
    on the issue to be updated, you can set the `retainExistingValuesWhenParameterNotProvided`
    flag as shown:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你不希望保留现有值，并且只想更新问题的摘要，你可以像下面这样设置`retainExistingValuesWhenParameterNotProvided`标志：
- en: '[PRE16]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Validate the input parameters using `IssueService`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`IssueService`验证输入参数：
- en: '[PRE17]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the issue is the existing issue object.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的问题是现有的问题对象。
- en: 'If `updateValidationResult` is valid, update the issue:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`updateValidationResult`有效，请更新问题：
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If it is not valid, handle the errors as we did while creating the issue.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果无效，请像创建问题时那样处理错误。
- en: 'Validate the `updateResult` and handle the error if any. If it is not valid,
    the updated issue object can be retrieved as:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`updateResult`并处理任何错误。如果无效，可以通过以下方式获取更新后的问题对象：
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Deleting an issue
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除问题
- en: In this recipe, let us look at deleting an issue programmatically.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，让我们看看如何通过编程删除问题。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行此操作...
- en: 'Let us assume that we have an existing issue object. For deletion as well,
    we will use the `IssueService` class. Following are the steps to do it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个现有的问题对象。对于删除操作，我们也将使用`IssueService`类。以下是执行此操作的步骤：
- en: Validate the delete operation on the issue using `IssueService`
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`IssueService`验证删除操作：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the issue is the existing issue object that needs to be deleted.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的问题是需要删除的现有问题对象。
- en: 'If `deleteValidationResult` is valid, invoke the delete operation:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`deleteValidationResult`有效，请调用删除操作：
- en: '[PRE21]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the `deleteValidationResult` is invalid, handle the errors appropriately.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`deleteValidationResult`无效，请适当地处理错误。
- en: Confirm whether the deletion was successful by checking `deleteErrors` ErrorCollection.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查`deleteErrors` ErrorCollection确认删除是否成功。
- en: '[PRE22]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Adding new issue operations
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新的问题操作
- en: In this recipe, we will look at adding new operations to an issue. The existing
    issue operations include **Edit** **Issue**, **Clone** **Issue**, and so on, and
    most of the time, people tend to look for similar operations with variations or
    entirely new operations that they can perform on an issue.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将讨论如何向问题中添加新的操作。现有的问题操作包括**编辑** **问题**、**克隆** **问题**等，大多数时候，人们倾向于寻找类似的操作变体或完全新的操作来处理问题。
- en: Prior to JIRA 4.1, the issue operations were added using the Issue Operations
    Plugin Module ([http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module](http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module)).
    But since JIRA 4.1, new issue operations are added using **Web Item Plugin Module**
    ([http://confluence.atlassian.com/display/JIRADEV/Web+Item+Plugin+Module](http://confluence.atlassian.com/display/JIRADEV/Web+Item+Plugin+Module)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在JIRA 4.1之前，问题操作是通过问题操作插件模块添加的（[http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module](http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module)）。但从JIRA
    4.1开始，新的问题操作是通过**Web项插件模块**添加的（[http://confluence.atlassian.com/display/JIRADEV/Web+Item+Plugin+Module](http://confluence.atlassian.com/display/JIRADEV/Web+Item+Plugin+Module)）。
- en: A **Web** **Item** **Plugin** module is a generic module that is used to define
    links in various application menus. One such menu is the issue operations menu.
    We will see more about the web items module and how it can be used to enhance
    the UI, later in this book; so, in this recipe, we will only concentrate on using
    the web-item module to create issue operations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web** **Item** **Plugin** 模块是一个通用模块，用于在各种应用菜单中定义链接。其中一个菜单就是问题操作菜单。我们将在本书后续部分看到更多关于网页项模块以及它如何用于增强
    UI 的内容；因此，在本食谱中，我们将只集中讨论如何使用网页项模块来创建问题操作。'
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a skeleton plugin using Atlassian Plugin SDK.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Atlassian Plugin SDK 创建一个框架插件。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Creating a web item is pretty easy! All we need to do is to place it in the
    appropriate section. There are already defined web sections in JIRA and we can
    add more sections using the **Web** **Section** module, if needed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个网页项非常简单！我们只需将其放置在合适的部分即可。JIRA 中已经定义了网页部分，如果需要，我们可以使用 **Web** **Section**
    模块来添加更多部分。
- en: 'Let us create a new operation that lets us administer the project of an issue
    when we are on the view issue page. All we need here is to add an operation that
    takes us to the **Administer** **Project** page. Following are the steps to create
    the new operation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新操作，当我们在查看问题页面时，可以管理问题的项目。我们需要做的只是添加一个操作，将我们带到 **管理** **项目** 页面。以下是创建新操作的步骤：
- en: Identify the web section where the new operation should be placed.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定新操作应该放置的网页部分。
- en: 'For issue operations, JIRA already has multiple web sections defined. We can
    add our new operation on any one of the sections. The following is a diagram from
    the Atlassian documentation detailing on each of the available web sections for
    the issue operations:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于问题操作，JIRA 已经定义了多个网页部分。我们可以在其中任何一个部分添加我们的新操作。以下是来自 Atlassian 文档的示意图，详细描述了每个可用的网页部分，用于问题操作：
- en: '![How to do it...](img/1803-07-01.jpg)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现...](img/1803-07-01.jpg)'
- en: For example, if we want to add a new operation along with **Move**, **Link**,
    and so on, we need to add the new web item under the **operations-operations**
    section. If you are rather hoping to add it right at the top, along with **Edit**,
    **Assign**, and **Comment**, the section must be **operations-top-level**. We
    can reorder the operation using the `weight` attribute.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，如果我们想添加一个新操作，并且与 **移动**、**链接** 等一起出现，我们需要将新网页项添加到 **operations-operations**
    部分。如果你希望将它添加到顶部，和 **编辑**、**分配**、**评论** 一起显示，则该部分必须是 **operations-top-level**。我们可以使用
    `weight` 属性重新排序操作。
- en: 'Define the web item module in the plugin descriptor with the section identified
    in the previous step! For our example, the module definition in `atlassian-plugin.xml`
    will look like the following:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在插件描述符中使用前面步骤中标识的部分来定义网页项模块！对于我们的示例，`atlassian-plugin.xml`中的模块定义将如下所示：
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, it has a unique `key` and a human-readable `name`. The section
    here is `operations-operations`. The `weight` attribute is used to reorder the
    operations as we saw earlier and here we use weight as 100 to put it at the bottom
    of the list.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，它有一个独特的 `key` 和一个可读的 `name`。这里的部分是 `operations-operations`。`weight` 属性用于重新排序操作，如我们之前所见，这里使用权重
    100 将其放置在列表底部。
- en: The `label` is the name of the operation that will appear to the user. We can
    add a `tooltip` as well, which can have a friendly description of the operation.
    The next part, that is, `link` attribute, is the most important one as that links
    us to the operation that we want to perform. Essentially, it is just a link and
    hence you can use it to redirect to anywhere, the Atlassian site, for example.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`label` 是将显示给用户的操作名称。我们还可以添加一个 `tooltip`，它可以包含该操作的友好描述。接下来的部分，即 `link` 属性，是最重要的部分，因为它将我们链接到我们想要执行的操作。实际上，它只是一个链接，因此你可以将其重定向到任何地方，例如
    Atlassian 网站。'
- en: In our example, we need to take the user to the *administer* project area. Luckily,
    in this case, we know the action to be invoked as it is an existing action in
    JIRA. All we need to do is to invoke the `ViewProject` action by passing the project
    ID as pid. The issue object is available on the view issue page as `$issue` and
    hence we can retrieve the project ID on the link as `${issue.project.id}`.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们需要将用户带到 *管理* 项目区域。幸运的是，在这种情况下，我们知道要调用的操作，因为它是 JIRA 中的一个现有操作。我们需要做的就是通过传递项目
    ID（作为 pid）来调用 `ViewProject` 操作。问题对象在查看问题页面上作为 `$issue` 可用，因此我们可以在链接中通过 `${issue.project.id}`
    获取项目 ID。
- en: In cases where we need to do new things, we will have to create an action by
    ourselves and point the link to the same. We will see more about creating new
    actions and extending actions later in the book.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们需要做新事物的情况下，我们必须自己创建一个动作并将链接指向相应的位置。我们将在本书后面了解如何创建新的动作并扩展动作。
- en: Package the plugin and deploy it.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打包插件并进行部署。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'At runtime, you will see a new operation on the **View** **Issue** page on
    the **More** **Actions** drop-down menu, as shown in the next screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，你将在 **查看** **问题** 页面上的 **更多** **操作** 下拉菜单中看到一个新的操作，具体如下一张截图所示：
- en: '![How it works...](img/1803-07-02.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1803-07-02.jpg)'
- en: After clicking on the link, the **Administer** **Project** screen will appear,
    as expected. As you might notice, the URL is populated with the correct `pid`
    from the expression `${issue.project.id}`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 点击链接后，**管理** **项目** 屏幕将如预期出现。如你所见，URL 已填充来自表达式 `${issue.project.id}` 的正确 `pid`。
- en: Also, just change the section or weight and see how the operation appears at
    various places on the screen!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，只需更改部分或权重，查看操作在屏幕上不同位置的显示情况！
- en: There's more...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Prior to JIRA 4.1, The **Issue** **Operations** module was used in creating
    new issue operations. It is outside the scope of the book, though you can find
    the details in the Atlassian documentation at: [http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module](http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module)
    .'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JIRA 4.1 之前，**问题** **操作** 模块用于创建新的问题操作。尽管此部分不在本书的范围内，但你可以在 Atlassian 文档中找到相关细节：[http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module](http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module)。
- en: See also
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*Extending* a *Webwork* *action* *in* *JIRA*'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在* *JIRA* 中 *扩展* *Webwork* *动作*'
- en: '*Adding* *new* *Links* *in* *the* *UI*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在* *UI* 中 *添加* *新* *链接*'
- en: Conditions on issue operations
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题操作中的条件
- en: When new operations are created, it is often a requirement to hide them or show
    them, based on the permissions or state of the issue or something else. JIRA allows
    conditions to be added while defining the web items, and when the conditions are
    not satisfied, the web item won't show up!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建新操作时，通常需要根据权限、问题状态或其他因素来隐藏或显示它们。JIRA 允许在定义 web 项目时添加条件，当条件不满足时，web 项目将不会显示！
- en: In this recipe, we will lock down the new issue operation we created in the
    previous recipe to *Project* *Administrators* exclusively.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将限制仅 *项目* *管理员* 才能使用之前创建的新问题操作。
- en: Getting ready...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中...
- en: Create the **Manage** **Project** issue operation, as explained in the previous
    recipe.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 **管理** **项目** 问题操作，如前面所述的食谱中所解释的。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Following are the steps to add a new condition to an issue operation''s web
    item:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将新条件添加到问题操作的 web 项目的步骤：
- en: Create the `condition` class. The class should implement the `com.atlassian.plugin.web.Condition`
    interface, but it is recommended to extend `com.atlassian.jira.plugin.webfragment.conditions.AbstractIssueCondition`
    when creating an issue condition.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `condition` 类。该类应该实现 `com.atlassian.plugin.web.Condition` 接口，但在创建问题条件时，建议扩展
    `com.atlassian.jira.plugin.webfragment.conditions.AbstractIssueCondition`。
- en: 'While extending `AbstractIssueCondition`, we will have to implement the `shouldDisplay`
    method, as shown here:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在扩展 `AbstractIssueCondition` 时，我们必须实现 `shouldDisplay` 方法，如下所示：
- en: '[PRE24]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, a `true` value is returned if the user has the `PROJECT_ADMIN` permission
    on the project. That is all we need on the `condition` class.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，如果用户具有项目上的 `PROJECT_ADMIN` 权限，则返回 `true` 值。这就是 `condition` 类中所需的一切。
- en: Include the `condition` in the web item.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 web 项目中包含 `condition`。
- en: '[PRE25]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is possible to invert a condition by using the invert flag, as shown:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过使用反转标志来反转条件，如下所示：
- en: '[PRE26]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Condition elements can also take optional parameters, as shown:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 条件元素也可以接受可选参数，如下所示：
- en: '[PRE27]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The parameters can be retrieved in the `condition` class by overriding the `init(Map
    params)` method. Here, `params` is a map of string key/value pairs that hold these
    parameters, in which case, the Map will have permission as the key, and the value
    passed (sysadmin in the example) can be accessed using the key and can then be
    used in passing or failing the condition.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过重写 `init(Map params)` 方法，在 `condition` 类中检索参数。在这里，`params` 是一个包含字符串键值对的映射，用来保存这些参数。在这种情况下，Map
    将权限作为键，传递的值（例如 sysadmin）可以通过该键访问，然后可以用于通过或失败条件。
- en: For example, the following code in the conditions class will get you the appropriate
    permission type.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，以下条件类中的代码将帮助你获取适当的权限类型。
- en: '[PRE28]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It is also possible to combine multiple conditions using the `conditions` element.
    `conditions` element will have multiple condition elements connected through logical
    AND (default) or OR condition.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也可以使用`conditions`元素组合多个条件。`conditions`元素将通过逻辑“与”（默认）或“或”条件连接多个条件元素。
- en: 'For example, if we want to make our example operation available to both project
    administrators as well JIRA System Administrators, we can do it using an `OR`
    condition, as shown:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果我们希望将我们的示例操作同时提供给项目管理员和JIRA系统管理员，我们可以使用`OR`条件来实现，如下所示：
- en: '[PRE29]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Package the plugin and deploy it.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打包插件并进行部署。
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once the plugin is deployed, we can go and check the operation on the View Issue
    Page, as we did in the previous chapter. If you are a Project Administrator (or
    a JIRA's system admin, depending on which condition you used), you will see the
    operation. If the user doesn't have the permissions, the operation won't be shown.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦插件部署完成，我们可以像上一章那样检查“查看问题页面”上的操作。如果你是项目管理员（或JIRA的系统管理员，取决于你使用的条件），你会看到该操作。如果用户没有权限，则该操作将不会显示。
- en: 'For example, if we added a **Manage** **Project** issue operation and limited
    it only to project admin, and a **New** **Manage** **Project** operation, and
    limited it to project admin or JIRA''s system admin, a logged in **Project** **Admin**
    would see both the operations, but a logged in **Admin** will see only the latter
    operation as shown in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们添加了**管理** **项目**问题操作，并且只限制给项目管理员，再添加一个**新建** **管理** **项目**操作，且限制给项目管理员或JIRA的系统管理员，已登录的**项目**
    **管理员**会看到两个操作，而已登录的**管理员**则只会看到后者操作，如下截图所示：
- en: '![How it works...](img/1803-07-03.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1803-07-03.jpg)'
- en: Working with attachments
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理附件
- en: Attachments feature is a useful feature in JIRA, and it sometimes helps to manage
    the attachments on an issue through the JIRA APIs. In this recipe, we will learn
    how to work with attachments using the JIRA API.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 附件功能是JIRA中的一个有用特性，有时可以通过JIRA API帮助管理问题中的附件。在本教程中，我们将学习如何使用JIRA API处理附件。
- en: There are three major operations that can be done on attachments - Create, Read
    , and Delete. We will see each of them in this recipe.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对附件可以执行三种主要操作——创建、读取和删除。我们将在本教程中详细讲解每个操作。
- en: Getting ready...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正在准备中...
- en: Make sure the attachments are enabled in your JIRA instance. You can do this
    from **Administration** **|** **Global** **Settings** **|** **Attachments**, as
    mentioned at [http://confluence.atlassian.com/display/JIRA/Configuring+File+Attachments](http://confluence.atlassian.com/display/JIRA/Configuring+File+Attachments).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在你的JIRA实例中启用了附件功能。你可以通过**管理** **|** **全局设置** **|** **附件**来完成此操作，详细信息见 [http://confluence.atlassian.com/display/JIRA/Configuring+File+Attachments](http://confluence.atlassian.com/display/JIRA/Configuring+File+Attachments)。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: All the operations on the attachments can be performed using the `AttachmentManager`
    API. The `AttachmentManager` can be retrieved either by injecting it in the constructor
    or from the `ComponentManager` class, as shown:.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对附件的所有操作都可以通过`AttachmentManager` API来执行。可以通过构造函数注入或从`ComponentManager`类中检索`AttachmentManager`，如示例所示。
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Creating an attachment**'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建附件**'
- en: 'An attachment can be created on an issue using the `createAttachment` method
    on the `AttachmentManager`, as shown:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`AttachmentManager`上的`createAttachment`方法在问题上创建附件，如下所示：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following are the arguments:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是参数：
- en: The `fileName` here needs to be the full path to the file on the server. You
    can also create a File object by uploading from the client machine, depending
    on the requirement.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的`fileName`需要是文件在服务器上的完整路径。你也可以根据需求通过从客户端机器上传来创建一个文件对象。
- en: '`newFileName` is the name with which the file will be attached to the issue,
    and it can be different from the original filename.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newFileName`是文件将附加到问题上的名称，它可以与原始文件名不同。'
- en: The third parameter is the `contentType` of the file. In this case, we are uploading
    a text file and hence the content type is text/plain.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是文件的`contentType`。在本例中，我们上传的是一个文本文件，因此内容类型是text/plain。
- en: '`user` is the user who is attaching the file'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`是上传文件的用户'
- en: '`issue` is the issue to which the file will be attached'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`issue`是文件将附加到的那个问题'
- en: 'If you also want to set a list of properties on an attachment as a key/value
    pair and create the attachment on a specific **time**, it can be done using the
    overloaded method `createAttachment`, which takes two extra parameters: `attachmentProperties`,
    a Map containing the key/value properties and `createdTime` which is of type `java.util.Date`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还希望将一组属性设置为附件的键/值对，并在特定的**时间**创建附件，可以使用重载方法`createAttachment`，该方法接受两个额外的参数：`attachmentProperties`，一个包含键/值属性的Map，以及`createdTime`，它的类型是`java.util.Date`。
- en: These properties will be stored in the database using `PropertySet`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性将通过`PropertySet`存储在数据库中。
- en: '**Reading attachments on an issue**'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在问题中读取附件**'
- en: '`AttachmentManager` has a method to retrieve the list of attachments, of type
    `com.atlassian.jira.issue.attachment.Attachment`, available on an issue. The following
    is how we do it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttachmentManager`有一个方法可以检索附件列表，类型为`com.atlassian.jira.issue.attachment.Attachment`，该列表可在问题上使用。以下是如何做到这一点：'
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The object attachment holds all the information of the attachment, including
    any properties set during the creation of the attachment.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 附件对象保存了附件的所有信息，包括在创建附件时设置的任何属性。
- en: '**Deleting an attachment**'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**删除附件**'
- en: All you need to do here is to retrieve the attachment object that needs to be
    deleted and invoke the `deleteAttachment` method on `AttachmentManager`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的就是获取需要删除的附件对象，并在`AttachmentManager`上调用`deleteAttachment`方法。
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, attachment is an attachment that can be retrieved using the getAttachment(id)
    method or by iterating on the list of attachments retrieved above.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的附件是可以通过`getAttachment(id)`方法或通过遍历上面获取的附件列表来检索的附件。
- en: There's more...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: '`AttachmentManager` also has other useful methods like `attachmentsEnabled()`,
    `isScreenshotAppletEnabled()`, `isScreenshotAppletSupportedByOS()`, and so on,
    to check whether the respective functionality is enabled or not.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttachmentManager`还具有其他有用的方法，如`attachmentsEnabled()`、`isScreenshotAppletEnabled()`、`isScreenshotAppletSupportedByOS()`等，用于检查相应的功能是否已启用。'
- en: 'Check out: [http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/AttachmentManager.html](http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/AttachmentManager.html)
    for a full list of available methods.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 查看：[http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/AttachmentManager.html](http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/AttachmentManager.html)获取可用方法的完整列表。
- en: Time tracking and worklog management
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间跟踪和工作日志管理
- en: Time tracking is one of the biggest pluses for any issue tracking system. JIRA's
    time tracking is highly configurable and gives plenty of options to manage the
    work done and the remaining time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 时间跟踪是任何问题跟踪系统的最大优势之一。JIRA的时间跟踪高度可配置，并提供了许多选项来管理已完成的工作和剩余时间。
- en: Even though the time tracking in JIRA can be done using the JIRA UI, many users
    want to do it from the customized pages or third-party applications or plugins.
    In this recipe, we will see how to do time tracking using the JIRA APIs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在JIRA中可以通过JIRA UI进行时间跟踪，但许多用户希望通过自定义页面、第三方应用程序或插件来进行。 在这个教程中，我们将学习如何使用JIRA
    API进行时间跟踪。
- en: 'Before we start, each of the operations on worklogs, namely, create, edit,
    or delete, have different modes. Whenever one of these operations is performed,
    we can adjust the remaining amount of work to be done in the following ways:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，工作日志的每个操作，即创建、编辑或删除，都有不同的模式。每当执行其中一个操作时，我们可以通过以下方式调整剩余的工作量：
- en: Let JIRA adjust the remaining work automatically.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让JIRA自动调整剩余工作量。
- en: For example, if the remaining estimate is 2 hours and if we log 30 minutes,
    JIRA will automatically adjust the remaining estimate to 1 hour 30 minutes.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果剩余估算时间是2小时，并且我们记录了30分钟，JIRA将自动将剩余估算时间调整为1小时30分钟。
- en: Enter a new remaining estimate time while performing the operations.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行操作时输入新的剩余估算时间。
- en: For example, if the remaining estimate is 2 hours and if we log 30 minutes,
    we can force JIRA to change the remaining estimate to 1 hour (instead of the automatically
    calculated 1 hour 30 minutes).
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果剩余估算时间是2小时，如果我们记录了30分钟，我们可以强制JIRA将剩余估算时间更改为1小时（而不是自动计算的1小时30分钟）。
- en: Adjust the remaining estimate or in other words reduce a specific amount of
    time from the remaining estimate
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整剩余估算时间，或者换句话说，从剩余估算时间中减少特定的时间量。
- en: For example, if the remaining estimate is 2 hours and if we log 30 minutes,
    we can force JIRA to reduce the remaining estimate by 1 hour 30 minutes (instead
    of automatically reducing the logged 30 minutes). When we do that, the remaining
    estimate will come out to be 30 minutes.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果剩余估算是 2 小时，且我们记录了 30 分钟的工作时间，我们可以强制 JIRA 将剩余估算减少 1 小时 30 分钟（而不是自动减少已记录的
    30 分钟）。这样，剩余估算将变为 30 分钟。
- en: Leave the remaining estimate as it is.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持剩余估算不变。
- en: Getting ready...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Make sure time tracking is turned on as explained at [http://confluence.atlassian.com/display/JIRA/Configuring+Time+Tracking](http://confluence.atlassian.com/display/JIRA/Configuring+Time+Tracking).
    It can be enabled from the **Administration** | **Global** **Settings** | **Time**
    **Tracking** menu.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 确保按[http://confluence.atlassian.com/display/JIRA/Configuring+Time+Tracking](http://confluence.atlassian.com/display/JIRA/Configuring+Time+Tracking)中的说明开启时间追踪功能。可以从
    **管理** | **全局** **设置** | **时间** **追踪** 菜单中启用该功能。
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Worklogs in JIRA can be managed using the `WorklogService` class. It does all
    the major operations like creating worklogs, updating them, or deleting them,
    and that too, in all the four different modes we have seen earlier.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JIRA 中，工作日志可以通过 `WorklogService` 类进行管理。它执行所有主要操作，如创建工作日志、更新工作日志或删除工作日志，并且支持我们之前看到的四种不同模式。
- en: 'We will see how to create worklogs, or in other words, log work in the following
    four modes:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在以下四种模式中创建工作日志，或者说记录工作：
- en: Auto adjusting the remaining estimate
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动调整剩余估算
- en: Logging work and retaining the remaining estimate
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录工作并保留剩余估算
- en: Logging work with a new remaining estimate
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的剩余估算记录工作
- en: Logging work and adjusting the remaining estimate by a value
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录工作并按某个值调整剩余估算
- en: Auto adjusting the remaining estimate
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动调整剩余估算
- en: Create the JIRA Service Context for the user who is logging work.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为记录工作时间的用户创建 JIRA 服务上下文。
- en: '[PRE34]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Create a `WorklogInputParametersImpl.Builder` object to create the parameters
    needed for the worklog creation.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `WorklogInputParametersImpl.Builder` 对象，以创建工作日志所需的参数。
- en: '[PRE35]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, the issue is the issue on which work is logged, and `timeSpent` is the
    time that we are going to log in. `timeSpent` is a String that represents the
    format in which time is entered in JIRA , that is, `*w *d *h *m` (representing
    weeks, days, hours, and minutes, where * can be any number).
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，问题是记录工作时间的那个问题，`timeSpent` 是我们将记录的时间。`timeSpent` 是一个字符串，表示在 JIRA 中输入时间的格式，即
    `*w *d *h *m`（表示周、天、小时和分钟，其中 * 可以是任何数字）。
- en: '`startDate` here can be the date from where the work has started. We can also
    optionally add comments and set the worklog visibility to certain groups or project
    roles! Set these parameters as null when the worklog is visible to all.'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的 `startDate` 可以是工作开始的日期。我们还可以选择性地添加评论，并将工作日志的可见性设置为特定的组或项目角色！当工作日志对所有人可见时，请将这些参数设置为
    null。
- en: Create the `WorklogInputParameters` object from the builder and validate it
    using the `WorklogService`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从构建器中创建 `WorklogInputParameters` 对象，并使用 `WorklogService` 对其进行验证。
- en: '[PRE36]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Create the worklog using `WorklogService`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `WorklogService` 创建工作日志。
- en: '[PRE37]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, as you can see, the method invoked is `createAndAutoAdjustRemainingEstimate`,
    which will create the worklog and automatically adjust the remaining estimate
    on the issue.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，如您所见，调用的方法是 `createAndAutoAdjustRemainingEstimate`，它将创建工作日志并自动调整问题上的剩余估算。
- en: The method takes as input the service context we created, the `WorklogResult`
    object after validating the input parameters, and a Boolean which will be used
    to dispatch an event, if needed. When the Boolean value is true, the **Work**
    **Logged** **On** **Issue** event is fired.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法接受我们创建的服务上下文，经过验证的 `WorklogResult` 对象和一个布尔值作为输入，如果需要，它将用于触发事件。当布尔值为 true
    时，将触发 **工作** **已记录** **在** **问题** 事件。
- en: With this, the work will be logged on the issue.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，工作将会被记录到问题中。
- en: Logging work and retaining the remaining estimate
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录工作并保留剩余估算
- en: 'Here, the first three steps are similar to what was discussed in the *Auto*
    *adjusting* *remaining* *estimate* section. The only difference is that the method
    invoked on `WorklogService` is `createAndRetainRemainingEstimate` instead of `createAndAutoAdjustRemainingEstimate`.
    The full code is as shown:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，前三个步骤与 *自动* *调整* *剩余* *估算* 部分讨论的内容相似。唯一的区别是，调用 `WorklogService` 的方法是 `createAndRetainRemainingEstimate`
    而不是 `createAndAutoAdjustRemainingEstimate`。完整的代码如下所示：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Logging work with a new remaining estimate
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用新的剩余估算记录工作
- en: Here the first two steps are similar to what was discussed in the *Auto* *adjusting*
    *remaining* *estimate* section.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的前两个步骤与“自动调整剩余估算”部分讨论的内容相似。
- en: Create the JIRA Service Context for the user who is logging work.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为记录工作的用户创建 JIRA 服务上下文。
- en: '[PRE39]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Create a `WorklogInputParametersImpl.Builder` object to create the parameters
    needed for the worklog creation.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `WorklogInputParametersImpl.Builder` 对象，以创建工作日志所需的参数。
- en: '[PRE40]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Create the New Estimate Input Parameters from the Builder object.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从构建器对象创建新的估算输入参数。
- en: '[PRE41]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we specify the `newEstimate`, which is a String representation similar
    to `timeSpent`. The `newEstimate` will be set as the remaining estimate on the
    issue.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们指定了 `newEstimate`，它是一个类似于 `timeSpent` 的字符串表示。`newEstimate` 将作为问题上的剩余估算设置。
- en: 'Create the `WorklogResult` from `WorklogNewEstimateInputParameters` using `WorklogService`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `WorklogService` 从 `WorklogNewEstimateInputParameters` 创建 `WorklogResult`：
- en: '[PRE42]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The result here will be an instance of `WorklogNewEstimateResult`, which will
    be used in the next step!
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的结果将是 `WorklogNewEstimateResult` 的一个实例，将在下一步中使用！
- en: Create the worklog using `WorklogService`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `WorklogService` 创建工作日志。
- en: '[PRE43]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the method used is `createWithNewRemainingEstimate`, which sets the `newEstimate`
    as the remaining estimate on the issue, after logging the work using `timeSpent`!
    As you can see, the result object is converted to `WorklogNewEstimateResult`.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，使用的方法是 `createWithNewRemainingEstimate`，它将 `newEstimate` 设置为问题上的剩余估算，在使用
    `timeSpent` 记录工作后！如您所见，结果对象转换为 `WorklogNewEstimateResult`。
- en: Logging work and adjusting the remaining estimate by a value
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录工作并通过值调整剩余估算
- en: Here the process is much similar to the above. The only difference is that the
    `adjustmentAmount` method is used on Builder instead of `newEstimate` and `validateCreateWithManuallyAdjustedEstimate`
    is used on `WorklogService` to create the worklog. Also, the `WorklogResult` is
    an instance of `WorklogAdjustmentAmountResult`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，过程与上述非常相似。唯一的区别是，在构建器上使用 `adjustmentAmount` 方法，而不是 `newEstimate`，并且在 `WorklogService`
    上使用 `validateCreateWithManuallyAdjustedEstimate` 来创建工作日志。此外，`WorklogResult` 是
    `WorklogAdjustmentAmountResult` 的一个实例。
- en: 'The code is as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Once we create or update the worklogs using the `WorklogService` API, the changes
    will be reflected on the issue under the **Work** **Log** tab, as shown in the
    following screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用 `WorklogService` API 创建或更新工作日志，更改将反映在问题的**工作日志**选项卡下，如下所示的屏幕截图：
- en: '![How it works...](img/1803-07-04.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1803-07-04.jpg)'
- en: You can also see that the graphical representation of time tracking reflects
    these changes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到时间跟踪的图形表示反映了这些更改。
- en: 'When a worklog is deleted, it appears on the **Change** **history** as shown:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除工作日志时，它将显示在**更改历史**中，如下所示：
- en: '![How it works...](img/1803-07-05.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1803-07-05.jpg)'
- en: There's more
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: Updating worklogs
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新工作日志
- en: Updating worklogs is similar to the creating them in many ways. Here, we pass
    the ID of the `Worklog` object to be updated instead of the issue we pass while
    creating a worklog. And, of course, the methods invoked on `WorklogService` are
    different. The following is the code to update a given **Worklog** for the first
    mode where the remaining estimate is auto adjusted.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，更新工作日志与创建工作日志类似。在这里，我们传递要更新的 `Worklog` 对象的 ID，而不是创建工作日志时传递的问题 ID。当然，`WorklogService`
    上调用的方法也不同。以下是更新给定 **Worklog** 的代码，其第一模式会自动调整剩余估算。
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, a *builder* is created by passing the worklog ID, which is unique
    across issues. The `WorklogResult` here is created using the `validateUpdate`
    method and the worklog is finally updated using the `updateAndAutoAdjustRemainingEstimate`
    method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过传递工作日志 ID 创建了一个 *builder*，该 ID 在所有问题中是唯一的。这里的 `WorklogResult` 是使用 `validateUpdate`
    方法创建的，最终使用 `updateAndAutoAdjustRemainingEstimate` 方法更新工作日志。
- en: 'The other modes are also similar to how we created the worklogs. Let us quickly
    see how to update a worklog with a new remaining estimate:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模式与我们创建工作日志的方式类似。让我们快速看看如何使用新的剩余估算更新工作日志：
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The above looks pretty familiar, doesn't it? It is similar to creating a worklog
    with a new estimate, except that we call the respective update methods, as discussed
    before.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上面看起来非常熟悉，不是吗？它类似于使用新估算创建工作日志，只是我们调用了相应的更新方法，如前所述。
- en: We can update a worklog by retaining the estimate and also adjust it by a specified
    amount of time from the remaining estimate in the same way.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过保留估算并按照相同方式从剩余估算中调整指定的时间量来更新工作日志。
- en: Deleting worklogs
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除工作日志
- en: Deleting a worklog is slightly different and maybe easier than creating or updating
    one, as it doesn't involve building the input parameters.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 删除工作日志稍微不同，可能比创建或更新工作日志更简单，因为它不涉及构建输入参数。
- en: Auto Adjusting remaining estimate
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动调整剩余估算
- en: 'All we need here is the worklog ID and to create the JIRA Service Context.
    The code is as shown below:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需要工作日志ID并创建JIRA服务上下文。代码如下所示：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, the `validateDelete` method takes the worklog ID as input and creates
    a `WorklogResult`, which is then used in the `deleteAndAutoAdjustRemainingEstimate`
    method.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`validateDelete`方法将工作日志ID作为输入，并创建`WorklogResult`，然后在`deleteAndAutoAdjustRemainingEstimate`方法中使用。
- en: Deleting a worklog and retaining the remaining estimate
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除工作日志并保留剩余估算
- en: This is done in much the same way as mentioned in the previous section, expect
    that the `deleteAndRetainRemainingEstimate` method is used instead of `deleteAndAutoAdjustRemainingEstimate`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前面提到的方式非常相似，只是使用了`deleteAndRetainRemainingEstimate`方法，而不是`deleteAndAutoAdjustRemainingEstimate`。
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Deleting a worklog with a new remaining estimate
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除带有新剩余估算的工作日志
- en: 'As mentioned before, we don''t create the input parameters while deleting worklogs.
    Instead, the `newEstimate` is used to create `WorklogResult`, which is an instance
    of `WorklogNewEstimateResult`, while validating. The code is as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，删除工作日志时我们不创建输入参数。相反，`newEstimate`用于创建`WorklogResult`，它是`WorklogNewEstimateResult`的实例，同时进行验证。代码如下：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is also pretty much the same as mentioned in the previous section, except
    for the method names.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前面提到的内容基本相同，唯一不同的是方法名称。
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, `adjustmentAmount` is the value that is used to increase the remaining
    estimate on the issue.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`adjustmentAmount`是用于增加问题上剩余估算的值。
- en: Working with comments on issues
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在问题上处理评论
- en: In this recipe, we will see how to manage commenting on issues using the JIRA
    API.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何使用JIRA API管理问题的评论。
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: JIRA uses the `CommentService` class to manage the comments on an issue. Let
    us have a look at all the three major operations—creating, editing, and deleting
    comments. We will also have a look at how to restrict the comment visibility to
    a specific group of people or to a project role.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: JIRA使用`CommentService`类来管理问题上的评论。我们来看看三大操作——创建、编辑和删除评论。我们还将看看如何将评论的可见性限制为特定的人员组或项目角色。
- en: Creating comments on issues
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在问题上创建评论
- en: 'A comment can be added on to an issue as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过如下方式向问题添加评论：
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, `commentString` is the comment we are adding, user is the user adding
    the comment, and issue is the issue on which the comment is added. The fourth
    argument is a boolean that determines whether an event should be dispatched or
    not. If it is true, an `Issue` `Commented` event is thrown.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`commentString`是我们添加的评论，user是添加评论的用户，issue是评论所添加的问题。第四个参数是一个布尔值，用于确定是否应派发事件。如果为真，则会抛出`Issue`
    `Commented`事件。
- en: Creating comments on an issue and restricting it to a project role or group
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在问题上创建评论并将其限制为项目角色或组
- en: If we need to restrict the visibility of the comments, we need to use the overridden
    `create` meth od on the `CommentService` class that takes the role ID and group
    name along with the other attributes. Only one of them should be passed at one
    time.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要限制评论的可见性，我们需要在`CommentService`类中使用重写的`create`方法，该方法需要传入角色ID和组名以及其他属性。每次只能传递其中一个。
- en: In order to restrict the comment visibility to groups, the `Comment` `visibility`
    property under **General** **Configuration** should be set to **Groups** **&**
    **Project** **Roles**. The default is to allow restricting comments only for project
    roles.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将评论的可见性限制为组，我们需要将**常规** **配置**下的`Comment` `visibility`属性设置为**组** **&** **项目角色**。默认情况下，只允许限制评论仅对项目角色可见。
- en: 'For example, the comment can be restricted to a **group** as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以通过如下方式将评论限制为**组**：
- en: '[PRE52]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this group, `group` is the name of the group, and the fifth parameter (`null`)
    is the `roleId`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组中，`group`是组名，第五个参数（`null`）是`roleId`。
- en: 'Restricting to a **role** is done as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 限制为**角色**的方法如下：
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this case, the `group` is `null` and `roleId` is the unique ID of the `ProjectRole`
    that we need to restrict the comment to.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`group`为`null`，`roleId`是我们需要限制评论的`ProjectRole`的唯一ID。
- en: The Boolean to dispatch events can be used in both cases.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值用于派发事件，可以在这两种情况中使用。
- en: Updating comments
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新评论
- en: 'Following are the steps to update a comment:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更新评论的步骤：
- en: Create the `MutableComment` object from the comment to be updated
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从要更新的评论中创建`MutableComment`对象。
- en: '[PRE54]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Modify the comment with the following statement:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下语句修改评论：
- en: '[PRE55]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we update the body of the comment, though we can also update other attributes
    like the author, group level, role level, and so on.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们更新了评论的主体，当然我们也可以更新其他属性，比如作者、组级别、角色级别等等。
- en: 'Update the comment using `CommentService`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CommentService`更新评论：
- en: '[PRE56]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Deleting comments
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除评论
- en: 'A comment can be deleted as shown:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照以下方式删除评论：
- en: '[PRE57]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`comment` is the comment object to be deleted.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`comment`是要删除的评论对象。'
- en: Programming Change Logs
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程变更日志
- en: Tracking changes to an issue is very important. JIRA stores all the changes
    that are done on an issue as change logs along with the information of who made
    the change and when. Sometimes, when we do custom development, we will have to
    update the **Change** **History** by ourselves when something changes on the issue
    by our plugin.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪问题的变更非常重要。JIRA 会存储所有在问题上进行的更改日志，并记录是谁在何时进行了更改。有时，当我们进行自定义开发时，如果插件对问题进行了更改，我们必须手动更新**变更**
    **历史**。
- en: Change Histories are logged as change groups which are a group of one or more
    change items made by a user at any one time. Each change item will be a change
    made on any single field.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 变更历史作为变更组记录，这些变更组由用户在同一时刻进行的一个或多个变更项组成。每个变更项都是对单一字段的更改。
- en: In this recipe, we will see how to add change logs on an issue using the JIRA
    API.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何使用 JIRA API 在问题上添加变更日志。
- en: How to do it...
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Each change item in JIRA is created as a `ChangeItemBean`. `ChangeItemBean`
    can be of two different types—one for **system** fields where the field type is
    `ChangeItemBean.STATIC_FIELD` and another for **custom** fields where the field
    type is `ChangeItemBean.CUSTOM_FIELD`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JIRA 中，每个更改项都作为`ChangeItemBean`创建。`ChangeItemBean`有两种不同的类型—一种是针对**系统**字段，其中字段类型为`ChangeItemBean.STATIC_FIELD`，另一种是针对**自定义**字段，其中字段类型为`ChangeItemBean.CUSTOM_FIELD`。
- en: The following are the steps to add a Change History.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是添加变更历史的步骤。
- en: Create a `ChangeItemBean` for the change that needs to be recorded for every
    item that is changed.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个需要记录变更的项目创建一个`ChangeItemBean`。
- en: '[PRE58]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, the first attribute is the `fieldType` and the second one is the name
    of the field. For system fields of type `ChangeItemBean.STATIC_FIELD`, the name
    can be retrieved from `IssueFieldConstants` class. For example, `IssueFieldConstants.SUMMARY`
    represents the issue summary.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，第一个属性是`fieldType`，第二个属性是字段名称。对于类型为`ChangeItemBean.STATIC_FIELD`的系统字段，名称可以从`IssueFieldConstants`类中获取。例如，`IssueFieldConstants.SUMMARY`表示问题摘要。
- en: The third and fourth arguments are the *old* *value* and the *new* *value* of
    the field respectively.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三和第四个参数分别是字段的*旧* *值*和*新* *值*。
- en: As we know, some of the JIRA fields have an id value and a String value. For
    example, the issue Status has the status name and the corresponding status ID.
    In such cases, we can use an overridden constructor that also takes the old id
    and new id as shown below.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们所知，一些 JIRA 字段有 ID 值和字符串值。例如，问题状态有状态名称和相应的状态 ID。在这种情况下，我们可以使用一个重载构造函数，同时传入旧的
    ID 和新的 ID，如下所示。
- en: '[PRE59]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: For custom fields, we use the field type `ChangeItemBean.CUSTOM_FIELD` and the
    custom field name. Everything else is same.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于自定义字段，我们使用字段类型`ChangeItemBean.CUSTOM_FIELD`和自定义字段名称。其他部分保持不变。
- en: '[PRE60]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It is worth noting that the field name can be manipulated to give any value
    when the `fieldType` is `ChangeItemBean.CUSTOM_FIELD`. It is probably a useful
    feature when you want to programmatically add change logs that are not directly
    relates to a field. Say, for adding a subtask!
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得注意的是，当`fieldType`为`ChangeItemBean.CUSTOM_FIELD`时，字段名称可以被修改为任何值。当你希望以编程方式添加与字段无直接关联的变更日志时，这可能是一个有用的功能。比如，添加一个子任务！
- en: '[PRE61]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Create a change holder and add the change items in to it.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变更持有者，并将变更项添加到其中。
- en: '[PRE62]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Create and store the `changelog` using the items in the `changeHolder` using
    `ChangeLogUtils` class.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ChangeLogUtils`类将`changeHolder`中的项目创建并存储为`changelog`。
- en: '[PRE63]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here **user** is the user making the change. The second and third arguments
    are the original issue and the issue after changes. You can give both the same
    if the change items are explicitly created and added to `changeHolder`.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里**用户**是进行更改的用户。第二个和第三个参数分别是原始问题和更改后的问题。如果更改项是显式创建并添加到`changeHolder`中，你可以将两者设置为相同。
- en: But if we are modifying an issue using the setter methods, an easier way might
    be to pass the original issue object along with the modified issue object (object
    after setter methods are invoked) and set the last argument as `true` which determines
    whether a list of change items needs to be generated from the before and after
    objects. In that case, we don't need to explicitly create `changeItems` and hence
    the third argument can be an empty list. We can still pass additional `changeItems`
    if needed as the third argument in which case both the passed `changeItems` and
    generated `changeItems` (from issue before and after modification) will be created!
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，如果我们使用setter方法修改问题，一个更简单的方法是传递原始问题对象与修改后的问题对象（调用setter方法后的对象），并将最后一个参数设置为`true`，这样就可以决定是否需要从前后的对象生成更改项列表。在这种情况下，我们不需要显式地创建`changeItems`，因此第三个参数可以是一个空列表。如果需要，也可以将附加的`changeItems`作为第三个参数传递，在这种情况下，传递的`changeItems`和由问题修改前后生成的`changeItems`都将被创建！
- en: How it works...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'Once the change logs are added, they will appear in the issues change log panel,
    as shown in the following screenshot:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更改日志添加完成，它们将显示在问题的更改日志面板中，如下图所示：
- en: '![How it works...](img/1803-07-06.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1803-07-06.jpg)'
- en: Notice that the highlighted *change* *log* is added even though there is no
    field named **Some** **Heading**. Also, see how both the ID and name are shown
    for the **Status** field!
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管没有名为**Some** **Heading**的字段，但高亮显示的*更改* *日志*已被添加。此外，还可以看到**状态**字段的ID和名称均被显示！
- en: Programming issue links
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程问题链接
- en: Issue linking is another important feature in JIRA. It helps us to define the
    relationship between issues. In this recipe, we will see how to create links between
    issues and to break them using the JIRA APIs!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接是JIRA中的另一个重要功能。它帮助我们定义问题之间的关系。在本教程中，我们将学习如何使用JIRA API创建问题之间的链接以及如何断开这些链接！
- en: Before we start, an issue link type has an inward and an outward description.
    For every issue link, there will be a source issue and a destination issue. From
    a source issue, we can look up the destination issues by looking up the outward
    links. Similarly, from a destination issue, we can look up the source issues by
    looking up inward links.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，问题链接类型有一个“入向”和一个“出向”描述。对于每个问题链接，都有一个源问题和一个目标问题。从源问题出发，我们可以通过查找出向链接来查找目标问题。同样，从目标问题出发，我们可以通过查找入向链接来查找源问题。
- en: Getting Ready...
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Make sure the Issue Linking feature is turned ON in JIRA and valid link types
    are created. This can be done from **Administration** | **Global** **Settings**
    | **Issue** **Linking**, as explained at [http://confluence.atlassian.com/display/JIRA/Configuring+Issue+Linking](http://confluence.atlassian.com/display/JIRA/Configuring+Issue+Linking)
    .
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在JIRA中启用了问题链接功能并且创建了有效的链接类型。可以通过**管理** | **全局** **设置** | **问题** **链接**来完成此操作，具体内容请参见[http://confluence.atlassian.com/display/JIRA/Configuring+Issue+Linking](http://confluence.atlassian.com/display/JIRA/Configuring+Issue+Linking)。
- en: How to do it...
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Issue Links are managed in JIRA with the help of the `IssueLinkManager` class.
    The following are the steps to create an issue link between two given issues:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 问题链接通过`IssueLinkManager`类在JIRA中进行管理。以下是创建两个给定问题之间问题链接的步骤：
- en: Get the `IssueLinkType` object for the link type we are going to create. This
    can be retrieved using the `IssueLinkTypeManager` class. The `IssueLinkTypeManager`
    class can be retrieved from the `ComponentManager` or can be injected in the constructor.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取我们要创建的链接类型的`IssueLinkType`对象。可以通过`IssueLinkTypeManager`类来获取。`IssueLinkTypeManager`类可以从`ComponentManager`中获取，或者可以在构造函数中注入。
- en: '[PRE64]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here we are getting the `Duplicate` issue link type. Even though the `getIssueLinkTypesByName`
    method returns a Collection, there will be only one link with the same name.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们获取了`Duplicate`问题链接类型。即使`getIssueLinkTypesByName`方法返回的是一个集合，具有相同名称的链接也只有一个。
- en: Create the issue link using the `IssueLinkManager` class. The `IssueLinkManager`
    class can also be retrieved from the `ComponentManager` class or injected in the
    constructor.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`IssueLinkManager`类创建问题链接。`IssueLinkManager`类也可以从`ComponentManager`类中获取，或者在构造函数中注入。
- en: '[PRE65]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, we pass the source and destination issue IDs, in the order mentioned,
    along with the link type ID. The fourth parameter is the sequence, which is of
    type `long`, used to order the links on the user interface. `user` is the user
    who is performing the link action.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们传递源和目标问题的ID，按所述顺序，以及链接类型ID。第四个参数是序列，类型为`long`，用于在用户界面上对链接进行排序。`user`是执行链接操作的用户。
- en: There's more...
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Let's now see how to delete them or just display links.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何删除它们或仅显示链接。
- en: Deleting Issue Links
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除问题链接
- en: 'Following are the steps:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是步骤：
- en: 'Retrieve the `IssueLinkType`, as we did earlier:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照之前的方式检索`IssueLinkType`：
- en: '[PRE66]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Get the `IssueLink` to be deleted using the `IssueLinkManager` class.:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`IssueLinkManager`类获取要删除的`IssueLink`：
- en: '[PRE67]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here the `sourceIssue` and `destIssue` are the source and destination issues,
    respectively.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的`sourceIssue`和`destIssue`分别是源问题和目标问题。
- en: Delete the Link using the `IssueLinkManager` class.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`IssueLinkManager`类删除链接。
- en: '[PRE68]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Retrieving Issue Links on an issue
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在问题上检索问题链接
- en: We can retrieve the inward or outward links on an issue or all the linked issues
    using different methods on the `IssueLinkManager` class.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`IssueLinkManager`类中的不同方法检索问题的内链或外链，或者所有已链接的问题。
- en: 'All inward links can be retrieved as shown:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内链可以按照如下方式检索：
- en: '[PRE69]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, `issue` is the destination object and we are getting all the inward issue
    links and displaying the source issue key.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`issue`是目标对象，我们获取所有内链问题并显示源问题键。
- en: 'Similarly, outward links can be retrieved as shown:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，外链可以按照如下方式检索：
- en: '[PRE70]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, issue is the source object and we are getting all the outward issue links
    and displaying the destination issue key.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，问题是源对象，我们获取所有的外部问题链接并显示目标问题键。
- en: 'All the linked issues can be retrieved in a single method as shown:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 所有已链接的问题可以通过一个方法检索，如下所示：
- en: '[PRE71]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Validations on issue linking
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题链接验证
- en: There are scenarios that we might come across where we need to do extra validations
    while linking. In this recipe, we will quickly look at adding some extra validations
    by extending the existing link issue action in JIRA.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，我们可能会遇到需要进行额外验证的情况。本文将简要介绍如何通过扩展现有的JIRA链接问题动作来添加一些额外的验证。
- en: Getting Ready...
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Create a Skeleton plugin using Atlassian Plugin SDK. It is recommended to read
    the *Extending* *JIRA* *actions* recipe before proceeding.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Atlassian Plugin SDK创建骨架插件。建议在继续之前阅读*扩展* *JIRA* *动作*配方。
- en: How to do it...
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: As we have seen while extending JIRA actions, all we need to do here is to create
    a new webwork action that extends the existing JIRA action and override the required
    method. In this specific case, will be overriding the `doValidation()` method
    to do some extra validation.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在扩展JIRA动作时所见，我们在这里需要做的只是创建一个新的webwork动作，扩展现有的JIRA动作并重写所需的方法。在这个特定的案例中，我们将重写`doValidation()`方法来做一些额外的验证。
- en: Let us, for example, consider that we want to restrict linking to all issues
    of type **New** **Feature**. Following are the steps to do the same.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，我们假设想要限制链接所有**新功能**类型的问题。以下是执行此操作的步骤。
- en: Add a new webwork module in the `atlassian-plugin.xml` with a new action class
    and the same alias as JIRA's link action, `LinkExistingIssue`. Once we do that,
    the new action class will be executed while linking issues.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`atlassian-plugin.xml`中添加一个新的webwork模块，包含一个新的动作类，并且使用与JIRA的链接动作相同的别名`LinkExistingIssue`。这样，我们的新动作类将在链接问题时执行。
- en: '[PRE72]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Create the new class extending the existing action class.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新类，扩展现有的动作类。
- en: '[PRE73]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Override the `doValidation`() method to add extra validation.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`doValidation()`方法以添加额外验证。
- en: '[PRE74]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Add the custom validation as appropriate. In our example, we throw an error
    if any of the issues selected for linking is of type **New** **Feature**. The
    selected issues can be found using the `getLinkKey()` method, which returns a
    String array of selected issue keys.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要添加自定义验证。在我们的示例中，如果任何选中的链接问题是**新功能**类型，我们会抛出错误。选中的问题可以通过`getLinkKey()`方法找到，该方法返回一个包含选中问题键的字符串数组。
- en: '[PRE75]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As you can see, all we do here is check for the issue key and mark it as invalid
    if the issue type is **New** **Feature**. If invalid, we then throw an error for
    those invalid keys.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们在这里做的只是检查问题键，如果问题类型是**新功能**，则将其标记为无效。如果无效，我们会对这些无效的键抛出错误。
- en: Package the plugin and deploy it.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打包插件并进行部署。
- en: We can use the same approach to add extra validations.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的方法来添加额外的验证。
- en: Note
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An action can be overridden only once. Care must be taken not to override it
    again in another plugin (might be a third-party plugin) as only one will be picked
    up.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 动作只能被重写一次。必须小心不要在其他插件（可能是第三方插件）中再次重写，因为只有一个动作会被选中。
- en: How it works...
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let us consider linking to three existing issues, out of which, two are **New**
    **Features**. Once the plugin is deployed, we will see an error as shown:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要链接到三个现有问题，其中两个是**新**的**功能**。插件部署后，我们会看到如下错误：
- en: '![How it works...](img/1803-07-07.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1803-07-07.jpg)'
- en: See also
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*Extending a Webwork action in JIRA*'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 JIRA 中扩展 Webwork 动作*'
- en: Discarding fields while cloning
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在克隆时丢弃字段
- en: Cloning of issues in JIRA is an easy way to replicate an existing issue. While
    cloning, a new issue is created exactly similar to the original issue with identical
    values for all its fields except for a few special ones. The special ones include
    `created` `date`, `updated` `date`, `issue` `key`, `status`, and so on.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JIRA 中克隆问题是一种简单的复制现有问题的方法。克隆时，会创建一个与原始问题完全相同的新问题，所有字段的值与原始问题一致，除了少数几个特殊字段。这些特殊字段包括`created`
    `date`、`updated` `date`、`issue` `key`、`status` 等等。
- en: But, in addition to the special fields JIRA has chosen, we might want to ignore
    a few other fields while cloning an issue. How about a unique custom field? We
    surely don't want to replicate it while cloning?
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，除了 JIRA 已选择的特殊字段外，我们可能还希望在克隆问题时忽略其他几个字段。比如，一个独特的自定义字段呢？我们当然不希望在克隆时复制它。
- en: Here is an easy way to discard any such fields while cloning an issue.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的方法，可以在克隆问题时丢弃任何这样的字段。
- en: Getting ready...
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Create a Skeleton plugin using Atlassian Plugin SDK. It is recommended to read
    the *Extending* *JIRA* *actions* recipe before proceeding.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Atlassian Plugin SDK 创建一个骨架插件。建议在继续之前阅读*扩展* *JIRA* *动作*的配方。
- en: How to do it...
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: As we have seen while extending JIRA actions in the previous recipe, all we
    need to do here is to create a new webwork action that extends the existing JIRA
    Clone action and overrides the required method. In this specific case, will be
    overriding the `setFields()` method to remove the cloning of the specific fields
    we are interested in!
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一个配方中扩展 JIRA 动作时所看到的，我们在这里要做的就是创建一个新的 webwork 动作，扩展现有的 JIRA 克隆动作并覆盖所需的方法。在这个特定的案例中，我们将覆盖`setFields()`方法，以移除我们关心的特定字段的克隆！
- en: 'Let us, for example, say that we want to avoid cloning a unique number field
    named `Test` `Number`. Following are the steps to follow:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们想避免克隆一个名为`Test` `Number`的唯一数字字段。以下是需要遵循的步骤：
- en: Add a new webwork module in the `atlassian-plugin.xml` with a new action class
    and the same alias as JIRA's clone action, `CloneIssueDetails`. Once we do that,
    the new action class will be executed while cloning issues.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`atlassian-plugin.xml`中添加一个新的 webwork 模块，包含一个新的动作类，并使用与 JIRA 克隆动作相同的别名`CloneIssueDetails`。我们这样做后，在克隆问题时，将执行新的动作类。
- en: '[PRE76]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Create the new class extending the existing action class.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类，扩展现有的动作类。
- en: '[PRE77]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Override the `setFields ()` method to set a `null` value for the fields we do
    not want to clone.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`setFields()`方法为我们不想克隆的字段设置`null`值。
- en: '[PRE78]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Add the code to set `null` values. In our example, we set null value for the
    `Test` `Number` custom field.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码以设置`null`值。在我们的例子中，我们为`Test` `Number`自定义字段设置了空值。
- en: '[PRE79]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here we get the cloned issue using the method `getIssueObject` and set the null
    value for the custom field. Don't forget to use the `getCustomFieldObject` method
    by passing the custom field ID if the field name is not unique!
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用`getIssueObject`方法获取克隆后的问题，并为自定义字段设置空值。如果字段名不是唯一的，请不要忘记使用`getCustomFieldObject`方法，并传入自定义字段
    ID！
- en: If we want to set null values for a system field like fix for versions, the
    method is the same.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们想为像版本修复这样的系统字段设置空值，方法是相同的。
- en: '[PRE80]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Package the plugin and deploy it.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打包插件并部署。
- en: Note
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An action can be overridden only once. Care must be taken not to override it
    again in another plugin (might be a third-party plugin) as only one will be picked
    up.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个动作只能被覆盖一次。必须小心避免在另一个插件中再次覆盖它（可能是第三方插件），因为只有一个会被选中。
- en: How it works...
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once the clone operation is invoked, the new action we have created will be
    executed. The clone operation creates a new issue object and copies the values
    to its fields from the original issue. This is done in the `setFields` method.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用克隆操作，我们创建的新动作将被执行。克隆操作会创建一个新的问题对象，并将其字段的值从原始问题复制过来。这是在`setFields`方法中完成的。
- en: It is only logical to override this method and set `null` values for fields
    we do not want to clone. As shown above, the `setFields` method from the super
    class, which is the JIRA's in-built class, is first executed. Once the method
    is executed, the new issue object, which can be retrieved using the method `getIssueObject`,
    has all the values populated. We just reset some of the values by setting them
    to `null`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，覆盖此方法并为我们不想克隆的字段设置 `null` 值是合理的。如上所示，首先执行的是超类中的 `setFields` 方法，即 JIRA
    内置的类。执行该方法后，可以使用 `getIssueObject` 方法获取的新问题对象已填充所有值。我们只需通过将某些值重置为 `null` 来重置它们。
- en: See also
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*Extending* *a* *Webwork* *action* *in* *JIRA*'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*扩展* *JIRA* 中的 *Webwork* *操作*'
- en: JavaScript tricks on issue fields
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对问题字段的 JavaScript 技巧
- en: JIRA provides a lot of options to manage the various fields on an issue. Field
    configuration schemes, screen schemes, and so on, help the JIRA admins to show
    or hide fields, mark them as mandatory, and so on, differently for different issue
    types and projects.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: JIRA 提供了许多选项来管理问题上的各类字段。字段配置方案、屏幕方案等帮助 JIRA 管理员为不同的 issue 类型和项目，显示或隐藏字段、标记字段为必填项等。
- en: Irrespective of how configurable these schemes are, there are still areas where
    we need to perform custom development. For example, if we need to show or hide
    fields, based on the values of another field, then JIRA doesn't have any in-built
    options to do so.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这些方案多么可配置，仍然有一些地方需要我们进行自定义开发。例如，如果我们需要根据另一个字段的值来显示或隐藏字段，JIRA 并没有内置的选项来实现这一点。
- en: Then, what is the best way to deal with this? It is always possible to create
    a new composite custom field that can have multiple fields driven by each other's
    behavior. But probably an easier way—that doesn't need developing a plugin—is
    to drive this using JavaScript. And to make things better, JIRA offers jQuery
    library that can be used to write neat JavaScript code!
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，处理这个问题的最佳方法是什么呢？我们始终可以创建一个新的复合自定义字段，让多个字段根据彼此的行为来驱动。但可能更简单的方式——不需要开发插件——是通过
    JavaScript 来实现。而且，为了让事情更好，JIRA 提供了可以用来编写整洁 JavaScript 代码的 jQuery 库！
- en: However, using JavaScript to handle field behavior can create problems. It limits
    the behavior to the browser, it is client side and is dependent on whether JavaScript
    is enabled or not. But given its advantages and ease of use, most users prefer
    to do it. In this recipe, we will see a small example of using JavaScript to show
    or hide the values of a custom field based on the issue's priority value!
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 JavaScript 来处理字段行为可能会带来一些问题。它将行为限制在浏览器中，是客户端的，并且取决于是否启用了 JavaScript。但鉴于其优势和易用性，大多数用户都更愿意使用它。在本食谱中，我们将展示一个小例子，使用
    JavaScript 根据问题的优先级值来显示或隐藏自定义字段的值！
- en: How to do it...
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Let us assume that we have a custom field named **Why** **Critical?**. The field
    should be shown only if the priority of the issue is **Critical**.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 **Why** **Critical?** 的自定义字段。该字段只有在问题的优先级为 **Critical** 时才会显示。
- en: 'Following are the simple steps to achieve it using JavaScript:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 JavaScript 实现此功能的简单步骤：
- en: Write the JavaScript to achieve the functionality.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 JavaScript 来实现该功能。
- en: In our example, we need to show the **Why** **Critical** field only when the
    priority is Critical. Let us write the JavaScript for these purposes as an example!
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只需要在优先级为 Critical 时显示 **Why** **Critical** 字段。让我们作为一个示例编写 JavaScript
    来实现这一功能！
- en: Identify the ID value for priority. We can get it by looking at the URL while
    editing the priority or from the JIRA database by looking at the `priority` table.
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出优先级的 ID 值。我们可以通过查看编辑优先级时的 URL 或从 JIRA 数据库中的 `priority` 表中获取它。
- en: Identify the ID of the custom field. We can get this also in a similar fashion,
    either by looking at the URL while editing the custom field or from the `customfield`
    table!
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出自定义字段的 ID。我们也可以通过类似的方式获取它，要么通过在编辑自定义字段时查看 URL，要么从`customfield`表中获取！
- en: Write the JavaScript to show or hide the field depending on the priority value.
    Here, we use the JIRA's jQuery library, which has a predefined namespace `AJS`,
    a short name for Atlassian JavaScript!
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 JavaScript 来根据优先级值显示或隐藏字段。在这里，我们使用 JIRA 的 jQuery 库，它具有一个预定义的命名空间 `AJS`，是
    Atlassian JavaScript 的简写！
- en: '[PRE81]'
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here 10170 is the `id` of the `customfield` and hence `customfield_10170` represents
    the unique custom field ID! Also, 2 is the ID of the priority system field.
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里 10170 是 `customfield` 的 `id`，因此 `customfield_10170` 表示唯一的自定义字段 ID！另外，2 是优先级系统字段的
    ID。
- en: In the example, we created a page load event where the script looks at the priority
    value and sets the visibility of the div surrounding the custom field as hidden
    or shown.
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个页面加载事件，脚本查看优先级值并设置围绕自定义字段的`div`的可见性为隐藏或显示。
- en: The following part captures the on load event of the page where custom field
    is in edit mode.
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下部分捕获了页面加载事件，其中自定义字段处于编辑模式。
- en: '[PRE82]'
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: And the following code shows the field, if priority is 2.
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码显示了当优先级为2时的字段。
- en: '[PRE83]'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: For every other priority value, the closet `div` surrounding field is hidden.
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于每个其他优先级值，围绕字段的最接近的`div`会被隐藏。
- en: Add the above JavaScript to the description of the custom field.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上述JavaScript添加到自定义字段的描述中。
- en: The field behavior will be effective on the next reload after the JavaScript
    is added on to the field description.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 字段行为将在JavaScript添加到字段描述后，下一次重新加载时生效。
- en: How it works...
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Whenever the field is rendered under the velocity view in the edit mode, the
    field description is executed along with all the JavaScript code in there!
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 每当字段在编辑模式下通过velocity视图渲染时，字段描述会与其中的所有JavaScript代码一起执行！
- en: 'Once the script is added in the relevant field configuration screen, the field
    will not appear for priority values other than **Critical**, as shown in the next
    screenshot:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本被添加到相关的字段配置屏幕中，字段将不会出现在**关键**以外的优先级值下，如下一个截图所示：
- en: '![How it works...](img/1803-07-08.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1803-07-08.jpg)'
- en: Here, the **Priority** is **Major** (value 3), and hence the field **Why** **Critical?**
    is not available. But the moment the priority is changed to **Critical**, we can
    see the field appearing back on the page.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**优先级**是**重大**（值为3），因此字段**为什么** **关键？** 不可用。但一旦优先级更改为**关键**，我们可以看到该字段重新出现在页面上。
- en: '![How it works...](img/1803-07-09.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1803-07-09.jpg)'
- en: The JavaScript can now be modified to do a lot of other useful stuff! Don't
    forget to modify the scripts according to your needs, specifically your browser
    and your version of JIRA.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，JavaScript可以被修改以执行许多其他有用的操作！不要忘记根据你的需求修改脚本，特别是根据你的浏览器和JIRA版本。
