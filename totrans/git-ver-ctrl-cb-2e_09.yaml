- en: Repository Maintenance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库维护
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下方案：
- en: Pruning remote branches
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修剪远程分支
- en: Running garbage collection manually
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动运行垃圾回收
- en: Turning off automatic garbage collection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭自动垃圾回收
- en: Splitting a repository
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆分仓库
- en: Rewriting history – changing a single file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写历史——修改单个文件
- en: Creating a backup of your repositories as mirror repositories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建仓库备份作为镜像仓库
- en: A quick "how-to" submodule
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速“如何做”子模块
- en: Subtree merging
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子树合并
- en: Submodule versus subtree merging
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子模块与子树合并
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we'll take a look at various tools used for repository maintenance.
    We'll look at how we can easily delete branches in the local repository that have
    been deleted from the remote repository. We'll also see how we can trigger garbage
    collection and how to turn it off. We'll take a look at how a repository can be
    split with the `filter-branch` command, and how the same command can be used to
    rewrite the history of a repository. Finally, we'll take a quick look at how to
    integrate other Git projects into a Git repository as subprojects, with either
    the submodule functionality or the subtree strategy.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨用于仓库维护的各种工具。我们将学习如何轻松删除已从远程仓库删除的本地仓库中的分支。我们还将了解如何触发垃圾回收以及如何关闭它。我们将查看如何使用
    `filter-branch` 命令拆分一个仓库，并了解如何使用相同的命令重写仓库的历史。最后，我们将简要了解如何将其他 Git 项目作为子项目集成到 Git
    仓库中，采用子模块功能或子树策略。
- en: Pruning remote branches
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修剪远程分支
- en: Often, the development of a software project tracked by Git happens on feature
    branches, and, as time goes by, an increasing number of feature branches are merged
    to the mainline. Usually, these feature branches are deleted in the main repository
    (the origin). However, branches are not automatically deleted from all clones
    while fetching and pulling request. Git must explicitly be told to delete branches
    from the local repository that have been deleted from the origin.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个由 Git 跟踪的软件项目的开发是在功能分支上进行的，随着时间的推移，越来越多的功能分支被合并到主干中。通常，这些功能分支会在主仓库（origin）中被删除。然而，分支在所有克隆中不会自动删除，只有在执行拉取（fetch）和拉取请求（pull
    request）时。必须明确告诉 Git 从本地仓库中删除那些已从 origin 仓库删除的分支。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, we''ll set up two repositories and use one of them as a remote for the
    other. We will use the `Git-Version-Control-Second-Edition_hello_world_flow_model`
    repository, but first we''ll clone a repository to a local bare repository:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设置两个仓库，并使用其中一个作为另一个的远程仓库。我们将使用 `Git-Version-Control-Second-Edition_hello_world_flow_model`
    仓库，但首先我们会克隆一个仓库到本地裸仓库：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we''ll clone the newly cloned repository to a local one with a working
    directory:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把新克隆的仓库克隆到一个本地仓库，并附带工作目录：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s delete a couple of merged feature branches in the bare repository:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们删除裸仓库中的几个已合并的功能分支：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, change the directory to your working copy and make sure `develop` branch
    is checked out:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，切换到工作副本目录并确保 `develop` 分支已被检出：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Start by listing all of the branches using the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令列出所有分支：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s try to fetch or pull and see whether anything happens, using the following
    command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试执行拉取或拉取请求，看看是否发生了任何变化，使用以下命令：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The branches are still there, even if they have been deleted in the remote
    repository. We need to tell Git explicitly to delete the branches that have also
    been deleted from the remote repository, using the following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使远程仓库中的分支已被删除，分支仍然存在于本地仓库中。我们需要明确告诉 Git 删除那些已经从远程仓库删除的分支，使用以下命令：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The branches have now also been deleted from our local repository.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分支现在也已从我们的本地仓库中删除。
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Git simply checks the remote-tracking branches under the remote or origin namespace
    and removes branches that are not found on the remote any more.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Git 会检查远程或 origin 命名空间下的远程跟踪分支，并移除那些在远程仓库中已不存在的分支。
- en: There's more...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are several ways to remove the branches from Git that have been deleted
    from the master. It can be done while updating the local repository, as we saw
    with `git fetch --prune`, and also with `git pull --prune`. It can even be performed
    with the `git remote prune origin` command. This will also remove the branches
    from Git that are no longer available on the remote, but it will not update remote-tracking
    branches in the repository.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从 Git 中删除已经从主分支删除的分支。我们可以在更新本地仓库时进行操作，正如我们在使用`git fetch --prune`时所看到的，也可以使用`git
    pull --prune`。甚至可以使用`git remote prune origin`命令来执行。这将删除远程仓库中已不再存在的分支，但不会更新仓库中的远程跟踪分支。
- en: Running garbage collection manually
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动运行垃圾回收
- en: When using Git on a regular basis, you might notice that some commands sometimes
    trigger Git to perform garbage collection and pack loose objects into a pack file
    (Git's objects storage). The garbage collection and packing of loose objects can
    also be triggered manually by executing the `git gc` command. Triggering `git
    gc` is useful if you have a lot of loose objects. A loose object can, for example,
    be a blob, a tree, or a commit. As we saw in [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml),
    *Navigating Git*, `blob-`, `tree-`, and `commit` objects are added to Git's database
    when we add files and create commits. These objects are first stored as unreachable
    objects in Git's object storage as single files inside the `.git/objects` folder.
    Eventually, or by manual request, Git packs the loose objects into pack files,
    which can reduce disk usage. A lot  of objects can become loose after adding many
    files to Git, for example, when starting a new project or after frequent adds
    and commits. Running garbage collection will make sure that loose objects are
    packed, and objects not referred to by any reference or object will be deleted.
    The latter is useful when you have deleted some branches/commits and want to make
    sure that the objects referenced by them are also deleted.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常使用 Git 时，你可能会注意到某些命令有时会触发 Git 执行垃圾回收，并将松散的对象打包成一个包文件（Git 的对象存储）。垃圾回收和松散对象的打包也可以通过执行`git
    gc`命令手动触发。如果你有很多松散对象，触发`git gc`会非常有用。松散对象可以是例如一个 blob、一个树对象或一个提交对象。正如我们在[第 1 章](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml)
    *Git 导航* 中看到的，`blob-`、`tree-`和`commit`对象会在我们添加文件并创建提交时被添加到 Git 的数据库中。这些对象最初作为不可达的对象存储在
    Git 的对象存储中，以单独的文件形式存放在`.git/objects`文件夹中。最终，或者通过手动请求，Git 会将这些松散对象打包成包文件，这样可以减少磁盘使用。添加大量文件到
    Git 后，很多对象会变成松散的对象，例如，当你开始一个新项目或频繁执行添加和提交时。运行垃圾回收将确保松散的对象被打包，并且任何没有被任何引用或对象指向的对象会被删除。当你删除了某些分支或提交，并希望确保它们所引用的对象也被删除时，这一操作尤其有用。
- en: Let's see how we can trigger garbage collection and remove some objects from
    the database.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何触发垃圾回收，并从数据库中移除一些对象。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, we need a repository to perform the garbage collection on. We''ll use
    the same repository as in the previous example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个仓库来执行垃圾回收操作。我们将使用与之前示例相同的仓库：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'First, we''ll check the repository for unpacked objects; we can do this with
    the `count-objects` command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将检查仓库中未打包的对象；我们可以使用`count-objects`命令来执行此操作：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll also check for unreachable objects, which are objects that can''t be
    reached from any reference (tag, branch, or other object). The unreachable objects
    will be deleted when the garbage collection runs. We also check the size of the
    `.git` directory using the following command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将检查不可达的对象，这些对象是无法通过任何引用（标签、分支或其他对象）访问的对象。这些不可达的对象将在垃圾回收运行时被删除。我们还将使用以下命令检查`.git`目录的大小：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are no unreachable objects. This is because we just cloned and haven''t
    actually worked in the repository. If we delete the origin remotely, the remote
    branches (`remotes/origin/*`) will be deleted, and we''ll lose the reference to
    some of the objects in the repository; they''ll be displayed as unreachable while
    running `fsck` and can be garbage collected:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前没有不可达的对象。这是因为我们刚刚克隆了仓库，并未实际进行操作。如果我们删除远程仓库的源（origin），远程分支（`remotes/origin/*`）将会被删除，且我们会失去对某些对象的引用；这些对象在运行`fsck`时会显示为不可达，并且可以被垃圾回收：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can see that we have some unreachable objects due to the deletion of the
    remote. Let''s try to trigger garbage collection manually:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到，由于远程仓库被删除，导致一些不可达的对象。让我们尝试手动触发垃圾回收：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we investigate the repository now, we will see the following:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在检查仓库，我们将看到以下内容：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The object count is smaller. Git has packed the objects to the pack file stored
    in the `.git/objects/pack` folder. The size of the repository is also smaller,
    as Git compresses and optimizes the objects in the pack file. However, there are
    still some unreachable objects left. This is because objects will only be deleted
    if they are older than what is specified in the `gc.pruneexpire` configuration
    option, which defaults to two weeks (`config value: 2.weeks.ago`). We can override
    the default or configured option by running the `--prune=now` option:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '对象的数量变小了。Git 已将这些对象打包到存储在 `.git/objects/pack` 文件夹中的包文件中。仓库的大小也变小了，因为 Git 对包文件中的对象进行了压缩和优化。然而，仍然有一些无法访问的对象残留。这是因为对象只有在它们比
    `gc.pruneexpire` 配置选项指定的时间更久远时才会被删除，而该选项的默认值为两周（`config value: 2.weeks.ago`）。我们可以通过运行
    `--prune=now` 选项来覆盖默认或配置的选项：'
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Investigating the repository gives the following output:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调查该仓库会产生以下输出：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The unreachable objects have been deleted, there are no loose objects, and the
    repository size is smaller now that the objects have been deleted.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 无法访问的对象已被删除，仓库中没有松散的对象，且由于对象已被删除，仓库的大小也变小了。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其工作原理...
- en: The `git gc` command optimizes the repository by compressing file revisions
    and deleting objects that there are no references to. The objects can be commits,
    and so on. On an abandoned (deleted) branch, blobs from invocations of git add,
    commits discarded/redone with `git commit --amend`, or other commands can leave
    objects behind. Objects are, by default, already compressed with `zlib` when they
    are created and, when moved into the pack file, Git makes sure to only store the
    necessary changes. For example, if you change only a single line in a large file,
    storing the entire file in the pack file again would waste a bit of space. Instead,
    Git stores the latest file as a whole in the pack file and only the delta for
    the older version. This is pretty smart, as you are more likely to require the
    latest version of the file, and Git doesn't have to do delta calculations for
    this. This might seem like a contradiction to the information from [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml),
    *Navigating Git*, where we learned that Git stores snapshots and not deltas. However,
    remember how the snapshot is made. Git hashes all of the file content in blobs,
    makes `tree` and `commit` objects, and the commit object describes the full tree
    state with the `root-tree sha-1` hash. Storing objects inside the pack-files has
    no effect on the computation of the tree state. When you check out an earlier
    version of commit, Git makes sure the sha-1 hashes match the branch, commit, or
    tag you requested.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`git gc` 命令通过压缩文件修订版本和删除没有引用的对象来优化仓库。这些对象可以是提交（commits）等。在一个被废弃（删除）的分支上，`git
    add` 的调用、通过 `git commit --amend` 丢弃/重做的提交或其他命令可能会留下对象。对象在创建时默认已经通过 `zlib` 压缩，并且在移入包文件（pack
    file）时，Git 确保只存储必要的更改。例如，如果你只更改了一个大文件中的一行，将整个文件再次存储到包文件中会浪费一些空间。相反，Git 会将最新的文件作为整体存储在包文件中，只存储旧版本的增量（delta）。这非常聪明，因为你更可能需要的是文件的最新版本，并且
    Git 不需要为此进行增量计算。这看起来似乎与[第一章](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml)中学到的 Git
    存储快照而非增量的说法相矛盾。可是，记住快照是如何生成的。Git 对文件内容进行哈希处理，生成 `tree` 和 `commit` 对象，而提交对象（commit
    object）描述了完整的树状态，并通过 `root-tree sha-1` 哈希来表示。存储对象到包文件中不会影响树状态的计算。当你检查早期版本的提交时，Git
    会确保 sha-1 哈希值与所请求的分支、提交或标签匹配。'
- en: Turning off automatic garbage collection
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭自动垃圾回收
- en: The automatic triggering of garbage collection can be turned off so that it
    will not run unless manually triggered. This can be useful if you are searching
    the repository for a lost commit/file and want to make sure that it is not being
    garbage collected while searching (running Git commands).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 自动触发垃圾回收的功能可以关闭，这样它就不会自动运行，除非手动触发。这在你搜索丢失的提交或文件时非常有用，可以确保在搜索过程中（运行 Git 命令时）不会被垃圾回收。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll use the `Git-Version-Control-Cookbook-Second-Edition_hello_world_flow_model`
    repository again for this example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用 `Git-Version-Control-Cookbook-Second-Edition_hello_world_flow_model`
    仓库作为本例：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To switch off automatic garbage collection from being triggered, we need to
    set the `gc.auto` configuration to 0\. First, we''ll check the existing setting,
    and then we can set it and verify the configuration using the following commands:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了关闭自动垃圾回收的触发，我们需要将 `gc.auto` 配置设置为 0。首先，我们将检查现有设置，然后可以使用以下命令设置并验证配置：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can try to run `git gc` with the `--auto` flag, as it will be called
    when normally triggered from an other command:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以尝试使用`git gc`命令并加上`--auto`标志，因为它将在从其他命令触发时被自动调用：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As expected, nothing happens, as the configuration disables automatic garbage
    collection. We can still trigger it manually though (without the `--auto` flag):'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如预期的那样，什么也没发生，因为配置禁用了自动垃圾回收。不过，我们仍然可以手动触发它（不带`--auto`标志）：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Splitting a repository
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分一个仓库
- en: Sometimes, a project tracked with Git is not one logical project, but consists
    of several projects. This may be fully intentional and there is nothing wrong
    with that, but there can also be cases where projects tracked in the same Git
    repository really should belong to two different repositories. You can imagine
    a project where the code base grows and, at some point in time, one of the subprojects
    could have value as an independent project. This can be achieved by splitting
    the subfolders and/or files that contain the project that should have its own
    repository with the full history of commits touching the files and/or folders.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个由 Git 跟踪的项目并不是一个逻辑上的单一项目，而是由多个项目组成的。这可能是完全有意为之，没什么问题，但也可能存在这样的情况，仓库中跟踪的项目确实应该分属于两个不同的仓库。你可以想象一个项目，其中代码库不断增长，在某个时刻，某个子项目可能会成为一个独立的项目。通过拆分包含该子项目的子文件夹和/或文件，可以实现这个目标，同时保留触及这些文件和/或文件夹的完整提交历史。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: In this example, we'll use the JGit repository, so we'll have some history to
    filter through. The subfolders we split into are not really projects, but serve
    well as an example for this exercise.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用 JGit 仓库，这样我们就有一些历史记录可以筛选。我们拆分的子文件夹并不是真正的项目，而是作为此练习的示例。
- en: 'First, clone the JGit repository and create local branches of the remote ones
    using the following command:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，克隆 JGit 仓库，并使用以下命令为远程分支创建本地分支：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Save the name of the current branch in a variable named `current`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前分支的名称保存到一个名为 `current` 的变量中：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the following step, we create local branches from all the remote branches
    in the repository:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们从仓库中的所有远程分支创建本地分支：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we filter the branches. From all the branches (`git branch -a`), we exclude
    branches that match the `$current` variable somewhere in the name (`grep -v $current`).
    Then, we include only the branches that match the remote (`grep remotes`). Finally,
    we exclude all branches with `HEAD` (`grep -v HEAD`). For each of the branches
    (`$br`), we create a local branch with the name given after the last "`/`" in
    the full name of the branch (`git branch ${br##*/} $br`). For example, the branch
    `remotes/origin/stable-0.10` becomes the local branch `stable-0.10`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们过滤分支。从所有分支（`git branch -a`）中，我们排除那些在名称中包含 `$current` 变量的分支（`grep -v $current`）。然后，我们仅包括那些匹配远程仓库的分支（`grep
    remotes`）。最后，我们排除所有带有 `HEAD` 的分支（`grep -v HEAD`）。对于每个分支（`$br`），我们创建一个本地分支，分支名取自该分支全名中最后一个
    "`/`" 后的部分（`git branch ${br##*/} $br`）。例如，`remotes/origin/stable-0.10` 这个分支变成了本地分支
    `stable-0.10`。
- en: 'Now, we''ll prepare a short script that will delete everything apart from the
    input to the shell script from the Git index. Save the following to the `clean-tree` file
    in the folder that contains the JGit repository (not the repository itself):'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将准备一个简短的脚本，该脚本会删除除输入的 Git 索引中的内容之外的所有内容。将以下内容保存为`clean-tree`文件，放在包含 JGit
    仓库的文件夹中（不是仓库本身）：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The short script filters all the files currently in the staging area (`git ls-files`), excluding
    the ones that match the input (`grep -v -E "$1"`). It lists only the first part
    of their `name/path` up to the first "`/`" (`grep -o -E "^[^/\"]"`), and finally
    sorts them by unique entries (`sort -u`). The entries in the remaining list (`$f`)
    are removed from the staging of Git (`git rm -rq --cached --ignore-unmatch $f`).
    The `--cached` option tells Git to remove them from the staging area and `--ignore-unmatched`
    tells Git not to fail if the file does not exist in the staging area. The `-rq`
    option is recursive and quiet respectively.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的脚本过滤所有当前在暂存区中的文件（`git ls-files`），排除与输入匹配的文件（`grep -v -E "$1"`）。它只列出文件的
    `name/path` 的第一部分，直到遇到第一个 "`/`"（`grep -o -E "^[^/\"]"`），最后按唯一条目进行排序（`sort -u`）。剩余列表中的条目（`$f`）将从
    Git 暂存区中移除（`git rm -rq --cached --ignore-unmatch $f`）。`--cached` 选项告诉 Git 从暂存区中删除文件，`--ignore-unmatch`
    告诉 Git 如果文件在暂存区中不存在时不要报错。`-rq` 选项分别表示递归和安静模式。
- en: The staging area contains all the files tracked by Git in the last snapshot
    (commit) and files (modified or new) you have added with `git add`. However, you
    only see differences between the latest commit and the staging area when you run
    `git status`, along with differences between the working tree and the staging
    area.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 暂存区包含 Git 在最后一次快照（提交）中跟踪的所有文件，以及你通过 `git add` 添加的文件（修改或新增）。然而，当你运行 `git status`
    时，你只会看到最新提交和暂存区之间的差异，以及工作树和暂存区之间的差异。
- en: 'Make the file executable using the following command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令使文件具有可执行权限：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we are ready to split out a subpart of the repository.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备好将仓库的一个子部分拆分出来。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we''ll decide which folders and files to keep in the new repository;
    we''ll delete everything from the repository except those files. We''ll store
    the files and folders to be kept in a string separated by `|` so that we can feed
    it to `grep` as a regular expression, as shown in the following command:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要决定哪些文件夹和文件需要保留在新的仓库中；我们会删除仓库中的所有内容，除了那些需要保留的文件。我们会将需要保留的文件和文件夹以 `|` 分隔，存储在一个字符串中，以便将其作为正则表达式传递给
    `grep`，如下所示的命令：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now we are ready to start the conversion of the repository. We'll use the `git
    filter-branch` command, which can rewrite the entire history of the repository; just
    what we need for this task.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备好开始转换仓库了。我们将使用 `git filter-branch` 命令，它可以重写整个仓库的历史；这正是我们需要完成此任务的工具。
- en: Always remember to make sure you have a backup of the repository you are about
    to run `git filter-branch` on, in case something goes wrong.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记得确保在运行 `git filter-branch` 前备份好即将操作的仓库，以防出现意外。
- en: 'We''ll use the `--index-filter` option to filter the branch. The option allows
    us to rewrite the index or staging area just before each commit is recorded, and
    we''ll do this with the `clean-tree` script we created previously. We''ll also
    preserve tags using `cat` as the `tag-name-filter`. We''ll perform the rewrite
    on all branches and remember to use the absolute path to the clean-tree script:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `--index-filter` 选项来过滤分支。该选项允许我们在每个提交记录之前重写索引或暂存区，我们将使用之前创建的 `clean-tree`
    脚本来完成这一操作。我们还将使用 `cat` 作为 `tag-name-filter` 来保留标签。我们将在所有分支上执行重写，并记得使用清理脚本的绝对路径：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The rewrite takes a bit of time, as all commits need to be processed. Once
    the rewrite is done, we can see that everything is deleted, except the files and
    folders we wanted to keep:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写过程需要一些时间，因为所有的提交都需要被处理。重写完成后，我们可以看到所有内容都被删除了，除了我们想要保留的文件和文件夹：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The cleanup isn''t done just yet. `git filter-branch` saves all the original
    references, branches and tags, under the `refs/original` namespace in the repository.
    After verification, the new history looks good, and we can get rid of the original
    `refs`, as these point to objects that are not in our current history and take
    up a lot of disk space. We''ll delete all the original refs and run the garbage
    collector to clear the repository of old objects:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理工作还没有完成。`git filter-branch` 会将所有原始引用、分支和标签保存到仓库的 `refs/original` 命名空间中。经过验证，新历史看起来没问题后，我们可以删除原始的
    `refs`，因为这些引用指向的对象不在我们当前的历史中，并且占用了大量磁盘空间。我们将删除所有原始引用，并运行垃圾回收器来清理仓库中的旧对象：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Delete original references, `refs/original`, and remove old objects with `git
    gc`, as shown in the following command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除原始引用 `refs/original`，并使用 `git gc` 删除旧对象，如下所示的命令：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Check the size of the repository after garbage collection:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查垃圾回收后的仓库大小：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The repository is now clean of all old objects, the size has been reduced, and
    the history is preserved for the files and directories we listed to keep.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仓库现在已清除所有旧对象，大小已减小，并且我们列出的需要保留的文件和目录的历史得以保留。
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `git filter-branch` command has different filter options depending on what
    needs to be done when rewriting the repository. In this example, where we are
    only removing files and folders from the repository; the `index-filter` is highly
    usable, as it allows us to rewrite the index just before recording a commit in
    the database without actually checking out the tree on disk, thereby saving a
    lot of disk I/O. The `clean-tree` script we prepared previously is then used to
    remove the unwanted files and folders from the index. First, we list the content
    of the index and filter the files and folders we want to keep. Then, we remove
    the remaining files and folders (`$f`) from the index with the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`git filter-branch`命令根据在重写仓库时需要做的操作有不同的过滤选项。在这个例子中，我们只需要从仓库中移除文件和文件夹；`index-filter`非常实用，它允许我们在将提交记录到数据库之前重写索引，而无需实际检出磁盘上的树，从而节省了大量的磁盘I/O。然后，我们使用之前准备好的`clean-tree`脚本来从索引中移除不需要的文件和文件夹。首先，我们列出索引的内容并过滤出我们想保留的文件和文件夹。然后，我们使用以下命令从索引中移除剩余的文件和文件夹（`$f`）：'
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `--cached` option tells Git to remove the index from files, and the `-rq`
    option tells it to remove `recursive (r)` option and be quiet (`q`). Finally,
    the `--ignore-unmatch` option is used so that `git rm` will not exit with an error
    if it tries to remove a file that is not in the index.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`--cached`选项告诉Git从文件中移除索引，`-rq`选项告诉它递归地移除（r）并保持安静（q）。最后，使用`--ignore-unmatch`选项，这样即使`git
    rm`尝试移除索引中没有的文件，也不会导致错误退出。'
- en: There's more...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'There are many more filters for `git filter-branch`; the most common ones and
    their use cases are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`git filter-branch`有许多其他过滤器，最常用的过滤器及其使用场景如下：'
- en: '`env-filter`: This filter is used to modify the environment where commits are
    recorded. This is particularly useful when rewriting author and committer information.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env-filter`：此过滤器用于修改记录提交时的环境，特别适用于重写作者和提交者的信息。'
- en: '`tree-filter`: The `tree-filter` is used to rewrite the tree. This is useful
    if you need to add or modify files in the tree, for example, to remove sensitive
    data from a repository.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tree-filter`：`tree-filter`用于重写树结构。如果需要在树中添加或修改文件，例如移除仓库中的敏感数据，它非常有用。'
- en: '`msg-filter`: This filter is used to update the commit message.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msg-filter`：此过滤器用于更新提交信息。'
- en: '`subdirectory-filter`: This filter can be used if you want to extract a single
    subdirectory to a new repository and keep the history of that subdirectory. The
    subdirectory will be the root of the new repository.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subdirectory-filter`：如果你想将一个子目录提取到新的仓库并保留该子目录的历史记录，可以使用此过滤器。该子目录将成为新仓库的根目录。'
- en: Rewriting history – changing a single file
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写历史 – 更改单个文件
- en: In this example, we'll see how we can use Git `filter-branch` to remove sensitive
    data from a file throughout the repository history.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将展示如何使用Git的`filter-branch`命令在整个仓库历史中移除敏感数据。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'For simplicity, we''ll use a very simple example repository. It contains a
    few files. One of them is .credentials, which contains a username and password.
    Start by cloning the repository and changing the directory, as shown in the following
    command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，我们将使用一个非常简单的示例仓库。它包含几个文件，其中之一是`.credentials`，它包含一个用户名和密码。首先克隆仓库并切换到该目录，如下所示：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Before proceeding, you can take a look at the content of the repository using
    `ls` and examine the history with `git log`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续操作之前，可以使用`ls`查看仓库内容，并使用`git log`查看历史记录。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As we need to modify a file when rewriting the history of this repository,
    we''ll use the `tree-filter` option to filter the branch. The `.credentials` file
    looks as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要在重写仓库历史时修改文件，所以我们将使用`tree-filter`选项来过滤分支。`.credentials`文件如下所示：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'All we need to do is remove everything after the equals sign on each line of
    the file. We can use the following `sed` command to do this:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的就是删除文件中每行等号后面的内容。我们可以使用以下`sed`命令来实现：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now run the filter branch with the following command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令运行过滤分支：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we look at the file now, we can see that the username and password are gone:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在查看文件，可以看到用户名和密码已经消失：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As we saw in the previous example, we still need to clean up after  `filter-branch`,
    by deleting original references, expiring the `reflog`, and triggering garbage
    collection. But, at this point, you can compare the content and commit history
    of the repository.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们在之前的示例中所见，我们仍然需要在 `filter-branch` 后进行清理，删除原始引用，过期 `reflog`，并触发垃圾回收。但此时，你可以比较仓库的内容和提交历史。
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For each commit in the repository, Git will check the content of that commit
    and run `tree-filter`. If the filter fails with a non-zero exit code, `filter-branch`
    will fail. Therefore, it is important to remember to handle cases where `tree-filter`
    might fail. This is the reason why the previous `tree-filter` checks whether the
    `.credentials` file exists, runs the `sed` command if it does, and otherwise returns
    true to continue the `filter-branch`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仓库中的每个提交，Git 会检查该提交的内容并运行 `tree-filter`。如果过滤器失败并返回非零退出码，`filter-branch` 会失败。因此，记得处理
    `tree-filter` 可能失败的情况非常重要。这也是为什么之前的 `tree-filter` 会检查 `.credentials` 文件是否存在，如果存在，则运行
    `sed` 命令，否则返回 `true` 以继续执行 `filter-branch`。
- en: Creating a backup of your repositories as mirror repositories
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建仓库的镜像仓库备份
- en: Even though Git is distributed and every clone is essentially a backup, there
    are some tricks that can be useful when backing up Git repositories. A normal
    Git repository has a working copy of the files it tracks and the full history
    of the repository in the `.git` folder of that repository. The repositories on
    the server, the ones you push to and pull from, will usually be bare repositories.
    A bare repository is a repository without a working copy. Roughly, it is just
    the `.git` folder of a normal repository. A mirror repository is almost the same
    as a bare repository, except it fetches all the references under `refs/*`, whereas
    a bare repository only fetches the references that fall under `refs/heads/*`.
    We'll now take a closer look at a normal, a bare, and a mirror clone of the JGit
    repository.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Git 是分布式的，每个克隆实际上都是一个备份，但在备份 Git 仓库时，仍然有一些技巧可以派上用场。一个普通的 Git 仓库会有它跟踪的文件的工作副本，以及该仓库的完整历史记录，这些都保存在该仓库的
    `.git` 文件夹中。服务器上的仓库，通常是你推送和拉取的仓库，通常是裸仓库。裸仓库是没有工作副本的仓库。大致上，它就只是一个普通仓库的 `.git` 文件夹。镜像仓库几乎与裸仓库相同，唯一的不同是它会获取所有位于
    `refs/*` 下的引用，而裸仓库只会获取位于 `refs/heads/*` 下的引用。接下来，我们将更详细地看一下普通、裸和镜像克隆的 JGit 仓库。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll start by creating three clones of the JGit repository: a normal, a bare,
    and a mirror clone. When we create the first clone, we can use that as a reference
    repository for the other clones. In this way, we can share the objects in the
    database, and we don''t have to transfer the same data three times:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建 JGit 仓库的三个克隆开始：一个普通的、一个裸的和一个镜像的克隆。当我们创建第一个克隆时，可以将其作为其他克隆的参考仓库。通过这种方式，我们可以共享数据库中的对象，而不需要将相同的数据传输三遍：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'One of the differences between a normal repository and a bare or mirror one
    is that there are no remote branches in a bare repository. All the branches are
    created locally. We can see this in the three repositories by listing the branches
    with the `git branch` command as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 普通仓库与裸仓库或镜像仓库之间的一个区别是，裸仓库中没有远程分支。所有分支都是本地创建的。我们可以通过使用 `git branch` 命令列出这三个仓库中的分支，来看这一点：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To see the difference between the bare and mirror repositories, we need to
    list the different refspecs fetches and the different `refs` namespaces. List
    the fetch `refspec` of origin in the mirror repository (`jgit.mirror`):'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看裸仓库和镜像仓库之间的区别，我们需要列出不同的 refspec 获取和不同的 `refs` 命名空间。列出镜像仓库 (`jgit.mirror`)
    中的 origin 的获取 `refspec`：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'List the different `refs` namespaces in the mirror repository:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出镜像仓库中的不同 `refs` 命名空间：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There is no explicit `refspec` fetch in the configuration for origin in the
    bare repository (`jgit.git`). When no configuration entry is found, Git uses the
    default `refspec` fetch, as it does in a normal repository. We can check the remote
    URL of origin using the following command:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 裸仓库 (`jgit.git`) 的 origin 配置中没有明确的 `refspec` 获取。当未找到配置条目时，Git 会使用默认的 `refspec`
    获取，就像在普通仓库中一样。我们可以使用以下命令检查 origin 的远程 URL：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'List the different `refs` namespaces in the bare repository using the following
    command and see the difference:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令列出裸仓库中的不同 `refs` 命名空间，看看有什么不同：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we can list the `refspec` fetch and `refs` namespaces for the normal
    repository (`jgit`):'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以列出普通仓库 (`jgit`) 的 `refspec` 拉取和 `refs` 命名空间：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The mirror repository has four ref namespaces not found in either the normal
    or the bare repositories: `refs-cache-automerge`, `changes`, `meta`, and `notes`.
    The normal repository is the only one that has the `refs/remote` namespace.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 镜像仓库有四个在普通或裸仓库中找不到的 ref 命名空间：`refs-cache-automerge`、`changes`、`meta` 和 `notes`。普通仓库是唯一一个拥有
    `refs/remote` 命名空间的仓库。
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: The normal and bare repositories are pretty similar, only the mirror one sticks
    out. This is due to the `refspec` fetch on the mirror repository, `+refs/*:refs/*`,
    which will fetch all `refs` from the remote and not just `refs/heads/*` and `refs/tags/*`
    as a normal repository (and a `bare` repository) does. The many different `ref`
    namespaces on the JGit repository is because the JGit repository is managed by
    Gerrit Code Review. It uses different namespaces for repository-specific content,
    such as change branches for all commits submitted for code review, and metadata
    on code review score.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 普通和裸仓库非常相似，只有镜像仓库显得与众不同。这是因为镜像仓库上的 `refspec` 拉取 `+refs/*:refs/*`，它将从远程获取所有 `refs`
    而不仅仅是普通仓库（和裸仓库）所做的 `refs/heads/*` 和 `refs/tags/*`。JGit 仓库上许多不同的 `ref` 命名空间是因为
    JGit 仓库由 Gerrit 代码审查管理。它使用不同的命名空间来存储仓库特定内容，例如用于所有提交的代码审查分支的变更分支和代码审查分数元数据。
- en: The `mirror` repositories are ideal when you would like a quick way to back
    up a Git repository. It ensures that you have everything included without the
    need for additional access than the Git access to the machine that hosts the Git
    repository.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`mirror` 仓库是当你想要快速备份 Git 仓库时的理想选择。它确保你包含了一切，而无需比 Git 仓库所在的主机的 Git 访问权限更多的额外访问权限。'
- en: There's more...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The repositories on GitHub store extra information in some refs namespaces.
    If a repository has had a pull request made, the pull request will be recorded
    in the `refs/pull/*` namespace. Let''s look at this in the following example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 上的仓库在某些 refs 命名空间中存储额外的信息。如果一个仓库曾经发起过一个拉取请求，该拉取请求将记录在 `refs/pull/*` 命名空间中。让我们在下面的例子中看看这个：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: A quick "how-to" submodule
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个快速的子模块 "如何"
- en: 'When working on a software project, you sometimes find yourself in a situation
    where you need to use another project as a part of your project. This other project
    can be anything, from another project you are developing to a third-party library.
    You want to keep projects separate, even though you need to use one project for
    the other. Git has a mechanism for this kind of project dependency, called submodules.
    The basic idea is that you can clone another Git repository into your project
    as a subdirectory, but keep the commits from the two repositories separate, as
    shown in the following diagram:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行软件项目开发时，有时会遇到需要将另一个项目作为自己项目的一部分的情况。这个其他项目可以是任何东西，从你正在开发的另一个项目到第三方库。尽管需要在一个项目中使用另一个项目，但你希望保持这些项目的分离。Git
    为这种项目依赖关系提供了一种机制，称为子模块。基本思想是你可以将另一个 Git 仓库克隆到你的项目中作为子目录，但保持两个仓库的提交记录分离，如下图所示：
- en: '![](img/272fa5ac-8cd1-4483-8660-0637a3408093.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/272fa5ac-8cd1-4483-8660-0637a3408093.png)'
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll start by cloning an example repository to be used as the super project:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从克隆一个示例仓库开始，作为超级项目的使用示例：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll add a subproject, `lib_a`, to the super project as a Git submodule:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把子项目`lib_a`作为 Git 子模块添加到超级项目中：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s check `git status` using the following command:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下命令检查`git status`的状态：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can take a closer look at the two files in the Git index; `.gitmodules`
    is a regular file, so we can use `cat`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以更仔细地查看 Git 索引中的两个文件；`.gitmodules` 是一个普通文件，所以我们可以使用 `cat`：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `.gitmodules` file, as above, contains information about all the submodules
    registered in the repository. The `lib_a` file stores which commit the submodule's
    `HEAD` is pointing to when added to the super project. Whenever the submodule
    is updated with new commits (created locally or fetched), the super project will
    show the submodule as having changed while running `git status`. If the changes
    to the submodule can be accepted, the submodule revision in the super project
    is updated by adding the submodule file and committing this to the super project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`.gitmodules`文件如上所述，包含有关所有在仓库中注册的子模块的信息。`lib_a`文件存储着当子模块被添加到超项目时，子模块`HEAD`指向的是哪个提交。每当子模块通过新的提交（本地创建或拉取）进行更新时，超项目在运行`git
    status`时会显示子模块发生了变化。如果子模块的更改可以接受，超项目中的子模块修订版本会通过添加子模块文件并提交到超项目来更新。'
- en: 'We''ll update the submodule, `lib_a`, to the latest change on the develop branch
    using the following command:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用以下命令将子模块`lib_a`更新到开发分支上的最新更改：
- en: '[PRE48]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s just check whether there are any updates to the submodule:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查一下子模块是否有任何更新：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Oops! Now we actually reset our submodule to the state described in the file
    for that submodule. We need to switch to the submodule again, check develop, and
    this time create a commit in the super repository:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哎呀！现在我们实际上已经将子模块重置为该子模块文件中描述的状态。我们需要再次切换到子模块，检查开发分支，并这次在超项目中创建一个提交：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that, by default, the submodule is in a detached head state, which means
    that `HEAD` is pointing directly to a commit instead of a branch. You can still
    edit the submodule and record commits; however, if you perform a submodule update in
    the super repository without first committing a new submodule state, your changes
    can be hard to find. Always remember to check out or create a branch while switching
    to a submodule to work on. If so, you can just check out the branch again and
    get your changes back. Since Git Version 1.8.2, it has been possible to make submodules
    track a branch rather than a single commit. Git 1.8.2 was released on March 13,
    2013, and you can check your version by running `git --version`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认情况下，子模块处于分离头指针（detached head）状态，这意味着`HEAD`直接指向某个提交，而不是分支。你仍然可以编辑子模块并记录提交；但是，如果在超项目中执行子模块更新而没有首先提交新的子模块状态，你的更改可能会很难找到。切记，在切换到子模块工作时，一定要检查或创建一个分支。如果是这样，你只需要再次检出该分支，就能恢复你的更改。从Git
    1.8.2版本开始，可以使子模块跟踪一个分支，而不是单个提交。Git 1.8.2版本发布于2013年3月13日，你可以通过运行`git --version`来检查你的版本。
- en: 'To make Git track the branch of a submodule rather than a specific commit,
    we need to record the name of the branch we want to track. This is done in the
    `.gitmodules` file for the submodule; here, we''ll use the stable branch:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让Git跟踪子模块的分支而不是特定的提交，我们需要记录我们想要跟踪的分支名称。这可以在子模块的`.gitmodules`文件中完成；在这里，我们将使用稳定分支：
- en: '[PRE51]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can now add and commit the submodule, and then try to update it using the
    following command:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以添加并提交子模块，然后尝试使用以下命令更新它：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The submodule is still in the detached `HEAD` state. However, when updating
    the submodule with `git submodule update --remote`, changes from the submodule's
    remote repository will be fetched and the submodule will be updated to the latest
    commit on the branch it is tracking. We still need to record a commit to the super
    repository, specifying the state of the submodule.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 子模块仍然处于分离`HEAD`状态。然而，当使用`git submodule update --remote`更新子模块时，将从子模块的远程仓库拉取更改，并将子模块更新到它正在跟踪的分支的最新提交。我们仍然需要记录一次提交到超项目中，指定子模块的状态。
- en: There's more...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When you are cloning a repository that contains one or more submodules, you
    need to explicitly fetch them after the clone. We can try this with our newly
    created submodule repository:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当你克隆一个包含一个或多个子模块的仓库时，你需要在克隆后显式地拉取它们。我们可以用新创建的子模块仓库尝试这个：
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, initialize and update the submodules:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，初始化并更新子模块：
- en: '[PRE55]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The repository is ready for development!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库已准备好进行开发！
- en: When cloning the repository, the submodules can be initialized and updated directly
    after the clone if the `--recursive` or `--recurse-submodules` option is given.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆仓库时，如果提供`--recursive`或`--recurse-submodules`选项，子模块可以在克隆后直接初始化和更新。
- en: Subtree merging
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子树合并
- en: An alternative to submodules is subtree merging. Subtree merging is a strategy
    that can be used when performing merges with Git. The strategy is useful when
    merging a branch (or, as we'll see in this recipe, another project) into a subdirectory
    of a Git repository instead of the root directory. When using the subtree merge
    strategy, the history of the subproject is joined with the history of the super
    project, while the subproject's history can be kept clean, except for commits
    intended to go upstream.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 子模块的替代方法是子树合并。子树合并是一种可以在使用Git执行合并时采用的策略。当将一个分支（或者如我们在本食谱中所看到的，另一个项目）合并到Git仓库的子目录而不是根目录时，这种策略非常有用。使用子树合并策略时，子项目的历史会与超级项目的历史合并，而子项目的历史可以保持清晰，除了那些计划合并到上游的提交。
- en: Getting ready
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll use the same repositories as in the last recipe, and we''ll reclone
    the super project to get rid of the submodule setup:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与上一个食谱中相同的仓库，并重新克隆超级项目以摆脱子模块设置：
- en: '[PRE56]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How to do it...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll add the subproject as a new remote and fetch the history:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把子项目作为一个新的远程仓库添加，并获取其历史记录：
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can now create a local branch, `lib_a_master`, which points to the same
    commit as the master branch in lib a (`lib_a/master`):'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个本地分支`lib_a_master`，该分支指向与lib a的主分支(`lib_a/master`)相同的提交：
- en: '[PRE58]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can check the content of our working tree using the following command:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查工作树的内容：
- en: '[PRE59]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If we switch back to the `master` branch, we should see the content of the
    super repository in our directory:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们切换回`master`分支，应该会在目录中看到超级仓库的内容：
- en: '[PRE60]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Git changes branches and populates the working directory as normal, even though
    the branches are originally from two different repositories. Now, we want to merge
    the history from `lib_a` into a subdirectory. First, we prepare a merge commit
    by merging with the `ours` strategy and make sure the commit isn''t completed
    (we need to bring in all the files):'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Git会正常切换分支并填充工作目录，即使这些分支最初来自两个不同的仓库。现在，我们想将`lib_a`的历史合并到一个子目录中。首先，我们使用`ours`策略准备一个合并提交，并确保该提交未完成（我们需要引入所有文件）：
- en: '[PRE61]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In short, what the `ours` strategy tells Git to do is the following: merge
    in this branch, but keep the resulting tree the same as the tree on the tip of
    this branch. So, the branch is merged, but all the changes it introduced are discarded.
    In our previous command line, we also passed the `--no-commit` option. This option
    stops Git from completing the merge, but leaves the repository in a merging state.
    We can now add the content of the `lib_a` repository to the `lib_a` folder in
    the repository root. We do this with `git read-tree` to make sure the two trees
    are exactly the same, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`ours`策略告诉Git执行以下操作：合并这个分支，但保持最终的树结构与该分支顶端的树结构相同。所以，分支被合并，但它所引入的所有更改都会被丢弃。在我们之前的命令行中，我们还传递了`--no-commit`选项。这个选项阻止Git完成合并，但让仓库保持在合并状态。现在我们可以将`lib_a`仓库的内容添加到仓库根目录中的`lib_a`文件夹。我们使用`git
    read-tree`来确保两个树完全相同，如下所示：
- en: '[PRE62]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Our current directory structure looks as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们当前的目录结构如下所示：
- en: '[PRE63]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'It is time to conclude the merge commit we started using the following command:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是通过以下命令结束我们开始的合并提交的时候了：
- en: '[PRE64]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now, the subproject is added. Next, we'll see how we can update the super project
    with new commits from the subproject and how to copy commits made in the super
    project to the subproject.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，子项目已添加。接下来，我们将看到如何使用子项目中的新提交更新超级项目，并且如何将超级项目中的提交复制到子项目中。
- en: 'We need to add and commit a few changes to the super project using the following
    command:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用以下命令向超级项目添加并提交一些更改：
- en: '[PRE65]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Changes are made to the subproject and committed in the super project:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对子项目进行了更改，并在超级项目中提交：
- en: '[PRE66]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The current history looks like the following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的历史记录如下图所示：
- en: '![](img/d983deb6-1f1c-4003-905f-5688b88b8e6d.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d983deb6-1f1c-4003-905f-5688b88b8e6d.png)'
- en: 'The merge can be seen in the preceding screenshot, and also the two root commits
    of the repository: the original root commit and the root from `lib_a`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 合并可以在之前的截图中看到，同时还可以看到仓库的两个根提交：原始根提交和来自`lib_a`的根提交。
- en: 'Now, we will learn how to integrate new commits into the super repository made
    in the subproject, `lib_a`. Normally, we would do this by checking out the `lib_a_master`
    branch and performing pull on it to get the latest commit from the remote repository.
    However, as we are working with example repositories in this recipe, no new commits
    are available on the master branch. Instead, we''ll use the `develop` and `stable`
    branches from `lib_a`. We''ll now integrate commits from the develop branch into `lib_a`.
    We do this directly using the `lib_a/develop` reference in the repository as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何将子项目`lib_a`中做的新提交集成到超级仓库中。通常，我们会通过切换到`lib_a_master`分支并执行拉取操作，获取远程仓库中的最新提交。然而，由于我们在本食谱中使用的是示例仓库，`master`分支上没有新提交。因此，我们将使用`lib_a`的`develop`和`stable`分支。现在，我们将直接使用`lib_a/develop`引用，将`develop`分支中的提交集成到`lib_a`中，如下所示：
- en: '[PRE67]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Our master branch has now been updated with the commits from `lib_a/develop`, as
    shown in the following screenshot:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`master`分支已经更新了来自`lib_a/develop`的提交，如下图所示：
- en: '![](img/7cdb3cb4-19d3-4f0b-bf13-195d9a1b5a5e.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7cdb3cb4-19d3-4f0b-bf13-195d9a1b5a5e.png)'
- en: 'Now, it is time to add the commits we made in the `lib_a` directory back to
    the `lib_a` project. First, we''ll change the `lib_a_master` branch and merge
    that with `lib_a/develop` to be as up-to-date as possible:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候将我们在`lib_a`目录中所做的提交添加回`lib_a`项目了。首先，我们将切换到`lib_a_master`分支，并将其与`lib_a/develop`合并，以确保尽可能保持最新：
- en: '[PRE68]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We are now ready to merge changes from the super project with the subproject.
    In order to not merge the history of the super project with the subproject, we''ll
    use the `--squash` option. This option stops Git from completing the merge and,
    unlike the previous case, where we also stopped a merge from recording a commit,
    it does not leave the repository in a merging state. The state of the working
    directory and staging area are, however, set as though a real merge has happened:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备好将超级项目中的更改与子项目合并。为了避免将超级项目的历史与子项目合并，我们将使用`--squash`选项。这个选项会阻止Git完成合并，并且与之前的情况不同，我们也阻止了合并提交记录，它不会使仓库处于合并状态。然而，工作目录和暂存区的状态会像真正的合并一样：
- en: '[PRE69]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we can record a commit with all the changes made in `lib_a` from the super
    project:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以记录一个包含所有`lib_a`更改的提交到超级项目中：
- en: '[PRE70]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The history for the `lib_a` repository is seen in the following screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`lib_a`仓库的历史如以下截图所示：'
- en: '![](img/65298db8-e8a5-4a83-afb3-97360e546772.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65298db8-e8a5-4a83-afb3-97360e546772.png)'
- en: 'We can integrate more changes from `lib_a/stable` into the super project, but
    first we''ll update the `lib_a_master` branch so that we can integrate them from
    here:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将更多来自`lib_a/stable`的更改集成到超级项目中，但首先我们需要更新`lib_a_master`分支，以便能够从这里集成它们：
- en: '[PRE71]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A new commit was added to the subproject, as shown in the following screenshot:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新提交已添加到子项目中，如下图所示：
- en: '![](img/3969f74d-fbc1-494b-9153-1002f42732dd.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3969f74d-fbc1-494b-9153-1002f42732dd.png)'
- en: 'The last task is to integrate the new commit on `lib_a_master` into the `master`
    branch in the super repository. This is done as in the previous case, using the
    `subtree strategy` option to `git merge`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的任务是将`lib_a_master`上的新提交集成到超级仓库中的`master`分支。这与之前的操作一样，通过`git merge`使用`subtree
    strategy`选项来完成：
- en: '[PRE72]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The resulting history is shown in the following screenshot:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 结果历史如以下截图所示：
- en: '![](img/b03aa1d4-b6ed-4159-9725-a57dcaca49cb.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b03aa1d4-b6ed-4159-9725-a57dcaca49cb.png)'
- en: How it works...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When using the subtree strategy, Git finds out which subtree in your repository
    the branch you are trying to merge fits into. This is why we added the content
    of the `lib_a` repository with the `read-tree` command, to make sure we got the
    exact same SHA-1 ID for the `lib_a` directory in the super project as the root
    tree in the `lib_a` project. In the following example, the SHA-1 is found in the
    first command.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用子树策略时，Git会确定你试图合并的分支适合你的仓库中的哪个子树。这就是我们使用`read-tree`命令添加`lib_a`仓库内容的原因，以确保在超级项目中获得与`lib_a`项目根树相同的`lib_a`目录的SHA-1
    ID。在下面的示例中，SHA-1 ID在第一条命令中找到。
- en: 'We can verify this by finding the SHA-1 of the `lib_a` tree in the super project
    in the commit that we merged the subproject with:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查找在我们合并子项目的提交中`lib_a`树的SHA-1来验证这一点：
- en: '[PRE73]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The ID of the root tree at `lib_a/master` can be found out by using the following
    command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`lib_a/master`上的根树ID可以通过以下命令获取：'
- en: '[PRE74]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: See also
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Another way of using subtree merging is with the `git subtree` command. This
    is not enabled by default in many Git installations, but has been distributed
    with Git since 1.7.11\. You can see how to install and use it at the following
    links:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `git subtree` 命令是另一种使用子树合并的方式。这在许多 Git 安装中默认未启用，但自 Git 1.7.11 起已随 Git 分发。您可以在以下链接中查看如何安装和使用：
- en: For installation, go to [https://github.com/git/git/blob/master/contrib/subtree/INSTALL](https://github.com/git/git/blob/master/contrib/subtree/INSTALL)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要安装，请访问 [https://github.com/git/git/blob/master/contrib/subtree/INSTALL](https://github.com/git/git/blob/master/contrib/subtree/INSTALL)
- en: To understand how to use a subtree, go to [https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt](https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解如何使用子树，请访问 [https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt](https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt)
- en: If you are a Homebrew or an Ubuntu user, their basic packages have support for
    subtrees. For Fedora, you must install additional packages.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是 Homebrew 或 Ubuntu 用户，它们的基本包支持子树。对于 Fedora，您必须安装额外的软件包。
- en: Submodule versus subtree merging
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子模块与子树合并
- en: There is no easy answer to the question of whether or not to use submodules
    or subtree merging for a project. When choosing submodules, a lot of extra pressure
    is put on the developers working on the project, as they need to make sure they
    keep the submodules and the super project in sync. When choosing to add a project
    by subtree merging, little to no extra complexity is added for developers. The
    repository maintainer, however, needs to make sure the subproject is up-to-date
    and that commits are added back to the subproject. Both methods work and are in
    use, and it is probably just a matter of getting used to either method. A completely
    different solution is to use the build system of the super project to fetch the
    necessary dependencies, as for example, Maven or Gradle does.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个项目是否应该使用子模块或者子树合并，没有一个简单的答案。选择子模块会给项目中的开发人员增加很大的额外压力，因为他们需要确保子模块和超级项目保持同步。选择通过子树合并添加项目时，对开发人员几乎没有额外的复杂性。然而，仓库维护者需要确保子项目是最新的，并且提交被添加回子项目中。这两种方法都行之有效，且广泛使用，可能只是一个习惯的问题。一个完全不同的解决方案是使用超级项目的构建系统来获取必要的依赖，例如
    Maven 或 Gradle。
