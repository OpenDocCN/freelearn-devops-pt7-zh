["```\n$ ansible -i /home/cloud-user/inventory all -m ansible.builtin.ping\n```", "```\ntarget1.example.org ansible_host=192.168.81.142 ansible_port=3333\ntarget2.example.org ansible_port=3333 ansible_user=james\ntarget3.example.org ansible_host=192.168.81.143 ansible_port=5555\n```", "```\n---\nungrouped:\n  hosts:\n    target1.example.org:\n      ansible_host: 192.168.81.142\n      ansible_port: 3333\n    target2.example.org:\n      ansible_port: 3333\n      ansible_user: james\n    target3.example.org:\n      ansible_host: 192.168.81.143\n      ansible_port: 5555\n```", "```\n$ ansible -i /etc/ansible/my_inventory.yaml all -m ansible.builtin.shell -a 'echo hello-yaml' -f 5\ntarget1.example.org | CHANGED | rc=0 >>\nhello-yaml\ntarget2.example.org | CHANGED | rc=0 >>\nhello-yaml\ntarget3.example.org | CHANGED | rc=0 >>\nhello-yaml\n```", "```\nloadbalancer.example.org\n[frontends]\nweb01.example.org\nweb02.example.org\n[apps]\napp01.example.org\napp02.example.org\n[databases]\ndb01.example.org\ndb02.example.org\n```", "```\nloadbalancer.example.org\n[frontends]\nweb01.example.org\nweb02.example.org\n[apps]\napp01.example.org\napp02.example.org\n[databases]\ndb01.example.org\ndb02.example.org\n[fedora:children]\napps\ndatabases\n[ubuntu:children]\nfrontends\n```", "```\nall:\n  hosts:\n    loadbalancer.example.org:\n  children:\n    fedora:\n      children:\n        apps:\n          hosts:\n            app01.example.org:\n            app02.example.org:\n        databases:\n          hosts:\n            db01.example.org:\n            db02.example.org:\n    ubuntu:\n      children:\n        frontends:\n          hosts:\n            web01.example.org:\n            web02.example.org:\n```", "```\n$ ansible -i hostgroups-yaml all -m ansible.builtin.shell -a 'echo hello-yaml' -f 5\n```", "```\n$ ansible -i hostgroups-yaml fedora -m ansible.builtin.shell -a 'echo hello-yaml' -f 5\napp01.example.org | CHANGED | rc=0 >>\nhello-yaml\napp02.example.org | CHANGED | rc=0 >>\nhello-yaml\ndb01.example.org | CHANGED | rc=0 >>\nhello-yaml\ndb02.example.org | CHANGED | rc=0 >>\nhello-yaml\n```", "```\n[apps]\napp01.example.org\napp02.example.org\n...\napp99.example.org\napp100.example.org\n```", "```\n[apps]\napp[01:100].example.org\n```", "```\n[cache]\ncache-[a:e].example.org\n```", "```\n[cache]\ncache-a.example.org\ncache-b.example.org\ncache-c.example.org\ncache-d.example.org\ncache-e.example.org\n```", "```\n    [frontends]\n    web01.example.org https_port=8443 lb_vip=lb.example.org\n    web02.example.org https_port=8443 lb_vip=lb.example.org\n    ```", "```\n$ ansible -i hostvars1-hostgroups-ini frontends -m ansible.builtin.debug -a \"msg=\\\"Connecting to {{ lb_vip }}, listening on {{ https_port }}\\\"\"\nweb01.example.org | SUCCESS => {\n    \"msg\": \"Connecting to lb.example.org, listening on 8443\"\n}\nweb02.example.org | SUCCESS => {\n    \"msg\": \"Connecting to lb.example.org, listening on 8443\"\n}\n```", "```\n    [frontends]\n    web01.example.org\n    web02.example.org\n    [frontends:vars]\n    https_port=8443\n    lb_vip=lb.example.org\n    ```", "```\n$ ansible -i groupvars1-hostgroups-ini frontends -m ansible.builtin.debug -a \"msg=\\\"Connecting to {{ lb_vip }}, listening on {{ https_port }}\\\"\"\nweb01.example.org | SUCCESS => {\n    \"msg\": \"Connecting to lb.example.org, listening on 8443\"\n}\nweb02.example.org | SUCCESS => {\n    \"msg\": \"Connecting to lb.example.org, listening on 8443\"\n}\n```", "```\n    [frontends]\n    web01.example.org https_port=8444\n    web02.example.org\n    [frontends:vars]\n    https_port=8443\n    lb_vip=lb.example.org\n    ```", "```\n$ ansible -i groupvars2-hostgroups-ini frontends -m ansible.builtin.debug -a \"msg=\\\"Connecting to {{ lb_vip }}, listening on {{ https_port }}\\\"\"\nweb01.example.org | SUCCESS => {\n    \"msg\": \"Connecting to lb.example.org, listening on 8444\"\n}\nweb02.example.org | SUCCESS => {\n    \"msg\": \"Connecting to lb.example.org, listening on 8443\"\n}\n```", "```\n    frontends:\n      hosts:\n        web01.example.org:\n          https_port: 8444\n        web02.example.org:\n      vars:\n        https_port: 8443\n        lb_vip: lb.example.org\n    ```", "```\n$ ansible -i groupvars2-hostgroups-yaml frontends -m ansible.builtin.debug -a \"msg=\\\"Connecting to {{ lb_vip }}, listening on {{ https_port }}\\\"\"\nweb01.example.org | SUCCESS => {\n    \"msg\": \"Connecting to lb.example.org, listening on 8444\"\n}\nweb02.example.org | SUCCESS => {\n    \"msg\": \"Connecting to lb.example.org, listening on 8443\"\n}\n```", "```\n    $ mkdir vartree\n    $ cd vartree\n    ```", "```\n    host_vars directory, we’ll create a file with the name of our host that needs the proxy setting, with .yml appended to it (that is, web01.example.org.yml). This file should contain the following:\n\n    ```", "```\n\n    ```", "```\n    ---\n    https_port: 8443\n    lb_vip: lb.example.org\n    ```", "```\n    loadbalancer.example.org\n    [frontends]\n    web01.example.org\n    web02.example.org\n    [apps]\n    app01.example.org\n    app02.example.org\n    [databases]\n    db01.example.org\n    db02.example.org\n    ```", "```\n$ tree\n.\n├── group_vars\n│   └── frontends.yml\n├── host_vars\n│   └── web01.example.org.yml\n└── inventory\n2 directories, 3 files\n```", "```\n    $ ansible -i inventory frontends -m ansible.builtin.debug -a \"msg=\\\"Connecting to {{ lb_vip }}, listening on {{ https_port }}\\\"\"\n    web01.example.org | SUCCESS => {\n        \"msg\": \"Connecting to lb.example.org, listening on 8444\"\n    }\n    web02.example.org | SUCCESS => {\n        \"msg\": \"Connecting to lb.example.org, listening on 8443\"\n    }\n    ```", "```\n    $ tree\n    .\n    ├── group_vars\n    │   └── frontends\n    │       ├── https_port.yml\n    │       └── lb_vip.yml\n    ├── host_vars\n    │   └── web01.example.org\n    │       └── main.yml\n    └── inventory\n    4 directories, 4 files\n    ```", "```\n$ cat host_vars/web01.example.org/main.yml\n---\nhttps_port: 8444\n$ cat group_vars/frontends/https_port.yml\n---\nhttps_port: 8443\n$ cat group_vars/frontends/lb_vip.yml\n---\nlb_vip: lb.example.org\n```", "```\n$ ansible -i inventory frontends -m ansible.builtin.debug -a \"msg=\\\"Connecting to {{ lb_vip }}, listening on {{ https_port }}\\\"\"\nweb01.example.org | SUCCESS => {\n    \"msg\": \"Connecting to lb.example.org, listening on 8444\"\n}\nweb02.example.org | SUCCESS => {\n    \"msg\": \"Connecting to lb.example.org, listening on 8443\"\n}\n```", "```\n    loadbalancer.example.org\n    [frontends]\n    web01.example.org\n    web02.example.org\n    [frontends:vars]\n    testvar=childgroup\n    [apps]\n    app01.example.org\n    app02.example.org\n    [databases]\n    db01.example.org\n    db02.example.org\n    [fedora:children]\n    apps\n    databases\n    [ubuntu:children]\n    frontends\n    [ubuntu:vars]\n    testvar=group\n    ```", "```\n$ ansible -i hostgroups-children-vars-ini ubuntu -m ansible.builtin.debug -a \"var=testvar\"\nweb01.example.org | SUCCESS => {\n    \"testvar\": \"childgroup\"\n}\nweb02.example.org | SUCCESS => {\n    \"testvar\": \"childgroup\"\nfrontends group is a child of the ubuntu group in this inventory (hence, the group is listed under [ubuntu:children]), and so the variable value we set at the frontends group level wins as this is the child group in this scenario.\nBy now, you should have a pretty good idea of how to work with static inventory files. However, no look at Ansible’s inventory capabilities is complete without a look at dynamic inventories, and we shall do exactly this in the next section.\nGenerating a dynamic inventory file\nIn these days of cloud computing and infrastructure-as-code, the hosts you may wish to automate could change on a daily, if not hourly, basis! Keeping a static Ansible inventory up to date could become a full-time job, and hence, in many large-scale scenarios, it becomes unrealistic to attempt to use a static inventory on an ongoing basis.\nThis is where Ansible’s dynamic inventory support comes in. In short, Ansible can gather its inventory data from just about any executable file (though you will find that most dynamic inventories are written in Python)—the only requirement is that the executable returns the inventory data in a specified JSON format. You are free to create your own inventory scripts if you wish, but thankfully, many have been created already for you to use that cover a multitude of potential inventory sources including Amazon EC2, Microsoft Azure, Red Hat Satellite, **Lightweight Directory Access Protocol** (**LDAP**) directories, and many more systems.\nWhen writing a book, it is difficult to know for certain which dynamic inventory script to use as an example, as it is not a given that everyone will have an Amazon EC2 account they can freely use to test against. As a result, we will use the Cobbler provisioning system by way of example, as this is freely available and easy to roll out on a Fedora system. For those interested, Cobbler is a system for dynamically provisioning and building Linux systems, and it can handle all aspects of this, including DNS, DHCP, PXE booting, and so on. Hence, if you were to use this to provision virtual or physical machines in your infrastructure, it would make sense to also use this as your inventory source, as Cobbler was responsible for building the systems in the first place and so knows all the system names.\nThis example will demonstrate to you the fundamentals of working with a dynamic inventory, which you can then take forward to use the dynamic inventory scripts for other systems. Let’s get started with this process by first installing Cobbler—the process outlined here was tested on Fedora:\n\n1.  Your first task is to install the relevant Cobbler packages using `dnf`. Note that, at the time of writing, the SELinux policy provided with Fedora 38 does not support Cobbler’s functionality and blocks some aspects from working. Although this is not something you should do in a production environment, your simplest path to getting this demo up and running is to simply disable SELinux:\n\n    ```", "```\n    # default, localhost\n    server: 127.0.0.1\n    ```", "```\n\nNote\nThis is not a public listening address, so please *do not use* `0.0.0.0`. You can also set it to the IP address of the Cobbler server.\n\n1.  With this step complete, you can start the `cobblerd` service using `systemctl`:\n\n    ```", "```\n    $ sudo cobbler distro add --name=Fedora38 --kernel=/boot/vmlinuz-6.2.9-300.fc38.x86_64 --initrd=/boot/initramfs-6.2.9-300.fc38.x86_64.img\n    $ sudo cobbler profile add --name=webservers --distro=Fedora38\n    ```", "```\n\nThis definition is quite rudimentary and would not necessarily be able to produce working server images; however, it will suffice for our simple demo as we can add some systems based on this notional Fedora 38-based image. Note that the profile name we are creating, `webservers`, will later become our inventory group name in our dynamic inventory.\n\n1.  Let’s now add those systems to Cobbler. The following two commands will add two hosts called `frontend01` and `frontend02` to our Cobbler system, using the `webservers` profile we created previously:\n\n    ```", "```\n\nNote that, for Ansible to work, it must be able to reach the FQDNs specified in the `--dns-name` parameter. To achieve this, I am also adding entries to `/etc/hosts` on the Ansible control node for these two machines to ensure we can reach them later. These entries can point to any two systems of your choosing, as this is just a test.\nAt this point, you have successfully installed Cobbler, created a profile, and added two hypothetical systems to this profile. The next stage in our process is to download and configure the Ansible dynamic inventory scripts to work with these entries. To achieve this, let’s get started on the process given here:\n\n1.  Since Ansible 3.0, most dynamic inventory scripts have been moved into Collections as this is the easiest way to distribute and update them while decoupling them from the `ansible-core` distribution. The Cobbler dynamic inventory script is included as part of the `community.general` collection, which you should find was installed as part of the Ansible 8.0 package you installed previously. You can verify this with the following command:\n\n    ```", "```\n\nHere, we can see that the `community.general` collection is installed and is at version 6.5.0 (collection versioning is independent of Ansible versioning).\nIf you have worked with dynamic inventory scripts in versions of Ansible before 2.9 (before Collections became mainstream), you would almost certainly have located the dynamic inventory script and made it executable, even executing it directly. This is no longer necessary in the new Collections- and Plugins-based architecture, which makes your life much easier, as you shall see shortly.\n\n1.  Referring to the documentation for the Cobbler dynamic inventory plugin ([https://docs.ansible.com/ansible/latest/collections/community/general/cobbler_inventory.xhtml](https://docs.ansible.com/ansible/latest/collections/community/general/cobbler_inventory.xhtml)), you will see that, to use the plugin, we must create a configuration file as an inventory source. The filename must end in `.cobbler.yml` or `.cobbler.yaml`, and contain a line referencing the plugin. There are also a whole host of configuration options available (which, in our simple demo setup, aren’t necessary), but if you were working with a cloud service provider, you would certainly have to specify your region and credentials in the configuration file. In some cases, you will also have to install additional libraries or software for the inventory plugin to work, and again, the documentation page for the plugin will tell you whether this is a requirement. In my demo environment, the Cobbler server I built is accessible at the address `cobbler.example.org`, so I shall add this to the configuration file, resulting in the following:\n\n    ```", "```\n    $ ansible-inventory -i my.cobbler.yml --graph\n    @all:\n      |--@ungrouped:\n      |--@cobbler:\n      |  |--frontend01.example.org\n      |  |--frontend02.example.org\n      |--@cobbler_webservers:\n      |  |--frontend01.example.org\n      |  |--frontend02.example.org\n      |--@cobbler_:\n      |  |--frontend01.example.org\n      |  |--frontend02.example.org\n    ```", "```\n\nThis is an incredibly powerful and rapid way to query the dynamic inventory operation and what it is returning. Notice also that all group names have had `cobbler_` placed in front of them by the plugin, so we will need to make use of this when we reference the group names.\n\n1.  You can now run an Ansible ad hoc command in the manner you are used to—the only difference this time is that you will specify the filename of the dynamic inventory plugin configuration file rather than the name of the static inventory file. Assuming you have set up hosts at the two addresses we entered into Cobbler earlier, your output should look something like that shown here:\n\n    ```", "```\n\nThat’s it! You have just implemented your first dynamic inventory in Ansible. Of course, we know that many of you won’t be using Cobbler, and some of the other dynamic inventory plugins are a little more complex to get going. For example, the Amazon EC2 dynamic inventory script requires your authentication details for Amazon Web Services (or a suitable IAM account) and the installation of the Python `boto` and `boto3` libraries. How would you know to do all of this? Luckily, it is all documented in the plugin documentation, which you can access via the official Ansible documentation website, or on the command line using a command such as the following:\n\n```", "```\n\n An example of the documentation you will see is shown in the following figure:\n![Figure 3.1 – The Ansible CLI documentation for the community.general.cobbler plugin](img/B20846_03_001.jpg)\n\nFigure 3.1 – The Ansible CLI documentation for the community.general.cobbler plugin\nThe most fundamental piece of advice I can give is this: whenever you install a new collection containing a dynamic inventory plugin, be sure to check out the documentation, as the requirements will have been documented for you.\nBefore we end this section, let’s have a look at a few other handy hints for working with inventories, starting with the use of multiple inventory sources in the next section.\nUsing multiple inventory sources in the inventory directories\nSo far in this book, we have been specifying our inventory file (either static or dynamic) using the `-i` switch in our Ansible commands. What might not be apparent is that you can specify the `-i` switch more than once and so use multiple inventories at the same time. This enables you to perform tasks such as running a playbook (or ad hoc command) across hosts from both static and dynamic inventories at the same time. Ansible will work out what needs to be done—static inventories should not be marked as executable and so will not be processed as such, whereas dynamic inventories will be. This small but clever trick enables you to combine multiple inventory sources with ease. Let’s move on, in the next section, to looking at the use of static inventory groups in combination with dynamic ones, an extension of this multiple-inventory functionality.\nUsing static groups with dynamic groups\nOf course, the possibility of mixing inventories brings with it an interesting question—what happens to the groups from a dynamic inventory and a static inventory if you define both? The answer is that Ansible combines both, and this leads to an interesting possibility. As you will have observed, our Cobbler inventory script produced an Ansible group called `cobbler_webservers` from a Cobbler profile that we called `webservers`. This is common for most dynamic inventory providers; most inventory sources (for example, Cobbler and Amazon EC2) are not Ansible-aware and so do not offer groups that Ansible can directly use—they may also automatically add prefixes or separators to metadata (which may or may not be configurable). As a result, most dynamic inventory scripts will use some facet of information from the inventory source to produce groupings—the Cobbler machine profile being one such example.\nLet’s extend our Cobbler example from the preceding section by mixing a static inventory. Suppose that we want to make our `cobbler_webservers` machines a child group of a group called `fedora` so that we can, in the future, group all Fedora machines together. We know that we only have a Cobbler profile called `webservers`, and ideally, we don’t want to start messing with the Cobbler setup to do something solely Ansible-related.\nThe answer to this is to create a static inventory file with two group definitions. The first must be the same name as the group you are expecting from the dynamic inventory, except that you should leave it blank. When Ansible combines the static and dynamic inventory contents, it will overlap the two groups and so add the hosts from Cobbler to these groups.\nThe second group definition should state that `cobbler_webservers` is a child group of the `fedora` group. The resulting file should look something like this:\n\n```", "```\n\n Now let’s run a simple ad hoc `ansible.builtin.ping` command in Ansible to see how it evaluates the two inventories together. Notice how we will specify the `fedora` group to run `ansible.builtin.ping` against, instead of the `cobbler_webservers` group. We know that Cobbler has no `fedora` group because we never created one, and we know that any hosts in this group must come via the `cobbler_webservers` group when you combine the two inventories, as our static inventory has no hosts in it. The results will look something like this:\n\n```", "```\n\n As you can see from the preceding output, we have referenced two different inventories, one static and the other dynamic. We have combined groups, taking hosts that only exist in one inventory source, and combining them with a group that only exists in another. As you can see, this is an incredibly simple example, and it would be easy to extend this to combine lists of static and dynamic hosts or to add a custom variable to a host that comes from a dynamic inventory.\nThis is a trick of Ansible that is little known but can be very powerful as your inventories expand and grow. As we have worked through this chapter, you will have observed that we have been very precise about specifying our inventory hosts either individually or by group; for example, we explicitly told the `ansible` command to run the ad hoc command against all hosts in the `cobbler_webservers` group. In the next section, we will build on this to look at how Ansible can manage a set of hosts specified using patterns.\nSpecial host management using patterns\nWe have already established that you will often want to run either an ad hoc command or a playbook against only a subsection of your inventory. So far, we have been quite precise in doing that, but let’s now expand upon this by looking at how Ansible can work with patterns to figure out which hosts a command (or playbook) should be run against.\nAs a starting point, let’s again consider an inventory that we defined earlier in this chapter for the purposes of exploring host groups and child groups. For your convenience, the inventory contents are provided again here:\n\n```", "```\n\n To demonstrate host/group selection by pattern, we shall use the `--list-hosts` switch with the `ansible` command to see which hosts Ansible would operate on. You are welcome to expand the example to use the `ansible.builtin.ping` module, but we’ll use `--list-hosts` here in the interests of space and keeping the output concise and readable:\n\n1.  We have already mentioned the special `all` group to specify all hosts in the inventory:\n\n    ```", "```\n\nThe asterisk character has the same effect as `all`, but needs to be quoted in single quotes for the shell to interpret the command properly:\n\n```", "```\n\n1.  Use `:` to specify a logical `OR`, meaning “*apply to hosts either in this group or that group*,” as in this example:\n\n    ```", "```\n    $ ansible -i hostgroups-ini 'all:!apps' --list-hosts\n      hosts (5):\n        loadbalancer.example.org\n        db01.example.org\n        db02.example.org\n        web01.example.org\n    :& to specify a logical AND between two groups, for example, if we want all hosts that are in the fedora group and the apps group (again, you must use single quotes in the shell):\n\n    ```", "```\n    $ ansible -i hostgroups-ini 'db*.example.org' --list-hosts\n      hosts (2):\n        db01.example.org\n        db02.example.org\n    ```", "```\n\n    ```", "```\n\nAnother way you can limit which hosts a command is run on is to use the `--limit` switch with Ansible. This uses exactly the same syntax and pattern notation as in the preceding but has the advantage that you can use it with the `ansible-playbook` command, where specifying a host pattern on the command line is only supported for the `ansible` command itself. Hence, for example, you could run the following:\n\n```", "```\n\n Patterns are a very useful and important part of working with inventories, and something you will no doubt find invaluable going forward. That concludes our chapter on Ansible inventories; however, it is hoped that this has given you everything you need to work confidently with Ansible inventories.\nSummary\nCreating and managing Ansible inventories is a crucial part of your work with Ansible, and hence we have covered this fundamental concept early in this book. They are vital as, without them, Ansible would have no knowledge of what hosts it is to run automation tasks against, yet they provide so much more than this. They provide an integration point with configuration management systems, they provide a sensible source for host-specific (or group-specific) variables to be stored, and they provide you with a flexible way of running this playbook.\nIn this chapter, you learned about creating simple static inventory files and adding hosts to them. We then extended this by learning how to add host groups and assign variables to hosts. We also looked at how to organize your inventories and variables when a single flat inventory file becomes too much to handle. We then learned how to make use of dynamic inventory files, before concluding with a look at useful tips and tricks such as combining inventory sources and using patterns to specify hosts, all of which will make how you work with inventories easier and yet simultaneously more powerful.\nIn the next chapter, we will learn how to develop playbooks and roles to configure, deploy, and manage remote machines using Ansible.\nQuestions\n\n1.  How do you add the `frontends` group variables to your inventory?\n    1.  `[``frontends::]`\n    2.  `[``frontends::values]`\n    3.  `[``frontends:host:vars]`\n    4.  `[``frontends::variables]`\n    5.  `[``frontends:vars]`\n2.  What enables you to automate Linux tasks such as provisioning DNS, managing DHCP, updating packages, and configuration management?\n    1.  Playbook\n    2.  Yum\n    3.  Cobbler\n    4.  Bash\n    5.  Role\n3.  Ansible allows you to specify an inventory file location by using the `-i` option on the command line:\n    1.  True\n    2.  False\n\nFurther reading\nDetails on using Ansible inventory plugins are available here: [https://docs.ansible.com/ansible/latest/plugins/inventory.xhtml#using-inventory-plugins](https://docs.ansible.com/ansible/latest/plugins/inventory.xhtml#using-inventory-plugins)\n\n```"]