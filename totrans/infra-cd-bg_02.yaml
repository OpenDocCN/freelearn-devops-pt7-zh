- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Ansible and Terraform beyond the Documentation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越文档的Ansible和Terraform
- en: The next phase in our journey to **Infrastructure as Code** (**IaC**) is to
    take a look at **Terraform**, an IaC tool from HashiCorp, and **Ansible**, an
    IaC and configuration management tool from *Red Hat*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迈向**基础设施即代码**（**IaC**）的下一阶段时，我们将看看**Terraform**，这是HashiCorp提供的IaC工具，以及**Ansible**，这是*Red
    Hat*提供的IaC和配置管理工具。
- en: We will also compare the advantages and disadvantages of using them, set them
    up on macOS, Windows 11, and Ubuntu Linux, and look at using Visual Studio Code
    as an **integrated development environment** (**IDE**) to write our code, plus
    look at which recommended extensions to install.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将比较使用这些工具的优缺点，分别在macOS、Windows 11和Ubuntu Linux上进行设置，并使用Visual Studio Code作为**集成开发环境**（**IDE**）编写我们的代码，同时还会查看推荐安装的扩展。
- en: 'In this chapter, we are going to take a look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: What is important when choosing a tool?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择工具时需要考虑哪些重要因素？
- en: Introducing Terraform
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Terraform
- en: Introducing Ansible
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Ansible
- en: Introducing Visual Studio Code, the open source IDE from Microsoft
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Visual Studio Code，来自微软的开源IDE
- en: Before we start looking at the tools we will be using throughout this title,
    let’s quickly discuss a checklist I use to choose which tools to use in a project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看将用于本书中的工具之前，让我们快速讨论一下我用来选择项目工具的检查清单。
- en: What is important when choosing a tool?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择工具时需要考虑哪些重要因素？
- en: So, you have a new project – you know which cloud provider you will use, and
    your development team has given you an overview of their application – meaning
    you already have a good idea of the resources you will deploy and manage. You
    have been given free rein to choose which IaC tool to use – so how do you choose?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，您有一个新项目——您已经知道将使用哪个云服务提供商，并且您的开发团队已向您提供了应用程序概览——这意味着您已经对要部署和管理的资源有了清晰的了解。您被允许自由选择使用哪种IaC工具——那么，您该如何选择呢？
- en: Personally, my approach is always to use the best tool for the job rather than
    trying to fit the job to the tool – that, in my experience, always ends up causing
    issues when it comes to deploying the code and managing the deployment once it
    has been deployed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我的做法始终是选择最适合任务的工具，而不是试图将任务与工具相匹配——根据我的经验，这样做总会在代码部署和部署后的管理过程中导致问题。
- en: Let us discuss some of the key things you will need to consider.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些您需要考虑的关键事项。
- en: Deployment types
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署类型
- en: There are two main types of deployment I come across, with the first being using
    IaC to repeatedly deploy the same resources in a predictable and consistent way.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到的主要有两种部署类型，第一种是使用IaC以可预测和一致的方式反复部署相同的资源。
- en: The most common use case for this approach is for dev, test, and other lower
    environments, not production.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法最常见的使用场景是用于开发、测试和其他低环境，而非生产环境。
- en: 'The goal is to integrate with your developer’s build, release, and test pipelines
    so that when they push their code changes for one of the environment branches
    mentioned, the following happens:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是与开发者的构建、发布和测试管道集成，这样当他们将代码更改推送到前述的某个环境分支时，以下情况将发生：
- en: The push triggers the deployment of the resources using your IaC scripts
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送操作触发使用您的IaC脚本部署资源
- en: Once the resources have been deployed, your IaC pipeline hands back over to
    developers’ pipelines for them to build their code and deploy it to the resources
    that have just been launched
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦资源部署完成，您的IaC管道会将控制权交还给开发者的管道，供他们构建代码并将其部署到刚刚启动的资源中
- en: Once the application code has been deployed, run the developer’s automated testing
    or notify someone within the team that the newly pushed code is ready for manual
    testing
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦应用程序代码部署完成，运行开发者的自动化测试，或者通知团队中的某个人，告知新推送的代码已经准备好进行手动测试
- en: Finally, with testing complete, after the results are stored and either by an
    automated or manual decision gate in the pipeline, the resources deployed at the
    start of the process are terminated
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，经过测试并完成结果存储后，在管道中的自动或手动决策门控作用下，流程开始时部署的资源会被终止。
- en: The process above is repeated for each push – with multiple deployments sometimes
    being executed in parallel.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上述过程会为每次推送重复执行——有时多个部署会并行执行。
- en: The advantage of taking an approach like this is that you not only get cost
    savings, but you are only running resources while they are needed. Additionally,
    configuration drift is avoided as you are launching the resources from scratch
    with each deployment.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法的优势在于，你不仅能节省成本，还可以仅在需要时运行资源。此外，由于每次部署时都是从零启动资源，因此避免了配置漂移。
- en: Configuration drift occurs when someone with the best intentions quickly tweaks
    a setting somewhere manually to get something working and doesn’t document it
    anywhere. In this case, ad-hoc fixes would need to be rolled into your code for
    them to persist through to the next deployment.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 配置漂移发生在某个人本着最好意图，快速手动调整某个设置以使某个功能正常工作，却没有在任何地方记录。此时，需要将这些临时修复纳入你的代码中，以便它们在下一次部署中得以持续。
- en: The next deployment type is to launch and manage your resources using your IaC
    scripts. As you may have guessed, this approach is used in longer-running environments
    such as production.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种部署类型是使用你的 IaC 脚本启动和管理资源。正如你可能猜到的那样，这种方法通常用于长时间运行的环境，如生产环境。
- en: 'When you first think about this type of deployment, it is easy to assume that
    it is quite close to the first deployment type – however, in fact, the first deployment
    type is only executed once per deployment, whereas this type is executed multiple
    times against the same deployment which can introduce some interesting challenges,
    such as the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次考虑这种类型的部署时，很容易认为它与第一种部署类型相似——然而，实际上，第一种部署类型每次部署仅执行一次，而这种类型则是多次执行相同的部署，这可能会带来一些有趣的挑战，例如：
- en: Depending on the resource type, where is the line drawn between what is configured
    and managed by your IaC scripts and the application deployment?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据资源类型，IaC 脚本配置和管理的内容与应用程序部署之间的界限在哪里？
- en: As you are dealing with long-running resources, what additional logic or error
    checking do you need to build into your IaC scripts so that the execution of your
    code is terminated rather than the resources you are running the code against?
    After all, you don’t want to cause an outage, no matter how easy it is to recreate
    your infrastructure!
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理长时间运行的资源时，你需要在 IaC 脚本中加入哪些额外的逻辑或错误检查，以确保终止的是你的代码执行而不是正在运行的资源？毕竟，无论基础设施重建多么简单，你都不希望导致服务中断！
- en: How are you managing the state of your infrastructure? As we will learn in the
    next section of this chapter, having a consistent state is important for one of
    the tools we will cover in this book – so where is it stored long term?
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是如何管理基础设施的状态的？正如我们在本章的下一节中将要学习的，保持一致的状态对于我们将在本书中介绍的工具之一至关重要——那么，它是长期存储在哪里的？
- en: Infrastructure and configuration
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施与配置
- en: While we will be talking a lot about IaC in this book, which I am hoping if
    you have made it this far shouldn’t be a surprise, where is the line drawn between
    your IaC scripts and the deployment/configuration of the application?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书中我们将大量讨论 IaC（基础设施即代码），如果你已经读到这里，应该不会感到惊讶，但 IaC 脚本与应用程序的部署/配置之间的界限在哪里？
- en: A good example of this is when your project involves deploying **Infrastructure
    as a Service** (**IaaS**) resources such as virtual machines. Let’s say you need
    to deploy two Linux servers and then install NGINX along with a scripting language
    such as PHP on there; how will you achieve that?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是，当你的项目涉及部署**基础设施即服务**（**IaaS**）资源，如虚拟机时。假设你需要部署两台 Linux 服务器，并在其上安装 NGINX
    和 PHP 等脚本语言；你如何实现这一目标？
- en: Most public cloud providers allow you to attach and execute a script when launching
    a virtual machine using a service such as cloud-init – while this should cover
    most basic use cases, using this approach does add a level of abstraction that
    could cause problems – for example, does your cloud provider provide any details
    on the execution of the script – and will your IaC execution know if that has
    failed?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数公共云提供商允许你在启动虚拟机时通过类似 cloud-init 的服务附加并执行脚本——虽然这种方式应该可以覆盖大多数基本用例，但这种方法也会增加一定的抽象层次，可能会引发一些问题——例如，云服务提供商是否提供有关脚本执行的详细信息——而你的
    IaC 执行是否能知道该脚本是否失败？
- en: If you need more granular control or visibility of the commands being run as
    part of the deployment, then this will dictate which tool you choose as a pure
    IaC tool may not be enough for your needs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要对部署过程中执行的命令有更细粒度的控制或可视化，那么这将决定你选择哪种工具，因为纯粹的 IaC 工具可能不足以满足你的需求。
- en: This will also influence the next decision.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会影响下一步的决策。
- en: External interactions and secrets
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部交互与机密
- en: As mentioned at the end of the last section, if your IaC script needs to interact
    with a resource using a service outside of a publicly accessible API – such as
    **Secure Shell** (**SSH**) or **Windows Remote Management** (**WinRM)** to run
    scripts on a virtual machine or an internally hosted API such as the vSphere API
    used to manage resources hosted in VMWare environments, then you will carefully
    need to choose where your IaC is executed from as you will need line of sight
    to the resource you are interacting with.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上一节末尾所提到的，如果你的IaC脚本需要与使用公共API之外的服务交互——例如**安全外壳（SSH）**或**Windows远程管理（WinRM）**，用于在虚拟机上运行脚本，或者像vSphere
    API这样用于管理VMware环境中托管资源的内部API，那么你就需要仔细选择执行IaC的地方，因为你需要直接访问与你交互的资源。
- en: Likewise, depending on how you manage secrets within your IaC scripts for things
    such as passwords or certificates for services you are launching, you will also
    need line of sight, by which I mean direct access, of your secret storage or a
    way of securely injecting them into your scripts because as storing them as *hardcoded
    values in plain text within your IaC is never an* *option, ever!*
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，取决于你如何在IaC脚本中管理诸如密码或服务证书等机密内容，你还需要确保能直接访问你的机密存储，或者有一种安全的方式将其注入脚本中，因为将它们作为*明文硬编码的值存储在你的IaC中*绝对不是*一个可选的办法！*
- en: This means that you will need to assess where and how you execute your scripts,
    considering things such as firewalls plus access to resources and credentials
    – all without exposing any secrets.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你需要评估在哪里以及如何执行你的脚本，考虑到诸如防火墙、资源和凭证的访问等问题——而且要做到不暴露任何机密。
- en: We will cover all of this when we roll up our sleeves and start building up
    our deployment in later chapters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们卷起袖子开始在后续章节中构建我们的部署时，我们会覆盖所有这些内容。
- en: Ease of use
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 易用性
- en: The final consideration is simply how easy the tool is to use.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的考虑因素就是工具的易用性。
- en: It is easy to get swept up in the latest shiny new technologies, but if you
    are the only person in your team who has any experience with it, you will be adding
    complications as not only will you need to up-skill the rest of the team so they
    can also work with the code but also you will need to deal the issues that can
    occur from being an early adopter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易被最新的炫酷技术所吸引，但如果你是团队中唯一有相关经验的人，你会增加复杂性，因为不仅需要提升其他团队成员的技能，让他们也能使用这些代码，还需要处理作为早期采用者可能遇到的各种问题。
- en: Summary
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Everything we have discussed in this section should be at the forefront of your
    mind when approaching any IaC project. By the end of this book, you will have
    both the answers and experience to all of the questions and considerations raised
    during this section to be able to choose the right tool for the job rather than
    trying to fit your project to the tool, or what sometimes can only be described
    as fitting a square peg in a round hole.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理任何IaC项目时，本节中讨论的所有内容都应该放在你脑海的最前沿。在本书结束时，你将拥有解决本节中提出的所有问题和考虑因素的答案和经验，从而能够选择合适的工具，而不是将项目强行适配工具，或者说有时只能形容为将方钉塞进圆孔。
- en: Now is the time I hope you have been waiting for; we will look at our two main
    tools.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我希望你一直期待的时刻；我们将看看我们的两个主要工具。
- en: Introducing Terraform
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Terraform
- en: The first of the two tools we will look at is Terraform by HashiCorp.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的两个工具中的第一个是HashiCorp的Terraform。
- en: Hashicorp Terraform is an enterprise-ready cloud and virtualization management
    tool. It helps you manage your resources and deploy new instances with ease. Terraform
    is an open source tool for managing the cloud infrastructure, allowing you to
    not only efficiently configure and deploy your resources but also help you maintain
    your infrastructure while evolving it over time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp的Terraform是一个企业级的云和虚拟化管理工具。它帮助你轻松管理资源并部署新的实例。Terraform是一个开源工具，用于管理云基础设施，既可以高效地配置和部署资源，还能帮助你维护和不断发展你的基础设施。
- en: Terraform has a unique architecture in that it uses a state machine to manage
    resources and it is fully modular, and you can scale the service as per your needs.
    Finally, it is also integrated with many third-party tools and services.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform有一个独特的架构，它使用状态机来管理资源，并且完全模块化，你可以根据需求扩展服务。最后，它还与许多第三方工具和服务集成。
- en: Terraform uses the **Hashicorp Configuration Language** (**HCL**). You could
    be mistaken at first glance for thinking it is for JSON or YAML, but it’s a syntax
    and API designed by HashiCorp for building structured configuration formats, whereas
    YAML and JSON are just formats that define data structures in human- and machine-readable
    formats respectively.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform使用**HashiCorp配置语言**（**HCL**）。乍一看，你可能会误以为它是为JSON或YAML设计的，但它是HashiCorp为构建结构化配置格式而设计的语法和API，而YAML和JSON只是分别定义人类和机器可读格式的数据结构的格式。
- en: Rather than going into any more detail about HCL – let’s take a look at an HCL
    example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不再深入讨论HCL——让我们来看一个HCL示例。
- en: An HCL example – creating a resource group
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个HCL示例——创建资源组
- en: I personally do a lot of my day-to-day work with Microsoft Azure, so I will
    target that with this example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人经常在日常工作中使用Microsoft Azure，所以我将以此为示例。
- en: Information
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Feel free to follow along; if you need assistance installing Terraform, then
    there are links to the relevant documentation in the *Further reading* section
    at the end of this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 随时跟着做；如果你需要帮助安装Terraform，可以在本章结尾的*进一步阅读*部分找到相关文档的链接。
- en: 'Azure has a concept of resource groups that act as a logical container for
    your resources, so let us start by creating one of those:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Azure有一个资源组的概念，它作为你资源的逻辑容器，因此让我们从创建一个资源组开始：
- en: 'There are three main sections we need in our Terraform, the first of which
    tells Terraform which version of Terraform our code is compatible with and also
    which external providers we need to use. In the case of creating a resource group,
    this looks like the following:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的Terraform配置需要三个主要部分，第一部分告诉Terraform我们的代码兼容哪个版本的Terraform，以及我们需要使用哪些外部提供程序。在创建资源组的情况下，它看起来像下面这样：
- en: '[PRE0]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: One of the biggest selling points of Terraform is that it is both machine- and
    human-readable – I am sure you will agree from the small preceding snippet of
    code that it is easy to figure out what is going on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform的最大卖点之一是它既适合机器读取，也适合人类阅读——从前面的这小段代码来看，我相信你也会同意它很容易理解。
- en: Here we have said that `required_version` of Terraform should be greater or
    equal to `1.0`. Next up, we have `required_providers`; a provider is an external
    library that extends the functionality – in this example, we are telling Terraform
    to download and use the latest version of the `3.0` release of the `azurerm` provider
    from `hashicorp/azurerm`, which is where the official provider releases should
    be sourced from.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们指定了`required_version`的Terraform版本应该大于或等于`1.0`。接下来是`required_providers`；提供程序是一个扩展功能的外部库——在这个示例中，我们告诉Terraform下载并使用来自`hashicorp/azurerm`的`azurerm`提供程序的最新版本`3.0`，这是官方提供程序发布的来源。
- en: 'The next section configures the providers. For our example, we won’t do any
    additional configuration, so this just looks like the following:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个部分配置了提供程序。对于我们的示例，我们不做任何额外的配置，因此这看起来就像下面这样：
- en: '[PRE1]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next up is the final section of our example; this is where we configure our
    resource group:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们示例的最后一个部分；这里是我们配置资源组的地方：
- en: '[PRE2]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, there is not much to it – we simply define what we want the
    resource to be called by providing `name` and also which Azure region we would
    like the resource group to be placed in using `location`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，没什么复杂的——我们只是通过提供`name`来定义我们想要的资源名称，并且使用`location`指定我们希望资源组所在的Azure区域。
- en: All the preceding code is placed in a file called `terraform.tf` in an empty
    folder. Before we can create the resource group, we will need to initialize Terraform;
    this will download the `azurerm` provider and create a few supporting files, such
    as `locks`, which are needed to execute the code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的代码都放在一个名为`terraform.tf`的文件中，文件位于一个空文件夹里。在我们创建资源组之前，我们需要初始化Terraform；这将下载`azurerm`提供程序并创建一些支持文件，比如`locks`，这些文件在执行代码时是必需的。
- en: 'To deploy the resource group, we first need to run the following command to
    prepare our local environment:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要部署资源组，我们首先需要运行以下命令来准备本地环境：
- en: '[PRE3]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will give something like the following output:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将产生类似以下的输出：
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So now that Terraform is ready, we can run it – first of all, we need to run
    a plan:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然Terraform已经准备好，我们可以运行它——首先，我们需要运行一个计划：
- en: '[PRE5]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This should give us an idea of what Terraform is going to do when we apply
    our configuration; in my case, this gave the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该能让我们了解当我们应用配置时，Terraform会做些什么；在我的情况下，得到了以下输出：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What Terraform has done here are some basic flight checks, discovering that
    it doesn’t know about a resource group called `rg-example-uks` in the `uksouth`
    region and, therefore, it needs to add it, and because we are only creating a
    single resource there is `1` to add.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 在这里所做的是一些基本的飞行检查，发现它不知道在`uksouth`区域有一个名为`rg-example-uks`的资源组，因此它需要将其添加进去，并且由于我们只创建了一个资源，需要添加的是`1`个资源。
- en: 'To create the resource group, we need to run the following command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建资源组，我们需要运行以下命令：
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When doing so, it will give us the same output as when running `terraform plan`,
    but this time, as usual, if we want to proceed, answering `yes` will then deploy
    the resource:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做时，它会给我们与运行`terraform plan`时相同的输出，但这次，像往常一样，如果我们希望继续，输入`yes`会部署该资源：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There we have it; our resource group has been created. Running the `terraform
    apply` command again gives the following output:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，我们的资源组就创建好了。再次运行`terraform apply`命令会显示以下输出：
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, no changes are needed – now let’s add another resource – how about a storage
    account?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不需要做任何更改——现在让我们添加另一个资源——比如存储账户怎么样？
- en: Adding more resources
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加更多资源
- en: 'Follow these steps to add a storage account:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤添加存储账户：
- en: 'To do this, we simply need the following resource at the end of the `terraform.tf`
    file:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们只需要在`terraform.tf`文件末尾添加以下资源：
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Running `terraform apply` now gives the following output, which I have truncated
    as the total amount of lines has gone from 13 to 166 lines:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`terraform apply`会显示以下输出，我已将总行数从13行截断为166行：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Answer `yes` to get the following output:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`yes`，将得到以下输出：
- en: '[PRE12]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, we now have our storage account – great, let’s destroy it and run it again:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经有了存储账户——太好了，让我们销毁它并重新运行：
- en: '[PRE13]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of this command will tell us what is going to be removed (again,
    the output has been truncated):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的输出会告诉我们将要删除的内容（输出已被截断）：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Answer `yes`, and that will, as you may have guessed, destroy the resources:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`yes`，正如你可能猜到的那样，这将销毁资源：
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now running the script again using `terraform apply` tells us that two resources
    are going to be added:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次运行脚本，使用`terraform apply`告诉我们将添加两个资源：
- en: '[PRE16]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, when you say `yes` and try to proceed, it will give an error:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，当你输入`yes`并尝试继续时，它会报错：
- en: '[PRE17]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Why did it error? Let’s take a look at the error and figure out what happened.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会报错？让我们看看错误并弄清楚发生了什么。
- en: Fixing the error
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复错误
- en: First of all, why are we getting the error?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为什么会出现错误？
- en: If you remember, in the previous chapter, we discussed the differences between
    imperative and declarative; this is an example of what happens if you don’t plan
    your deployment right with an imperative tool.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在上一章中，我们讨论了命令式和声明式的区别；这就是如果你使用命令式工具而没有正确规划部署时会发生的情况。
- en: As the storage account is attached to a resource group, and at the time of execution,
    the resource group didn’t exist, and the storage account couldn’t be created.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存储账户附属于资源组，而在执行时资源组并不存在，因此存储账户无法被创建。
- en: However, the resource group had no dependency failures as part of the Terraform
    run, meaning if you were to run `terraform apply` again, the storage account would
    be created – so how do we get around this so that it works the first time we run
    `terraform apply`?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Terraform运行过程中，资源组没有依赖失败，这意味着如果你再次运行`terraform apply`，存储账户将被创建——那么我们如何解决这个问题，以便第一次运行`terraform
    apply`时就能成功呢？
- en: You may have noticed that Terraform refers to the two resources we are creating
    as `azurerm_resource_group.example` and `azurerm_storage_account.example`; these
    are internal references that we can use in our own code. Also, for most of these
    references, some outputs are only populated once the resource has been created.
    Some of these references are only known after the resource has been created because
    it is a return value of the resource being created in Azure, such as a unique
    ID, while for others, they are ones which we have defined – but are only populated
    once the resource has been launched. In the case of `azurerm_resource_group`,
    the name and location are populated as an output value once the group has been
    created.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到Terraform将我们创建的两个资源称为`azurerm_resource_group.example`和`azurerm_storage_account.example`；这些是我们可以在自己的代码中使用的内部引用。此外，对于这些引用中的大多数，某些输出只有在资源创建后才会填充。某些引用只有在资源创建后才能知道，因为它是Azure中创建资源时返回的值，例如唯一ID，而其他引用则是我们定义的——但只有在资源启动后才会填充。在`azurerm_resource_group`的情况下，名称和位置会在资源组创建后作为输出值填充。
- en: 'We can reference these in our `azurerm_storage_account` block by referring
    to the resource; this looks like the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`azurerm_storage_account`块中引用这些资源，通过引用资源来实现；如下所示：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What this will do is wait for the resource group to be deployed before Terraform
    will attempt to create the storage account – rather than just attempting to create
    both resources at the point of execution and failing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将等待资源组部署完成后，Terraform才会尝试创建存储帐户——而不是在执行时就尝试创建两个资源并失败。
- en: While I wouldn’t describe scenarios like this as errors or faults, they are
    more like quirks that you won’t discover until you attempt something. Because
    of this, as we progress through the book, I will call out quite a few examples
    of this and other similar approaches because the more complex your deployment
    code is, the more considerations you will need to make when writing it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不会将这种情况描述为错误或故障，但它们更像是一些怪癖，直到你尝试某个操作时才能发现。因此，在我们继续深入本书时，我会指出一些这样的例子和其他类似的做法，因为你的部署代码越复杂，编写时需要考虑的因素就越多。
- en: 'The following screenshot shows the resources deployed in the Azure portal:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了在Azure门户中部署的资源：
- en: '![Figure 2.1 – The deployed resources within the Azure portal](img/Figure_2.01_B19537.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 在Azure门户中部署的资源](img/Figure_2.01_B19537.jpg)'
- en: Figure 2.1 – The deployed resources within the Azure portal
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 在Azure门户中部署的资源
- en: 'You can clean up the resources you have launched by running the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令清理已启动的资源：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This permanently deletes the resource group and storage account, so please ensure
    that you are happy to proceed before saying `Yes`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将永久删除资源组和存储帐户，因此在选择`Yes`之前，请确保你已准备好继续操作。
- en: Now that we have learned a little about Terraform, let’s look at the other tool
    we will be using in the book, Ansible.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些关于Terraform的知识，接下来让我们看看本书中将要使用的另一个工具——Ansible。
- en: Introducing Ansible
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Ansible
- en: The second tool we cover in detail in this book is Ansible by Red Hat.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中详细介绍的第二个工具是Red Hat的Ansible。
- en: Ansible is a popular configuration management tool that enables users to automate
    the deployment and management of their applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个流行的配置管理工具，使用户能够自动化部署和管理他们的应用程序。
- en: It uses a hub-and-spoke model where a controlling machine instructs other machines
    to perform tasks. You can use it to manage your servers, deploy applications,
    or configure your network devices. One of the biggest advantages over other agentless
    devices is you don’t need to install anything on the target device you’re managing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它采用中心-辐射模型，其中一个控制机器指示其他机器执行任务。你可以用它来管理你的服务器、部署应用程序或配置网络设备。与其他无需代理的设备相比，它的最大优势之一是你无需在目标设备上安装任何东西。
- en: It supports YAML and JSON for writing playbooks, the main configuration file,
    meaning that it is language-agnostic when managing your remote systems and their
    state.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持YAML和JSON来编写playbook，即主配置文件，这意味着在管理远程系统及其状态时，它是语言无关的。
- en: There is no one-size-fits-all solution when it comes to your IaC solution, and
    Ansible allows you to choose from various modules to achieve your desired result,
    providing a great deal of flexibility when managing your infrastructure.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的IaC（基础设施即代码）解决方案中没有“一刀切”的解决方案，Ansible允许你选择不同的模块来实现你想要的结果，在管理基础设施时提供了极大的灵活性。
- en: An Ansible example
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible示例
- en: 'Let’s take the same example we used for Terraform and recreate it in Ansible,
    creating an Azure resource group and placing an Azure storage account in it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 Terraform 中使用的相同示例为基础，在 Ansible 中重新创建它，创建一个 Azure 资源组，并将一个 Azure 存储帐户放入其中：
- en: Information
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Again, feel free to follow along; if you need assistance installing Ansible,
    there are links provided in the *Further reading* section at the end of this chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，随时跟着操作；如果你需要安装 Ansible 的帮助，可以在本章末尾的 *进一步阅读* 部分找到相关链接。
- en: 'Place the following code in a blank file on your local machine called `playbook.yml`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码放入本地计算机的空白文件中，命名为 `playbook.yml`：
- en: '[PRE20]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Hint
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As this is a YAML file, the indentation is extremely important – before attempting
    to execute the playbook, I would reco[mmend using an online too](https://www.yamllint.com/)l
    such as [https://www.yamllint.com/](https://www.yamllint.com/) to quickly validate
    your file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个 YAML 文件，缩进非常重要——在尝试执行 playbook 之前，我建议使用类似 [https://www.yamllint.com/](https://www.yamllint.com/)
    的在线工具快速验证文件。
- en: 'Once you are ready to run your playbook, you can run the following command:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你准备好运行 playbook 时，可以运行以下命令：
- en: '[PRE21]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On the first run, this gives the following error:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次运行时，会出现以下错误：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first two warnings can be ignored; however, the error is something we will
    need to take care of before we can run our playbook.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前两条警告可以忽略；然而，错误是我们在运行 playbook 之前需要处理的问题。
- en: As mentioned in the introduction of this section, Ansible is modular – these
    modules are known as collections. As you can see from the code, we are using the
    `azure.azcollection` collection.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如本节介绍中所提到的，Ansible 是模块化的——这些模块被称为集合。从代码中可以看到，我们正在使用 `azure.azcollection` 集合。
- en: 'To install it, we need to run two commands; the first downloads the collection
    itself, and the second installs the required Python dependencies needed for the
    collection to work:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，我们需要运行两个命令；第一个下载集合本身，第二个安装集合所需的 Python 依赖项：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once installed, rerun the following command:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，重新运行以下命令：
- en: '[PRE24]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This should result in the following output (I have removed the warnings this
    time; as already mentioned, they can be ignored for now):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出（这次我已去掉警告；如前所述，警告目前可以忽略）：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, everything went as planned this time, and of the three tasks
    executed (the first being a check on `localhost`), two show changes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这一次一切按计划进行，执行的三个任务中（第一个是对 `localhost` 的检查），有两个显示了更改。
- en: 'Running the command again results in a play recap showing three OKs:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行命令会显示三个 OK 的执行回顾：
- en: '[PRE26]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You may have also noticed that it just ran the first time – if you ignore installing
    the prerequisites.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到，它只在第一次运行时执行——如果忽略了安装先决条件的话。
- en: Unlike Terraform, Ansible, when executed this way, is declarative. This means
    that it ran the tasks in order and waited for each of them to complete before
    progressing to the next task in the playbook file. This means that we didn’t find
    ourselves in a situation where Ansible was trying to launch resources linked to
    other resources that don’t already exist.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Terraform 不同，当以这种方式执行时，Ansible 是声明式的。这意味着它按顺序运行任务，并在每个任务完成后再执行下一个任务。这意味着我们不会遇到
    Ansible 尝试启动与其他尚未存在的资源关联的资源的情况。
- en: Another key difference between Ansible and Terraform is that Ansible is stateless
    – which means Ansible does not track or store the state of your resources in a
    file and instead looks at each resource at the time of execution.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 和 Terraform 之间的另一个关键区别是，Ansible 是无状态的——这意味着 Ansible 不会跟踪或存储资源的状态，而是在执行时查看每个资源。
- en: Personally, I think this is one of the critical differences between Terraform
    and Ansible, as I have lost count of the times that I have had to debug problems
    because someone or something has made a change to a resource outside of Terraform,
    which Terraform has then struggled to reconcile between the resources that are
    actually there and ones that it thinks are there.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我认为这是 Terraform 和 Ansible 之间的一个关键区别，因为我已经数不清有多少次需要调试问题，因为某人或某些事物在 Terraform
    外部更改了资源，导致 Terraform 在实际存在的资源和它认为存在的资源之间难以协调。
- en: Finding yourself in this situation is dangerous territory if you don’t pay attention.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不小心，进入这种情况是非常危险的。
- en: You may find that the only way Terraform can get its state back to how it thinks
    it should be deployed is to start terminating and redeploying resources – which
    would cause all sorts of chaos if you were in a production environment.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现，Terraform 唯一能够恢复其状态到它认为应该部署的方式的方法，就是开始终止并重新部署资源 —— 如果你在生产环境中，这将导致各种混乱。
- en: On the other hand, because Ansible does not keep track of the state of the resources
    it manages, it won’t know about a resource’s state or configuration until you
    execute the playbook.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，由于 Ansible 不跟踪它管理的资源的状态，它在执行 playbook 之前无法了解资源的状态或配置。
- en: 99% of the time, running an Ansible playbook will execute tasks that launch
    or update existing resources, so Ansible not keeping track of the state is not
    an issue – in fact, it could be a benefit as it is not trying to enforce a state
    it knows about.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 99%的情况下，运行 Ansible playbook 会执行启动或更新现有资源的任务，因此 Ansible 不跟踪状态并不是问题 —— 事实上，它可能是一个好处，因为它不会强制执行自己所知道的状态。
- en: The one downside to this is that because it doesn’t know what resources are
    present, there is not an Ansible equivalent of the `terraform destroy` command.
    When you run this command in Terraform, it simply removes the resources present
    within the state file giving a convenient way of removing everything Terraform
    is managing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的缺点是，由于它不知道哪些资源是存在的，因此没有 Ansible 等效的 `terraform destroy` 命令。当你在 Terraform
    中运行这个命令时，它只会删除状态文件中存在的资源，提供了一种便捷的方式来删除 Terraform 管理的所有内容。
- en: To get around this with Ansible, I normally provide a second playbook that sets
    the state of all or just some of the resources to `absent` – given the default
    state for most resources is `present`, this will remove the resources listed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我通常提供第二个 playbook，将所有或部分资源的状态设置为 `absent` —— 由于大多数资源的默认状态是 `present`，这将删除列出的资源。
- en: 'In the example we have just covered, the playbook to remove the resources looks
    like the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚才讲解的示例中，删除资源的 playbook 如下所示：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You may have noticed an empty line (`---`) at the end of the code block; it
    is important that these are present.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到代码块末尾有一行空行（`---`）；这些空行是必须存在的。
- en: Warning
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: You may have noticed that we are setting the `force_delete_nonempty` flag to
    `true` in the preceding code snippet. Please be careful when using that flag as
    you will not be asked if you are sure, and this overrides the default action of
    failing because there are resources within the resource group.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在前面的代码片段中将 `force_delete_nonempty` 标志设置为 `true`。使用这个标志时请小心，因为系统不会询问你是否确认，并且它会覆盖默认的操作（即资源组中有资源时会失败）。
- en: 'Place the preceding code in a file called `destroy.yml` and run the following
    command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码放入一个名为 `destroy.yml` 的文件中，并运行以下命令：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will delete the resource group. Because the storage account is a child
    resource within the resource group and we have instructed Ansible to remove resource
    groups even if they are not empty, it will also be removed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除资源组。由于存储账户是资源组中的子资源，并且我们已指示 Ansible 即使资源组不为空也删除资源组，因此它也将被删除。
- en: Now that we have learned about Ansible, let’s look at a tool we can use to write
    our code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Ansible，接下来让我们看看一个可以用来编写代码的工具。
- en: Introducing Visual Studio Code
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Visual Studio Code
- en: The final tool I am going to introduce isn’t an IaC tool but an IDE, which is
    used to write the code itself.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我将要介绍的最后一个工具不是一个 IaC 工具，而是一个 IDE，用于编写代码本身。
- en: Visual Studio Code is a powerful code editor perfect for most development languages,
    including your IaC projects. It is feature-rich, fast, and highly customizable,
    making it the ideal choice no matter which of the tools you decide to go with.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 是一个强大的代码编辑器，适用于大多数开发语言，包括你的 IaC 项目。它功能丰富、速度快且高度可定制，无论你选择哪种工具，它都是理想的选择。
- en: The best part is that Visual Studio Code is completely free and open source.
    Whether you’re a professional web developer, system administrator, or DevOps practitioner,
    Visual Studio Code has everything you need to create well-structured code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最棒的部分是，Visual Studio Code 完全免费且开源。无论你是专业的网页开发人员、系统管理员，还是 DevOps 从业者，Visual Studio
    Code 都提供了你需要的一切，帮助你编写结构良好的代码。
- en: 'Is it something I use on a daily basis – as you can see from the following
    screenshot, via the use of extensions, you get features such as syntax highlighting:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我每天使用的工具 —— 正如你从以下截图中看到的，通过使用扩展，你可以获得诸如语法高亮等功能：
- en: '![Figure 2.2 – Our Terraform example opened in Visual Studio Code](img/Figure_2.02_B19537.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 我们在Visual Studio Code中打开的Terraform示例](img/Figure_2.02_B19537.jpg)'
- en: Figure 2.2 – Our Terraform example opened in Visual Studio Code
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 我们在Visual Studio Code中打开的Terraform示例
- en: 'But beyond syntax highlighting, with extensions you can also get powerful features
    such as the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了语法高亮，使用扩展后，你还可以获得如下强大的功能：
- en: '**Inline error checking**: This is where your code is checked for syntax errors
    and general issues, such as referencing a variable or output that does not exist,
    and makes you aware of them'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内联错误检查**：这是指你的代码会被检查语法错误和一般性问题，例如引用了不存在的变量或输出，并提醒你。'
- en: '**Auto-complete**: This functionality varies between extensions, but they can
    fill in details as you type, suggesting which flags/keywords and values could
    be used'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动完成**：这个功能在不同的扩展中有所不同，但它们可以在你输入时自动填写详细信息，建议使用哪些标志/关键字和值。'
- en: '**Formatting**: As already mentioned, formatting is really important when it
    comes to both HCL and YAML; there are extensions for both languages that will
    check your formatting as you type and auto-correct if there are problems, which
    should hopefully save you from having to use an online tool such as the one linked
    in the Ansible section'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式化**：如前所述，格式化在HCL和YAML中都非常重要；这两种语言都有扩展，可以在你输入时检查格式，并在发现问题时自动修正，应该可以帮你省去使用如Ansible部分中链接的在线工具的麻烦。'
- en: '**Version Control and continuous integration/continuous delivery (CI/CD)**:
    There is a built-in integration with Git, as well as extensions for services such
    as GitHub, Azure DevOps, and other popular version control and CI/CD tools and
    services'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制与持续集成/持续交付（CI/CD）**：内置了Git集成，并且有适用于GitHub、Azure DevOps以及其他流行版本控制和CI/CD工具和服务的扩展。'
- en: While it is not essential to use an IDE such as Visual Studio Code, I think
    you will miss out on a lot of functionality and troubleshooting help if you don’t.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用像Visual Studio Code这样的IDE并非必须，但我认为如果不使用，你将错失很多功能和故障排除的帮助。
- en: For details on where to get Visual Studio Code from as well as recommended extensions
    that will be helpful throughout this book, please see the *Further* *reading*
    section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何获得Visual Studio Code以及本书中会用到的推荐扩展的详细信息，请参见*进一步阅读*部分。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we got a very quick feel for the approach and considerations
    when it comes to choosing the right IaC tool for your project.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速了解了选择适合你项目的IaC工具时所需要考虑的方法和因素。
- en: We also looked at both Terraform and Ansible and some of the small differences
    between the two tools before discussing Visual Studio Code, which I hope you will
    install and make use of.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还查看了Terraform和Ansible，以及这两种工具之间的一些小差异，然后再讨论Visual Studio Code，我希望你能安装并使用它。
- en: In the next chapter, which is the last chapter of *Part 1* of this book, we
    will look at the example project, which we will execute throughout the remainder
    of the book and get our teeth into both Terraform and Ansible on the two major
    public cloud providers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，也就是本书*第一部分*的最后一章，我们将查看示例项目，并在书中剩余部分中使用它，同时深入学习Terraform和Ansible在两个主要公共云服务商上的应用。
- en: Further reading
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some resources to help you delve deeper into Terraform:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些帮助你深入了解Terraform的资源：
- en: 'Main website: [https://www.terraform.io/](https://www.terraform.io/)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主网站：[https://www.terraform.io/](https://www.terraform.io/)
- en: 'Download and install guides: [https://developer.hashicorp.com/terraform/downloads](https://developer.hashicorp.com/terraform/downloads)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载和安装指南：[https://developer.hashicorp.com/terraform/downloads](https://developer.hashicorp.com/terraform/downloads)
- en: 'Azure Resource Manager provider: [https://registry.terraform.io/providers/hashicorp/azurerm/latest](https://registry.terraform.io/providers/hashicorp/azurerm/latest)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure资源管理器提供程序：[https://registry.terraform.io/providers/hashicorp/azurerm/latest](https://registry.terraform.io/providers/hashicorp/azurerm/latest)
- en: 'Here are some resources to help you delve deeper into Ansible:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些帮助你深入了解Ansible的资源：
- en: 'Main website: [https://www.ansible.com/](https://www.ansible.com/)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主网站：[https://www.ansible.com/](https://www.ansible.com/)
- en: 'Download and install guides: [https://docs.ansible.com/ansible/latest/installation_guide/index.html](https://docs.ansible.com/ansible/latest/installation_guide/index.html)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载和安装指南：[https://docs.ansible.com/ansible/latest/installation_guide/index.html](https://docs.ansible.com/ansible/latest/installation_guide/index.html)
- en: 'Azure collection: [https://galaxy.ansible.com/azure/azcollection](https://galaxy.ansible.com/azure/azcollection)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure集合：[https://galaxy.ansible.com/azure/azcollection](https://galaxy.ansible.com/azure/azcollection)
- en: 'Here are some resources to help you delve deeper into Visual Studio Code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些资源，帮助你深入了解 Visual Studio Code：
- en: 'Main Website: [https://code.visualstudio.com/](https://code.visualstudio.com/)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方网站： [https://code.visualstudio.com/](https://code.visualstudio.com/)
- en: 'Downloads: [https://code.visualstudio.com/Download](https://code.visualstudio.com/Download)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载链接： [https://code.visualstudio.com/Download](https://code.visualstudio.com/Download)
- en: 'HashiCorp Terraform extension: [https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform](https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Terraform 扩展： [https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform](https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform)
- en: 'Red Hat Ansible extension: [https://marketplace.visualstudio.com/items?itemName=redhat.ansible](https://marketplace.visualstudio.com/items?itemName=redhat.ansible)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Red Hat Ansible 扩展： [https://marketplace.visualstudio.com/items?itemName=redhat.ansible](https://marketplace.visualstudio.com/items?itemName=redhat.ansible)
- en: 'GitHub Repositories extension: [https://marketplace.visualstudio.com/items?itemName=GitHub.remotehub](https://marketplace.visualstudio.com/items?itemName=GitHub.remotehub)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 仓库扩展： [https://marketplace.visualstudio.com/items?itemName=GitHub.remotehub](https://marketplace.visualstudio.com/items?itemName=GitHub.remotehub)
